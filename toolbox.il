


procedure(TBX_ADVMIRROR_Calculate_Spin_Angle(obj text_mode) 
    let((spin_angle pin_list axis_angle result axis_angle_mirror) 
	case((obj->objType) 
	    ("text" 
		(axis_angle = (obj->rotation))
	    ) 
	    ("symbol" 
		(pin_list = setof(x 
			(obj->pins) 
			!(x->isMech)
		    )) 
		(spin_angle = 0.0) 
		when((length(pin_list) == 2) 
		    (result = TBX_GEOM_Get_Vector_Info((car(pin_list)->xy) 
			    (cadr(pin_list)->xy)
			)) 
		    when(result 
			(axis_angle = car(result))
		    )
		)
	    )
	) 
	if(axis_angle then 
	    if((((obj->objType) == "text") && (text_mode == 'alt)) then 
		(axis_angle = (360.0 - axis_angle)) 
		(spin_angle = (axis_angle - (obj->rotation))) 
		when((spin_angle < 0.0) 
		    (spin_angle = (spin_angle + 360.0))
		)
		else 
		when((axis_angle >= 180.0) 
		    (axis_angle = (axis_angle - 180.0))
		) 
		(axis_angle_mirror = (180.0 - axis_angle)) 
		(spin_angle = (axis_angle_mirror - axis_angle)) 
		when((spin_angle < 0.0) 
		    (spin_angle = (spin_angle + 360.0))
		)
	    ) else 
	    (spin_angle = 0.0)
	) spin_angle
    )
)
procedure(TBX_ADVMIRROR_Calculate_Text_Offset(txt mode) 
    let((block_info char_height char_width char_space char_cnt
	    rotation_rad text_physical_length dx dy ret
	    PI
	) 
	(PI = (defMathConstants('mymathconst)->PI)) 
	(block_info = (axlGetParam 
		strcat("paramTextBlock:" 
		    (txt->textBlock)
		)
	    )) 
	caseq(mode 
	    (base 
		(char_height = (block_info->height)) 
		(rotation_rad = ((((txt->rotation) + 90.0) / 360.0) * 2 * PI)) 
		(dx = (char_height * cos(rotation_rad))) 
		(dy = (char_height * sin(rotation_rad)))
	    ) 
	    (alt 
		(char_width = (block_info->width)) 
		(char_space = (block_info->charSpace)) 
		(char_cnt = strlen((txt->text))) 
		(rotation_rad = (((txt->rotation) / 360.0) * 2 * PI))
		(text_physical_length = ((char_cnt * char_width) + ((char_cnt - 1) * char_space))) 
		case(lowerCase((txt->justify)) 
		    ("left" 
			(dx = (text_physical_length * cos(rotation_rad))) 
			(dy = (text_physical_length * sin(rotation_rad)))
		    ) 
		    ("right" 
			(dx = ((- text_physical_length) * cos(rotation_rad))) 
			(dy = ((- text_physical_length) * sin(rotation_rad)))
		    )
		)
	    )
	) 
	if((dx && dy) then 
	    (ret = list(dx dy)) else 
	    (ret = list(0.0 0.0))
	)
	ret
    )
)
procedure(TBX_ADVMIRROR_Callback(form_handle) 
    let((angle_incr) 
	case((form_handle->curField) 
	    ("no_mirror" 
		(axlSetDynamicsMirror nil) 
		(axlFormSetFieldEditable form_handle "via_mirror" nil) 
		(axlFormSetFieldEditable form_handle "text_mirror" nil) 
		(axlFormSetFieldEditable form_handle "smart_rotate" nil)
	    ) 
	    ("geometry_and_layer" 
		(axlSetDynamicsMirror t) 
		(axlFormSetFieldEditable form_handle "via_mirror" nil) 
		(axlFormSetFieldEditable form_handle "text_mirror" nil) 
		(axlFormSetFieldEditable form_handle "smart_rotate" nil)
	    ) 
	    ("geometry_only" 
		(axlSetDynamicsMirror 
		    'GEOMETRY
		) 
		(axlFormSetFieldEditable form_handle "via_mirror" t) 
		(axlFormSetFieldEditable form_handle "text_mirror" t) 
		(axlFormSetFieldEditable form_handle "smart_rotate" t)
	    ) 
	    ("rotation_type" t)
	    ("angle_value" 
		if(((axlFormGetField form_handle "rotation_type") == "absolute") then t else 
		    (angle_incr = atof((form_handle->curValue)))
		    ((tbx_advmirror_data->runTime)->angleIncr = angle_incr) 
		    (axlSetRotateIncrement ?angular 
			((tbx_advmirror_data->runTime)->angleIncr)
		    )
		)
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_ADVMIRROR_Cleanup() 
    foreach(grp 
	(axlSelectByName "GROUP" "_TBX_ADVM*" t) 
	(axlDBDisbandGroup grp)
    ) 
    (axlClearSelSet) 
    (axlAddSelectAll) 
    (axlClearSelSet)
)
procedure(TBX_ADVMIRROR_Cleanup_Refdes(sym_list) 
    let((text_class text_layer text_value text_xy text_orient) 
	foreach(sym sym_list 
	    foreach(txt 
		(axlDBGetAttachedText sym) 
		(text_layer = (txt->layer)) 
		(text_class = upperCase(car(parseString((txt->layer) "/")))) 
		when((text_class == "REF DES") 
		    (text_value = upperCase((txt->text))) 
		    (text_orient = (axlTextOrientationCopy txt)) 
		    (text_xy = (txt->xy)) 
		    when(text_value 
			rexCompile("[1-9][1-9]*.*$") 
			(text_value = rexReplace(text_value "*" 0)) 
			(axlDeleteObject txt) 
			(axlDBCreateText text_value text_xy text_orient text_layer
			    sym
			)
		    )
		)
	    )
	) t
    )
)
procedure(TBX_ADVMIRROR_Event_Loop() 
    let((loop event start_pick bBox) 
	(loop = t) 
	((tbx_advmirror_data->runTime)->baseMode = "select") 
	(axlEventSetStartPopup 
	    'TBX_ADVMIRROR_Popup_Callback
	) 
	(tbx_advmirror_data->eventMask = list('PICK 
		'STARTDRAG 
		'STOPDRAG 
		'PICK_TOGGLE 
		'STARTDRAG_TOGGLE
		'STOPDRAG_TOGGLE
	    ))
	(tbx_advmirror_data->transMark = (axlDBTransactionStart)) 
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    list("noall" "boundary_shapes" "shapes" "symbols" "vias"
		"clines" "lines" "text"
	    ) ?onButtons 
	    list("all")
	) 
	printf("Select element(s) for operation") 
	while(loop 
	    (event = (axlEnterEvent 
		    (tbx_advmirror_data->eventMask) nil nil
		)) 
	    caseq((event->type) 
		(PICK 
		    TBX_ADVMIRROR_Select_and_Process((event->xy) "regular")
		) 
		(PICK_TOGGLE 
		    TBX_ADVMIRROR_Select_and_Process((event->xy) "toggle")
		) 
		(STARTDRAG 
		    when((((tbx_advmirror_data->runTime)->baseMode) == "select") 
			(axlAddSimpleRbandDynamics 
			    (event->xy) "box" ?origin 
			    (0.0:0.0)
			) 
			(start_pick = (event->xy))
		    )
		) 
		(STARTDRAG_TOGGLE 
		    when((((tbx_advmirror_data->runTime)->baseMode) == "select") 
			(axlAddSimpleRbandDynamics 
			    (event->xy) "box" ?origin 
			    (0.0:0.0)
			) 
			(start_pick = (event->xy))
		    )
		)
		(STOPDRAG 
		    when((((tbx_advmirror_data->runTime)->baseMode) == "select") 
			(bBox = list(start_pick 
				(event->xy)
			    )) 
			TBX_ADVMIRROR_Select_and_Process(bBox "regular") 
			(axlClearDynamics) 
			(start_pick = nil)
		    )
		) 
		(STOPDRAG_TOGGLE 
		    when((((tbx_advmirror_data->runTime)->baseMode) == "select") 
			(bBox = list(start_pick 
				(event->xy)
			    )) 
			TBX_ADVMIRROR_Select_and_Process(bBox "toggle") 
			(start_pick = nil)
		    )
		) 
		(DONE 
		    (axlDBTransactionCommit 
			(tbx_advmirror_data->transMark)
		    ) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    (loop = nil)
		    TBX_ADVMIRROR_Cleanup() 
		    if((tbx_advmirror_data->isModified) then 
			TBX_UTIL_Backup_Database("commit") else 
			TBX_UTIL_Backup_Database("cancel")
		    ) 
		    (tbx_advmirror_data = nil)
		) 
		(CANCEL 
		    (axlDBTransactionRollback 
			(tbx_advmirror_data->transMark)
		    ) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    (loop = nil)
		    TBX_ADVMIRROR_Cleanup() 
		    TBX_UTIL_Backup_Database("cancel") 
		    (tbx_advmirror_data = nil)
		)
	    )
	)
	(axlEventSetStartPopup)
    )
)
procedure(TBX_ADVMIRROR_Execute() 
    let((dx dy mirror_type angle sym_list
	    via_list text_list base_list msg org_group
	    base_group sym_group mirror_mode copy_group ok_smart_rotate
	) 
	(axlDBIgnoreFixed t) 
	(axlClearSelSet) 
	(org_group = car((axlSelectByName "GROUP" "_TBX_ADVM_SELECT"))) 
	(dx = (car(((tbx_advmirror_data->runTime)->destinationPick)) - car(((tbx_advmirror_data->runTime)->sourcePick))))
	(dy = (cadr(((tbx_advmirror_data->runTime)->destinationPick)) - cadr(((tbx_advmirror_data->runTime)->sourcePick)))) 
	(angle = ((tbx_advmirror_data->runTime)->angle)) 
	cond(((axlFormGetField 
		    (tbx_advmirror_data->formId) "no_mirror"
		) 
		(mirror_type = "no_mirror")
	    ) 
	    ((axlFormGetField 
		    (tbx_advmirror_data->formId) "geometry_and_layer"
		) 
		(mirror_type = "geometry_and_layer")
	    ) 
	    ((axlFormGetField 
		    (tbx_advmirror_data->formId) "geometry_only"
		) 
		(mirror_type = "geometry_only")
	    )
	) 
	if((axlFormGetField 
		(tbx_advmirror_data->formId) "move_mode"
	    ) then 
	    (mirror_mode = "move") else 
	    (mirror_mode = "copy")
	) 
	unless(angle 
	    (angle = 0.0)
	)
	case(mirror_type 
	    ("no_mirror" 
		if((mirror_mode == "move") then 
		    (axlTransformObject org_group ?move 
			(dx:dy)
		    ) 
		    (axlTransformObject org_group ?angle angle ?origin
			((tbx_advmirror_data->runTime)->destinationPick)
		    ) else
		    (axlCopyObject 
			(org_group->groupMembers) ?move 
			(dx:dy) ?retainNet
			t
		    ) 
		    (copy_group = TBX_ADVMIRROR_Group_Copied_Elements()) 
		    (axlTransformObject copy_group ?angle angle ?origin
			((tbx_advmirror_data->runTime)->destinationPick)
		    )
		) 
		(tbx_advmirror_data->isModified = t)
	    ) 
	    ("geometry_and_layer" 
		if((mirror_mode == "move") then 
		    (axlTransformObject org_group ?move 
			(dx:dy)
		    ) 
		    (axlTransformObject org_group ?mirror t ?angle
			angle ?origin 
			((tbx_advmirror_data->runTime)->destinationPick)
		    ) else
		    (axlCopyObject 
			(org_group->groupMembers) ?move 
			(dx:dy) ?retainNet
			t
		    ) 
		    (copy_group = TBX_ADVMIRROR_Group_Copied_Elements()) 
		    (axlTransformObject copy_group ?mirror t ?angle
			angle ?origin 
			((tbx_advmirror_data->runTime)->destinationPick)
		    ) 
		    (sym_list = setof(x 
			    (copy_group->groupMembers) 
			    ((x->objType) == "symbol")
			)) 
		    TBX_ADVMIRROR_Cleanup_Refdes(sym_list)
		) 
		(tbx_advmirror_data->isModified = t)
	    ) 
	    ("geometry_only" 
		(ok_smart_rotate = (axlFormGetField 
			(tbx_advmirror_data->formId) "smart_rotate"
		    )) 
		unless((axlFormGetField 
			(tbx_advmirror_data->formId) "via_mirror"
		    ) 
		    (via_list = setof(x 
			    (org_group->groupMembers) 
			    ((x->objType) == "via")
			))
		) 
		unless((axlFormGetField 
			(tbx_advmirror_data->formId) "text_mirror"
		    ) 
		    (text_list = setof(x 
			    (org_group->groupMembers) 
			    ((x->objType) == "text")
			))
		) 
		(sym_list = setof(x 
			(org_group->groupMembers) 
			((x->objType) == "symbol")
		    ))
		(base_list = (org_group->groupMembers)) 
		(base_list = setof(x base_list 
			!memq(x sym_list)
		    )) 
		(base_list = setof(x base_list 
			!memq(x via_list)
		    )) 
		(base_list = setof(x base_list 
			!memq(x text_list)
		    )) 
		when(sym_list 
		    (msg = "") 
		    (msg = strcat(msg "Note: Symbols cannot be mirrored when option <Geometry only> is checked. Transformation will be applied only to xy coordinate and rotation of symbol\n")) 
		    (axlUIConfirm msg)
		)
		(base_group = (axlDBCreateGroup "_TBX_ADVM_OTHER" "generic" base_list)) 
		(axlDBDisbandGroup org_group) 
		when(base_list 
		    if((mirror_mode == "move") then 
			(axlTransformObject base_group ?move 
			    (dx:dy)
			) 
			(axlTransformObject base_group ?mirror 
			    'GEOMETRY ?angle
			    angle ?origin 
			    ((tbx_advmirror_data->runTime)->destinationPick)
			) else
			(axlCopyObject 
			    (base_group->groupMembers) ?move 
			    (dx:dy) ?retainNet
			    t
			) 
			(copy_group = TBX_ADVMIRROR_Group_Copied_Elements()) 
			(axlTransformObject copy_group ?mirror 
			    'GEOMETRY ?angle
			    angle ?origin 
			    ((tbx_advmirror_data->runTime)->destinationPick)
			)
		    )
		) 
		when(sym_list 
		    (ok_smart_rotate = ok_smart_rotate) 
		    (axlDBCloak 
			'TBX_ADVMIRROR_Single_Process(mirror_mode sym_list ok_smart_rotate 
				((tbx_advmirror_data->runTime)->sourcePick) 
				((tbx_advmirror_data->runTime)->destinationPick)
				angle
			    ) 
			list('shape 
			    'ignoreFixed
			)
		    ) 
		    when((mirror_mode == "copy") 
			(sym_group = car((axlSelectByName "GROUP" "_TBX_ADVM_SYM"))) 
			TBX_ADVMIRROR_Cleanup_Refdes((sym_group->groupMembers))
		    )
		) 
		when(via_list 
		    (axlDBCloak 
			'TBX_ADVMIRROR_Single_Process(mirror_mode via_list nil 
				((tbx_advmirror_data->runTime)->sourcePick) 
				((tbx_advmirror_data->runTime)->destinationPick)
				angle
			    ) 
			list('shape 
			    'ignoreFixed
			)
		    )
		)
		when(text_list 
		    (axlDBCloak 
			'TBX_ADVMIRROR_Single_Process(mirror_mode text_list nil 
				((tbx_advmirror_data->runTime)->sourcePick) 
				((tbx_advmirror_data->runTime)->destinationPick)
				angle
			    ) 
			list('shape 
			    'ignoreFixed
			)
		    )
		) 
		(tbx_advmirror_data->isModified = t)
	    )
	) 
	(axlClearSelSet) 
	(axlClearDynamics)
    )
)
procedure(TBX_ADVMIRROR_Group_All() 
    let((grp) 
	(grp = car((axlSelectByName "GROUP" "_TBX_ADVM_ALL" t))) 
	when(grp 
	    (axlDBDisbandGroup grp)
	) 
	(axlClearSelSet) 
	(axlSetFindFilter ?onButtons 
	    cons("noall" 
		(axlGetFindFilter t)
	    )
	)
	(axlAddSelectAll) 
	(axlDBCreateGroup "_TBX_ADVM_ALL" "generic" 
	    (axlGetSelSet)
	) 
	(axlClearSelSet)
    )
)
procedure(TBX_ADVMIRROR_Group_Copied_Elements() 
    let((org_items copy_group copy_items) 
	(org_items = (car((axlSelectByName "GROUP" "_TBX_ADVM_ALL"))->groupMembers)) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	(copy_items = (axlGetSelSet))
	foreach(itm org_items 
	    (copy_items = remq(itm copy_items))
	) 
	(copy_group = (axlDBCreateGroup "_TBX_ADVM_COPY" "generic" copy_items)) 
	foreach(gm 
	    (copy_group->groupMembers) 
	    (axlDBRefreshId gm) 
	    when((gm->thermal) 
		(axlDBRemoveGroupObjects copy_group gm)
	    )
	) 
	(axlClearSelSet) copy_group
    )
)
procedure(TBX_ADVMIRROR_Init() 
    foreach(grp 
	(axlSelectByName "GROUP" "_TBX_ADVM*" t) 
	(axlDBDisbandGroup grp)
    ) 
    unless(boundp('tbx_advmirror_data) 
	iliDefstruct('defstruct(tbx_advmirror_data_struct runTime transMark formId eventMask
		    isModified
		)
	) 
	defvar(tbx_advmirror_data nil)
    ) 
    if(!tbx_advmirror_data then 
	(tbx_advmirror_data = (make_tbx_advmirror_data_struct ?runTime 
		ncons(nil) ?transMark nil
		?formId nil ?eventMask nil ?isModified
		nil
	    )) else 
	(tbx_advmirror_data->runTime = ncons(nil))
	(tbx_advmirror_data->transMark = nil) 
	(tbx_advmirror_data->formId = nil) 
	(tbx_advmirror_data->eventMask = nil) 
	(tbx_advmirror_data->isModified = nil)
    )
)
procedure(TBX_ADVMIRROR_Init_Next() 
    let((group_list) 
	(axlClearSelSet) 
	(axlDBRefreshId nil) 
	(group_list = (axlSelectByName "GROUP" "_TBX_ADVM*" t)) 
	foreach(grp group_list 
	    (axlDBDisbandGroup grp)
	)
	(axlClearSelSet) 
	(tbx_advmirror_data->runTime = ncons(nil)) 
	((tbx_advmirror_data->runTime)->baseMode = "select") 
	(axlClearDynamics) 
	printf("Select element(s) for operation\n")
	t
    )
)
procedure((TBX_ADVMIRROR_Main \@optional arg) ;³¬¼¶¾µÏñ
    let((info_file VERSION_STR port fid FORM_FILE
	    lic_check_result FC_FEATURE FC_VERSION SUB_VERSION
	) 
	(FC_FEATURE = "ADVMIRROR") 
	(FC_VERSION = "16.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Advanced Mirror %s (C)2016" FC_VERSION))
	(VERSION_STR = VERSION_STR) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./advmirror_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Advanced Mirror information:\n") 
		fprintf(port "===============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Advanced Mirror: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    TBX_ADVMIRROR_Init() 
		    TBX_UTIL_Backup_Database("init") 
		    if((axlOKToProceed t) then 
			(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "advmirror_mini")) 
			(fid = (axlMiniStatusLoad 
				gensym() FORM_FILE 
				'TBX_ADVMIRROR_Callback nil
			    )) 
			(tbx_advmirror_data->formId = fid)
			TBX_FORM_Init_Header(fid nil lic_check_result nil) 
			when((axlDBControl 
				'dynamicFilletsOn
			    ) 
			    printf("Info: Dynamic fillets will be disabled.\n") 
			    (axlDBControl 
				'dynamicFilletsOn nil
			    )
			) 
			(axlFormSetField fid "geometry_and_layer" t) 
			(axlFormSetField fid "move_mode" t) 
			(axlFormSetField fid "rotation_type" "incremental")
			(axlFormSetField fid "angle_value" 45) 
			(axlFormSetField fid "smart_rotate" t) 
			(axlFormSetFieldEditable fid "via_mirror" nil) 
			(axlFormSetFieldEditable fid "text_mirror" nil) 
			(axlFormSetFieldEditable fid "smart_rotate" nil)
			(axlFormDisplay fid) 
			(axlAutoOpenFindFilter) 
			TBX_ADVMIRROR_Event_Loop() 
			TBX_FORM_Delete(lic_check_result FORM_FILE) else
			printf("Warning: Finish active command first\n")
		    ) 
		    printf("For additional help enter: 'tbx help advmirror' in console window\n")
		)
	    )
	)
    )
)
procedure(TBX_ADVMIRROR_Popup_Callback(event) 
    let((popup) 
	(event = event) 
	case(((tbx_advmirror_data->runTime)->baseMode) 
	    ("select" 
		if(!((tbx_advmirror_data->runTime)->tempGroup) then 
		    (popup = (axlUIPopupDefine nil 
			    list(list("Done" 
				    'TBX_ADVMIRROR_RMB_Done
				) 
				list("Oops" 
				    'TBX_ADVMIRROR_RMB_Oops
				) 
				list("Temp Group" 
				    'TBX_ADVMIRROR_RMB_Temp_Group
				) 
				list("Cancel" 
				    'TBX_ADVMIRROR_RMB_Cancel
				)
			    )
			)) else 
		    (popup = (axlUIPopupDefine nil 
			    list(list("Done" 
				    'TBX_ADVMIRROR_RMB_Done
				) 
				list("Oops" 
				    'TBX_ADVMIRROR_RMB_Oops
				) 
				list("Complete" 
				    'TBX_ADVMIRROR_RMB_Complete
				) 
				list("Cancel" 
				    'TBX_ADVMIRROR_RMB_Cancel
				)
			    )
			))
		) 
		(axlUIPopupSet popup)
	    ) 
	    ("continue" 
		if(((tbx_advmirror_data->runTime)->sourcePick) then 
		    (popup = (axlUIPopupDefine nil 
			    list(list("Done" 
				    'TBX_ADVMIRROR_RMB_Done
				) 
				list("Oops" 
				    'TBX_ADVMIRROR_RMB_Oops
				) 
				list("No Mirror" 
				    'TBX_ADVMIRROR_RMB_No_Mirror
				) 
				list("Mirror Layer" 
				    'TBX_ADVMIRROR_RMB_Mirror_Layer
				) 
				list("Mirror Geometry" 
				    'TBX_ADVMIRROR_RMB_Mirror_Geometry
				)
				list("Rotate" 
				    'TBX_ADVMIRROR_RMB_Rotate
				) 
				list("Cancel" 
				    'TBX_ADVMIRROR_RMB_Cancel
				)
			    )
			)) 
		    (axlUIPopupSet popup) else
		    t
		)
	    ) 
	    ("dummy" t)
	)
    )
)
procedure(TBX_ADVMIRROR_RMB_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_ADVMIRROR_RMB_Complete() 
    ((tbx_advmirror_data->runTime)->tempGroup = nil) 
    ((tbx_advmirror_data->runTime)->baseMode = "continue") t
)
procedure(TBX_ADVMIRROR_RMB_Done() 
    when((((tbx_advmirror_data->runTime)->baseMode) == "continue") 
	(axlDBTransactionOops 
	    (tbx_advmirror_data->transMark)
	)
    ) 
    (axlFinishEnterFun)
)
procedure(TBX_ADVMIRROR_RMB_Mirror_Geometry() 
    (axlSetDynamicsMirror 
	'GEOMETRY
    ) 
    (axlFormSetField 
	(tbx_advmirror_data->formId) "geometry_only" t
    ) 
    (axlFormSetFieldEditable 
	(tbx_advmirror_data->formId) "via_mirror" t
    ) 
    (axlFormSetFieldEditable 
	(tbx_advmirror_data->formId) "text_mirror" t
    )
    (axlFormSetFieldEditable 
	(tbx_advmirror_data->formId) "smart_rotate" t
    )
)
procedure(TBX_ADVMIRROR_RMB_Mirror_Layer() 
    (axlSetDynamicsMirror t) 
    (axlFormSetField 
	(tbx_advmirror_data->formId) "geometry_and_layer" t
    ) 
    (axlFormSetFieldEditable 
	(tbx_advmirror_data->formId) "via_mirror" nil
    ) 
    (axlFormSetFieldEditable 
	(tbx_advmirror_data->formId) "text_mirror" nil
    )
    (axlFormSetFieldEditable 
	(tbx_advmirror_data->formId) "smart_rotate" nil
    )
)
procedure(TBX_ADVMIRROR_RMB_No_Mirror() 
    (axlSetDynamicsMirror nil) 
    (axlFormSetField 
	(tbx_advmirror_data->formId) "no_mirror" t
    ) 
    (axlFormSetFieldEditable 
	(tbx_advmirror_data->formId) "via_mirror" nil
    ) 
    (axlFormSetFieldEditable 
	(tbx_advmirror_data->formId) "text_mirror" nil
    )
    (axlFormSetFieldEditable 
	(tbx_advmirror_data->formId) "smart_rotate" nil
    )
)
procedure(TBX_ADVMIRROR_RMB_Oops() 
    (axlDBTransactionOops 
	(tbx_advmirror_data->transMark)
    ) 
    ((tbx_advmirror_data->runTime)->tempGroup = nil) 
    ((tbx_advmirror_data->runTime)->baseMode = "select") 
    TBX_ADVMIRROR_Init_Next()
)
procedure(TBX_ADVMIRROR_RMB_Rotate() 
    let((angle angle_incr) 
	if(((axlFormGetField 
		    (tbx_advmirror_data->formId) "rotation_type"
		) == "absolute") then 
	    (angle = atof((axlFormGetField 
			(tbx_advmirror_data->formId) "angle_value"
		    )
		)) else 
	    (angle_incr = atof((axlFormGetField 
			(tbx_advmirror_data->formId) "angle_value"
		    )
		))
	    ((tbx_advmirror_data->runTime)->angleIncr = angle_incr) 
	    (axlSetRotateIncrement ?angular 
		((tbx_advmirror_data->runTime)->angleIncr)
	    ) 
	    (angle = (axlEnterAngle 
		    (axlCursorGet nil) ?lockAngle angle_incr
		))
	) 
	(axlSetDynamicsRotation angle) 
	((tbx_advmirror_data->runTime)->angle = angle) t
    )
)
procedure(TBX_ADVMIRROR_RMB_Temp_Group() 
    ((tbx_advmirror_data->runTime)->tempGroup = t)
)
procedure(TBX_ADVMIRROR_Select_and_Process(user_input mode) 
    let((user_pick user_box group_dbid fixed_items answer) 
	cond(((((tbx_advmirror_data->runTime)->baseMode) == "select") 
		if(((tbx_advmirror_data->runTime)->tempGroup) then 
		    if((isBoxp user_input) then 
			(user_box = user_input) 
			case(mode 
			    ("regular" 
				(axlAddSelectBox user_box)
			    ) 
			    ("toggle" 
				(axlSubSelectBox user_box)
			    ) 
			    (t t)
			) 
			(axlClearDynamics)
			else 
			(user_pick = user_input) 
			case(mode 
			    ("regular" 
				(axlAddSelectPoint user_pick)
			    ) 
			    ("toggle" 
				(axlSubSelectPoint user_pick)
			    ) 
			    (t t)
			)
		    ) else 
		    if((isBoxp user_input) then 
			(user_box = user_input) 
			(axlClearSelSet) 
			(axlAddSelectBox user_box)
			else 
			(user_pick = user_input) 
			(axlClearSelSet) 
			(axlAddSelectPoint user_pick)
		    )
		    (fixed_items = setof(x 
			    (axlGetSelSet) 
			    (axlDBIsFixed x)
			)) 
		    when(fixed_items 
			(answer = (axlUIYesNoCancel "Selection contains fixed items. Selecting \"Yes\" will apply operation to all items, \"No\" will skip fixed items, \"Cancel\" will cancel this operation" nil 
				'yes
			    )) 
			caseq(answer 
			    (0 
				(axlSubSelectObject fixed_items)
			    ) 
			    (1 t) 
			    (2 
				(axlClearSelSet)
			    )
			)
		    ) 
		    if((axlGetSelSet) then 
			((tbx_advmirror_data->runTime)->baseMode = "continue") 
			printf("Pick origin\n") else
			((tbx_advmirror_data->runTime)->baseMode = "select")
		    )
		)
	    ) 
	    ((((tbx_advmirror_data->runTime)->baseMode) == "dummy") 
		((tbx_advmirror_data->runTime)->baseMode = "continue") 
		printf("Pick origin\n")
	    ) 
	    ((((tbx_advmirror_data->runTime)->baseMode) == "continue") 
		cond((!((tbx_advmirror_data->runTime)->sourcePick) 
			(axlDBTransactionMark 
			    (tbx_advmirror_data->transMark)
			) 
			(group_dbid = (axlDBCreateGroup "_TBX_ADVM_SELECT" "generic" 
				(axlGetSelSet)
			    )) 
			(axlClearSelSet) 
			when((axlFormGetField 
				(tbx_advmirror_data->formId) "move_mode"
			    ) 
			    printf("Erasing objects\n") 
			    (axlEraseObject group_dbid)
			)
			(axlDynamicsObject group_dbid) 
			((tbx_advmirror_data->runTime)->sourcePick = user_input) 
			TBX_ADVMIRROR_Update_Dynamics() 
			printf("Pick for destination\n")
		    ) 
		    (((tbx_advmirror_data->runTime)->sourcePick) 
			((tbx_advmirror_data->runTime)->destinationPick = user_input) 
			TBX_ADVMIRROR_Group_All() 
			TBX_ADVMIRROR_Execute() 
			TBX_ADVMIRROR_Init_Next()
		    ) 
		    (t t)
		)
	    )
	)
    )
)
procedure(TBX_ADVMIRROR_Single_Process(mirror_mode obj_list ok_smart_rotate source_pick destination_pick
	angle
    ) 
    let((obj_x_rel obj_y_rel obj_xy_rel_mir obj_x_dest obj_y_dest
	    obj_xy_dest move_x move_y group_dbid data_mod
	    spin_angle result dx dy text_mode
	) 
	(text_mode = 'alt) 
	when(((mirror_mode == "copy") && ((car(obj_list)->objType) == "symbol")) 
	    (group_dbid = (axlDBCreateGroup "_TBX_ADVM_SYM" "generic" nil))
	) 
	foreach(obj obj_list 
	    if(((obj->objType) == "text") then 
		(result = TBX_ADVMIRROR_Calculate_Text_Offset(obj text_mode)) 
		(dx = car(result)) 
		(dy = cadr(result))
		(obj_x_rel = ((car((obj->xy)) + dx) - car(source_pick))) 
		(obj_y_rel = ((cadr((obj->xy)) + dy) - cadr(source_pick))) else 
		(obj_x_rel = (car((obj->xy)) - car(source_pick))) 
		(obj_y_rel = (cadr((obj->xy)) - cadr(source_pick)))
	    ) 
	    (obj_xy_rel_mir = (axlGeoRotatePt 0.0 
		    (obj_x_rel:obj_y_rel) 
		    (0.0:0.0) t
		)) 
	    (obj_x_dest = (car(destination_pick) + car(obj_xy_rel_mir)))
	    (obj_y_dest = (cadr(destination_pick) + cadr(obj_xy_rel_mir))) 
	    (obj_xy_dest = (obj_x_dest:obj_y_dest)) 
	    when((angle > 0.0) 
		(obj_xy_dest = (axlGeoRotatePt angle obj_xy_dest destination_pick nil))
	    ) 
	    (move_x = (car(obj_xy_dest) - car((obj->xy)))) 
	    (move_y = (cadr(obj_xy_dest) - cadr((obj->xy))))
	    (spin_angle = 0.0) 
	    when(((((obj->objType) == "symbol") && ok_smart_rotate) || ((obj->objType) == "text")) 
		(spin_angle = TBX_ADVMIRROR_Calculate_Spin_Angle(obj text_mode))
	    ) 
	    if((mirror_mode == "move") then 
		(axlTransformObject obj ?mirror nil ?move
		    (move_x:move_y) ?angle angle
		) 
		when((spin_angle > 0.0) 
		    (axlTransformObject obj ?mirror nil ?angle
			spin_angle ?origin obj_xy_dest
		    )
		) else
		(data_mod = (axlCopyObject obj ?mirror nil ?move
			(move_x:move_y) ?angle angle ?retainNet t
		    )) 
		when((spin_angle > 0.0) 
		    (axlTransformObject data_mod ?mirror nil ?angle
			spin_angle ?origin obj_xy_dest ?retainNet t
		    )
		) 
		when((group_dbid && data_mod) 
		    (axlDBAddGroupObjects group_dbid data_mod)
		)
	    )
	) 
	(axlClearSelSet)
    )
)
procedure(TBX_ADVMIRROR_Update_Dynamics() 
    let((form_handle angle) 
	(form_handle = (tbx_advmirror_data->formId)) 
	(axlSetDynamicsMirror t) 
	cond(((axlFormGetField 
		    (tbx_advmirror_data->formId) "geometry_and_layer"
		) 
		(axlSetDynamicsMirror t)
	    ) 
	    ((axlFormGetField 
		    (tbx_advmirror_data->formId) "geometry_only"
		) 
		(axlSetDynamicsMirror 
		    'GEOMETRY
		)
	    ) 
	    ((axlFormGetField 
		    (tbx_advmirror_data->formId) "no_mirror"
		) 
		(axlSetDynamicsMirror nil)
	    )
	) 
	cond((((axlFormGetField form_handle "rotation_type") == "absolute") 
		(angle = atof((axlFormGetField form_handle "angle_value"))) 
		(angle = angle) t
	    ) 
	    (((axlFormGetField form_handle "rotation_type") == "incremental") t)
	)
    )
)
procedure((TBX_ADVTPCHECK_Calculate_Component_Spacing comp_height ruleParam \@optional ruleset_name) 
    let((m b spacing_required spacing_info comp_spacing
	    lower_data upper_data lower_height upper_height lower_spacing
	    upper_spacing name_list
	) 
	if(ruleset_name then 
	    (name_list = list(ruleset_name)) else 
	    (name_list = TBX_UTIL_Get_Hash_Keys(ruleParam t))
	) 
	foreach(rs name_list 
	    (comp_spacing = (ruleParam[rs]->tpCompSpacing)) 
	    when((caar(comp_spacing) != 0.0) 
		(comp_spacing = cons(list(0.0 0.0) comp_spacing))
	    ) 
	    (spacing_required = nil)
	    for(i 0 
		(length(comp_spacing) - 2) 
		(lower_data = nth(i comp_spacing)) 
		(upper_data = nth((i + 1) comp_spacing))
		(lower_height = car(lower_data)) 
		(lower_spacing = cadr(lower_data)) 
		(upper_height = car(upper_data)) 
		(upper_spacing = cadr(upper_data)) 
		when(((lower_height <= comp_height) && (comp_height < upper_height)) 
		    (spacing_required = upper_spacing) 
		    when((ruleParam[rs]->tpCompInterpolateRules) 
			if(((upper_height - lower_height) > 0.0) then 
			    (m = ((upper_spacing - lower_spacing) / (upper_height - lower_height))) 
			    (b = (lower_spacing - (m * lower_height))) 
			    (spacing_required = ((m * comp_height) + b))
			    else 
			    printf("Warning: Invalid data %L. Cannot interpolate\n" comp_spacing)
			)
		    )
		)
	    ) 
	    unless(spacing_required 
		(spacing_required = upper_spacing)
	    ) 
	    when(spacing_required 
		(spacing_info = cons(list(spacing_required rs) spacing_info))
	    )
	) 
	(spacing_info = sortcar(spacing_info 
		'greaterp
	    )) spacing_info
    )
)
procedure(TBX_ADVTPCHECK_Change_Visibility(key) 
    let((top_cond_layers bottom_cond_layers top_comp_layers bottom_comp_layers top_probe_layers
	    bottom_probe_layers mfg_layers top_keepout_layers bottom_keepout_layers design_outline
	    drc_layer general_layers layerMap vis_flag layer_list
	) 
	(design_outline = strcat((axlMapClassName "BOARD GEOMETRY") "/DESIGN_OUTLINE")) 
	(drc_layer = strcat((axlMapClassName "DRC ERROR CLASS") "/ALL")) 
	if((axlIsLayer design_outline) then 
	    (general_layers = cons(design_outline general_layers)) 
	    (general_layers = cons(strcat((axlMapClassName "BOARD GEOMETRY") "/CUTOUT") general_layers)) else
	    (general_layers = cons(strcat((axlMapClassName "BOARD GEOMETRY") "/OUTLINE") general_layers))
	) 
	(general_layers = cons(strcat((axlMapClassName "ROUTE KEEPIN") "/ALL") general_layers))
	(general_layers = cons(strcat((axlMapClassName "PACKAGE KEEPIN") "/ALL") general_layers)) 
	(general_layers = cons(drc_layer general_layers)) 
	(top_cond_layers = list(strcat((axlMapClassName "ETCH") "/" 
		    (axlConductorTopLayer)
		) 
		strcat((axlMapClassName "PIN") "/" 
		    (axlConductorTopLayer)
		) 
		strcat((axlMapClassName "VIA CLASS") "/" 
		    (axlConductorTopLayer)
		)
	    )) 
	(bottom_cond_layers = list(strcat((axlMapClassName "ETCH") "/" 
		    (axlConductorBottomLayer)
		) 
		strcat((axlMapClassName "PIN") "/" 
		    (axlConductorBottomLayer)
		) 
		strcat((axlMapClassName "VIA CLASS") "/" 
		    (axlConductorBottomLayer)
		)
	    )) 
	(top_comp_layers = list(car(((tbx_advtpcheck_global->layers)->compBoundary)) 
		strcat((axlMapClassName "REF DES") "/ASSEMBLY_TOP")
	    ))
	(bottom_comp_layers = list(cadr(((tbx_advtpcheck_global->layers)->compBoundary)) 
		strcat((axlMapClassName "REF DES") "/ASSEMBLY_BOTTOM")
	    )) 
	(top_probe_layers = list(car(((tbx_advtpcheck_global->layers)->probe)))) 
	(bottom_probe_layers = list(cadr(((tbx_advtpcheck_global->layers)->probe)))) 
	(mfg_layers = (axlSubclasses 
		(axlMapClassName "MANUFACTURING")
	    )) 
	(top_keepout_layers = mapcar(lambda((x) 
		    strcat((axlMapClassName "MANUFACTURING") "/" x)
		) 
		rexMatchList("^TP_KEEPOUT_.*TOP$" mfg_layers)
	    ))
	(bottom_keepout_layers = mapcar(lambda((x) 
		    strcat((axlMapClassName "MANUFACTURING") "/" x)
		) 
		rexMatchList("^TP_KEEPOUT_.*BOTTOM$" mfg_layers)
	    )) 
	(layerMap = makeTable("layer_map_table" nil)) 
	(layerMap["global_off"] = list(nil nil)) 
	(layerMap["global_limit"] = list(t 
		nconc(copy(general_layers) 
		    copy(top_cond_layers) 
		    copy(bottom_cond_layers) 
		    copy(top_comp_layers) 
		    copy(bottom_comp_layers)
		    copy(top_probe_layers) 
		    copy(bottom_probe_layers) 
		    copy(top_keepout_layers) 
		    copy(bottom_keepout_layers)
		)
	    )) 
	(layerMap["show_top_all"] = list(t 
		nconc(copy(general_layers) 
		    copy(top_cond_layers) 
		    copy(top_comp_layers) 
		    copy(top_probe_layers) 
		    copy(top_keepout_layers)
		)
	    ))
	(layerMap["show_top_cond"] = list(t top_cond_layers)) 
	(layerMap["show_top_comp"] = list(t top_comp_layers)) 
	(layerMap["show_top_tp"] = list(t top_probe_layers)) 
	(layerMap["show_top_kpo"] = list(t top_keepout_layers)) 
	(layerMap["hide_top_all"] = list(nil 
		cadr(layerMap["show_top_all"])
	    ))
	(layerMap["hide_top_cond"] = list(nil top_cond_layers)) 
	(layerMap["hide_top_comp"] = list(nil top_comp_layers)) 
	(layerMap["hide_top_tp"] = list(nil top_probe_layers)) 
	(layerMap["hide_top_kpo"] = list(nil top_keepout_layers)) 
	(layerMap["show_bottom_all"] = list(t 
		nconc(copy(general_layers) 
		    copy(bottom_cond_layers) 
		    copy(bottom_comp_layers) 
		    copy(bottom_probe_layers) 
		    copy(bottom_keepout_layers)
		)
	    ))
	(layerMap["show_bottom_cond"] = list(t bottom_cond_layers)) 
	(layerMap["show_bottom_comp"] = list(t bottom_comp_layers)) 
	(layerMap["show_bottom_tp"] = list(t bottom_probe_layers)) 
	(layerMap["show_bottom_kpo"] = list(t bottom_keepout_layers)) 
	(layerMap["hide_bottom_all"] = list(nil 
		cadr(layerMap["show_bottom_all"])
	    ))
	(layerMap["hide_bottom_cond"] = list(nil bottom_cond_layers)) 
	(layerMap["hide_bottom_comp"] = list(nil bottom_comp_layers)) 
	(layerMap["hide_bottom_tp"] = list(nil bottom_probe_layers)) 
	(layerMap["hide_bottom_kpo"] = list(nil bottom_keepout_layers)) 
	when((key == "global_toggle_drc") 
	    if((axlIsVisibleLayer drc_layer) then 
		(axlVisibleLayer drc_layer nil) else 
		(axlVisibleLayer drc_layer t)
	    )
	)
	when(((key == "global_off") || (key == "global_limit")) 
	    printf("Okay global off\n") 
	    (axlVisibleDesign nil)
	) 
	when((key != "global_toggle_drc") 
	    (vis_flag = car(layerMap[key])) 
	    (layer_list = cadr(layerMap[key])) 
	    foreach(lyr layer_list 
		(axlVisibleLayer lyr vis_flag)
	    )
	) 
	(axlVisibleUpdate t)
    )
)
procedure(TBX_ADVTPCHECK_Clean_Layers(layer_list) 
    let((a) 
	(a = a) 
	foreach(lyr layer_list 
	    (axlVisibleLayer lyr t)
	) 
	(axlVisibleUpdate nil) 
	(axlDeleteByLayer layer_list)
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_ADVTPCHECK_Cleanup() 
    let((param) 
	(axlVisibleLayer 
	    ((tbx_advtpcheck_global->layers)->tmp) t
	) 
	(axlDeleteByLayer 
	    ((tbx_advtpcheck_global->layers)->tmp)
	) 
	(param = (axlLayerGet 
		((tbx_advtpcheck_global->layers)->tmp)
	    )) 
	when(param 
	    (axlDeleteObject param)
	)
	(axlVisibleUpdate t) 
	(axlDBRefreshId nil) t
    )
)
procedure(TBX_ADVTPCHECK_Clear_DRC_Markers(drc_type) 
    let((drc_list drc_sys_name_pat) 
	when(stringp(drc_type) 
	    case(lowerCase(drc_type) 
		("tp2comp" 
		    (drc_sys_name_pat = "^TESTPOINT TO COMPONENT -")
		) 
		("tp2tp" 
		    (drc_sys_name_pat = "^TESTPOINT TO TESTPOINT -")
		)
	    )
	) 
	when(drc_sys_name_pat 
	    (axlSetFindFilter ?enabled 
		list("noall" "invisible" "drcs") ?onButtons 
		list("all")
	    ) 
	    (axlClearSelSet) 
	    (axlAddSelectAll) 
	    (drc_list = setof(x 
		    (axlGetSelSet) 
		    (((x->name) == "Externally Determined Violation") && rexMatchp(drc_sys_name_pat 
			    upperCase((x->source))
			))
		))
	    when(drc_list 
		(axlDeleteObject drc_list)
	    )
	) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_ADVTPCHECK_Clear_Restriction_Shapes() 
    let((layer_list) 
	(layer_list = rexMatchList("^TP_KEEPOUT_.*" 
		(axlSubclasses 
		    (axlMapClassName "MANUFACTURING")
		)
	    )) 
	(layer_list = mapcar(lambda((x) 
		    strcat((axlMapClassName "MANUFACTURING") "/" x)
		) layer_list
	    )) 
	when(layer_list 
	    TBX_ADVTPCHECK_Clean_Layers(layer_list)
	)
    )
)
procedure(TBX_ADVTPCHECK_Create_DRC_Marker(drc_type drc_side drc_xy req_value act_value
	first_obj second_obj
    ) 
    let((obj_list req_value_str act_value_str) 
	(obj_list = list(first_obj)) 
	when(second_obj 
	    (obj_list = list(first_obj second_obj))
	) 
	(req_value_str = "Undef") 
	(act_value_str = "Undef")
	when(numberp(req_value) 
	    (req_value_str = (axlGeo2Str req_value))
	) 
	when(numberp(act_value) 
	    (act_value_str = (axlGeo2Str act_value))
	) 
	(axlDBCreateExternalDRC 
	    list(sprintf(nil "%s - %s" drc_type drc_side) req_value_str) drc_xy "DRC ERROR CLASS/ALL" obj_list
	    nil act_value_str
	)
    )
)
procedure(TBX_ADVTPCHECK_Filter_Components(ignore_pattern) 
    let((arr comp_list pat_regexp) 
	when((ignore_pattern && stringp(ignore_pattern)) 
	    (arr = parseString(ignore_pattern ";"))
	) 
	(comp_list = ((axlDBGetDesign)->components)) 
	(comp_list = setof(c comp_list 
		((c->symbol)->xy)
	    )) 
	foreach(pat arr 
	    (pat_regexp = TBX_UTIL_Regex_From_Shell(pat t)) 
	    (comp_list = setof(c comp_list 
		    !rexMatchp(pat_regexp 
			    (c->name)
			)
		))
	)
	comp_list
    )
)
procedure(TBX_ADVTPCHECK_Get_Boundary_Layers(component_boundary) 
    let((layer_list) 
	case(component_boundary 
	    ("PLACE_BOUND" 
		(layer_list = ((tbx_advtpcheck_global->layers)->placeBoundary))
	    ) 
	    ("DFA_BOUND" 
		(layer_list = list(strcat((axlMapClassName "PACKAGE GEOMETRY") "/DFA_BOUND_TOP") 
			strcat((axlMapClassName "PACKAGE GEOMETRY") "/DFA_BOUND_BOTTOM")
		    ))
	    ) 
	    (t 
		(layer_list = ((tbx_advtpcheck_global->layers)->placeBoundary))
	    )
	) layer_list
    )
)
procedure(TBX_ADVTPCHECK_Get_Component_Boundary(cmp boundary_layers) 
    let((shape_list shape_poly height design_units boundary_info) 
	(design_units = car((axlDBGetDesignUnits))) 
	(shape_list = setof(s 
		((cmp->symbol)->children) 
		(((s->objType) == "shape") && member((s->layer) boundary_layers))
	    )) 
	foreach(shp shape_list 
	    (shape_poly = car((axlPolyFromDB shp))) 
	    (height = nil) 
	    when(((shp->prop)->PACKAGE_HEIGHT_MAX) 
		(height = (axlMKSConvert 
			((shp->prop)->PACKAGE_HEIGHT_MAX) design_units
		    ))
	    )
	    (boundary_info = cons(list(shp shape_poly height) boundary_info))
	) boundary_info
    )
)
procedure(TBX_ADVTPCHECK_Get_Component_Height(cmp) 
    let((placebound_layers sym_height_list comp_height design_units result
	    pb_childs_inst value
	) 
	(design_units = car((axlDBGetDesignUnits))) 
	(placebound_layers = ((tbx_advtpcheck_global->layers)->placeBoundary)) 
	(pb_childs_inst = setof(x 
		((cmp->symbol)->children) 
		member((x->layer) placebound_layers)
	    )) 
	foreach(pb pb_childs_inst 
	    when(((pb->prop)->PACKAGE_HEIGHT_MAX) 
		(value = (axlMKSConvert 
			((pb->prop)->PACKAGE_HEIGHT_MAX) design_units
		    )) 
		when((value && (value >= 0.0)) 
		    (value = TBX_MATH_Round(value)) 
		    unless(exists(x sym_height_list 
			    (value == x)
			) 
			(sym_height_list = cons(value sym_height_list))
		    )
		)
	    )
	)
	unless(sym_height_list 
	    (sym_height_list = list(0.0))
	) 
	(sym_height_list = sort(sym_height_list 
		'greaterp
	    )) 
	when((((cmp->compdef)->prop)->HEIGHT) 
	    (comp_height = (axlMKSConvert 
		    (((cmp->compdef)->prop)->HEIGHT) design_units
		)) 
	    (comp_height = TBX_MATH_Round(comp_height))
	) 
	(result = list(sym_height_list comp_height)) result
    )
)
procedure(TBX_ADVTPCHECK_Get_Component_Report_Data() 
    let((refdes xy side package result
	    info
	) 
	foreach(cmp 
	    ((axlDBGetDesign)->components) 
	    (refdes = (cmp->name)) 
	    (side = nil) 
	    when(((cmp->symbol)->xy) 
		(xy = ((cmp->symbol)->xy)) 
		(package = ((cmp->symbol)->name)) 
		(side = "TOP") 
		when(((cmp->symbol)->isMirrored) 
		    (side = "BOTTOM")
		)
		(result = TBX_ADVTPCHECK_Get_Component_Height(cmp)) 
		(info = cons(list(refdes package side xy 
			    car(result)
			    cadr(result)
			) info
		    ))
	    )
	) 
	(info = sortcar(info 
		'axlStrcmpAlpNum
	    )) info
    )
)
procedure(TBX_ADVTPCHECK_Get_Config(file_name) 
    let((att config_path data config_units design_units
	    name prop value comp_data height_value
	    spacing_value
	) 
	(design_units = car((axlDBGetDesignUnits))) 
	if(file_name then 
	    (data = TBX_UTIL_File_Lineread(file_name)) 
	    printf("Reading form settings from file %L\n" file_name) else
	    (att = (axlGetAttachment "tbx_advtpcheck" 
		    'string
		)) 
	    if(att then 
		(data = car(linereadstring((att->data)))) 
		printf("Reading form settings from database attachment\n") else
		(config_path = car(TBX_UTIL_Search_Config("advtpcheck.ini" nil nil ?includeWorkDir t))) 
		(data = TBX_UTIL_File_Lineread(config_path)) 
		printf("Reading ftorm settings from %L\n" config_path)
	    )
	) 
	foreach(entry data 
	    when(eq(car(entry) 
		    'units
		) 
		(config_units = cadr(entry))
	    )
	) 
	if(config_units then 
	    foreach(entry data 
		cond((eq(car(entry) 
			    'units
			) t
		    ) 
		    (memq(car(entry) 
			    list('tp2compFixedSpacingValue 
				'tp2tpFixedSpacingValue
			    )
			) 
			(prop = car(entry)) 
			(value = (axlMKSConvert 
				cadr(entry) config_units design_units
			    )) 
			putprop((tbx_advtpcheck_global->formParam) value prop)
		    ) 
		    (eq(car(entry) 
			    'ruleset
			) 
			foreach(sd 
			    cdr(entry) 
			    when((eq(car(sd) 
					'name
				    ) && stringp(cadr(sd))) 
				(name = upperCase(cadr(sd))) 
				(comp_data = nil) 
				unless((tbx_advtpcheck_global->ruleParam)[name] 
				    ((tbx_advtpcheck_global->ruleParam)[name] = ncons(nil))
				) 
				foreach(lpair 
				    cddr(sd) 
				    cond((memq(car(lpair) 
						list('tpSize 
						    'tpSizeTolerance 
						    'tpInterSpacingAir 
						    'tpInterSpacingCenter
						)
					    ) 
					    (prop = car(lpair)) 
					    (value = (axlMKSConvert 
						    cadr(lpair) config_units design_units
						)) 
					    putprop((tbx_advtpcheck_global->ruleParam)[name] value prop)
					) 
					(eq(car(lpair) 
						'tpCompSpacing
					    ) 
					    foreach(hsp 
						cdr(lpair) 
						when((numberp(car(hsp)) && numberp(cadr(hsp))) 
						    (height_value = (axlMKSConvert 
							    car(hsp) config_units design_units
							)) 
						    (spacing_value = (axlMKSConvert 
							    cadr(hsp) config_units design_units
							))
						) 
						(comp_data = cons(list(height_value spacing_value) comp_data))
					    ) 
					    (comp_data = sortcar(comp_data 
						    'lessp
						)) 
					    putprop((tbx_advtpcheck_global->ruleParam)[name] comp_data 
						'tpCompSpacing
					    )
					) 
					(t 
					    putprop((tbx_advtpcheck_global->ruleParam)[name] 
						cadr(lpair) 
						car(lpair)
					    )
					)
				    )
				)
			    )
			)
		    ) 
		    (t 
			(prop = car(entry)) 
			(value = cadr(entry)) 
			putprop((tbx_advtpcheck_global->formParam) value prop)
		    )
		)
	    ) else 
	    printf("Warning: Missing units in file %L\n" config_path)
	)
	t
    )
)
procedure(TBX_ADVTPCHECK_Get_Spacing_Report_Data(form_handle) 
    let((ignore_pattern comp_list component_boundary component_height derive_device_height
	    spacing_info result
	) 
	(ignore_pattern = (axlFormGetField form_handle "tp2compIgnoreDesignators")) 
	(component_boundary = (axlFormGetField form_handle "tp2compUseBoundary")) 
	(derive_device_height = (axlFormGetField form_handle "tp2compDeriveHeightSymbolNDevice")) 
	(component_boundary = component_boundary)
	(comp_list = TBX_ADVTPCHECK_Filter_Components(ignore_pattern)) 
	foreach(cmp comp_list 
	    (result = TBX_ADVTPCHECK_Get_Component_Height(cmp)) 
	    (component_height = caar(result)) 
	    when((derive_device_height && cadr(result)) 
		(component_height = cadr(result))
	    )
	    (result = TBX_ADVTPCHECK_Calculate_Component_Spacing(component_height 
		    (tbx_advtpcheck_global->ruleParam)
		)) 
	    (spacing_info = cons(list((cmp->name) 
			((cmp->symbol)->name) component_height result
		    ) spacing_info
		))
	) 
	(spacing_info = sortcar(spacing_info 
		'axlStrcmpAlpNum
	    ))
    )
)
procedure(TBX_ADVTPCHECK_Get_Testpoint_Attributes(size_acc) 
    let((tpAttr tp_list attr) 
	(tpAttr = makeTable("tp_attr_data" nil)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "pins" "vias") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll)
	(tp_list = setof(x 
		(axlGetSelSet) 
		(x->testPoint)
	    )) 
	(axlClearSelSet) 
	foreach(pv tp_list 
	    (attr = TBX_ADVTPCHECK_Get_Testpoint_Geom(pv size_acc)) 
	    (tpAttr[pv] = attr)
	) tpAttr
    )
)
procedure(TBX_ADVTPCHECK_Get_Testpoint_Geom(pv acc) 
    let((tp_refdes tp_side probe_layers probe_side tp_poly
	    box_ll box_ur width height tp_size
	    result ret pad_layer
	) 
	(tp_refdes = "") 
	(probe_layers = ((tbx_advtpcheck_global->layers)->probe)) 
	foreach(txt 
	    (axlDBGetAttachedText pv) 
	    when(member((txt->layer) probe_layers) 
		(tp_refdes = (txt->text))
	    )
	) 
	(tp_size = 0.0)
	(probe_side = (pv->testPoint)) 
	(result = (axlPolyFromDB pv ?layer probe_side ?padType
		'REGULAR
	    )) 
	when(result 
	    (tp_poly = car(result)) 
	    (box_ll = car((tp_poly->bBox))) 
	    (box_ur = cadr((tp_poly->bBox))) 
	    (width = (car(box_ur) - car(box_ll)))
	    (height = (cadr(box_ur) - cadr(box_ll))) 
	    (tp_size = max(width height))
	) 
	(tp_size = TBX_MATH_Round(tp_size "absolute" acc)) 
	(tp_side = cadr(parseString((pv->testPoint) "/")))
	case((pv->objType) 
	    ("via" 
		(pad_layer = strcat((axlMapClassName "VIA CLASS") "/" tp_side))
	    ) 
	    ("pin" 
		(pad_layer = strcat((axlMapClassName "PIN") "/" tp_side))
	    )
	) 
	(ret = list(nil 
		'refdes tp_refdes 
		'size tp_size
		'side tp_side 
		'padLayer pad_layer 
		'poly
		tp_poly
	    )) ret
    )
)
procedure(TBX_ADVTPCHECK_Get_Testpoint_Report_Data(size_acc) 
    let((tp_list tpInfo hcnt data size_list
	    attr
	) 
	(tpInfo = makeTable("tp_info_data" nil)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "pins" "vias") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll)
	(tp_list = setof(x 
		(axlGetSelSet) 
		(x->testPoint)
	    )) 
	(axlClearSelSet) 
	(hcnt = 0) 
	foreach(pv tp_list 
	    (attr = TBX_ADVTPCHECK_Get_Testpoint_Geom(pv size_acc)) 
	    unless(tpInfo[(attr->size)] 
		(tpInfo[(attr->size)] = makeTable(sprintf(nil "tp_info_%d_subtable" 
			    ++hcnt
			) nil
		    ))
	    ) 
	    (tpInfo[(attr->size)][(attr->side)] = cons(list((attr->refdes) 
			(pv->xy)
		    ) 
		    tpInfo[(attr->size)][(attr->side)]
		))
	) 
	foreach(sk tpInfo 
	    foreach(lk 
		tpInfo[sk] 
		(tpInfo[sk][lk] = sortcar(tpInfo[sk][lk] 
			'axlStrcmpAlpNum
		    ))
	    )
	)
	foreach(key tpInfo 
	    (size_list = cons(key size_list))
	) 
	(size_list = sort(size_list 
		'lessp
	    )) 
	(data = tconc(nil nil)) 
	foreach(sk size_list 
	    foreach(entry 
		tpInfo[sk]["TOP"] 
		tconc(data 
		    cons(sk 
			cons("TOP" entry)
		    )
		)
	    ) 
	    foreach(entry 
		tpInfo[sk]["BOTTOM"] 
		tconc(data 
		    cons(sk 
			cons("BOTTOM" entry)
		    )
		)
	    )
	) 
	(data = cdar(data))
    )
)
procedure(TBX_ADVTPCHECK_Init() 
    let((formParam design_units defParam ruleParam place_bound_layers
	    probe_layers tmp_layer
	) 
	(design_units = car((axlDBGetDesignUnits))) 
	(defParam = ncons(nil)) 
	(defParam->maxGridSize = 8) 
	(defParam->sizeAcc = 2)
	(formParam = ncons(nil)) 
	(formParam->tp2compFixedSpacingMode = t) 
	(formParam->tp2compFixedSpacingValue = (axlMKSConvert "1.0 MM" design_units)) 
	(formParam->tp2compUseRulesetMode = nil) 
	(formParam->tp2compUseRulesetName = "DEFAULT")
	(formParam->tp2compMatchRulesetMode = nil) 
	(formParam->tp2compUseBoundary = "PLACE_BOUND") 
	(formParam->tp2compDeriveHeightSymbolNDevice = t) 
	(formParam->tp2compCheckTestpointCenter = nil) 
	(formParam->tp2compGenerateRestrictionAreas = nil)
	(formParam->tp2tpFixedSpacingMode = t) 
	(formParam->tp2tpFixedSpacingValue = (axlMKSConvert "1.27 MM" design_units)) 
	(formParam->tp2tpUseRulesetMode = nil) 
	(formParam->tp2tpUseRulesetName = "DEFAULT") 
	(formParam->tp2tpMatchRulesetMode = t)
	(formParam->tp2tpCheckTestpointCenter = nil) 
	(ruleParam = makeTable("ruleParam_data" nil)) 
	(ruleParam["DEFAULT"] = ncons(nil)) 
	(ruleParam["DEFAULT"]->tpSize = (axlMKSConvert "0.8  MM" design_units)) 
	(ruleParam["DEFAULT"]->tpSizeTolerance = (axlMKSConvert "0.05 MM" design_units))
	(ruleParam["DEFAULT"]->tpInterSpacingAir = (axlMKSConvert "0.47 MM" design_units)) 
	(ruleParam["DEFAULT"]->tpInterSpacingCenter = (axlMKSConvert "1.27 MM" design_units)) 
	(ruleParam["DEFAULT"]->tpCompSpacing = list(list(0.0 0.0) 
		list((axlMKSConvert "3.0 MM" design_units) 
		    (axlMKSConvert "0.65 MM" design_units)
		)
	    )) 
	(ruleParam["DEFAULT"]->tpCompInterpolateRules = t) 
	(place_bound_layers = list(strcat((axlMapClassName "PACKAGE GEOMETRY") "/PLACE_BOUND_TOP") 
		strcat((axlMapClassName "PACKAGE GEOMETRY") "/PLACE_BOUND_BOTTOM")
	    ))
	(probe_layers = list(strcat((axlMapClassName "MANUFACTURING") "/PROBE_TOP") 
		strcat((axlMapClassName "MANUFACTURING") "/PROBE_BOTTOM")
	    )) 
	(tmp_layer = strcat((axlMapClassName "MANUFACTURING") "/TMP_DRAFTING")) 
	unless((axlIsLayer tmp_layer) 
	    (axlLayerCreateNonConductor tmp_layer)
	) 
	unless(boundp('tbx_advtpcheck_global) 
	    iliDefstruct('defstruct(tbx_advtpcheck_global_struct formId licCheck version defParam
			formParam ruleParam layers
		    )
	    ) 
	    defvar(tbx_advtpcheck_global nil)
	) 
	if(!tbx_advtpcheck_global then 
	    (tbx_advtpcheck_global = (make_tbx_advtpcheck_global_struct ?formId 
		    ncons(nil) ?version nil
		    ?licCheck nil ?defParam defParam ?formParam
		    formParam ?ruleParam ruleParam ?layers 
		    list(nil 
			'placeBoundary place_bound_layers 
			'probe probe_layers
			'tmp tmp_layer
		    )
		)) else 
	    (tbx_advtpcheck_global->formId = ncons(nil))
	    (tbx_advtpcheck_global->version = nil) 
	    (tbx_advtpcheck_global->licCheck = nil) 
	    (tbx_advtpcheck_global->defParam = defParam) 
	    (tbx_advtpcheck_global->formParam = formParam) 
	    (tbx_advtpcheck_global->ruleParam = ruleParam)
	    (tbx_advtpcheck_global->layers = list(nil 
		    'placeBoundary place_bound_layers 
		    'probe probe_layers
		    'tmp tmp_layer
		))
	)
	t
    )
)
procedure(TBX_ADVTPCHECK_Init_Form(form_handle form_name \@optional 
	(set_name "DEFAULT")
    ) 
    let((name_list) 
	(name_list = TBX_UTIL_Get_Hash_Keys((tbx_advtpcheck_global->ruleParam) t)) 
	when((form_name == "main") 
	    (axlFormBuildPopup form_handle "tp2compUseRulesetName" name_list) 
	    (axlFormSetField form_handle "tp2compFixedSpacingMode" 
		((tbx_advtpcheck_global->formParam)->tp2compFixedSpacingMode)
	    ) 
	    (axlFormSetField form_handle "tp2compFixedSpacingValue" 
		((tbx_advtpcheck_global->formParam)->tp2compFixedSpacingValue)
	    ) 
	    (axlFormSetField form_handle "tp2compUseRulesetMode" 
		((tbx_advtpcheck_global->formParam)->tp2compUseRulesetMode)
	    )
	    (axlFormSetField form_handle "tp2compUseRulesetName" 
		((tbx_advtpcheck_global->formParam)->tp2compUseRulesetName)
	    ) 
	    (axlFormSetField form_handle "tp2compMatchRulesetMode" 
		((tbx_advtpcheck_global->formParam)->tp2compMatchRulesetMode)
	    ) 
	    (axlFormSetField form_handle "tp2compUseBoundary" 
		((tbx_advtpcheck_global->formParam)->tp2compUseBoundary)
	    ) 
	    (axlFormSetField form_handle "tp2compIgnoreDesignators" 
		((tbx_advtpcheck_global->formParam)->tp2compIgnoreDesignators)
	    ) 
	    (axlFormSetField form_handle "tp2compDeriveHeightSymbolNDevice" 
		((tbx_advtpcheck_global->formParam)->tp2compDeriveHeightSymbolNDevice)
	    )
	    (axlFormSetField form_handle "tp2compCheckTestpointCenter" 
		((tbx_advtpcheck_global->formParam)->tp2compCheckTestpointCenter)
	    ) 
	    (axlFormSetField form_handle "tp2compGenerateRestrictionAreas" 
		((tbx_advtpcheck_global->formParam)->tp2compGenerateRestrictionAreas)
	    ) 
	    (axlFormSetField form_handle "tp2tpFixedSpacingMode" 
		((tbx_advtpcheck_global->formParam)->tp2tpFixedSpacingMode)
	    ) 
	    (axlFormSetField form_handle "tp2tpFixedSpacingValue" 
		((tbx_advtpcheck_global->formParam)->tp2tpFixedSpacingValue)
	    ) 
	    (axlFormSetField form_handle "tp2tpUseRulesetMode" 
		((tbx_advtpcheck_global->formParam)->tp2tpUseRulesetMode)
	    )
	    (axlFormSetField form_handle "tp2tpUseRulesetName" 
		((tbx_advtpcheck_global->formParam)->tp2tpUseRulesetName)
	    ) 
	    (axlFormSetField form_handle "tp2tpMatchRulesetMode" 
		((tbx_advtpcheck_global->formParam)->tp2tpMatchRulesetMode)
	    ) 
	    (axlFormSetField form_handle "tp2tpCheckTestpointCenter" 
		((tbx_advtpcheck_global->formParam)->tp2tpCheckTestpointCenter)
	    )
	) 
	when((form_name == "ruleset") 
	    (axlFormBuildPopup form_handle "rulesetName" name_list) 
	    (axlFormSetField form_handle "rulesetName" set_name) 
	    (axlFormSetField form_handle "tpSize" 
		((tbx_advtpcheck_global->ruleParam)[set_name]->tpSize)
	    ) 
	    (axlFormSetField form_handle "tpSizeTolerance" 
		((tbx_advtpcheck_global->ruleParam)[set_name]->tpSizeTolerance)
	    )
	    (axlFormSetField form_handle "tpInterSpacingAir" 
		((tbx_advtpcheck_global->ruleParam)[set_name]->tpInterSpacingAir)
	    ) 
	    (axlFormSetField form_handle "tpInterSpacingCenter" 
		((tbx_advtpcheck_global->ruleParam)[set_name]->tpInterSpacingCenter)
	    ) 
	    (axlFormSetField form_handle "tpCompInterpolateRules" 
		((tbx_advtpcheck_global->ruleParam)[set_name]->tpCompInterpolateRules)
	    ) 
	    (axlFormGridReset form_handle "grid") 
	    TBX_ADVTPCHECK_Ruleset_Init_Grid_Cols(form_handle)
	    TBX_ADVTPCHECK_Ruleset_Init_Grid_Rows(form_handle) 
	    (axlFormGridUpdate form_handle "grid") 
	    (axlFormGridEvents form_handle "grid" 
		list('cellselect 
		    'change
		)
	    )
	)
    )
)
procedure(TBX_ADVTPCHECK_Init_No_Probe_Layers(name_list) 
    let((noProbeTop noProbeBottom ret layer_list top_layer
	    bottom_layer tmp_str
	) 
	(noProbeTop = makeTable("no_probe_top_table" nil)) 
	(noProbeBottom = makeTable("no_probe_bottom_table" nil)) 
	foreach(nm name_list 
	    (tmp_str = strcat(nm "_")) 
	    when((nm == "") 
		(tmp_str = "")
	    ) 
	    (top_layer = strcat((axlMapClassName "MANUFACTURING") "/TP_KEEPOUT_" tmp_str "TOP"))
	    (bottom_layer = strcat((axlMapClassName "MANUFACTURING") "/TP_KEEPOUT_" tmp_str "BOTTOM")) 
	    unless((axlIsLayer top_layer) 
		(axlLayerCreateNonConductor top_layer) 
		TBX_DBDISPLAY_Set_Layer_Color(top_layer 
		    list(251 216 181)
		)
	    ) 
	    unless((axlIsLayer bottom_layer) 
		(axlLayerCreateNonConductor bottom_layer) 
		TBX_DBDISPLAY_Set_Layer_Color(bottom_layer 
		    list(251 216 181)
		)
	    ) 
	    (layer_list = cons(top_layer 
		    cons(bottom_layer layer_list)
		)) 
	    (noProbeTop[nm] = top_layer)
	    (noProbeBottom[nm] = bottom_layer)
	) 
	TBX_ADVTPCHECK_Clean_Layers(layer_list)
	(ret = list(noProbeTop noProbeBottom)) ret
    )
)
procedure((TBX_ADVTPCHECK_Main \@optional arg) ;³¬¼¶²âÊÔµã¼ì²é
    let((lic_check_result fid FORM_FILE FC_FEATURE FC_VERSION
	    SUB_VERSION VERSION_STR info_file port ok_start_app
	) 
	(FC_FEATURE = "ADVTPCHECK") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Advanced Testpoint Checking %s (C)2017" FC_VERSION))
	(ok_start_app = t) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./tpcheckadv_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Advanced Tespoint Checking information:\n") 
		fprintf(port "=============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  reset   : Deletes configuration from database. Default settings will be used after launch\n") 
		fprintf(port "  version : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port)
		(axlUIViewFileCreate info_file "Advanced Tespoint Checking: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "reset")) 
		when((axlUIYesNo "Delete configuration from database?" nil 
			'no
		    ) 
		    printf("Deleting configuration from database...\n") 
		    (axlDeleteAttachment "tbx_advtpcheck")
		) 
		(ok_start_app = nil)
	    ) 
	    (arg 
		(ok_start_app = nil)
	    )
	) 
	when(ok_start_app 
	    (lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
	    when(lic_check_result 
		(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "advtpcheck_main")) 
		unless(boundp('tbxAdvTpCheckMainHandle) 
		    defvar(tbxAdvTpCheckMainHandle nil)
		) 
		(fid = (axlFormCreate 
			'tbxAdvTpCheckMainHandle FORM_FILE 
			'(e outer) 
			'TBX_ADVTPCHECK_Main_Callback
			t
		    )) 
		when(fid 
		    TBX_ADVTPCHECK_Init() 
		    ((tbx_advtpcheck_global->formId)->main = fid) 
		    (tbx_advtpcheck_global->licCheck = lic_check_result) 
		    (tbx_advtpcheck_global->version = VERSION_STR)
		    TBX_ADVTPCHECK_Get_Config(nil) 
		    TBX_FORM_Init_Header(fid "Licensed for " lic_check_result VERSION_STR) 
		    TBX_ADVTPCHECK_Init_Form(fid "main") 
		    TBX_ADVTPCHECK_Update_Form(fid "tp2comp") 
		    TBX_ADVTPCHECK_Update_Form(fid "tp2tp")
		    ((tbx_advtpcheck_global->layers)->compBoundary = TBX_ADVTPCHECK_Get_Boundary_Layers((axlFormGetField fid "tp2compUseBoundary"))) 
		    (axlFormDisplay fid) 
		    TBX_FORM_Delete(lic_check_result FORM_FILE)
		)
	    )
	) t
    )
)
procedure(TBX_ADVTPCHECK_Main_Callback(form_handle) 
    let((output_file input_file data report_file FORM_FILE
	    fid
	) 
	case((form_handle->curField) 
	    ("tp2compFixedSpacingMode" 
		TBX_ADVTPCHECK_Update_Form(form_handle "tp2comp")
	    ) 
	    ("tp2compFixedSpacingValue" t) 
	    ("tp2compUseRulesetMode" 
		TBX_ADVTPCHECK_Update_Form(form_handle "tp2comp")
	    ) 
	    ("tp2compUseRulesetName" t)
	    ("tp2compMatchRulesetMode" 
		TBX_ADVTPCHECK_Update_Form(form_handle "tp2comp")
	    ) 
	    ("tp2compUseBoundary" 
		((tbx_advtpcheck_global->layers)->compBoundary = TBX_ADVTPCHECK_Get_Boundary_Layers((form_handle->curValue)))
	    ) 
	    ("tp2compIgnoreDesignators" t) 
	    ("tp2compDeriveHeightSymbolNDevice" t) 
	    ("tp2compCheckTestpointCenter" t)
	    ("tp2compGenerateRestrictionAreas" t) 
	    ("tp2tpFixedSpacingMode" 
		TBX_ADVTPCHECK_Update_Form(form_handle "tp2tp")
	    ) 
	    ("tp2tpFixedSpacingValue" t) 
	    ("tp2tpUseRulesetMode" 
		TBX_ADVTPCHECK_Update_Form(form_handle "tp2tp")
	    ) 
	    ("tp2tpUseRulesetName" t)
	    ("tp2tpMatchRulesetMode" 
		TBX_ADVTPCHECK_Update_Form(form_handle "tp2tp")
	    ) 
	    ("tp2tpCheckTestpointCenter" t) 
	    ("edit_ruleset" 
		(axlUIWShow 
		    ((tbx_advtpcheck_global->formId)->main) 
		    'hide
		) 
		(FORM_FILE = TBX_FORM_Get_Name((tbx_advtpcheck_global->licCheck) "advtpcheck_ruleset")) 
		unless(boundp('tbxAdvTpCheckRulesetHandle) 
		    defvar(tbxAdvTpCheckRulesetHandle nil)
		) 
		(fid = (axlFormCreate 
			'tbxAdvTpCheckRulesetHandle FORM_FILE 
			'(e outer) 
			'TBX_ADVTPCHECK_Ruleset_Callback
			t nil
		    ))
		when(fid 
		    ((tbx_advtpcheck_global->formId)->ruleset = fid) 
		    TBX_FORM_Init_Header(fid nil 
			(tbx_advtpcheck_global->licCheck) nil
		    ) 
		    (axlFormDisplay fid) 
		    TBX_ADVTPCHECK_Init_Form(fid "ruleset")
		    TBX_FORM_Delete((tbx_advtpcheck_global->licCheck) FORM_FILE)
		)
	    ) 
	    ("report" 
		case((form_handle->curValue) 
		    ("testpoint_details" 
			(data = TBX_ADVTPCHECK_Get_Testpoint_Report_Data(((tbx_advtpcheck_global->defParam)->sizeAcc))) 
			(report_file = TBX_ADVTPCHECK_Write_Testpoint_Report(data)) 
			(axlUIViewFileCreate report_file "Testpoint Details Report" nil)
		    ) 
		    ("component_details" 
			(data = TBX_ADVTPCHECK_Get_Component_Report_Data()) 
			(report_file = TBX_ADVTPCHECK_Write_Component_Report(data)) 
			(axlUIViewFileCreate report_file "Component Details Report" nil)
		    ) 
		    ("component_spacings" 
			(data = TBX_ADVTPCHECK_Get_Spacing_Report_Data(form_handle)) 
			(report_file = TBX_ADVTPCHECK_Write_Spacing_Report(data)) 
			(axlUIViewFileCreate report_file "Component Spacings Report" nil)
		    )
		)
	    ) 
	    ("config" 
		case((form_handle->curValue) 
		    ("save_config" 
			(output_file = (axlDMFileBrowse "ALLEGRO_TEXT" t)) 
			when(output_file 
			    printf("Saving configuration to file %L\n" output_file) 
			    TBX_ADVTPCHECK_Save_Config(form_handle output_file)
			)
		    ) 
		    ("load_config" 
			(input_file = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
			when(input_file 
			    TBX_ADVTPCHECK_Get_Config(input_file) 
			    TBX_ADVTPCHECK_Init_Form(form_handle "main") 
			    TBX_ADVTPCHECK_Update_Form(form_handle "tp2comp") 
			    TBX_ADVTPCHECK_Update_Form(form_handle "tp2tp")
			)
		    ) 
		    (t t)
		)
	    )
	    ("run_drc" 
		case((form_handle->curValue) 
		    ("drc_tp2comp" 
			TBX_ADVTPCHECK_Clear_Restriction_Shapes() 
			TBX_ADVTPCHECK_Clear_DRC_Markers("tp2comp") 
			TBX_ADVTPCHECK_Testpoint2Component_DRC_Run(form_handle)
		    ) 
		    ("drc_tp2tp" 
			TBX_ADVTPCHECK_Clear_DRC_Markers("tp2tp") 
			TBX_ADVTPCHECK_Testpoint2Component_DRC_Run(form_handle)
		    ) 
		    ("drc_both" 
			TBX_ADVTPCHECK_Clear_Restriction_Shapes() 
			TBX_ADVTPCHECK_Clear_DRC_Markers("tp2comp") 
			TBX_ADVTPCHECK_Clear_DRC_Markers("tp2tp") 
			TBX_ADVTPCHECK_Testpoint2Component_DRC_Run(form_handle)
		    ) 
		    ("drc_clear_markers" 
			TBX_ADVTPCHECK_Clear_DRC_Markers("tp2comp") 
			TBX_ADVTPCHECK_Clear_DRC_Markers("tp2tp")
		    )
		    ("drc_clear_all" 
			TBX_ADVTPCHECK_Clear_DRC_Markers("tp2comp") 
			TBX_ADVTPCHECK_Clear_DRC_Markers("tp2tp") 
			TBX_ADVTPCHECK_Clear_Restriction_Shapes()
		    )
		) 
		(axlVisibleLayer 
		    strcat((axlMapClassName "DRC ERROR CLASS") "/ALL") t
		) 
		(axlVisibleUpdate t) t
	    ) 
	    ("display_control" 
		(axlUIWShow 
		    ((tbx_advtpcheck_global->formId)->main) 
		    'hide
		) 
		(FORM_FILE = "tbx_advtpcheck_viscontrol.form") 
		unless(boundp('tbxAdvTpCheckVisControlHandle) 
		    defvar(tbxAdvTpCheckVisControlHandle nil)
		) 
		(fid = (axlFormCreate 
			'tbxAdvTpCheckVisControlHandle FORM_FILE 
			'(e outer) 
			'TBX_ADVTPCHECK_Visibility_Callback
			t nil
		    ))
		when(fid 
		    ((tbx_advtpcheck_global->formId)->visibility = fid) 
		    (axlFormDisplay fid) 
		    (axlDBControl 
			'activeLayer 
			strcat((axlMapClassName "DRC ERROR CLASS") "/ALL")
		    ) 
		    (axlVisibleUpdate t)
		)
	    ) 
	    ("done" 
		TBX_ADVTPCHECK_Save_Config(form_handle nil) 
		(axlFormClose form_handle) 
		TBX_ADVTPCHECK_Cleanup()
	    ) 
	    ("my_help" 
		(axlShell "tbx help advtpcheck")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_ADVTPCHECK_Map_Testpoint_Rules(tpAttr ruleParam rule_name fixed_value) 
    let((min_size max_size) 
	foreach(pv tpAttr 
	    cond((((rule_name == "") && fixed_value) 
		    (tpAttr[pv]->applyRule = rule_name) 
		    (tpAttr[pv]->tpInterSpacingAir = fixed_value) 
		    (tpAttr[pv]->tpInterSpacingCenter = fixed_value)
		) 
		(stringp(rule_name) 
		    (tpAttr[pv]->applyRule = rule_name) 
		    (tpAttr[pv]->tpInterSpacingAir = (ruleParam[rule_name]->tpInterSpacingAir)) 
		    (tpAttr[pv]->tpInterSpacingCenter = (ruleParam[rule_name]->tpInterSpacingCenter))
		) 
		(!rule_name 
		    foreach(rs ruleParam 
			(min_size = ((ruleParam[rs]->tpSize) - (ruleParam[rs]->tpSizeTolerance))) 
			(max_size = ((ruleParam[rs]->tpSize) + (ruleParam[rs]->tpSizeTolerance))) 
			when((((tpAttr[pv]->size) >= min_size) && ((tpAttr[pv]->size) <= max_size)) 
			    (tpAttr[pv]->applyRule = rs) 
			    (tpAttr[pv]->tpInterSpacingAir = (ruleParam[rs]->tpInterSpacingAir)) 
			    (tpAttr[pv]->tpInterSpacingCenter = (ruleParam[rs]->tpInterSpacingCenter))
			)
		    )
		)
	    )
	) tpAttr
    )
)
procedure(TBX_ADVTPCHECK_Ruleset_Callback(form_handle) 
    let((cur_ruleset answer new_set) 
	case((form_handle->curField) 
	    ("rulesetName" 
		(cur_ruleset = (form_handle->curValue)) 
		TBX_ADVTPCHECK_Init_Form(form_handle "ruleset" cur_ruleset)
	    ) 
	    ("tpSize" 
		(cur_ruleset = (axlFormGetField form_handle "rulesetName")) 
		((tbx_advtpcheck_global->ruleParam)[cur_ruleset]->tpSize = (form_handle->curValue))
	    ) 
	    ("tpSizeTolerance" 
		(cur_ruleset = (axlFormGetField form_handle "rulesetName")) 
		((tbx_advtpcheck_global->ruleParam)[cur_ruleset]->tpSizeTolerance = (form_handle->curValue))
	    ) 
	    ("tpInterSpacingAir" 
		(cur_ruleset = (axlFormGetField form_handle "rulesetName")) 
		((tbx_advtpcheck_global->ruleParam)[cur_ruleset]->tpInterSpacingAir = (form_handle->curValue))
	    )
	    ("tpInterSpacingCenter" 
		(cur_ruleset = (axlFormGetField form_handle "rulesetName")) 
		((tbx_advtpcheck_global->ruleParam)[cur_ruleset]->tpInterSpacingCenter = (form_handle->curValue))
	    ) 
	    ("grid" 
		caseq((form_handle->event) 
		    (change 
			(cur_ruleset = (axlFormGetField form_handle "rulesetName")) 
			((tbx_advtpcheck_global->ruleParam)[cur_ruleset]->tpCompSpacing = TBX_ADVTPCHECK_Ruleset_Extract_Grid_Data(form_handle))
		    ) 
		    (t t)
		)
	    ) 
	    ("tpCompInterpolateRules" 
		(cur_ruleset = (axlFormGetField form_handle "rulesetName")) 
		((tbx_advtpcheck_global->ruleParam)[cur_ruleset]->tpCompInterpolateRules = (form_handle->curValue))
	    ) 
	    ("addRuleset" 
		(new_set = (axlEnterString ?prompts 
			list("Specify ruleset name:")
		    )) 
		when((new_set && stringp(new_set)) 
		    (new_set = upperCase(new_set)) 
		    if(!(tbx_advtpcheck_global->ruleParam)[new_set] then 
			((tbx_advtpcheck_global->ruleParam)[new_set] = ncons(nil)) 
			((tbx_advtpcheck_global->ruleParam)[new_set]->tpSize = ((tbx_advtpcheck_global->ruleParam)["DEFAULT"]->tpSize)) 
			((tbx_advtpcheck_global->ruleParam)[new_set]->tpSizeTolerance = ((tbx_advtpcheck_global->ruleParam)["DEFAULT"]->tpSizeTolerance))
			((tbx_advtpcheck_global->ruleParam)[new_set]->tpInterSpacingAir = ((tbx_advtpcheck_global->ruleParam)["DEFAULT"]->tpInterSpacingAir)) 
			((tbx_advtpcheck_global->ruleParam)[new_set]->tpInterSpacingCenter = ((tbx_advtpcheck_global->ruleParam)["DEFAULT"]->tpInterSpacingCenter)) 
			((tbx_advtpcheck_global->ruleParam)[new_set]->tpCompSpacing = ((tbx_advtpcheck_global->ruleParam)["DEFAULT"]->tpCompSpacing)) 
			((tbx_advtpcheck_global->ruleParam)[new_set]->tpCompInterpolateRules = ((tbx_advtpcheck_global->ruleParam)["DEFAULT"]->tpCompInterpolateRules)) 
			TBX_ADVTPCHECK_Init_Form(form_handle "ruleset" new_set)
			else 
			printf("Warning: Ruleset already exist.\n")
		    )
		)
	    ) 
	    ("deleteRuleset" 
		(cur_ruleset = (axlFormGetField form_handle "ruleSetName")) 
		if((cur_ruleset == "DEFAULT") then 
		    (axlUIConfirm "Cannot delete ruleset DEFAULT" 
			'warn
		    ) else 
		    (answer = (axlUIYesNo 
			    sprintf(nil "Delete ruleset %s?" cur_ruleset) nil 
			    'no
			))
		    when(answer 
			remove(cur_ruleset 
			    (tbx_advtpcheck_global->ruleParam)
			) 
			TBX_ADVTPCHECK_Init_Form(form_handle "ruleset" "DEFAULT")
		    )
		)
	    )
	    ("done" 
		(axlFormClose form_handle) 
		(axlUIWShow 
		    ((tbx_advtpcheck_global->formId)->main) 
		    'show
		)
	    ) 
	    ("my_help" 
		(axlShell "tbx help advtpcheck")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_ADVTPCHECK_Ruleset_Extract_Grid_Data(form_handle) 
    let((cell comp_height tp_comp_distance rule_data) 
	for(i 1 
	    ((tbx_advtpcheck_global->defParam)->maxGridSize) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 1) 
	    (comp_height = ((axlFormGridGetCell form_handle "grid" cell)->value)) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i) 
	    (cell->col = 2)
	    (tp_comp_distance = ((axlFormGridGetCell form_handle "grid" cell)->value)) 
	    when((comp_height && tp_comp_distance) 
		(rule_data = cons(list(comp_height tp_comp_distance) rule_data))
	    )
	) 
	(rule_data = sortcar(rule_data 
		'lessp
	    )) rule_data
    )
)
procedure(TBX_ADVTPCHECK_Ruleset_Init_Grid_Cols(form_handle) 
    let((p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'REAL) 
	(p->colWidth = 6) 
	(p->min = 0.0)
	(p->max = (axlMKSConvert "100.0 MM" 
		car((axlDBGetDesignUnits))
	    )) 
	(p->headText = "Height") 
	(p->scriptLabel = "comp_height") 
	(axlFormGridInsertCol form_handle "grid" p) 
	(p = (make_formGridCol))
	(p->fieldType = 'REAL) 
	(p->colWidth = 6) 
	(p->min = 0.0) 
	(p->max = (axlMKSConvert "100.0 MM" 
		car((axlDBGetDesignUnits))
	    )) 
	(p->headText = "Spacing")
	(p->scriptLabel = "tp_comp_spacing") 
	(axlFormGridInsertCol form_handle "grid" p)
    )
)
procedure(TBX_ADVTPCHECK_Ruleset_Init_Grid_Rows(form_handle) 
    let((ruleset_name row_cnt) 
	(ruleset_name = (axlFormGetField form_handle "rulesetName")) 
	if((length(((tbx_advtpcheck_global->ruleParam)[ruleset_name]->tpCompSpacing)) > ((tbx_advtpcheck_global->defParam)->maxGridSize)) then 
	    (row_cnt = length(((tbx_advtpcheck_global->ruleParam)[ruleset_name]->tpCompSpacing))) else 
	    (row_cnt = ((tbx_advtpcheck_global->defParam)->maxGridSize))
	) 
	(axlFormGridInsertRows form_handle "grid" 0 row_cnt) 
	(axlFormGridSetBatch form_handle "grid" 
	    'TBX_ADVTPCHECK_Ruleset_Init_Grid_Rows_CB ruleset_name
	)
    )
)
procedure(TBX_ADVTPCHECK_Ruleset_Init_Grid_Rows_CB(set_name) 
    let((cell rownum) 
	(rownum = 1) 
	foreach(hsp 
	    ((tbx_advtpcheck_global->ruleParam)[set_name]->tpCompSpacing) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 1) 
	    (cell->row = rownum)
	    (cell->value = car(hsp)) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 2) 
	    (cell->row = rownum)
	    (cell->value = cadr(hsp)) 
	    (axlFormGridBatch cell) 
	    rownum++
	)
    )
)
procedure(TBX_ADVTPCHECK_Save_Config(form_handle output_file) 
    let((data data_str rulesets tmp_set port) 
	(data = tconc(nil nil)) 
	tconc(data 
	    list('units 
		car((axlDBGetDesignUnits))
	    )
	) 
	tconc(data 
	    list('tp2compFixedSpacingMode 
		(axlFormGetField form_handle "tp2compFixedSpacingMode")
	    )
	) 
	tconc(data 
	    list('tp2compFixedSpacingValue 
		(axlFormGetField form_handle "tp2compFixedSpacingValue")
	    )
	)
	tconc(data 
	    list('tp2compUseRulesetMode 
		(axlFormGetField form_handle "tp2compUseRulesetMode")
	    )
	) 
	tconc(data 
	    list('tp2compUseRulesetName 
		(axlFormGetField form_handle "tp2compUseRulesetName")
	    )
	) 
	tconc(data 
	    list('tp2compMatchRulesetMode 
		(axlFormGetField form_handle "tp2compMatchRulesetMode")
	    )
	) 
	tconc(data 
	    list('tp2compUseBoundary 
		(axlFormGetField form_handle "tp2compUseBoundary")
	    )
	) 
	tconc(data 
	    list('tp2compIgnoreDesignators 
		(axlFormGetField form_handle "tp2compIgnoreDesignators")
	    )
	)
	tconc(data 
	    list('tp2compDeriveHeightSymbolNDevice 
		(axlFormGetField form_handle "tp2compDeriveHeightSymbolNDevice")
	    )
	) 
	tconc(data 
	    list('tp2compGenerateRestrictionAreas 
		(axlFormGetField form_handle "tp2compGenerateRestrictionAreas")
	    )
	) 
	tconc(data 
	    list('tp2compCheckTestpointCenter 
		(axlFormGetField form_handle "tp2compCheckTestpointCenter")
	    )
	) 
	tconc(data 
	    list('tp2tpFixedSpacingMode 
		(axlFormGetField form_handle "tp2tpFixedSpacingMode")
	    )
	) 
	tconc(data 
	    list('tp2tpFixedSpacingValue 
		(axlFormGetField form_handle "tp2tpFixedSpacingValue")
	    )
	)
	tconc(data 
	    list('tp2tpUseRulesetMode 
		(axlFormGetField form_handle "tp2tpUseRulesetMode")
	    )
	) 
	tconc(data 
	    list('tp2tpUseRulesetName 
		(axlFormGetField form_handle "tp2tpUseRulesetName")
	    )
	) 
	tconc(data 
	    list('tp2tpMatchRulesetMode 
		(axlFormGetField form_handle "tp2tpMatchRulesetMode")
	    )
	) 
	tconc(data 
	    list('tp2tpCheckTestpointCenter 
		(axlFormGetField form_handle "tp2tpCheckTestpointCenter")
	    )
	) 
	(rulesets = tconc(nil nil))
	tconc(rulesets 
	    'ruleset
	) 
	foreach(rs 
	    TBX_UTIL_Get_Hash_Keys((tbx_advtpcheck_global->ruleParam) t) 
	    (tmp_set = list('name rs 
		    list('tpSize 
			((tbx_advtpcheck_global->ruleParam)[rs]->tpSize)
		    ) 
		    list('tpSizeTolerance 
			((tbx_advtpcheck_global->ruleParam)[rs]->tpSizeTolerance)
		    ) 
		    list('tpInterSpacingAir 
			((tbx_advtpcheck_global->ruleParam)[rs]->tpInterSpacingAir)
		    )
		    list('tpInterSpacingCenter 
			((tbx_advtpcheck_global->ruleParam)[rs]->tpInterSpacingCenter)
		    ) 
		    cons('tpCompSpacing 
			((tbx_advtpcheck_global->ruleParam)[rs]->tpCompSpacing)
		    ) 
		    list('tpCompInterpolateRules 
			((tbx_advtpcheck_global->ruleParam)[rs]->tpCompInterpolateRules)
		    )
		)) 
	    tconc(rulesets tmp_set)
	) 
	(rulesets = cdar(rulesets)) 
	tconc(data rulesets) 
	(data = cdar(data))
	if(output_file then 
	    (port = outfile(output_file)) 
	    pprint(data port) 
	    close(port)
	    else 
	    (axlDeleteAttachment "tbx_advtpcheck") 
	    (data_str = sprintf(nil "%L" data)) 
	    (axlCreateAttachment "tbx_advtpcheck" nil 1 
		'string
		data_str
	    )
	)
    )
)
procedure(TBX_ADVTPCHECK_Testpoint2Component_DRC_Run(form_handle) 
    let((ignore_pattern comp_list component_boundary derive_device_height result
	    generate_restriction_shapes bnd_info fixed_mode fixed_value use_ruleset_mode
	    use_ruleset_name match_ruleset_mode offset name_list drc_xy
	    spacing_act check_testpoint_center comp_np_poly refdes design_units
	    noProbeTop noProbeBottom symMaxHeight devMaxHeight sel_offset
	    spacing_rules cur_shape cur_poly cur_height boundary_layers
	    rule_name spacing_req tp_list tpAttr geom_window
	    comp_side np_layer marker_radius rpath drc_type
	    drc_cnt
	) 
	(drc_type = "Testpoint to Component") 
	(design_units = car((axlDBGetDesignUnits))) 
	(offset = (axlMKSConvert "1.0 MM" design_units)) 
	(marker_radius = (1.0 / (10.0**cadr((axlDBGetDesignUnits)))))
	(ignore_pattern = (axlFormGetField form_handle "tp2compIgnoreDesignators")) 
	(component_boundary = (axlFormGetField form_handle "tp2compUseBoundary")) 
	(derive_device_height = (axlFormGetField form_handle "tp2compDeriveHeightSymbolNDevice")) 
	(generate_restriction_shapes = (axlFormGetField form_handle "tp2compGenerateRestrictionAreas")) 
	(check_testpoint_center = (axlFormGetField form_handle "tp2compCheckTestpointCenter"))
	(fixed_mode = (axlFormGetField form_handle "tp2compFixedSpacingMode")) 
	(fixed_value = (axlFormGetField form_handle "tp2compFixedSpacingValue")) 
	(use_ruleset_mode = (axlFormGetField form_handle "tp2compUseRulesetMode")) 
	(use_ruleset_name = (axlFormGetField form_handle "tp2compUseRulesetName")) 
	(match_ruleset_mode = (axlFormGetField form_handle "tp2compMatchRulesetMode"))
	(boundary_layers = TBX_ADVTPCHECK_Get_Boundary_Layers(component_boundary)) 
	((tbx_advtpcheck_global->layers)->compBoundary = boundary_layers) 
	(tpAttr = TBX_ADVTPCHECK_Get_Testpoint_Attributes(((tbx_advtpcheck_global->defParam)->sizeAcc))) 
	cond((fixed_mode 
		(name_list = list("")) 
		(tpAttr = TBX_ADVTPCHECK_Map_Testpoint_Rules(tpAttr 
			(tbx_advtpcheck_global->ruleParam) "" fixed_value
		    ))
	    ) 
	    (use_ruleset_mode 
		(name_list = list(use_ruleset_name)) 
		(tpAttr = TBX_ADVTPCHECK_Map_Testpoint_Rules(tpAttr 
			(tbx_advtpcheck_global->ruleParam) use_ruleset_name nil
		    ))
	    ) 
	    (match_ruleset_mode 
		(name_list = TBX_UTIL_Get_Hash_Keys((tbx_advtpcheck_global->ruleParam) t)) 
		(tpAttr = TBX_ADVTPCHECK_Map_Testpoint_Rules(tpAttr 
			(tbx_advtpcheck_global->ruleParam) nil nil
		    ))
	    )
	) 
	when(generate_restriction_shapes 
	    (result = TBX_ADVTPCHECK_Init_No_Probe_Layers(name_list)) 
	    (noProbeTop = car(result)) 
	    (noProbeBottom = cadr(result))
	)
	(symMaxHeight = makeTable("sym_max_height_table" nil)) 
	(devMaxHeight = makeTable("dev_max_height_table" nil)) 
	(comp_list = TBX_ADVTPCHECK_Filter_Components(ignore_pattern)) 
	foreach(cmp comp_list 
	    (refdes = (cmp->name)) 
	    (result = TBX_ADVTPCHECK_Get_Component_Height(cmp)) 
	    (symMaxHeight[refdes] = caar(result))
	    when((derive_device_height && cadr(result)) 
		(devMaxHeight[refdes] = cadr(result))
	    )
	) 
	(drc_cnt = 0)
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "pins" "vias") ?onButtons 
	    list("all")
	) 
	foreach(cmp comp_list 
	    (refdes = (cmp->name)) 
	    (comp_side = "TOP") 
	    when(((cmp->symbol)->isMirrored) 
		(comp_side = "BOTTOM")
	    )
	    (bnd_info = TBX_ADVTPCHECK_Get_Component_Boundary(cmp boundary_layers)) 
	    foreach(entry bnd_info 
		(cur_shape = car(entry)) 
		(cur_poly = cadr(entry)) 
		cond((devMaxHeight[refdes] 
			(cur_height = devMaxHeight[refdes])
		    ) 
		    (!caddr(entry) 
			(cur_height = symMaxHeight[refdes])
		    ) 
		    (t 
			(cur_height = caddr(entry))
		    )
		)
		cond((fixed_mode 
			(spacing_rules = list(list(fixed_value ""))) 
			(sel_offset = (fixed_value + offset))
		    ) 
		    (use_ruleset_mode 
			(spacing_rules = TBX_ADVTPCHECK_Calculate_Component_Spacing(cur_height 
				(tbx_advtpcheck_global->ruleParam) use_ruleset_name
			    )) 
			(sel_offset = (caar(spacing_rules) + offset))
		    ) 
		    (match_ruleset_mode 
			(spacing_rules = TBX_ADVTPCHECK_Calculate_Component_Spacing(cur_height 
				(tbx_advtpcheck_global->ruleParam)
			    )) 
			(sel_offset = (caar(spacing_rules) + offset))
		    )
		) 
		(geom_window = (bBoxAdd 
			(cur_poly->bBox) 
			list(((- sel_offset):(- sel_offset)) 
			    (sel_offset:sel_offset)
			)
		    )) 
		(axlSingleSelectBox geom_window) 
		(tp_list = setof(x 
			(axlGetSelSet) 
			(x->testPoint)
		    )) 
		(axlClearSelSet)
		foreach(spce spacing_rules 
		    (spacing_req = car(spce)) 
		    (rule_name = cadr(spce)) 
		    (comp_np_poly = car((axlPolyExpand cur_poly spacing_req 
				'ALL_ARC
			    )
			))
		    when(generate_restriction_shapes 
			if(((cmp->symbol)->isMirrored) then 
			    (np_layer = noProbeBottom[rule_name]) else 
			    (np_layer = noProbeTop[rule_name])
			) 
			(axlDBCreateShape comp_np_poly t np_layer)
		    ) 
		    foreach(tp tp_list 
			(spacing_act = nil) 
			when((((tpAttr[tp]->applyRule) == rule_name) && ((tpAttr[tp]->side) == comp_side)) 
			    if(check_testpoint_center then 
				when((axlGeoPointInShape 
					(tp->xy) comp_np_poly
				    ) 
				    (drc_xy = (tp->xy)) 
				    (rpath = (axlPathStartCircle 
					    list((tp->xy) marker_radius) 0.0
					)) 
				    (result = (axlDBCreateShape rpath t 
					    ((tbx_advtpcheck_global->layers)->tmp)
					)) 
				    when(result 
					(spacing_act = (axlAirGap 
						car(result) cur_shape nil 
						'anyLayer
					    )) 
					(axlDeleteObject 
					    car(result)
					)
				    )
				    ++drc_cnt 
				    TBX_ADVTPCHECK_Create_DRC_Marker(drc_type comp_side drc_xy spacing_req spacing_act
					tp 
					(cmp->symbol)
				    )
				) else 
				(result = (axlPolyOperation 
					(tpAttr[tp]->poly) comp_np_poly 
					'AND
				    ))
				when(car(result) 
				    (spacing_act = (axlAirGap tp cur_shape 
					    (tp->padLayer) 
					    'anyLayer
					)) 
				    (drc_xy = TBX_UTIL_Get_Box_Center((car(result)->bBox))) 
				    ++drc_cnt 
				    TBX_ADVTPCHECK_Create_DRC_Marker(drc_type comp_side drc_xy spacing_req spacing_act
					tp 
					(cmp->symbol)
				    )
				)
			    )
			)
		    )
		)
	    )
	) 
	if((drc_cnt > 0) then 
	    printf("Testpoint to Component Check: %d errors detected.\n" drc_cnt) else 
	    printf("Testpoint to Component Check: No errors.\n")
	)
    )
)
procedure(TBX_ADVTPCHECK_Testpoint2Testpoint_DRC_Run(form_handle) 
    let((fixed_mode fixed_value use_ruleset_mode use_ruleset_name match_ruleset_mode
	    offset spacing_act check_testpoint_center tmp_values design_units
	    sel_offset spacing_req tpAttr geom_window spacing_a
	    spacing_b table_cnt tp_candidates drcDone drc_type
	    poly_exp drc_cnt
	) 
	(drc_type = "Testpoint to Testpoint") 
	(design_units = car((axlDBGetDesignUnits))) 
	(offset = (axlMKSConvert "1.0 MM" design_units)) 
	(check_testpoint_center = (axlFormGetField form_handle "tp2tpCheckTestpointCenter"))
	(fixed_mode = (axlFormGetField form_handle "tp2tpFixedSpacingMode")) 
	(fixed_value = (axlFormGetField form_handle "tp2tpFixedSpacingValue")) 
	(use_ruleset_mode = (axlFormGetField form_handle "tp2tpUseRulesetMode")) 
	(use_ruleset_name = (axlFormGetField form_handle "tp2tpUseRulesetName")) 
	(match_ruleset_mode = (axlFormGetField form_handle "tp2tpMatchRulesetMode"))
	foreach(rs 
	    (tbx_advtpcheck_global->ruleParam) 
	    (tmp_values = cons(((tbx_advtpcheck_global->ruleParam)[rs]->tpInterSpacingAir) tmp_values)) 
	    (tmp_values = cons(((tbx_advtpcheck_global->ruleParam)[rs]->tpInterSpacingCenter) tmp_values))
	) 
	(tmp_values = sort(tmp_values 
		'greaterp
	    )) 
	(sel_offset = (car(tmp_values) + offset)) 
	(tpAttr = TBX_ADVTPCHECK_Get_Testpoint_Attributes(((tbx_advtpcheck_global->defParam)->sizeAcc))) 
	cond((fixed_mode 
		(tpAttr = TBX_ADVTPCHECK_Map_Testpoint_Rules(tpAttr 
			(tbx_advtpcheck_global->ruleParam) "" fixed_value
		    ))
	    ) 
	    (use_ruleset_mode 
		(tpAttr = TBX_ADVTPCHECK_Map_Testpoint_Rules(tpAttr 
			(tbx_advtpcheck_global->ruleParam) use_ruleset_name nil
		    ))
	    ) 
	    (match_ruleset_mode 
		(tpAttr = TBX_ADVTPCHECK_Map_Testpoint_Rules(tpAttr 
			(tbx_advtpcheck_global->ruleParam) nil nil
		    ))
	    )
	)
	(table_cnt = 0) 
	(drc_cnt = 0) 
	(drcDone = makeTable("check_done_table" nil)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "pins" "vias") ?onButtons 
	    list("all")
	) 
	foreach(tp_a tpAttr 
	    unless(drcDone[tp_a] 
		(drcDone[tp_a] = makeTable(sprintf(nil "check_done_table_%d" 
			    ++table_cnt
			) nil
		    ))
	    ) 
	    (geom_window = (bBoxAdd 
		    ((tpAttr[tp_a]->poly)->bBox) 
		    list(((- sel_offset):(- sel_offset)) 
			(sel_offset:sel_offset)
		    )
		)) 
	    (axlClearSelSet)
	    (axlSingleSelectBox geom_window) 
	    (tp_candidates = setof(x 
		    (axlGetSelSet) 
		    (x->testPoint)
		)) 
	    (tp_candidates = setof(x tp_candidates 
		    (x != tp_a)
		)) 
	    foreach(tp_b tp_candidates 
		unless(drcDone[tp_b] 
		    (drcDone[tp_b] = makeTable(sprintf(nil "check_done_table_%d" 
				++table_cnt
			    ) nil
			))
		) 
		when(((tpAttr[tp_a]->side) == (tpAttr[tp_b]->side)) 
		    if(check_testpoint_center then 
			(spacing_a = (tpAttr[tp_a]->tpInterSpacingCenter)) 
			(spacing_b = (tpAttr[tp_b]->tpInterSpacingCenter)) 
			(spacing_req = max(spacing_a spacing_b))
			(spacing_act = (axlDistance 
				(tp_a->xy) 
				(tp_b->xy)
			    )) 
			when(((spacing_act < spacing_req) && !drcDone[tp_a][tp_b] && !drcDone[tp_b][tp_a]) 
			    ++drc_cnt 
			    TBX_ADVTPCHECK_Create_DRC_Marker(drc_type 
				(tpAttr[tp_a]->side) 
				(tp_a->xy) spacing_req spacing_act
				tp_a tp_b
			    ) 
			    (drcDone[tp_a][tp_b] = t) 
			    (drcDone[tp_b][tp_a] = t)
			) else 
			(spacing_a = (tpAttr[tp_a]->tpInterSpacingAir)) 
			(spacing_b = (tpAttr[tp_b]->tpInterSpacingAir))
			(spacing_req = max(spacing_a spacing_b)) 
			(spacing_act = (axlAirGap tp_a tp_b 
				(tp_a->testPoint) 
				'anyLayer
			    )) 
			(poly_exp = car((axlPolyExpand 
				    (tpAttr[tp_a]->poly) spacing_req 
				    'ALL_ARC
				)
			    )) 
			when((car((axlPolyOperation poly_exp 
					(tpAttr[tp_b]->poly) 
					'AND
				    )
				) && !drcDone[tp_a][tp_b] && !drcDone[tp_b][tp_a]) 
			    ++drc_cnt 
			    TBX_ADVTPCHECK_Create_DRC_Marker(drc_type 
				(tpAttr[tp_a]->side) 
				(tp_a->xy) spacing_req spacing_act
				tp_a tp_b
			    ) 
			    (drcDone[tp_a][tp_b] = t) 
			    (drcDone[tp_b][tp_a] = t)
			)
		    )
		)
	    )
	)
	if((drc_cnt > 0) then 
	    printf("Testpoint to Testpoint Check: %d errors detected.\n" drc_cnt) else 
	    printf("Testpoint to Testpoint Check: No errors.\n")
	)
    )
)
procedure(TBX_ADVTPCHECK_Update_Form(form_handle mode) 
    let((a) 
	(a = a) 
	when((mode == "tp2comp") 
	    cond(((axlFormGetField form_handle "tp2compFixedSpacingMode") 
		    (axlFormSetFieldEditable form_handle "tp2compFixedSpacingValue" t) 
		    (axlFormSetFieldEditable form_handle "tp2compUseRulesetName" nil) 
		    (axlFormSetFieldEditable form_handle "tp2compGenerateRestrictionAreas" t)
		) 
		((axlFormGetField form_handle "tp2compUseRulesetMode") 
		    (axlFormSetFieldEditable form_handle "tp2compFixedSpacingValue" nil) 
		    (axlFormSetFieldEditable form_handle "tp2compUseRulesetName" t) 
		    (axlFormSetFieldEditable form_handle "tp2compGenerateRestrictionAreas" t)
		) 
		((axlFormGetField form_handle "tp2compMatchRulesetMode") 
		    (axlFormSetFieldEditable form_handle "tp2compFixedSpacingValue" nil) 
		    (axlFormSetFieldEditable form_handle "tp2compUseRulesetName" nil) 
		    (axlFormSetFieldEditable form_handle "tp2compGenerateRestrictionAreas" t)
		)
	    )
	) 
	when((mode == "tp2tp") 
	    cond(((axlFormGetField form_handle "tp2tpFixedSpacingMode") 
		    (axlFormSetFieldEditable form_handle "tp2tpFixedSpacingValue" t) 
		    (axlFormSetFieldEditable form_handle "tp2tpUseRulesetName" nil)
		) 
		((axlFormGetField form_handle "tp2tpUseRulesetMode") 
		    (axlFormSetFieldEditable form_handle "tp2tpFixedSpacingValue" nil) 
		    (axlFormSetFieldEditable form_handle "tp2tpUseRulesetName" t)
		) 
		((axlFormGetField form_handle "tp2tpMatchRulesetMode") 
		    (axlFormSetFieldEditable form_handle "tp2tpFixedSpacingValue" nil) 
		    (axlFormSetFieldEditable form_handle "tp2tpUseRulesetName" nil)
		)
	    )
	)
    )
)
procedure(TBX_ADVTPCHECK_Visibility_Callback(form_handle) 
    let((a) 
	(a = a) 
	case((form_handle->curField) 
	    ("global_off" 
		TBX_ADVTPCHECK_Change_Visibility("global_off")
	    ) 
	    ("global_limit" 
		TBX_ADVTPCHECK_Change_Visibility("global_limit")
	    ) 
	    ("global_toggle_drc" 
		TBX_ADVTPCHECK_Change_Visibility("global_toggle_drc")
	    ) 
	    ("show_top" 
		TBX_ADVTPCHECK_Change_Visibility((form_handle->curValue))
	    )
	    ("hide_top" 
		TBX_ADVTPCHECK_Change_Visibility((form_handle->curValue))
	    ) 
	    ("show_bottom" 
		TBX_ADVTPCHECK_Change_Visibility((form_handle->curValue))
	    ) 
	    ("hide_bottom" 
		TBX_ADVTPCHECK_Change_Visibility((form_handle->curValue))
	    ) 
	    ("done" 
		(axlFormClose form_handle) 
		(axlUIWShow 
		    ((tbx_advtpcheck_global->formId)->main) 
		    'show
		)
	    ) 
	    ("my_help" 
		(axlShell "tbx help advtpcheck")
	    )
	    (t t)
	)
    )
)
procedure(TBX_ADVTPCHECK_Write_Component_Report(data) 
    let((report_file port ret refdes package
	    side xy_str sym_height_str dev_height_str tmp_list
	) 
	(report_file = strcat(getWorkingDir() "/component_report.txt")) 
	(port = outfile(report_file "w")) 
	fprintf(port "Component Details Report:\n") 
	fprintf(port "========================\n")
	fprintf(port "  Design:   %s\n" 
	    caddr((axlDMFileParts 
		    (axlGetDrawingName)
		)
	    )
	) 
	fprintf(port "  Date:     %s\n" 
	    getCurrentTime()
	) 
	fprintf(port "\n") 
	fprintf(port "  %-8s  %-25s  %-8s  %-20s  %-9s  %-9s\n" "Refdes" "Package" "Side"
	    "Location" "DevHeight" "SymHeight"
	) 
	fprintf(port "  -------------------------------------------------------------------------------------------------\n")
	foreach(entry data 
	    (refdes = car(entry)) 
	    (package = cadr(entry)) 
	    (side = caddr(entry))
	    (xy_str = sprintf(nil "%L" 
		    nth(3 entry)
		)) 
	    (sym_height_str = "NA") 
	    when(nth(4 entry) 
		if((length(nth(4 entry)) > 1) then 
		    (tmp_list = mapcar(lambda((x) 
				sprintf(nil "%L" x)
			    ) 
			    nth(4 entry)
			)) 
		    (sym_height_str = sprintf(nil "[%s]" 
			    buildString(tmp_list ", ")
			)) else
		    (sym_height_str = sprintf(nil "%L" 
			    car(nth(4 entry))
			))
		)
	    ) 
	    (dev_height_str = "NA") 
	    when(nth(5 entry) 
		(dev_height_str = sprintf(nil "%L" 
			nth(5 entry)
		    ))
	    )
	    fprintf(port "  %-8s  %-25s  %-8s  %-20s  %-9s  %-9s\n" refdes package side
		xy_str dev_height_str sym_height_str
	    )
	) 
	close(port) 
	when(isFile(report_file) 
	    printf("Note: File %L has been written\n" report_file) 
	    (ret = report_file)
	) ret
    )
)
procedure(TBX_ADVTPCHECK_Write_Spacing_Report(data) 
    let((report_file port rs_names ret refdes
	    package height_str tmp_table
	) 
	foreach(spce 
	    nth(3 
		car(data)
	    ) 
	    (rs_names = cons(cadr(spce) rs_names))
	) 
	(rs_names = sort(rs_names nil)) 
	(report_file = strcat(getWorkingDir() "/component_spacings_report.txt")) 
	(port = outfile(report_file "w"))
	fprintf(port "Component Spacings Report:\n") 
	fprintf(port "========================\n") 
	fprintf(port "  Design:   %s\n" 
	    caddr((axlDMFileParts 
		    (axlGetDrawingName)
		)
	    )
	) 
	fprintf(port "  Date:     %s\n" 
	    getCurrentTime()
	) 
	fprintf(port "\n")
	fprintf(port "  - Reports calculated component testpoint spacings by matching the height with each ruleset.\n") 
	fprintf(port "  - In case of multiple placebound heights, only the maximum height value will be reported (does not apply to DRC check).\n") 
	fprintf(port "  - The value reported by Height represents symbol height. If device height is enabled its value will take priority.\n") 
	fprintf(port "  - Pay attention to \"Interpolate spacing rules\" switch within each ruleset.\n") 
	fprintf(port "  - Components specifed by \"Ignore Designators\" won't be listed, also unplaced components are ignored.\n")
	fprintf(port "\n") 
	fprintf(port "  -----------------------------------------------------------------------------------------------------\n") 
	fprintf(port "  %-8s  %-25s  %-15s  %-s\n" " " " " " "
	    "Spacing Required"
	) 
	fprintf(port "  %-8s  %-25s  %-15s  %-s\n" " " " " " "
	    "-->"
	) 
	fprintf(port "  %-8s  %-25s  %-15s" "Refdes" "Package" "Height")
	foreach(rs rs_names 
	    fprintf(port "  %-15s" rs)
	) 
	fprintf(port "\n") 
	fprintf(port "  -----------------------------------------------------------------------------------------------------\n") 
	foreach(entry data 
	    (refdes = car(entry)) 
	    (package = cadr(entry)) 
	    (height_str = "NA")
	    when(caddr(entry) 
		(height_str = sprintf(nil "%.4f" 
			caddr(entry)
		    ))
	    ) 
	    (tmp_table = makeTable("tmp_table_data" "NA")) 
	    foreach(spce 
		nth(3 entry) 
		when(car(spce) 
		    (tmp_table[cadr(spce)] = sprintf(nil "%.4f" 
			    car(spce)
			))
		)
	    ) 
	    fprintf(port "  %-8s  %-25s  %-15s" refdes package height_str) 
	    foreach(rs rs_names 
		fprintf(port "  %-15s" 
		    tmp_table[rs]
		)
	    )
	    fprintf(port "\n")
	) 
	close(port)
	when(isFile(report_file) 
	    printf("Note: File %L has been written\n" report_file) 
	    (ret = report_file)
	) ret
    )
)
procedure(TBX_ADVTPCHECK_Write_Testpoint_Report(data) 
    let((report_file port ret total_number size_list
	    total_top_cnt total_bottom_cnt tpTOPCnt tpBOTTOMCnt tp_size
	    tp_side tp_size_str tp_refdes tp_xy_str
	) 
	(report_file = strcat(getWorkingDir() "/testpoint_report.txt")) 
	(tpTOPCnt = makeTable("tp_top_table" 0)) 
	(tpBOTTOMCnt = makeTable("tp_bottom_table" 0)) 
	(total_number = length(data))
	(total_top_cnt = 0) 
	(total_bottom_cnt = 0) 
	foreach(entry data 
	    (tp_size = car(entry)) 
	    (tp_side = cadr(entry)) 
	    unless(exists(x size_list 
		    (x == tp_size)
		) 
		(size_list = cons(tp_size size_list))
	    )
	    case(tp_side 
		("TOP" 
		    ++total_top_cnt 
		    ++tpTOPCnt[tp_size]
		) 
		("BOTTOM" 
		    ++total_bottom_cnt 
		    ++tpBOTTOMCnt[tp_size]
		)
	    )
	) 
	(size_list = sort(size_list 
		'lessp
	    )) 
	(port = outfile(report_file "w"))
	fprintf(port "Testpoint Summary:\n") 
	fprintf(port "==================\n") 
	fprintf(port "  Design:   %s\n" 
	    caddr((axlDMFileParts 
		    (axlGetDrawingName)
		)
	    )
	) 
	fprintf(port "  Date:     %s\n" 
	    getCurrentTime()
	) 
	fprintf(port "\n")
	fprintf(port "  Total number of testpoints:   %d\n" total_number) 
	fprintf(port "  Number of testpoints TOP:     %d\n" total_top_cnt) 
	fprintf(port "  Number of testpoints BOTTOM:  %d\n" total_bottom_cnt) 
	fprintf(port "  Detected sizes:               %L\n" size_list) 
	fprintf(port "\n")
	fprintf(port "  %-5s  %-10s  %-5s\n" "Size" "Side" "Count") 
	fprintf(port "  -------------------------\n") 
	foreach(s size_list 
	    (tp_size_str = sprintf(nil "%L" s)) 
	    fprintf(port "  %-5s  %-10s  %-5d\n" tp_size_str "TOP" 
		tpTOPCnt[s]
	    ) 
	    fprintf(port "  %-5s  %-10s  %-5d\n" tp_size_str "BOTTOM" 
		tpBOTTOMCnt[s]
	    )
	) 
	fprintf(port "\n") 
	fprintf(port "Testpoint Details:\n")
	fprintf(port "==================\n") 
	fprintf(port "  %-5s  %-8s  %-8s  %-15s\n" "Size" "Side" "TpDes"
	    "Location"
	) 
	fprintf(port "  ----------------------------------------------\n") 
	foreach(entry data 
	    (tp_size_str = sprintf(nil "%L" 
		    car(entry)
		)) 
	    (tp_side = cadr(entry)) 
	    (tp_refdes = caddr(entry))
	    (tp_xy_str = sprintf(nil "%L" 
		    nth(3 entry)
		)) 
	    fprintf(port "  %-5s  %-8s  %-8s  %-15s\n" tp_size_str tp_side tp_refdes
		tp_xy_str
	    )
	) 
	close(port)
	when(isFile(report_file) 
	    printf("Note: File %L has been written\n" report_file) 
	    (ret = report_file)
	) ret
    )
)
procedure(TBX_BARCODE_Get_Unit_Defaults(application default_value) 
    let((design_units) 
	(design_units = lowerCase(car((axlDBGetDesignUnits)))) 
	case(application 
	    ("linear" 
		if(((design_units == "microns") || (design_units == "millimeters") || (design_units == "centimeters")) then 
		    (default_value->barcodeHeight = (axlMKSConvert "10.0 MM" 
			    car((axlDBGetDesignUnits))
			)) 
		    (default_value->barcodeWidth = (axlMKSConvert "30.0 MM" 
			    car((axlDBGetDesignUnits))
			)) 
		    (default_value->minBarWidth = (axlMKSConvert "0.1 MM" 
			    car((axlDBGetDesignUnits))
			))
		    (default_value->marginTopBottom = (axlMKSConvert "2.0 MM" 
			    car((axlDBGetDesignUnits))
			)) 
		    (default_value->marginLeftRight = (axlMKSConvert "2.0 MM" 
			    car((axlDBGetDesignUnits))
			)) else 
		    (default_value->barcodeHeight = (axlMKSConvert "400.0 MILS" 
			    car((axlDBGetDesignUnits))
			)) 
		    (default_value->barcodeWidth = (axlMKSConvert "1200.0 MILS" 
			    car((axlDBGetDesignUnits))
			))
		    (default_value->minBarWidth = (axlMKSConvert "4.0 MILS" 
			    car((axlDBGetDesignUnits))
			)) 
		    (default_value->marginTopBottom = (axlMKSConvert "80.0 MILS" 
			    car((axlDBGetDesignUnits))
			)) 
		    (default_value->marginLeftRight = (axlMKSConvert "80.0 MILS" 
			    car((axlDBGetDesignUnits))
			))
		)
	    ) 
	    ("matrix" 
		if(((design_units == "microns") || (design_units == "millimeters") || (design_units == "centimeters")) then 
		    (default_value->unitSize = (axlMKSConvert "0.15 MM" 
			    car((axlDBGetDesignUnits))
			)) else 
		    (default_value->unitSize = (axlMKSConvert "6.0 MILS" 
			    car((axlDBGetDesignUnits))
			))
		)
	    )
	) default_value
    )
)
procedure(TBX_BARCODE_LINEAR_Calculate_Extents() 
    let((barcode_width margin_left_right margin_top_bottom embed_text text_block
	    text_value block_param tmp_list char_cnt box_width
	    box_height box_origin_x box_origin_y text_width text_height
	    text_origin_x text_origin_y barcode_height barcode_origin_x barcode_origin_y
	    token width height pt1 pt2
	    pt3 pt4 extents
	) 
	(extents = makeTable("extents_table" nil)) 
	(barcode_height = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "barcode_height"
	    )) 
	(barcode_width = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "barcode_width"
	    )) 
	(margin_left_right = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "margin_left_right"
	    ))
	(margin_top_bottom = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "margin_top_bottom"
	    )) 
	(embed_text = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "embed_text"
	    )) 
	(text_block = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "text_block"
	    )) 
	(text_value = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "text_value"
	    )) 
	(block_param = (axlGetParam 
		strcat("paramTextBlock:" 
		    sprintf(nil "%d" text_block)
		)
	    ))
	(box_origin_x = 0.0) 
	(box_origin_y = 0.0) 
	(char_cnt = strlen(text_value)) 
	if(embed_text then 
	    (text_width = ((char_cnt * (block_param->width)) + ((char_cnt - 1) * (block_param->charSpace)))) 
	    (text_height = (block_param->height)) 
	    (box_width = (max(barcode_width text_width) + 
		    (2 * margin_left_right)))
	    (box_height = (barcode_height + text_height + (tbx_barcode_linear_global->textOffset) + (2 * margin_top_bottom))) 
	    if((barcode_width >= text_width) then 
		(barcode_origin_x = (box_origin_x + margin_left_right)) 
		(text_origin_x = (box_origin_x + margin_left_right + ((barcode_width - text_width) / 2.0))) else
		(barcode_origin_x = (box_origin_x + margin_left_right + ((text_width - barcode_width) / 2.0))) 
		(text_origin_x = (box_origin_x + margin_left_right))
	    ) 
	    (barcode_origin_y = (box_origin_y + margin_top_bottom + text_height + (tbx_barcode_linear_global->textOffset))) 
	    (text_origin_y = (box_origin_y + margin_top_bottom)) else
	    (box_width = (barcode_width + (2 * margin_left_right))) 
	    (box_height = (barcode_height + (2 * margin_top_bottom))) 
	    (barcode_origin_x = (box_origin_x + margin_left_right)) 
	    (barcode_origin_y = (box_origin_y + margin_top_bottom))
	) 
	(tmp_list = list(list("box" 
		    (box_origin_x:box_origin_y) box_width box_height
		) 
		list("barcode" 
		    (barcode_origin_x:barcode_origin_y) barcode_width barcode_height
		)
	    ))
	when(embed_text 
	    (tmp_list = cons(list("text" 
			(text_origin_x:text_origin_y) text_width text_height
		    ) tmp_list
		))
	) 
	foreach(entry tmp_list 
	    (token = car(entry)) 
	    (pt1 = cadr(entry)) 
	    (width = caddr(entry))
	    (height = nth(3 entry)) 
	    (pt2 = ((car(pt1) + width):cadr(pt1))) 
	    (pt3 = ((car(pt1) + width):(cadr(pt1) + height))) 
	    (pt4 = (car(pt1):(cadr(pt1) + height))) 
	    (extents[token] = list(nil 
		    'origin pt1 
		    'width width
		    'height height 
		    'ptList 
		    list(pt1 pt2 pt3 pt4 pt1)
		))
	) extents
    )
)
procedure(TBX_BARCODE_LINEAR_Callback(form_handle) 
    let((class_name subclass_name text_block) 
	case((form_handle->curField) 
	    ("done" 
		(axlFinishEnterFun)
	    ) 
	    ("cancel" 
		(axlCancelEnterFun)
	    ) 
	    ("text_value" 
		TBX_BARCODE_LINEAR_Validate(list(nil 
			'getText t 
			'updateBarParam t
			'dynamicPreview t
		    )
		)
	    ) 
	    ("class_name" 
		(class_name = (axlMapClassName 
			(form_handle->curValue)
		    )) 
		(axlBuildSubclassPopup form_handle "subclass_name" class_name) 
		if((class_name == "DRAWING FORMAT") then 
		    (subclass_name = "OUTLINE") else 
		    (subclass_name = car((axlSubclasses class_name)))
		) 
		(axlFormSetField form_handle "subclass_name" subclass_name)
	    )
	    ("code39" 
		when((form_handle->curValue) 
		    TBX_BARCODE_LINEAR_Validate(list(nil 
			    'getText t 
			    'updateBarParam t
			    'dynamicPreview t
			)
		    )
		)
	    ) 
	    ("code128" 
		when((form_handle->curValue) 
		    TBX_BARCODE_LINEAR_Validate(list(nil 
			    'getText t 
			    'updateBarParam t
			    'dynamicPreview t
			)
		    )
		)
	    ) 
	    ("barcode_height" 
		when(((form_handle->curValue) < 0.0) 
		    printf("Warning: Only positive values are allowed\n") 
		    (axlFormSetField form_handle "barcode_height" 
			abs((form_handle->curValue))
		    )
		) 
		TBX_BARCODE_LINEAR_Validate(list(nil 
			'updateBarParam nil 
			'dynamicPreview t
		    )
		)
	    ) 
	    ("barcode_width" 
		when(((form_handle->curValue) < 0.0) 
		    printf("Warning: Only positive values are allowed\n") 
		    (axlFormSetField form_handle "barcode_width" 
			abs((form_handle->curValue))
		    )
		) 
		TBX_BARCODE_LINEAR_Validate(list(nil 
			'updateBarParam t 
			'dynamicPreview t
		    )
		)
	    ) 
	    ("min_bar_width" 
		TBX_BARCODE_LINEAR_Validate(list(nil 
			'updateBarParam t 
			'dynamicPreview t
		    )
		)
	    )
	    ("margin_top_bottom" 
		when(((form_handle->curValue) < 0.0) 
		    printf("Warning: Only positive values are allowed\n") 
		    (axlFormSetField form_handle "margin_top_bottom" 
			abs((form_handle->curValue))
		    )
		) 
		TBX_BARCODE_LINEAR_Validate(list(nil 
			'updateBarParam nil 
			'dynamicPreview t
		    )
		)
	    ) 
	    ("margin_left_right" 
		when(((form_handle->curValue) < 0.0) 
		    printf("Warning: Only positive values are allowed\n") 
		    (axlFormSetField form_handle "margin_left_right" 
			abs((form_handle->curValue))
		    )
		) 
		TBX_BARCODE_LINEAR_Validate(list(nil 
			'updateBarParam t 
			'dynamicPreview t
		    )
		)
	    ) 
	    ("embed_text" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "text_block" t) 
		    (text_block = sprintf(nil "%d" 
			    (axlFormGetField form_handle "text_block")
			)) 
		    when(((axlFormGetField form_handle "invert_structure") && 
			    zerop(((axlGetParam 
					strcat("paramTextBlock:" text_block)
				    )->photoWidth)
			    )) 
			(axlUIConfirm "Warning: For inverted structure text block photo width must be greater than 0.0\nChoose another text block.")
		    )
		    else 
		    (axlFormSetFieldEditable form_handle "text_block" nil)
		) 
		TBX_BARCODE_LINEAR_Validate(list(nil 
			'updateBarParam t 
			'dynamicPreview t
		    )
		)
	    ) 
	    ("text_block" 
		(text_block = sprintf(nil "%d" 
			(form_handle->curValue)
		    )) 
		when(((axlFormGetField form_handle "invert_structure") && 
			zerop(((axlGetParam 
				    strcat("paramTextBlock:" text_block)
				)->photoWidth)
			)) 
		    (axlUIConfirm "Warning: For inverted structure text block photo width must be greater than 0.0\nChoose another text block.")
		) 
		TBX_BARCODE_LINEAR_Validate(list(nil 
			'updateBarParam t 
			'dynamicPreview t
		    )
		)
	    ) 
	    ("invert_structure" 
		when(((form_handle->curValue) && (axlFormGetField form_handle "embed_text")) 
		    (text_block = sprintf(nil "%d" 
			    (axlFormGetField form_handle "text_block")
			)) 
		    when(zerop(((axlGetParam 
				    strcat("paramTextBlock:" text_block)
				)->photoWidth)
			) 
			(axlUIConfirm "Warning: For inverted structure text block photo width must be greater than 0.0\nChoose another text block.")
		    )
		) 
		TBX_BARCODE_LINEAR_Validate(list(nil 
			'updateBarParam t 
			'dynamicPreview t
		    )
		)
	    )
	    ("fix_barcode_width" 
		when((form_handle->curValue) 
		    (axlFormSetFieldEditable form_handle "barcode_width" t) 
		    (axlFormSetFieldEditable form_handle "min_bar_width" nil) 
		    TBX_BARCODE_LINEAR_Validate(list(nil 
			    'dynamicPreview t
			)
		    )
		)
	    ) 
	    ("fix_min_bar_width" 
		when((form_handle->curValue) 
		    (axlFormSetFieldEditable form_handle "barcode_width" nil) 
		    (axlFormSetFieldEditable form_handle "min_bar_width" t) 
		    TBX_BARCODE_LINEAR_Validate(list(nil 
			    'dynamicPreview t
			)
		    )
		)
	    ) 
	    ("place" 
		if(TBX_BARCODE_LINEAR_Validate(list(nil 
			    'getText t 
			    'updateBarParam t
			    'dynamicPreview t
			)
		    ) then 
		    ((tbx_barcode_linear_global->eventHandler)->pickOrigin = t) else 
		    printf("Warning: Invalid text to be encoded. Cannot generate data.\n")
		)
	    ) 
	    ("myhelp" 
		TBX_HELP_Launch("barcode")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_BARCODE_LINEAR_Check_Text_Against_Spec() 
    let((current_text new_text code_value is_code39 is_code128) 
	(current_text = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "text_value"
	    )) 
	(is_code39 = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "code39"
	    )) 
	(is_code128 = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "code128"
	    )) 
	(new_text = "")
	cond((is_code39 
		(code_value = ((tbx_barcode_linear_global->code39)->value)) 
		foreach(char 
		    parseString(current_text "") 
		    cond((rexMatchp("[a-z]" char) 
			    printf("Warning: Code39 does not support lower case characters, converting %L to upper case...\n" char) 
			    (char = upperCase(char)) 
			    (new_text = strcat(new_text char))
			) 
			(!code_value[char] 
			    printf("Warning: Code39 does not support character %L, skipping...\n" char)
			) 
			(t 
			    (new_text = strcat(new_text char))
			)
		    )
		)
	    ) 
	    (is_code128 
		(code_value = ((tbx_barcode_linear_global->code128)->valueB)) 
		foreach(char 
		    parseString(current_text "") 
		    cond((!code_value[char] 
			    printf("Warning: Code128 does not support character %L, skipping...\n" char)
			) 
			(t 
			    (new_text = strcat(new_text char))
			)
		    )
		)
	    )
	) 
	when((new_text != current_text) 
	    (axlFormSetField 
		(tbx_barcode_linear_global->formid) "text_value" new_text
	    )
	) t
    )
)
procedure(TBX_BARCODE_LINEAR_Cleanup() 
    let((param) 
	(axlVisibleLayer 
	    (tbx_barcode_linear_global->tmpLayer) t
	) 
	(axlDeleteByLayer 
	    (tbx_barcode_linear_global->tmpLayer)
	) 
	(param = (axlLayerGet 
		(tbx_barcode_linear_global->tmpLayer)
	    )) 
	when(param 
	    (axlDeleteObject param)
	)
	(axlVisibleUpdate t) 
	(axlDBRefreshId nil)
    )
)
procedure(TBX_BARCODE_LINEAR_Decompose_String(text_value) 
    let((substring_list previous_digit two_digit_str) 
	(substring_list = list()) 
	foreach(char 
	    parseString(text_value "") 
	    cond((rexMatchp("[0-9]" char) 
		    if(previous_digit then 
			(two_digit_str = strcat(previous_digit char)) 
			(substring_list = cons(two_digit_str substring_list)) 
			(previous_digit = nil)
			else 
			(previous_digit = char)
		    )
		) 
		(t 
		    when(previous_digit 
			(substring_list = cons(previous_digit substring_list))
		    ) 
		    (substring_list = cons(char substring_list)) 
		    (previous_digit = nil)
		)
	    )
	) 
	when(previous_digit 
	    (substring_list = cons(previous_digit substring_list))
	) 
	(substring_list = reverse(substring_list))
	substring_list
    )
)
procedure(TBX_BARCODE_LINEAR_Draw_Geometry(sym_location sym_inst) 
    let((form_handle text_orient text_value text_block class_name
	    subclass_name layer rpath text_origin extents
	    path_list shape_poly void_poly_list result text_dbid
	    text_poly_list
	) 
	(form_handle = (tbx_barcode_linear_global->formid)) 
	(extents = (tbx_barcode_linear_global->curExtents)) 
	(text_value = (axlFormGetField form_handle "text_value")) 
	(text_block = sprintf(nil "%d" 
		(axlFormGetField form_handle "text_block")
	    ))
	(class_name = (axlFormGetField form_handle "class_name")) 
	(subclass_name = (axlFormGetField form_handle "subclass_name")) 
	(layer = strcat(class_name "/" subclass_name)) 
	(axlVisibleLayer layer t) 
	when(sym_location 
	    (axlDBTransactionMark 
		(tbx_barcode_linear_global->transMark)
	    ) 
	    (rpath = (axlPathStart 
		    (extents["box"]->ptList) 0.0
		)) 
	    (rpath = (axlPathOffset rpath sym_location)) 
	    (axlDBCreateShape rpath nil 
		(tbx_barcode_linear_global->sysLayer) nil
		sym_inst
	    )
	    (rpath = (axlPathStart 
		    (extents["barcode"]->ptList) 0.0
		)) 
	    (rpath = (axlPathOffset rpath sym_location)) 
	    (axlDBCreateShape rpath nil 
		(tbx_barcode_linear_global->sysLayer) nil
		sym_inst
	    ) 
	    when((axlFormGetField form_handle "embed_text") 
		if((text_value != "") then 
		    (rpath = (axlPathStart 
			    (extents["text"]->ptList) 0.0
			)) 
		    (rpath = (axlPathOffset rpath sym_location)) 
		    (axlDBCreateShape rpath nil 
			(tbx_barcode_linear_global->sysLayer) nil
			sym_inst
		    )
		    else 
		    printf("Warning: Null text has been specified\n")
		)
	    ) 
	    (path_list = TBX_BARCODE_LINEAR_Process())
	    (void_poly_list = list()) 
	    if((axlFormGetField form_handle "invert_structure") then 
		(rpath = (axlPathStart 
			(extents["box"]->ptList) 0.0
		    )) 
		(rpath = (axlPathOffset rpath sym_location)) 
		(shape_poly = (axlPolyFromDB rpath))
		foreach(rp path_list 
		    (rpath = (axlPathOffset rp sym_location)) 
		    (void_poly_list = cons(car((axlPolyFromDB rpath)) void_poly_list))
		) 
		when((axlFormGetField form_handle "embed_text") 
		    when((text_value != "") 
			(text_origin = (extents["text"]->origin)) 
			(text_orient = (make_axlTextOrientation ?textBlock text_block ?rotation 0.0
				?mirrored nil ?justify "left"
			    )) 
			(result = (axlDBCreateText text_value 
				((car(text_origin) + car(sym_location)):(cadr(text_origin) + cadr(sym_location))) text_orient layer
				sym_inst
			    )) 
			(text_dbid = caar(result))
			(text_poly_list = TBX_BARCODE_LINEAR_Poly_From_Text(text_dbid 
				(tbx_barcode_linear_global->tmpLayer)
			    )) 
			(axlDeleteObject text_dbid) 
			foreach(tpl text_poly_list 
			    (void_poly_list = cons(tpl void_poly_list))
			)
		    )
		) 
		foreach(rp 
		    (axlPolyOperation shape_poly void_poly_list 
			'ANDNOT
		    ) 
		    (axlDBCreateShape rp t layer nil
			sym_inst
		    )
		) else 
		foreach(rp path_list 
		    (rpath = (axlPathOffset rp sym_location)) 
		    (axlDBCreateShape rpath t layer nil
			sym_inst
		    )
		)
		when((axlFormGetField form_handle "embed_text") 
		    when((text_value != "") 
			(text_origin = (extents["text"]->origin)) 
			(text_orient = (make_axlTextOrientation ?textBlock text_block ?rotation 0.0
				?mirrored nil ?justify "left"
			    )) 
			(result = (axlDBCreateText text_value 
				((car(text_origin) + car(sym_location)):(cadr(text_origin) + cadr(sym_location))) text_orient layer
				sym_inst
			    ))
		    )
		)
	    )
	)
	t
    )
)
procedure(TBX_BARCODE_LINEAR_Encode_Text() 
    let((substring_list is_code39 is_code128 code_value bar_data
	    text_value weight_list symbol_list start_symbol stop_symbol
	    check_symbol current_subset tmp_string check_sum full_symbol_list
	    symbol_arr symbol_value text_info
	) 
	(text_value = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "text_value"
	    )) 
	(is_code128 = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "code128"
	    )) 
	(is_code39 = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "code39"
	    )) 
	(text_info = ncons(nil))
	(weight_list = tconc(nil nil)) 
	(symbol_list = list()) 
	cond((is_code39 
		(code_value = ((tbx_barcode_linear_global->code39)->value)) 
		(bar_data = ((tbx_barcode_linear_global->code39)->data)) 
		(text_value = strcat("*" text_value "*")) 
		(substring_list = parseString(text_value ""))
		(tmp_string = buildString(substring_list "!")) 
		foreach(char 
		    parseString(tmp_string "") 
		    if((char != "!") then 
			(symbol_value = code_value[char]) 
			(symbol_list = cons(symbol_value symbol_list)) 
			when(symbol_value 
			    foreach(nr 
				bar_data[symbol_value] 
				tconc(weight_list nr)
			    )
			)
			else 
			tconc(weight_list 1)
		    )
		) 
		(symbol_list = reverse(symbol_list)) 
		(weight_list = cdar(weight_list)) 
		(text_info->value = text_value)
		(text_info->code = "code39") 
		(text_info->substringList = substring_list) 
		(text_info->symbolList = symbol_list) 
		(text_info->weightList = weight_list)
	    ) 
	    (is_code128 
		(substring_list = TBX_BARCODE_LINEAR_Decompose_String(text_value)) 
		(stop_symbol = ((tbx_barcode_linear_global->code128)->stop)) 
		(bar_data = ((tbx_barcode_linear_global->code128)->data)) 
		if(substring_list then 
		    (symbol_list = list()) 
		    foreach(str substring_list 
			cond(((strlen(str) == 2) 
				unless(start_symbol 
				    (start_symbol = ((tbx_barcode_linear_global->code128)->startC)) 
				    (current_subset = "C")
				) 
				case(current_subset 
				    ("A" 
					(symbol_list = cons(((tbx_barcode_linear_global->code128)->switchAtoC) symbol_list)) 
					(current_subset = "C")
				    ) 
				    ("B" 
					(symbol_list = cons(((tbx_barcode_linear_global->code128)->switchBtoC) symbol_list)) 
					(current_subset = "C")
				    ) 
				    (t t)
				) 
				(symbol_list = cons(((tbx_barcode_linear_global->code128)->valueC)[str] symbol_list))
			    ) 
			    (rexMatchp("[A-Z]" str) 
				unless(start_symbol 
				    (start_symbol = ((tbx_barcode_linear_global->code128)->startA)) 
				    (current_subset = "A")
				) 
				case(current_subset 
				    ("B" 
					(symbol_list = cons(((tbx_barcode_linear_global->code128)->switchBtoA) symbol_list)) 
					(current_subset = "A")
				    ) 
				    ("C" 
					(symbol_list = cons(((tbx_barcode_linear_global->code128)->switchCtoA) symbol_list)) 
					(current_subset = "A")
				    ) 
				    (t t)
				) 
				(symbol_list = cons(((tbx_barcode_linear_global->code128)->valueA)[str] symbol_list))
			    ) 
			    (t 
				unless(start_symbol 
				    (start_symbol = ((tbx_barcode_linear_global->code128)->startB)) 
				    (current_subset = "B")
				) 
				case(current_subset 
				    ("A" 
					(symbol_list = cons(((tbx_barcode_linear_global->code128)->switchAtoB) symbol_list)) 
					(current_subset = "B")
				    ) 
				    ("C" 
					(symbol_list = cons(((tbx_barcode_linear_global->code128)->switchCtoB) symbol_list)) 
					(current_subset = "B")
				    ) 
				    (t t)
				) 
				(symbol_list = cons(((tbx_barcode_linear_global->code128)->valueB)[str] symbol_list))
			    )
			)
		    ) 
		    (symbol_list = reverse(symbol_list))
		    (symbol_arr = listToVector(symbol_list)) 
		    (check_sum = start_symbol) 
		    for(i 0 
			(length(symbol_arr) - 1) 
			(check_sum = (check_sum + ((i + 1) * symbol_arr[i])))
		    ) 
		    (check_symbol = mod(check_sum 103)) 
		    (full_symbol_list = list())
		    (full_symbol_list = cons(start_symbol full_symbol_list)) 
		    foreach(sym symbol_list 
			(full_symbol_list = cons(sym full_symbol_list))
		    ) 
		    (full_symbol_list = cons(check_symbol full_symbol_list)) 
		    (full_symbol_list = cons(stop_symbol full_symbol_list)) 
		    (full_symbol_list = reverse(full_symbol_list))
		    else 
		    (full_symbol_list = list(((tbx_barcode_linear_global->code128)->startA) 0 
			    ((tbx_barcode_linear_global->code128)->stop)
			))
		)
		foreach(sym full_symbol_list 
		    foreach(nr 
			bar_data[sym] 
			tconc(weight_list nr)
		    )
		) 
		(weight_list = cdar(weight_list)) 
		(text_info->value = text_value) 
		(text_info->code = "code128") 
		(text_info->substringList = substring_list)
		(text_info->symbolList = full_symbol_list) 
		(text_info->weightList = weight_list)
	    ) 
	    (t t)
	) text_info
    )
)
procedure(TBX_BARCODE_LINEAR_Event_Loop() 
    let((eventMask loop event) 
	(axlEventSetStartPopup 
	    'TBX_BARCODE_LINEAR_Popup_Callback
	) 
	(eventMask = list('PICK)) 
	(loop = t) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil nil)) 
	    caseq((event->type) 
		(PICK 
		    if(((tbx_barcode_linear_global->eventHandler)->pickOrigin) then 
			TBX_BARCODE_LINEAR_Generate((event->xy)) 
			((tbx_barcode_linear_global->eventHandler)->pickOrigin = nil) else
			printf("Info: Use Place button or context menu RMB - Place Geom for final barcode generation.\n")
		    )
		) 
		(DONE 
		    (loop = nil) 
		    (axlDBTransactionCommit 
			(tbx_barcode_linear_global->transMark)
		    ) 
		    (axlClearDynamics) 
		    (axlFormClose 
			(tbx_barcode_linear_global->formid)
		    )
		) 
		(CANCEL 
		    (loop = nil) 
		    (axlDBTransactionRollback 
			(tbx_barcode_linear_global->transMark)
		    ) 
		    (axlClearDynamics) 
		    (axlFormClose 
			(tbx_barcode_linear_global->formid)
		    )
		)
	    )
	)
	(axlEventSetStartPopup)
    )
)
procedure(TBX_BARCODE_LINEAR_Generate(sym_location) 
    let((sym_name sym_inst form_handle msg) 
	(form_handle = (tbx_barcode_linear_global->formid)) 
	if((rexMatchp("!" 
		    (axlFormGetField form_handle "text_value")
		) && (axlFormGetField form_handle "code128") && 
		(axlFormGetField form_handle "embed_text")) then 
	    (msg = "Warning: ! character not supported while creating texts. Disable  embedding option or change the text to be encoded.") 
	    (axlUIConfirm msg) 
	    (axlClearDynamics)
	    else 
	    (sym_name = "tbx_barcode") 
	    (axlClearDynamics) 
	    if(!(axlSelectByName "SYMTYPE" sym_name) then 
		(axlDBCreateSymDefSkeleton 
		    list(sym_name "mechanical") 
		    list(list(0 
			    (axlMKSConvert -100 "MILS")
			) 
			list((axlMKSConvert 100 "MILS") 0)
		    )
		) else 
		(axlClearSelSet)
	    ) 
	    (sym_inst = car((axlDBCreateSymbolSkeleton 
			list(sym_name "mechanical") sym_location nil 0.0
			nil
		    )
		))
	    TBX_BARCODE_LINEAR_Draw_Geometry(sym_location sym_inst)
	) t
    )
)
procedure(TBX_BARCODE_LINEAR_Init() 
    let((text_offset code39_info code128_info data39 data128
	    value39 value128a value128b value128c sys_layer
	    tmp_layer min_single_width nr_str valid_classes
	) 
	(sys_layer = "PACKAGE GEOMETRY/TBX_BARCODE_OUTLINE") 
	(tmp_layer = "MANUFACTURING/TMP_DRAFTING") 
	(valid_classes = list((axlMapClassName "ETCH") 
		(axlMapClassName "BOARD GEOMETRY") 
		(axlMapClassName "PACKAGE GEOMETRY") 
		(axlMapClassName "MANUFACTURING") 
		(axlMapClassName "DRAWING FORMAT")
	    )) 
	(text_offset = (axlMKSConvert "1.0 MM" 
		car((axlDBGetDesignUnits))
	    ))
	(min_single_width = (axlMKSConvert "0.1 MM" 
		car((axlDBGetDesignUnits))
	    )) 
	unless((axlIsLayer sys_layer) 
	    (axlLayerCreateNonConductor sys_layer)
	) 
	unless((axlIsLayer tmp_layer) 
	    (axlLayerCreateNonConductor tmp_layer)
	) 
	declare(data39[44]) 
	(data39[0] = list(1 1 1 2 2
		1 2 1 1
	    ))
	(data39[1] = list(2 1 1 2 1
		1 1 1 2
	    )) 
	(data39[2] = list(1 1 2 2 1
		1 1 1 2
	    )) 
	(data39[3] = list(2 1 2 2 1
		1 1 1 1
	    )) 
	(data39[4] = list(1 1 1 2 2
		1 1 1 2
	    )) 
	(data39[5] = list(2 1 1 2 2
		1 1 1 1
	    ))
	(data39[6] = list(1 1 2 2 2
		1 1 1 1
	    )) 
	(data39[7] = list(1 1 1 2 1
		1 2 1 2
	    )) 
	(data39[8] = list(2 1 1 2 1
		1 2 1 1
	    )) 
	(data39[9] = list(1 1 2 2 1
		1 2 1 1
	    )) 
	(data39[10] = list(2 1 1 1 1
		2 1 1 2
	    ))
	(data39[11] = list(1 1 2 1 1
		2 1 1 2
	    )) 
	(data39[12] = list(2 1 2 1 1
		2 1 1 1
	    )) 
	(data39[13] = list(1 1 1 1 2
		2 1 1 2
	    )) 
	(data39[14] = list(2 1 1 1 2
		2 1 1 1
	    )) 
	(data39[15] = list(1 1 2 1 2
		2 1 1 1
	    ))
	(data39[16] = list(1 1 1 1 1
		2 2 1 2
	    )) 
	(data39[17] = list(2 1 1 1 1
		2 2 1 1
	    )) 
	(data39[18] = list(1 1 2 1 1
		2 2 1 1
	    )) 
	(data39[19] = list(1 1 1 1 2
		2 2 1 1
	    )) 
	(data39[20] = list(2 1 1 1 1
		1 1 2 2
	    ))
	(data39[21] = list(1 1 2 1 1
		1 1 2 2
	    )) 
	(data39[22] = list(2 1 2 1 1
		1 1 2 1
	    )) 
	(data39[23] = list(1 1 1 1 2
		1 1 2 2
	    )) 
	(data39[24] = list(2 1 1 1 2
		1 1 2 1
	    )) 
	(data39[25] = list(1 1 2 1 2
		1 1 2 1
	    ))
	(data39[26] = list(1 1 1 1 1
		1 2 2 2
	    )) 
	(data39[27] = list(2 1 1 1 1
		1 2 2 1
	    )) 
	(data39[28] = list(1 1 2 1 1
		1 2 2 1
	    )) 
	(data39[29] = list(1 1 1 1 2
		1 2 2 1
	    )) 
	(data39[30] = list(2 2 1 1 1
		1 1 1 2
	    ))
	(data39[31] = list(1 2 2 1 1
		1 1 1 2
	    )) 
	(data39[32] = list(2 2 2 1 1
		1 1 1 1
	    )) 
	(data39[33] = list(1 2 1 1 2
		1 1 1 2
	    )) 
	(data39[34] = list(2 2 1 1 2
		1 1 1 1
	    )) 
	(data39[35] = list(1 2 2 1 2
		1 1 1 1
	    ))
	(data39[36] = list(1 2 1 1 1
		1 2 1 2
	    )) 
	(data39[37] = list(2 2 1 1 1
		1 2 1 1
	    )) 
	(data39[38] = list(1 2 2 1 1
		1 2 1 1
	    )) 
	(data39[39] = list(1 2 1 2 1
		2 1 1 1
	    )) 
	(data39[40] = list(1 2 1 2 1
		1 1 2 1
	    ))
	(data39[41] = list(1 2 1 1 1
		2 1 2 1
	    )) 
	(data39[42] = list(1 1 1 2 1
		2 1 2 1
	    )) 
	(data39[43] = list(1 2 1 1 2
		1 2 1 1
	    )) 
	(value39 = makeTable("value39_table" nil)) 
	(value39["0"] = 0)
	(value39["1"] = 1) 
	(value39["2"] = 2) 
	(value39["3"] = 3) 
	(value39["4"] = 4) 
	(value39["5"] = 5)
	(value39["6"] = 6) 
	(value39["7"] = 7) 
	(value39["8"] = 8) 
	(value39["9"] = 9) 
	(value39["A"] = 10)
	(value39["B"] = 11) 
	(value39["C"] = 12) 
	(value39["D"] = 13) 
	(value39["E"] = 14) 
	(value39["F"] = 15)
	(value39["G"] = 16) 
	(value39["H"] = 17) 
	(value39["I"] = 18) 
	(value39["J"] = 19) 
	(value39["K"] = 20)
	(value39["L"] = 21) 
	(value39["M"] = 22) 
	(value39["N"] = 23) 
	(value39["O"] = 24) 
	(value39["P"] = 25)
	(value39["Q"] = 26) 
	(value39["R"] = 27) 
	(value39["S"] = 28) 
	(value39["T"] = 29) 
	(value39["U"] = 30)
	(value39["V"] = 31) 
	(value39["W"] = 32) 
	(value39["X"] = 33) 
	(value39["Y"] = 34) 
	(value39["Z"] = 35)
	(value39["-"] = 36) 
	(value39["."] = 37) 
	(value39[" "] = 38) 
	(value39["$"] = 39) 
	(value39["/"] = 40)
	(value39["+"] = 41) 
	(value39["%"] = 42) 
	(value39["*"] = 43) 
	declare(data128[107]) 
	(data128[0] = list(2 1 2 2 2
		2
	    ))
	(data128[1] = list(2 2 2 1 2
		2
	    )) 
	(data128[2] = list(2 2 2 2 2
		1
	    )) 
	(data128[3] = list(1 2 1 2 2
		3
	    )) 
	(data128[4] = list(1 2 1 3 2
		2
	    )) 
	(data128[5] = list(1 3 1 2 2
		2
	    ))
	(data128[6] = list(1 2 2 2 1
		3
	    )) 
	(data128[7] = list(1 2 2 3 1
		2
	    )) 
	(data128[8] = list(1 3 2 2 1
		2
	    )) 
	(data128[9] = list(2 2 1 2 1
		3
	    )) 
	(data128[10] = list(2 2 1 3 1
		2
	    ))
	(data128[11] = list(2 3 1 2 1
		2
	    )) 
	(data128[12] = list(1 1 2 2 3
		2
	    )) 
	(data128[13] = list(1 2 2 1 3
		2
	    )) 
	(data128[14] = list(1 2 2 2 3
		1
	    )) 
	(data128[15] = list(1 1 3 2 2
		2
	    ))
	(data128[16] = list(1 2 3 1 2
		2
	    )) 
	(data128[17] = list(1 2 3 2 2
		1
	    )) 
	(data128[18] = list(2 2 3 2 1
		1
	    )) 
	(data128[19] = list(2 2 1 1 3
		2
	    )) 
	(data128[20] = list(2 2 1 2 3
		1
	    ))
	(data128[21] = list(2 1 3 2 1
		2
	    )) 
	(data128[22] = list(2 2 3 1 1
		2
	    )) 
	(data128[23] = list(3 1 2 1 3
		1
	    )) 
	(data128[24] = list(3 1 1 2 2
		2
	    )) 
	(data128[25] = list(3 2 1 1 2
		2
	    ))
	(data128[26] = list(3 2 1 2 2
		1
	    )) 
	(data128[27] = list(3 1 2 2 1
		2
	    )) 
	(data128[28] = list(3 2 2 1 1
		2
	    )) 
	(data128[29] = list(3 2 2 2 1
		1
	    )) 
	(data128[30] = list(2 1 2 1 2
		3
	    ))
	(data128[31] = list(2 1 2 3 2
		1
	    )) 
	(data128[32] = list(2 3 2 1 2
		1
	    )) 
	(data128[33] = list(1 1 1 3 2
		3
	    )) 
	(data128[34] = list(1 3 1 1 2
		3
	    )) 
	(data128[35] = list(1 3 1 3 2
		1
	    ))
	(data128[36] = list(1 1 2 3 1
		3
	    )) 
	(data128[37] = list(1 3 2 1 1
		3
	    )) 
	(data128[38] = list(1 3 2 3 1
		1
	    )) 
	(data128[39] = list(2 1 1 3 1
		3
	    )) 
	(data128[40] = list(2 3 1 1 1
		3
	    ))
	(data128[41] = list(2 3 1 3 1
		1
	    )) 
	(data128[42] = list(1 1 2 1 3
		3
	    )) 
	(data128[43] = list(1 1 2 3 3
		1
	    )) 
	(data128[44] = list(1 3 2 1 3
		1
	    )) 
	(data128[45] = list(1 1 3 1 2
		3
	    ))
	(data128[46] = list(1 1 3 3 2
		1
	    )) 
	(data128[47] = list(1 3 3 1 2
		1
	    )) 
	(data128[48] = list(3 1 3 1 2
		1
	    )) 
	(data128[49] = list(2 1 1 3 3
		1
	    )) 
	(data128[50] = list(2 3 1 1 3
		1
	    ))
	(data128[51] = list(2 1 3 1 1
		3
	    )) 
	(data128[52] = list(2 1 3 3 1
		1
	    )) 
	(data128[53] = list(2 1 3 1 3
		1
	    )) 
	(data128[54] = list(3 1 1 1 2
		3
	    )) 
	(data128[55] = list(3 1 1 3 2
		1
	    ))
	(data128[56] = list(3 3 1 1 2
		1
	    )) 
	(data128[57] = list(3 1 2 1 1
		3
	    )) 
	(data128[58] = list(3 1 2 3 1
		1
	    )) 
	(data128[59] = list(3 3 2 1 1
		1
	    )) 
	(data128[60] = list(3 1 4 1 1
		1
	    ))
	(data128[61] = list(2 2 1 4 1
		1
	    )) 
	(data128[62] = list(4 3 1 1 1
		1
	    )) 
	(data128[63] = list(1 1 1 2 2
		4
	    )) 
	(data128[64] = list(1 1 1 4 2
		2
	    )) 
	(data128[65] = list(1 2 1 1 2
		4
	    ))
	(data128[66] = list(1 2 1 4 2
		1
	    )) 
	(data128[67] = list(1 4 1 1 2
		2
	    )) 
	(data128[68] = list(1 4 1 2 2
		1
	    )) 
	(data128[69] = list(1 1 2 2 1
		4
	    )) 
	(data128[70] = list(1 1 2 4 1
		2
	    ))
	(data128[71] = list(1 2 2 1 1
		4
	    )) 
	(data128[72] = list(1 2 2 4 1
		1
	    )) 
	(data128[73] = list(1 4 2 1 1
		2
	    )) 
	(data128[74] = list(1 4 2 2 1
		1
	    )) 
	(data128[75] = list(2 4 1 2 1
		1
	    ))
	(data128[76] = list(2 2 1 1 1
		4
	    )) 
	(data128[77] = list(4 1 3 1 1
		1
	    )) 
	(data128[78] = list(2 4 1 1 1
		2
	    )) 
	(data128[79] = list(1 3 4 1 1
		1
	    )) 
	(data128[80] = list(1 1 1 2 4
		2
	    ))
	(data128[81] = list(1 2 1 1 4
		2
	    )) 
	(data128[82] = list(1 2 1 2 4
		1
	    )) 
	(data128[83] = list(1 1 4 2 1
		2
	    )) 
	(data128[84] = list(1 2 4 1 1
		2
	    )) 
	(data128[85] = list(1 2 4 2 1
		1
	    ))
	(data128[86] = list(4 1 1 2 1
		2
	    )) 
	(data128[87] = list(4 2 1 1 1
		2
	    )) 
	(data128[88] = list(4 2 1 2 1
		1
	    )) 
	(data128[89] = list(2 1 2 1 4
		1
	    )) 
	(data128[90] = list(2 1 4 1 2
		1
	    ))
	(data128[91] = list(4 1 2 1 2
		1
	    )) 
	(data128[92] = list(1 1 1 1 4
		3
	    )) 
	(data128[93] = list(1 1 1 3 4
		1
	    )) 
	(data128[94] = list(1 3 1 1 4
		1
	    )) 
	(data128[95] = list(1 1 4 1 1
		3
	    ))
	(data128[96] = list(1 1 4 3 1
		1
	    )) 
	(data128[97] = list(4 1 1 1 1
		3
	    )) 
	(data128[98] = list(4 1 1 3 1
		1
	    )) 
	(data128[99] = list(1 1 3 1 4
		1
	    )) 
	(data128[100] = list(1 1 4 1 3
		1
	    ))
	(data128[101] = list(3 1 1 1 4
		1
	    )) 
	(data128[102] = list(4 1 1 1 3
		1
	    )) 
	(data128[103] = list(2 1 1 4 1
		2
	    )) 
	(data128[104] = list(2 1 1 2 1
		4
	    )) 
	(data128[105] = list(2 1 1 2 3
		2
	    ))
	(data128[106] = list(2 3 3 1 1
		1 2
	    )) 
	(value128a = makeTable("value128a_table" nil)) 
	(value128a[" "] = 0) 
	(value128a["!"] = 1) 
	(value128a["\""] = 2)
	(value128a["#"] = 3) 
	(value128a["$"] = 4) 
	(value128a["%"] = 5) 
	(value128a["&"] = 6) 
	(value128a["'"] = 7)
	(value128a["("] = 8) 
	(value128a[")"] = 9) 
	(value128a["*"] = 10) 
	(value128a["+"] = 11) 
	(value128a[","] = 12)
	(value128a["-"] = 13) 
	(value128a["."] = 14) 
	(value128a["/"] = 15) 
	(value128a["0"] = 16) 
	(value128a["1"] = 17)
	(value128a["2"] = 18) 
	(value128a["3"] = 19) 
	(value128a["4"] = 20) 
	(value128a["5"] = 21) 
	(value128a["6"] = 22)
	(value128a["7"] = 23) 
	(value128a["8"] = 24) 
	(value128a["9"] = 25) 
	(value128a[":"] = 26) 
	(value128a[";"] = 27)
	(value128a["<"] = 28) 
	(value128a["="] = 29) 
	(value128a[">"] = 30) 
	(value128a["?"] = 31) 
	(value128a["@"] = 32)
	(value128a["A"] = 33) 
	(value128a["B"] = 34) 
	(value128a["C"] = 35) 
	(value128a["D"] = 36) 
	(value128a["E"] = 37)
	(value128a["F"] = 38) 
	(value128a["G"] = 39) 
	(value128a["H"] = 40) 
	(value128a["I"] = 41) 
	(value128a["J"] = 42)
	(value128a["K"] = 43) 
	(value128a["L"] = 44) 
	(value128a["M"] = 45) 
	(value128a["N"] = 46) 
	(value128a["O"] = 47)
	(value128a["P"] = 48) 
	(value128a["Q"] = 49) 
	(value128a["R"] = 50) 
	(value128a["S"] = 51) 
	(value128a["T"] = 52)
	(value128a["U"] = 53) 
	(value128a["V"] = 54) 
	(value128a["W"] = 55) 
	(value128a["X"] = 56) 
	(value128a["Y"] = 57)
	(value128a["Z"] = 58) 
	(value128a["["] = 59) 
	(value128a["\\"] = 60) 
	(value128a["]"] = 61) 
	(value128a["^"] = 62)
	(value128a["_"] = 63) 
	(value128b = makeTable("value128b_table" nil)) 
	foreach(key value128a 
	    (value128b[key] = value128a[key])
	) 
	(value128b["a"] = 65) 
	(value128b["b"] = 66)
	(value128b["c"] = 67) 
	(value128b["d"] = 68) 
	(value128b["e"] = 69) 
	(value128b["f"] = 70) 
	(value128b["g"] = 71)
	(value128b["h"] = 72) 
	(value128b["i"] = 73) 
	(value128b["j"] = 74) 
	(value128b["k"] = 75) 
	(value128b["l"] = 76)
	(value128b["m"] = 77) 
	(value128b["n"] = 78) 
	(value128b["o"] = 79) 
	(value128b["p"] = 80) 
	(value128b["q"] = 81)
	(value128b["r"] = 82) 
	(value128b["s"] = 83) 
	(value128b["t"] = 84) 
	(value128b["u"] = 85) 
	(value128b["v"] = 86)
	(value128b["w"] = 87) 
	(value128b["x"] = 88) 
	(value128b["y"] = 89) 
	(value128b["z"] = 90) 
	(value128b["{"] = 91)
	(value128b["|"] = 92) 
	(value128b["}"] = 93) 
	(value128b["~"] = 94) 
	(value128c = makeTable("value128c_table" nil)) 
	for(i 0 99 
	    (nr_str = sprintf(nil "%02d" i)) 
	    (value128c[nr_str] = i)
	)
	(code39_info = ncons(nil)) 
	(code39_info->data = data39) 
	(code39_info->value = value39) 
	(code128_info = ncons(nil)) 
	(code128_info->data = data128)
	(code128_info->valueA = value128a) 
	(code128_info->valueB = value128b) 
	(code128_info->valueC = value128c) 
	(code128_info->startA = 103) 
	(code128_info->startB = 104)
	(code128_info->startC = 105) 
	(code128_info->stop = 106) 
	(code128_info->switchAtoB = 100) 
	(code128_info->switchAtoC = 99) 
	(code128_info->switchBtoA = 101)
	(code128_info->switchBtoC = 99) 
	(code128_info->switchCtoA = 101) 
	(code128_info->switchCtoB = 100) 
	unless(boundp('tbx_barcode_linear_global) 
	    iliDefstruct('defstruct(tbx_barcode_linear_global_struct code39 code128 curExtents formid
			sysLayer textOffset tmpLayer minSingleWidth textInfo
			validClasses licCheck eventHandler
		    )
	    ) 
	    defvar(tbx_barcode_linear_global nil)
	) 
	if(!tbx_barcode_linear_global then 
	    (tbx_barcode_linear_global = (make_tbx_barcode_linear_global_struct ?code39 code39_info ?code128 code128_info
		    ?curExtents nil ?formid nil ?minSingleWidth
		    min_single_width ?sysLayer sys_layer ?textOffset text_offset
		    ?textInfo nil ?tmpLayer tmp_layer ?validClasses
		    valid_classes ?licCheck nil ?eventHandler 
		    ncons(nil)
		)) else 
	    (tbx_barcode_linear_global->code39 = code39_info)
	    (tbx_barcode_linear_global->code128 = code128_info) 
	    (tbx_barcode_linear_global->curExtents = nil) 
	    (tbx_barcode_linear_global->formid = nil) 
	    (tbx_barcode_linear_global->minSingleWidth = min_single_width) 
	    (tbx_barcode_linear_global->sysLayer = sys_layer)
	    (tbx_barcode_linear_global->textOffset = text_offset) 
	    (tbx_barcode_linear_global->textInfo = nil) 
	    (tbx_barcode_linear_global->tmpLayer = tmp_layer) 
	    (tbx_barcode_linear_global->validClasses = valid_classes) 
	    (tbx_barcode_linear_global->licCheck = nil)
	    (tbx_barcode_linear_global->eventHandler = ncons(nil))
	)
    )
)
procedure(TBX_BARCODE_LINEAR_Init_Defaults() 
    let((cfg_file data default_value file_data) 
	(default_value = ncons(nil)) 
	(default_value->className = (axlMapClassName "ETCH")) 
	(default_value->subclassName = "TOP") 
	(default_value->code39 = t)
	(default_value->code128 = nil) 
	(default_value->fixWidth = t) 
	(default_value->fixMinBar = nil) 
	(default_value->embedText = nil) 
	(default_value->textBlock = 2)
	(default_value->invertStructure = nil) 
	(default_value = TBX_BARCODE_Get_Unit_Defaults("linear" default_value)) 
	(cfg_file = car(TBX_UTIL_Search_Config("barcode.ini" nil nil))) 
	when(cfg_file 
	    (file_data = TBX_UTIL_File_Lineread(cfg_file)) 
	    foreach(entry file_data 
		when((car(entry) == "linear") 
		    (data = cdr(entry))
		)
	    )
	) 
	foreach(entry data 
	    cond((memq(car(entry) 
			list('barcodeHeight 
			    'barcodeWidth 
			    'minBarWidth 
			    'marginTopBottom 
			    'marginLeftRight
			)
		    ) 
		    putprop(default_value 
			(axlMKSConvert 
			    cadr(entry) 
			    car((axlDBGetDesignUnits))
			) 
			car(entry)
		    )
		) 
		((car(entry) == 'className) 
		    putprop(default_value 
			(axlMapClassName 
			    cadr(entry)
			) 
			car(entry)
		    )
		) 
		(t 
		    putprop(default_value 
			cadr(entry) 
			car(entry)
		    )
		)
	    )
	)
	default_value
    )
)
procedure(TBX_BARCODE_LINEAR_Poly_From_Text(txt_dbid tmp_layer) 
    let((tmp_plt_file orgvis orgactive seg_poly_list poly_info) 
	(orgvis = (axlVisibleGet)) 
	(orgactive = (axlDBControl 
		'activeLayer
	    )) 
	(tmp_plt_file = (axlTempFile t)) 
	(axlDetailSave tmp_plt_file 
	    (txt_dbid->bBox) 
	    list(txt_dbid)
	)
	(axlDBControl 
	    'activeLayer tmp_layer
	) 
	(axlDetailLoad tmp_plt_file 
	    car((txt_dbid->bBox)) 1.0 0
	    nil
	) 
	(axlVisibleDesign nil) 
	(axlVisibleLayer tmp_layer t) 
	(axlVisibleUpdate nil)
	(axlSetFindFilter ?enabled 
	    list("noall" "linesegs") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlSingleSelectBox 
	    (txt_dbid->bBox)
	) 
	if((axlGetSelSet) then 
	    foreach(seg 
		(axlGetSelSet) 
		when(((seg->width) != 0.0) 
		    foreach(p 
			(axlPolyFromDB seg ?endCapType 
			    'ROUND
			) 
			(seg_poly_list = cons(p seg_poly_list))
		    )
		)
	    ) 
	    if(onep(length(seg_poly_list)) then 
		(poly_info = seg_poly_list) else 
		(poly_info = (axlPolyOperation 
			cdr(seg_poly_list) 
			list(car(seg_poly_list)) 
			'OR
		    ))
	    ) poly_info
	    else t
	) 
	when(isFile(tmp_plt_file) 
	    (axlTempFileRemove tmp_plt_file)
	)
	(axlDeleteObject 
	    (axlGetSelSet)
	) 
	(axlVisibleSet orgvis) 
	(axlDBControl 
	    'activeLayer orgactive
	) 
	(axlVisibleUpdate nil) poly_info
    )
)
procedure(TBX_BARCODE_LINEAR_Popup_Callback(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Place Geom" 
			'TBX_BARCODE_LINEAR_Popup_Place_Geom
		    ) 
		    list("Done" 
			'TBX_BARCODE_LINEAR_Popup_Done
		    ) 
		    list("Oops" 
			'TBX_BARCODE_LINEAR_Popup_Oops
		    ) 
		    list("Cancel" 
			'TBX_BARCODE_LINEAR_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_BARCODE_LINEAR_Popup_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_BARCODE_LINEAR_Popup_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_BARCODE_LINEAR_Popup_Oops() 
    (axlDBTransactionOops 
	(tbx_barcode_linear_global->transMark)
    )
)
procedure(TBX_BARCODE_LINEAR_Popup_Place_Geom() 
    if(TBX_BARCODE_LINEAR_Validate(list(nil 
		'getText t 
		'updateBarParam t
		'dynamicPreview t
	    )
	) then 
	((tbx_barcode_linear_global->eventHandler)->pickOrigin = t) else 
	printf("Warning: Invalid text to be encoded. Cannot generate data.\n")
    )
)
procedure(TBX_BARCODE_LINEAR_Process() 
    let((weight weight_arr barcode_frame origin origin_x
	    origin_y height min_bar_width path_list rpath
	    pt1 pt2 pt3 pt4
	) 
	(min_bar_width = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "min_bar_width"
	    )) 
	(barcode_frame = (tbx_barcode_linear_global->curExtents)["barcode"]) 
	(origin = (barcode_frame->origin)) 
	(height = (barcode_frame->height))
	(weight_arr = listToVector(((tbx_barcode_linear_global->textInfo)->weightList))) 
	(origin_x = car(origin)) 
	(origin_y = cadr(origin)) 
	for(i 0 
	    (length(weight_arr) - 1) 
	    (weight = weight_arr[i]) 
	    when(zerop(mod(i 2)) 
		(pt1 = (origin_x:origin_y)) 
		(pt2 = ((origin_x + (weight * min_bar_width)):origin_y)) 
		(pt3 = (car(pt2):(origin_y + height))) 
		(pt4 = (car(pt1):cadr(pt3)))
		(rpath = (axlPathStart 
			list(pt1 pt2 pt3 pt4 pt1) 0.0
		    )) 
		(path_list = cons(rpath path_list))
	    )
	    (origin_x = (origin_x + (weight * min_bar_width)))
	) path_list
    )
)
procedure(TBX_BARCODE_LINEAR_Update_Bar_Parameter() 
    let((barcode_width min_bar_width bar_cnt margin_left_right min_margin_left_right
	    is_code128
	) 
	(is_code128 = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "code128"
	    )) 
	(margin_left_right = (axlFormGetField 
		(tbx_barcode_linear_global->formid) "margin_left_right"
	    )) 
	(bar_cnt = 0) 
	foreach(w 
	    ((tbx_barcode_linear_global->textInfo)->weightList) 
	    (bar_cnt = (bar_cnt + w))
	)
	if((axlFormGetField 
		(tbx_barcode_linear_global->formid) "fix_min_bar_width"
	    ) then 
	    (min_bar_width = (axlFormGetField 
		    (tbx_barcode_linear_global->formid) "min_bar_width"
		)) 
	    (barcode_width = (bar_cnt * min_bar_width)) 
	    when(is_code128 
		(min_margin_left_right = (10.0 * min_bar_width)) 
		when((margin_left_right <= min_margin_left_right) 
		    printf("Info: Min margin left/right must be at leat ten times the single bar width. Adjusting value...\n") 
		    (axlFormSetField 
			(tbx_barcode_linear_global->formid) "margin_left_right" min_margin_left_right
		    )
		)
	    )
	    (axlFormSetField 
		(tbx_barcode_linear_global->formid) "barcode_width" barcode_width
	    ) else 
	    (barcode_width = (axlFormGetField 
		    (tbx_barcode_linear_global->formid) "barcode_width"
		)) 
	    (min_bar_width = (barcode_width / bar_cnt)) 
	    if((min_bar_width >= (tbx_barcode_linear_global->minSingleWidth)) then 
		(axlFormSetField 
		    (tbx_barcode_linear_global->formid) "min_bar_width" min_bar_width
		) else 
		printf("Warning: Min bar width is not allowed to be smaller than %f, changing barcode width unconditionally\n" 
		    (tbx_barcode_linear_global->minSingleWidth)
		)
		(min_bar_width = (tbx_barcode_linear_global->minSingleWidth)) 
		(barcode_width = (bar_cnt * min_bar_width)) 
		when(is_code128 
		    (min_margin_left_right = (10.0 * min_bar_width)) 
		    when((margin_left_right <= min_margin_left_right) 
			printf("Info: Min margin left/right must be at leat ten times the single bar width. Adjusting value...\n") 
			(axlFormSetField 
			    (tbx_barcode_linear_global->formid) "margin_left_right" min_margin_left_right
			)
		    )
		) 
		(axlFormSetField 
		    (tbx_barcode_linear_global->formid) "min_bar_width" 
		    (tbx_barcode_linear_global->minSingleWidth)
		) 
		(axlFormSetField 
		    (tbx_barcode_linear_global->formid) "barcode_width" barcode_width
		)
	    )
	)
    )
)
procedure(TBX_BARCODE_LINEAR_Update_Dynamics() 
    let((extents rpath) 
	(extents = (tbx_barcode_linear_global->curExtents)) 
	(axlClearDynamics) 
	(rpath = (axlPathStart 
		(extents["box"]->ptList) 0.0
	    )) 
	(axlAddSimpleMoveDynamics 
	    (0.0:0.0) rpath "path"
	)
	(rpath = (axlPathStart 
		(extents["barcode"]->ptList) 0.0
	    )) 
	(axlAddSimpleMoveDynamics 
	    (0.0:0.0) rpath "path"
	) 
	when(extents["text"] 
	    (rpath = (axlPathStart 
		    (extents["text"]->ptList) 0.0
		)) 
	    (axlAddSimpleMoveDynamics 
		(0.0:0.0) rpath "path"
	    )
	) t
    )
)
procedure(TBX_BARCODE_LINEAR_Validate(arg) 
    let((ok_data) 
	(ok_data = t) 
	when((arg->getText) 
	    TBX_BARCODE_LINEAR_Check_Text_Against_Spec() 
	    (tbx_barcode_linear_global->textInfo = TBX_BARCODE_LINEAR_Encode_Text()) 
	    cond((((((tbx_barcode_linear_global->textInfo)->code) == "code39") && (((tbx_barcode_linear_global->textInfo)->value) == "**")) 
		    (ok_data = nil)
		) 
		(((((tbx_barcode_linear_global->textInfo)->code) == "code128") && (((tbx_barcode_linear_global->textInfo)->value) == "")) 
		    (ok_data = nil)
		)
	    )
	) 
	if(ok_data then 
	    when((arg->updateBarParam) 
		TBX_BARCODE_LINEAR_Update_Bar_Parameter()
	    ) 
	    when((arg->dynamicPreview) 
		(tbx_barcode_linear_global->curExtents = TBX_BARCODE_LINEAR_Calculate_Extents()) 
		TBX_BARCODE_LINEAR_Update_Dynamics()
	    ) else
	    ((tbx_barcode_linear_global->eventHandler)->pickOrigin = nil) 
	    (axlClearDynamics) 
	    (axlVisibleUpdate t)
	) ok_data
    )
)
procedure(TBX_BARCODE_MATRIX_Calculate_Extents(form_handle) 
    let((box_origin_x box_origin_y box_width box_height extents
	    qr_version unit_size pt1 pt2 pt3
	    pt4
	) 
	(qr_version = (axlFormGetField form_handle "version")) 
	(unit_size = (axlFormGetField form_handle "unit_size")) 
	(box_origin_x = 0.0) 
	(box_origin_y = 0.0)
	(box_width = (((4 * atoi(qr_version)) + 17) * unit_size)) 
	(box_width = (box_width + (8 * unit_size))) 
	(box_height = box_width) 
	(pt1 = (box_origin_x:box_origin_y)) 
	(pt2 = ((box_origin_x + box_width):box_origin_y))
	(pt3 = ((box_origin_x + box_width):(box_origin_y + box_height))) 
	(pt4 = (box_origin_x:(box_origin_y + box_height))) 
	(extents = list(nil 
		'origin pt1 
		'width box_width
		'height box_height 
		'ptList 
		list(pt1 pt2 pt3 pt4 pt1)
	    )) extents
    )
)
procedure(TBX_BARCODE_MATRIX_Calculate_Form(iV iR iC) 
    let((iPosR iRetval) 
	(iPosR = ((iV * 4) + 10)) 
	cond((zerop(iR) 
		when((((iC >= 0) && (iC <= 6)) || ((iC >= iPosR) && (iC <= (iPosR + 6)))) 
		    (iRetval = 1)
		)
	    ) 
	    ((iR == 6) 
		when((zerop(mod(iC 2)) || 
			((iC >= 0) && (iC <= 6)) || ((iC >= iPosR) && (iC <= (iPosR + 6)))) 
		    (iRetval = 1)
		)
	    ) 
	    ((onep(iR) || (iR == 5)) 
		when((zerop(iC) || (iC == 6) || (iC == iPosR) || (iC == (iPosR + 6))) 
		    (iRetval = 1)
		)
	    ) 
	    (((iR >= 2) && (iR <= 4)) 
		when((zerop(iC) || ((iC >= 2) && (iC <= 4)) || (iC == 6) || (iC == iPosR) || ((iC >= (iPosR + 2)) && (iC <= (iPosR + 4))) || (iC == (iPosR + 6))) 
		    (iRetval = 1)
		)
	    ) 
	    ((iR == (iPosR - 2)) 
		cond(((iC == 6) 
			(iRetval = 1)
		    ) 
		    ((iV > 1) 
			when(((iC >= (iPosR - 2)) && (iC <= (iPosR + 2))) 
			    (iRetval = 1)
			)
		    )
		)
	    )
	    ((iR == (iPosR - 1)) 
		cond(((iC == 8) 
			(iRetval = 1)
		    ) 
		    ((iV > 1) 
			when(((iC == (iPosR - 2)) || (iC == (iPosR + 2))) 
			    (iRetval = 1)
			)
		    )
		)
	    ) 
	    ((iR == iPosR) 
		cond((((iC >= 0) && (iC <= 6)) 
			(iRetval = 1)
		    ) 
		    ((iV > 1) 
			when(((iC == (iPosR - 2)) || (iC == iPosR) || (iC == (iPosR + 2))) 
			    (iRetval = 1)
			)
		    )
		)
	    ) 
	    ((iR == (iPosR + 1)) 
		cond(((zerop(iC) || (iC == 6)) 
			(iRetval = 1)
		    ) 
		    ((iV > 1) 
			when(((iC == (iPosR - 2)) || (iC == (iPosR + 2))) 
			    (iRetval = 1)
			)
		    )
		)
	    ) 
	    ((iR == (iPosR + 2)) 
		cond(((zerop(iC) || ((iC >= 2) && (iC <= 4)) || (iC == 6)) 
			(iRetval = 1)
		    ) 
		    ((iV > 1) 
			when(((iC >= (iPosR - 2)) && (iC <= (iPosR + 2))) 
			    (iRetval = 1)
			)
		    )
		)
	    ) 
	    (((iR > (iPosR + 2)) && (iR <= (iPosR + 4))) 
		when((zerop(iC) || ((iC >= 2) && (iC <= 4)) || (iC == 6)) 
		    (iRetval = 1)
		)
	    )
	    ((iR == (iPosR + 5)) 
		when((zerop(iC) || (iC == 6)) 
		    (iRetval = 1)
		)
	    ) 
	    ((iR == (iPosR + 6)) 
		when(((iC >= 0) && (iC <= 6)) 
		    (iRetval = 1)
		)
	    ) 
	    (t 
		when((zerop(mod(iR 2)) && 
			(iC == 6)) 
		    (iRetval = 1)
		)
	    )
	) 
	unless(iRetval 
	    when(((iV >= 1) && (iV <= 6)) 
		(iRetval = 0)
	    )
	) 
	unless(iRetval 
	    (iRetval = 0) 
	    cond(((iV == 7) 
		    cond(((iR == 35) 
			    when(((iC >= 1) && (iC <= 4)) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when(((iC >= 35) && (iC <= 36)) 
				(iRetval = 1)
			    )
			) 
			((iR == 36) 
			    when((zerop(iC) || ((iC >= 3) && (iC <= 4)) || ((iC >= 20) && (iC <= 24))) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 20) && (iC <= 24)) || ((iC >= 34) && (iC <= 36))) 
				(iRetval = 1)
			    )
			) 
			((iR == 38) 
			    when(((iC == 20) || (iC == 22) || (iC == 24)) 
				(iRetval = 1)
			    )
			)
			((iR == 22) 
			    when(((iC == 4) || (iC == 8) || (iC == 20) || (iC == 22) || (iC == 24) || (iC == 36) || (iC == 38) || (iC == 40)) 
				(iRetval = 1)
			    )
			) 
			((iR == 34) 
			    when((iC == 4) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when((iC == 36) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 40)) 
			    when(((iC >= 20) && (iC <= 24)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 21) || (iR == 23)) 
			    when(((iC == 4) || (iC == 8) || (iC == 20) || (iC == 24) || (iC == 36) || (iC == 40)) 
				(iRetval = 1)
			    )
			)
			((onep(iR) || (iR == 2)) 
			    when((iC == 35) 
				(iRetval = 1)
			    )
			) 
			(((iR == 20) || (iR == 24)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 20) && (iC <= 24)) || ((iC >= 36) && (iC <= 40))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 5) || (iR == 7) || (iR == 37) || (iR == 39)) 
			    when(((iC == 20) || (iC == 24)) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 8) 
		    cond(((iR == 40) 
			    when((((iC >= 0) && (iC <= 2)) || ((iC >= 22) && (iC <= 26))) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when((iC == 40) 
				(iRetval = 1)
			    )
			) 
			((iR == 38) 
			    when((onep(iC) || (iC == 5)) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 22) || (iC == 26) || (iC == 38)) 
				(iRetval = 1)
			    )
			) 
			((iR == 24) 
			    when(((iC == 4) || (iC == 8) || (iC == 22) || (iC == 24) || (iC == 26) || (iC == 40) || (iC == 42) || (iC == 44)) 
				(iRetval = 1)
			    )
			)
			((iR == 39) 
			    when(((iC >= 1) && (iC <= 3)) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when(((iC >= 38) && (iC <= 40)) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when(((iC >= 39) && (iC <= 40)) 
				(iRetval = 1)
			    )
			) 
			((iR == 42) 
			    when(((iC == 22) || (iC == 24) || (iC == 26)) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when((iC == 39) 
				(iRetval = 1)
			    )
			)
			(((iR == 23) || (iR == 25)) 
			    when(((iC == 4) || (iC == 8) || (iC == 22) || (iC == 26) || (iC == 40) || (iC == 44)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 22) || (iR == 26)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 22) && (iC <= 26)) || ((iC >= 40) && (iC <= 44))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 41) || (iR == 43)) 
			    when(((iC == 22) || (iC == 26)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 4) || (iR == 8) || (iR == 44)) 
			    when(((iC >= 22) && (iC <= 26)) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 9) 
		    cond(((iR == 26) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 26) || (iC == 28) || (iC == 44) || (iC == 46) || (iC == 48)) 
				(iRetval = 1)
			    )
			) 
			((iR == 46) 
			    when(((iC == 24) || (iC == 26) || (iC == 28)) 
				(iRetval = 1)
			    )
			) 
			((iR == 44) 
			    when(((iC == 3) || ((iC >= 24) && (iC <= 28))) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 24) || (iC == 28) || (iC == 42)) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when((iC == 42) 
				(iRetval = 1)
			    )
			)
			(onep(iR) 
			    when(((iC >= 42) && (iC <= 43)) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when((iC == 43) 
				(iRetval = 1)
			    )
			) 
			((iR == 43) 
			    when(((iC >= 1) && (iC <= 2)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 24) && (iC <= 28)) || (iC == 42)) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when(((iC == 42) || (iC == 44)) 
				(iRetval = 1)
			    )
			)
			((iR == 42) 
			    when((((iC >= 0) && (iC <= 1)) || ((iC >= 3) && (iC <= 5))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 24) || (iR == 28)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 24) && (iC <= 28)) || ((iC >= 44) && (iC <= 48))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 25) || (iR == 27)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 28) || (iC == 44) || (iC == 48)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 48)) 
			    when(((iC >= 24) && (iC <= 28)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 45) || (iR == 47)) 
			    when(((iC == 24) || (iC == 28)) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 10) 
		    cond(((iR == 28) 
			    when(((iC == 4) || (iC == 8) || (iC == 26) || (iC == 28) || (iC == 30) || (iC == 48) || (iC == 50) || (iC == 52)) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 26) || (iC == 30) || (iC == 46)) 
				(iRetval = 1)
			    )
			) 
			((iR == 46) 
			    when((zerop(iC) || (iC == 2) || (iC == 5)) 
				(iRetval = 1)
			    )
			) 
			((iR == 50) 
			    when(((iC == 26) || (iC == 28) || (iC == 30)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 26) && (iC <= 30)) || (iC == 47)) 
				(iRetval = 1)
			    )
			)
			((iR == 47) 
			    when(((iC >= 0) && (iC <= 4)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 27) || (iR == 29)) 
			    when(((iC == 4) || (iC == 8) || (iC == 26) || (iC == 30) || (iC == 48) || (iC == 52)) 
				(iRetval = 1)
			    )
			) 
			((zerop(iR) || (iR == 2)) 
			    when(((iC >= 46) && (iC <= 47)) 
				(iRetval = 1)
			    )
			) 
			((onep(iR) || (iR == 3)) 
			    when((iC == 47) 
				(iRetval = 1)
			    )
			) 
			(((iR == 26) || (iR == 30)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 26) && (iC <= 30)) || ((iC >= 48) && (iC <= 52))) 
				(iRetval = 1)
			    )
			)
			(((iR == 7) || (iR == 49) || (iR == 51)) 
			    when(((iC == 26) || (iC == 30)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 48) || (iR == 52)) 
			    when(((iC >= 26) && (iC <= 30)) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 11) 
		    cond(((iR == 50) 
			    when(((iC >= 2) && (iC <= 5)) 
				(iRetval = 1)
			    )
			) 
			((iR == 52) 
			    when((((iC >= 0) && (iC <= 3)) || ((iC >= 28) && (iC <= 32))) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when(((iC >= 50) && (iC <= 52)) 
				(iRetval = 1)
			    )
			) 
			((iR == 30) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 30) || (iC == 32) || (iC == 52) || (iC == 54) || (iC == 56)) 
				(iRetval = 1)
			    )
			) 
			((iR == 54) 
			    when(((iC == 28) || (iC == 30) || (iC == 32)) 
				(iRetval = 1)
			    )
			)
			((iR == 4) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 50) && (iC <= 51))) 
				(iRetval = 1)
			    )
			) 
			((iR == 51) 
			    when((((iC >= 0) && (iC <= 2)) || (iC == 4)) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 28) || (iC == 32) || (iC == 50)) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when(((iC == 50) || (iC == 52)) 
				(iRetval = 1)
			    )
			) 
			((zerop(iR) || onep(iR)) 
			    when(((iC >= 51) && (iC <= 52)) 
				(iRetval = 1)
			    )
			)
			(((iR == 29) || (iR == 31)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 32) || (iC == 52) || (iC == 56)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 28) || (iR == 32)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 56)) 
			    when(((iC >= 28) && (iC <= 32)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 53) || (iR == 55)) 
			    when(((iC == 28) || (iC == 32)) 
				(iRetval = 1)
			    )
			)
		    )
		)
		((iV == 12) 
		    cond(((iR == 55) 
			    when((zerop(iC) || (iC == 3)) 
				(iRetval = 1)
			    )
			) 
			((iR == 56) 
			    when((((iC >= 1) && (iC <= 2)) || (iC == 4) || ((iC >= 30) && (iC <= 34))) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 30) || (iC == 34) || (iC == 54)) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when((iC == 56) 
				(iRetval = 1)
			    )
			) 
			((iR == 32) 
			    when(((iC == 4) || (iC == 8) || (iC == 30) || (iC == 32) || (iC == 34) || (iC == 56) || (iC == 58) || (iC == 60)) 
				(iRetval = 1)
			    )
			)
			((iR == 4) 
			    when((((iC >= 30) && (iC <= 34)) || (iC == 56)) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when(((iC >= 54) && (iC <= 55)) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when(((iC == 54) || (iC == 56)) 
				(iRetval = 1)
			    )
			) 
			((iR == 54) 
			    when((((iC >= 2) && (iC <= 3)) || (iC == 5)) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when((iC == 55) 
				(iRetval = 1)
			    )
			)
			((iR == 58) 
			    when(((iC == 30) || (iC == 32) || (iC == 34)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 30) || (iR == 34)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 30) && (iC <= 34)) || ((iC >= 56) && (iC <= 60))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 60)) 
			    when(((iC >= 30) && (iC <= 34)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 31) || (iR == 33)) 
			    when(((iC == 4) || (iC == 8) || (iC == 30) || (iC == 34) || (iC == 56) || (iC == 60)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 57) || (iR == 59)) 
			    when(((iC == 30) || (iC == 34)) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 13) 
		    cond(((iR == 3) 
			    when((iC == 60) 
				(iRetval = 1)
			    )
			) 
			((iR == 58) 
			    when((zerop(iC) || (iC == 2) || ((iC >= 4) && (iC <= 5))) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when((iC == 58) 
				(iRetval = 1)
			    )
			) 
			((iR == 62) 
			    when(((iC == 32) || (iC == 34) || (iC == 36)) 
				(iRetval = 1)
			    )
			) 
			((iR == 60) 
			    when((zerop(iC) || ((iC >= 3) && (iC <= 4)) || ((iC >= 32) && (iC <= 36))) 
				(iRetval = 1)
			    )
			)
			((iR == 34) 
			    when(((iC == 4) || (iC == 8) || (iC == 32) || (iC == 34) || (iC == 36) || (iC == 60) || (iC == 62) || (iC == 64)) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when(((iC >= 58) && (iC <= 60)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 32) && (iC <= 36)) || (iC == 58) || (iC == 60)) 
				(iRetval = 1)
			    )
			) 
			((iR == 59) 
			    when(zerop(iC) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 32) || (iC == 36) || (iC == 58)) 
				(iRetval = 1)
			    )
			)
			(((iR == 32) || (iR == 36)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 32) && (iC <= 36)) || ((iC >= 60) && (iC <= 64))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 33) || (iR == 35)) 
			    when(((iC == 4) || (iC == 8) || (iC == 32) || (iC == 36) || (iC == 60) || (iC == 64)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 64)) 
			    when(((iC >= 32) && (iC <= 36)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 61) || (iR == 63)) 
			    when(((iC == 32) || (iC == 36)) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 14) 
		    cond(((iR == 63) 
			    when(((iC >= 3) && (iC <= 4)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 24) && (iC <= 28)) || ((iC >= 44) && (iC <= 48)) || ((iC >= 63) && (iC <= 64))) 
				(iRetval = 1)
			    )
			) 
			((iR == 66) 
			    when(((iC == 24) || (iC == 26) || (iC == 28) || (iC == 44) || (iC == 46) || (iC == 48)) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when(((iC >= 62) && (iC <= 63)) 
				(iRetval = 1)
			    )
			) 
			((iR == 64) 
			    when((zerop(iC) || (iC == 4) || ((iC >= 24) && (iC <= 28)) || ((iC >= 44) && (iC <= 48))) 
				(iRetval = 1)
			    )
			)
			((iR == 5) 
			    when(((iC == 24) || (iC == 28) || (iC == 44) || (iC == 48) || (iC == 62)) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when(((iC == 62) || (iC == 64)) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when((iC == 62) 
				(iRetval = 1)
			    )
			) 
			((iR == 62) 
			    when((((iC >= 0) && (iC <= 1)) || (iC == 3) || (iC == 5)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 68)) 
			    when((((iC >= 24) && (iC <= 28)) || ((iC >= 44) && (iC <= 48))) 
				(iRetval = 1)
			    )
			)
			(((iR == 26) || (iR == 46)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 26) || (iC == 28) || (iC == 44) || (iC == 46) || (iC == 48) || (iC == 64) || (iC == 66) || (iC == 68)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 65) || (iR == 67)) 
			    when(((iC == 24) || (iC == 28) || (iC == 44) || (iC == 48)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 25) || (iR == 27) || (iR == 45) || (iR == 47)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 28) || (iC == 44) || (iC == 48) || (iC == 64) || (iC == 68)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 24) || (iR == 28) || (iR == 44) || (iR == 48)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 24) && (iC <= 28)) || ((iC >= 44) && (iC <= 48)) || ((iC >= 64) && (iC <= 68))) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 15) 
		    cond(((iR == 66) 
			    when((onep(iC) || ((iC >= 4) && (iC <= 5))) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 24) && (iC <= 28)) || ((iC >= 46) && (iC <= 50)) || ((iC >= 66) && (iC <= 68))) 
				(iRetval = 1)
			    )
			) 
			((iR == 68) 
			    when((((iC >= 1) && (iC <= 4)) || ((iC >= 24) && (iC <= 28)) || ((iC >= 46) && (iC <= 50))) 
				(iRetval = 1)
			    )
			) 
			((iR == 67) 
			    when((iC == 4) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when(((iC == 66) || (iC == 68)) 
				(iRetval = 1)
			    )
			)
			((iR == 70) 
			    when(((iC == 24) || (iC == 26) || (iC == 28) || (iC == 46) || (iC == 48) || (iC == 50)) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 24) || (iC == 28) || (iC == 46) || (iC == 50) || (iC == 66)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 2) || (iR == 3)) 
			    when((iC == 68) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 72)) 
			    when((((iC >= 24) && (iC <= 28)) || ((iC >= 46) && (iC <= 50))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 26) || (iR == 48)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 26) || (iC == 28) || (iC == 46) || (iC == 48) || (iC == 50) || (iC == 68) || (iC == 70) || (iC == 72)) 
				(iRetval = 1)
			    )
			)
			(((iR == 7) || (iR == 69) || (iR == 71)) 
			    when(((iC == 24) || (iC == 28) || (iC == 46) || (iC == 50)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 24) || (iR == 28) || (iR == 46) || (iR == 50)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 24) && (iC <= 28)) || ((iC >= 46) && (iC <= 50)) || ((iC >= 68) && (iC <= 72))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 25) || (iR == 27) || (iR == 47) || (iR == 49)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 28) || (iC == 46) || (iC == 50) || (iC == 68) || (iC == 72)) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 16) 
		    cond(((iR == 74) 
			    when(((iC == 24) || (iC == 26) || (iC == 28) || (iC == 48) || (iC == 50) || (iC == 52)) 
				(iRetval = 1)
			    )
			) 
			((iR == 70) 
			    when(((iC >= 1) && (iC <= 3)) 
				(iRetval = 1)
			    )
			) 
			((iR == 72) 
			    when((((iC >= 1) && (iC <= 3)) || ((iC >= 24) && (iC <= 28)) || ((iC >= 48) && (iC <= 52))) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when(((iC >= 70) && (iC <= 72)) 
				(iRetval = 1)
			    )
			) 
			((iR == 71) 
			    when((onep(iC) || (iC == 5)) 
				(iRetval = 1)
			    )
			)
			((iR == 5) 
			    when(((iC == 24) || (iC == 28) || (iC == 48) || (iC == 52) || (iC == 71)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 26) || (iR == 50)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 26) || (iC == 28) || (iC == 48) || (iC == 50) || (iC == 52) || (iC == 72) || (iC == 74) || (iC == 76)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 2) || (iR == 3)) 
			    when(((iC == 70) || (iC == 72)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 4) || (iR == 8) || (iR == 76)) 
			    when((((iC >= 24) && (iC <= 28)) || ((iC >= 48) && (iC <= 52))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 73) || (iR == 75)) 
			    when(((iC == 24) || (iC == 28) || (iC == 48) || (iC == 52)) 
				(iRetval = 1)
			    )
			)
			(((iR == 24) || (iR == 28) || (iR == 48) || (iR == 52)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 24) && (iC <= 28)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 72) && (iC <= 76))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 25) || (iR == 27) || (iR == 49) || (iR == 51)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 28) || (iC == 48) || (iC == 52) || (iC == 72) || (iC == 76)) 
				(iRetval = 1)
			    )
			)
		    )
		)
		((iV == 17) 
		    cond(((iR == 2) 
			    when((iC == 74) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when((iC == 75) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when(((iC == 74) || (iC == 76)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56)) || (iC == 74)) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 28) || (iC == 32) || (iC == 52) || (iC == 56) || (iC == 75)) 
				(iRetval = 1)
			    )
			)
			((iR == 74) 
			    when((((iC >= 0) && (iC <= 2)) || (iC == 4)) 
				(iRetval = 1)
			    )
			) 
			((iR == 78) 
			    when(((iC == 28) || (iC == 30) || (iC == 32) || (iC == 52) || (iC == 54) || (iC == 56)) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when(((iC >= 74) && (iC <= 75)) 
				(iRetval = 1)
			    )
			) 
			((iR == 76) 
			    when((zerop(iC) || ((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56))) 
				(iRetval = 1)
			    )
			) 
			((iR == 75) 
			    when((onep(iC) || (iC == 3) || (iC == 5)) 
				(iRetval = 1)
			    )
			)
			(((iR == 30) || (iR == 54)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 30) || (iC == 32) || (iC == 52) || (iC == 54) || (iC == 56) || (iC == 76) || (iC == 78) || (iC == 80)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 80)) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 77) || (iR == 79)) 
			    when(((iC == 28) || (iC == 32) || (iC == 52) || (iC == 56)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 29) || (iR == 31) || (iR == 53) || (iR == 55)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 32) || (iC == 52) || (iC == 56) || (iC == 76) || (iC == 80)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 28) || (iR == 32) || (iR == 52) || (iR == 56)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 76) && (iC <= 80))) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 18) 
		    cond(((iR == 79) 
			    when((((iC >= 0) && (iC <= 1)) || ((iC >= 4) && (iC <= 5))) 
				(iRetval = 1)
			    )
			) 
			((iR == 78) 
			    when((zerop(iC) || (iC == 3)) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when(((iC == 78) || (iC == 80)) 
				(iRetval = 1)
			    )
			) 
			((iR == 80) 
			    when((zerop(iC) || (iC == 3) || ((iC >= 28) && (iC <= 32)) || ((iC >= 54) && (iC <= 58))) 
				(iRetval = 1)
			    )
			) 
			((iR == 82) 
			    when(((iC == 28) || (iC == 30) || (iC == 32) || (iC == 54) || (iC == 56) || (iC == 58)) 
				(iRetval = 1)
			    )
			)
			((iR == 5) 
			    when(((iC == 28) || (iC == 32) || (iC == 54) || (iC == 58) || (iC == 79)) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when(((iC >= 78) && (iC <= 80)) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when((iC == 79) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 54) && (iC <= 58)) || (iC == 79)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 84)) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 54) && (iC <= 58))) 
				(iRetval = 1)
			    )
			)
			(((iR == 30) || (iR == 56)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 30) || (iC == 32) || (iC == 54) || (iC == 56) || (iC == 58) || (iC == 80) || (iC == 82) || (iC == 84)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 81) || (iR == 83)) 
			    when(((iC == 28) || (iC == 32) || (iC == 54) || (iC == 58)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 29) || (iR == 31) || (iR == 55) || (iR == 57)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 32) || (iC == 54) || (iC == 58) || (iC == 80) || (iC == 84)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 28) || (iR == 32) || (iR == 54) || (iR == 58)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 28) && (iC <= 32)) || ((iC >= 54) && (iC <= 58)) || ((iC >= 80) && (iC <= 84))) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 19) 
		    cond((onep(iR) 
			    when(((iC >= 83) && (iC <= 84)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 82) && (iC <= 83))) 
				(iRetval = 1)
			    )
			) 
			((iR == 84) 
			    when((((iC >= 1) && (iC <= 2)) || ((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60))) 
				(iRetval = 1)
			    )
			) 
			((iR == 83) 
			    when((((iC >= 0) && (iC <= 1)) || ((iC >= 3) && (iC <= 5))) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when((iC == 84) 
				(iRetval = 1)
			    )
			)
			((iR == 86) 
			    when(((iC == 28) || (iC == 30) || (iC == 32) || (iC == 56) || (iC == 58) || (iC == 60)) 
				(iRetval = 1)
			    )
			) 
			((iR == 82) 
			    when((iC == 4) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 28) || (iC == 32) || (iC == 56) || (iC == 60) || (iC == 83)) 
				(iRetval = 1)
			    )
			) 
			((zerop(iR) || (iR == 3)) 
			    when((iC == 83) 
				(iRetval = 1)
			    )
			) 
			(((iR == 30) || (iR == 58)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 30) || (iC == 32) || (iC == 56) || (iC == 58) || (iC == 60) || (iC == 84) || (iC == 86) || (iC == 88)) 
				(iRetval = 1)
			    )
			)
			(((iR == 8) || (iR == 88)) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 85) || (iR == 87)) 
			    when(((iC == 28) || (iC == 32) || (iC == 56) || (iC == 60)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 29) || (iR == 31) || (iR == 57) || (iR == 59)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 32) || (iC == 56) || (iC == 60) || (iC == 84) || (iC == 88)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 28) || (iR == 32) || (iR == 56) || (iR == 60)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 84) && (iC <= 88))) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 20) 
		    cond(((iR == 4) 
			    when((((iC >= 32) && (iC <= 36)) || ((iC >= 60) && (iC <= 64)) || (iC == 88)) 
				(iRetval = 1)
			    )
			) 
			((iR == 87) 
			    when((zerop(iC) || (iC == 2) || (iC == 5)) 
				(iRetval = 1)
			    )
			) 
			((iR == 88) 
			    when((((iC >= 0) && (iC <= 4)) || ((iC >= 32) && (iC <= 36)) || ((iC >= 60) && (iC <= 64))) 
				(iRetval = 1)
			    )
			) 
			((iR == 90) 
			    when(((iC == 32) || (iC == 34) || (iC == 36) || (iC == 60) || (iC == 62) || (iC == 64)) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 32) || (iC == 36) || (iC == 60) || (iC == 64) || (iC == 87)) 
				(iRetval = 1)
			    )
			)
			((onep(iR) || (iR == 3)) 
			    when((iC == 88) 
				(iRetval = 1)
			    )
			) 
			((zerop(iR) || (iR == 2)) 
			    when(((iC >= 87) && (iC <= 88)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 34) || (iR == 62)) 
			    when(((iC == 4) || (iC == 8) || (iC == 32) || (iC == 34) || (iC == 36) || (iC == 60) || (iC == 62) || (iC == 64) || (iC == 88) || (iC == 90) || (iC == 92)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 92)) 
			    when((((iC >= 32) && (iC <= 36)) || ((iC >= 60) && (iC <= 64))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 89) || (iR == 91)) 
			    when(((iC == 32) || (iC == 36) || (iC == 60) || (iC == 64)) 
				(iRetval = 1)
			    )
			)
			(((iR == 32) || (iR == 36) || (iR == 60) || (iR == 64)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 32) && (iC <= 36)) || ((iC >= 60) && (iC <= 64)) || ((iC >= 88) && (iC <= 92))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 33) || (iR == 35) || (iR == 61) || (iR == 63)) 
			    when(((iC == 4) || (iC == 8) || (iC == 32) || (iC == 36) || (iC == 60) || (iC == 64) || (iC == 88) || (iC == 92)) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 21) 
		    cond(((iR == 90) 
			    when((zerop(iC) || ((iC >= 3) && (iC <= 4))) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when((iC == 91) 
				(iRetval = 1)
			    )
			) 
			((iR == 91) 
			    when((zerop(iC) || ((iC >= 2) && (iC <= 3)) || (iC == 5)) 
				(iRetval = 1)
			    )
			) 
			((iR == 94) 
			    when(((iC == 26) || (iC == 28) || (iC == 30) || (iC == 48) || (iC == 50) || (iC == 52) || (iC == 70) || (iC == 72) || (iC == 74)) 
				(iRetval = 1)
			    )
			) 
			((iR == 92) 
			    when(((iC == 4) || ((iC >= 26) && (iC <= 30)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 70) && (iC <= 74))) 
				(iRetval = 1)
			    )
			)
			((iR == 5) 
			    when(((iC == 26) || (iC == 30) || (iC == 48) || (iC == 52) || (iC == 70) || (iC == 74) || (iC == 91)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 26) && (iC <= 30)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 70) && (iC <= 74)) || (iC == 90) || (iC == 92)) 
				(iRetval = 1)
			    )
			) 
			((zerop(iR) || (iR == 3)) 
			    when(((iC >= 90) && (iC <= 91)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 96)) 
			    when((((iC >= 26) && (iC <= 30)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 70) && (iC <= 74))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 93) || (iR == 95)) 
			    when(((iC == 26) || (iC == 30) || (iC == 48) || (iC == 52) || (iC == 70) || (iC == 74)) 
				(iRetval = 1)
			    )
			)
			(((iR == 28) || (iR == 50) || (iR == 72)) 
			    when(((iC == 4) || (iC == 8) || (iC == 26) || (iC == 28) || (iC == 30) || (iC == 48) || (iC == 50) || (iC == 52) || (iC == 70) || (iC == 72) || (iC == 74) || (iC == 92) || (iC == 94) || (iC == 96)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 27) || (iR == 29) || (iR == 49) || (iR == 51) || (iR == 71) || (iR == 73)) 
			    when(((iC == 4) || (iC == 8) || (iC == 26) || (iC == 30) || (iC == 48) || (iC == 52) || (iC == 70) || (iC == 74) || (iC == 92) || (iC == 96)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 26) || (iR == 30) || (iR == 48) || (iR == 52) || (iR == 70) || (iR == 74)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 26) && (iC <= 30)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 70) && (iC <= 74)) || ((iC >= 92) && (iC <= 96))) 
				(iRetval = 1)
			    )
			)
		    )
		)
		((iV == 22) 
		    cond(((iR == 98) 
			    when(((iC == 24) || (iC == 26) || (iC == 28) || (iC == 48) || (iC == 50) || (iC == 52) || (iC == 72) || (iC == 74) || (iC == 76)) 
				(iRetval = 1)
			    )
			) 
			((iR == 95) 
			    when(((iC == 2) || ((iC >= 4) && (iC <= 5))) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when((iC == 96) 
				(iRetval = 1)
			    )
			) 
			((iR == 96) 
			    when((((iC >= 3) && (iC <= 4)) || ((iC >= 24) && (iC <= 28)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 72) && (iC <= 76))) 
				(iRetval = 1)
			    )
			) 
			((iR == 94) 
			    when(((iC >= 0) && (iC <= 2)) 
				(iRetval = 1)
			    )
			)
			((iR == 4) 
			    when((((iC >= 24) && (iC <= 28)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 72) && (iC <= 76)) || ((iC >= 95) && (iC <= 96))) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 24) || (iC == 28) || (iC == 48) || (iC == 52) || (iC == 72) || (iC == 76) || (iC == 95)) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when(((iC >= 94) && (iC <= 95)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 100)) 
			    when((((iC >= 24) && (iC <= 28)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 72) && (iC <= 76))) 
				(iRetval = 1)
			    )
			) 
			((zerop(iR) || onep(iR)) 
			    when((iC == 94) 
				(iRetval = 1)
			    )
			)
			(((iR == 26) || (iR == 50) || (iR == 74)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 26) || (iC == 28) || (iC == 48) || (iC == 50) || (iC == 52) || (iC == 72) || (iC == 74) || (iC == 76) || (iC == 96) || (iC == 98) || (iC == 100)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 97) || (iR == 99)) 
			    when(((iC == 24) || (iC == 28) || (iC == 48) || (iC == 52) || (iC == 72) || (iC == 76)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 24) || (iR == 28) || (iR == 48) || (iR == 52) || (iR == 72) || (iR == 76)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 24) && (iC <= 28)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 72) && (iC <= 76)) || ((iC >= 96) && (iC <= 100))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 25) || (iR == 27) || (iR == 49) || (iR == 51) || (iR == 73) || (iR == 75)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 28) || (iC == 48) || (iC == 52) || (iC == 72) || (iC == 76) || (iC == 96) || (iC == 100)) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 23) 
		    cond(((iR == 3) 
			    when(((iC >= 98) && (iC <= 99)) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when(((iC >= 98) && (iC <= 100)) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when(((iC == 98) || (iC == 100)) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 28) || (iC == 32) || (iC == 52) || (iC == 56) || (iC == 76) || (iC == 80) || (iC == 99)) 
				(iRetval = 1)
			    )
			) 
			((iR == 100) 
			    when((((iC >= 0) && (iC <= 2)) || (iC == 4) || ((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 76) && (iC <= 80))) 
				(iRetval = 1)
			    )
			)
			((iR == 99) 
			    when(((iC >= 2) && (iC <= 5)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 76) && (iC <= 80)) || ((iC >= 98) && (iC <= 100))) 
				(iRetval = 1)
			    )
			) 
			((iR == 102) 
			    when(((iC == 28) || (iC == 30) || (iC == 32) || (iC == 52) || (iC == 54) || (iC == 56) || (iC == 76) || (iC == 78) || (iC == 80)) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when((iC == 100) 
				(iRetval = 1)
			    )
			) 
			((iR == 98) 
			    when(((iC >= 1) && (iC <= 4)) 
				(iRetval = 1)
			    )
			)
			(((iR == 8) || (iR == 104)) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 76) && (iC <= 80))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 101) || (iR == 103)) 
			    when(((iC == 28) || (iC == 32) || (iC == 52) || (iC == 56) || (iC == 76) || (iC == 80)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 30) || (iR == 54) || (iR == 78)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 30) || (iC == 32) || (iC == 52) || (iC == 54) || (iC == 56) || (iC == 76) || (iC == 78) || (iC == 80) || (iC == 100) || (iC == 102) || (iC == 104)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 28) || (iR == 32) || (iR == 52) || (iR == 56) || (iR == 76) || (iR == 80)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 76) && (iC <= 80)) || ((iC >= 100) && (iC <= 104))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 29) || (iR == 31) || (iR == 53) || (iR == 55) || (iR == 77) || (iR == 79)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 32) || (iC == 52) || (iC == 56) || (iC == 76) || (iC == 80) || (iC == 100) || (iC == 104)) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 24) 
		    cond((zerop(iR) 
			    when((iC == 104) 
				(iRetval = 1)
			    )
			) 
			((iR == 106) 
			    when(((iC == 26) || (iC == 28) || (iC == 30) || (iC == 52) || (iC == 54) || (iC == 56) || (iC == 78) || (iC == 80) || (iC == 82)) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when(((iC >= 102) && (iC <= 104)) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when(((iC >= 102) && (iC <= 103)) 
				(iRetval = 1)
			    )
			) 
			((iR == 104) 
			    when((zerop(iC) || (iC == 3) || ((iC >= 26) && (iC <= 30)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 78) && (iC <= 82))) 
				(iRetval = 1)
			    )
			)
			((iR == 5) 
			    when(((iC == 26) || (iC == 30) || (iC == 52) || (iC == 56) || (iC == 78) || (iC == 82) || ((iC >= 102) && (iC <= 103))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 102) || (iR == 103)) 
			    when((((iC >= 2) && (iC <= 3)) || (iC == 5)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 4) || (iR == 8) || (iR == 108)) 
			    when((((iC >= 26) && (iC <= 30)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 78) && (iC <= 82))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 105) || (iR == 107)) 
			    when(((iC == 26) || (iC == 30) || (iC == 52) || (iC == 56) || (iC == 78) || (iC == 82)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 28) || (iR == 54) || (iR == 80)) 
			    when(((iC == 4) || (iC == 8) || (iC == 26) || (iC == 28) || (iC == 30) || (iC == 52) || (iC == 54) || (iC == 56) || (iC == 78) || (iC == 80) || (iC == 82) || (iC == 104) || (iC == 106) || (iC == 108)) 
				(iRetval = 1)
			    )
			)
			(((iR == 26) || (iR == 30) || (iR == 52) || (iR == 56) || (iR == 78) || (iR == 82)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 26) && (iC <= 30)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 78) && (iC <= 82)) || ((iC >= 104) && (iC <= 108))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 27) || (iR == 29) || (iR == 53) || (iR == 55) || (iR == 79) || (iR == 81)) 
			    when(((iC == 4) || (iC == 8) || (iC == 26) || (iC == 30) || (iC == 52) || (iC == 56) || (iC == 78) || (iC == 82) || (iC == 104) || (iC == 108)) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 25) 
		    cond((onep(iR) 
			    when((iC == 108) 
				(iRetval = 1)
			    )
			) 
			((iR == 106) 
			    when((zerop(iC) || (iC == 2) || ((iC >= 4) && (iC <= 5))) 
				(iRetval = 1)
			    )
			) 
			((iR == 108) 
			    when((((iC >= 1) && (iC <= 2)) || ((iC >= 30) && (iC <= 34)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 82) && (iC <= 86))) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 30) || (iC == 34) || (iC == 56) || (iC == 60) || (iC == 82) || (iC == 86) || ((iC >= 106) && (iC <= 107))) 
				(iRetval = 1)
			    )
			) 
			((iR == 110) 
			    when(((iC == 30) || (iC == 32) || (iC == 34) || (iC == 56) || (iC == 58) || (iC == 60) || (iC == 82) || (iC == 84) || (iC == 86)) 
				(iRetval = 1)
			    )
			)
			((iR == 107) 
			    when(((iC == 2) || (iC == 5)) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when(((iC >= 106) && (iC <= 108)) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when((iC == 106) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 30) && (iC <= 34)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 82) && (iC <= 86)) || (iC == 106)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 112)) 
			    when((((iC >= 30) && (iC <= 34)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 82) && (iC <= 86))) 
				(iRetval = 1)
			    )
			)
			(((iR == 7) || (iR == 109) || (iR == 111)) 
			    when(((iC == 30) || (iC == 34) || (iC == 56) || (iC == 60) || (iC == 82) || (iC == 86)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 32) || (iR == 58) || (iR == 84)) 
			    when(((iC == 4) || (iC == 8) || (iC == 30) || (iC == 32) || (iC == 34) || (iC == 56) || (iC == 58) || (iC == 60) || (iC == 82) || (iC == 84) || (iC == 86) || (iC == 108) || (iC == 110) || (iC == 112)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 31) || (iR == 33) || (iR == 57) || (iR == 59) || (iR == 83) || (iR == 85)) 
			    when(((iC == 4) || (iC == 8) || (iC == 30) || (iC == 34) || (iC == 56) || (iC == 60) || (iC == 82) || (iC == 86) || (iC == 108) || (iC == 112)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 30) || (iR == 34) || (iR == 56) || (iR == 60) || (iR == 82) || (iR == 86)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 30) && (iC <= 34)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 82) && (iC <= 86)) || ((iC >= 108) && (iC <= 112))) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 26) 
		    cond(((iR == 112) 
			    when((((iC >= 1) && (iC <= 3)) || ((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 84) && (iC <= 88))) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when(((iC >= 110) && (iC <= 111)) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when(((iC == 110) || (iC == 112)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 84) && (iC <= 88)) || (iC == 111)) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when(((iC >= 110) && (iC <= 112)) 
				(iRetval = 1)
			    )
			)
			((iR == 110) 
			    when((((iC >= 0) && (iC <= 1)) || (iC == 3) || (iC == 5)) 
				(iRetval = 1)
			    )
			) 
			((iR == 114) 
			    when(((iC == 28) || (iC == 30) || (iC == 32) || (iC == 56) || (iC == 58) || (iC == 60) || (iC == 84) || (iC == 86) || (iC == 88)) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when(((iC >= 111) && (iC <= 112)) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 28) || (iC == 32) || (iC == 56) || (iC == 60) || (iC == 84) || (iC == 88) || ((iC >= 110) && (iC <= 111))) 
				(iRetval = 1)
			    )
			) 
			((iR == 111) 
			    when((zerop(iC) || ((iC >= 2) && (iC <= 5))) 
				(iRetval = 1)
			    )
			)
			(((iR == 8) || (iR == 116)) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 84) && (iC <= 88))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 113) || (iR == 115)) 
			    when(((iC == 28) || (iC == 32) || (iC == 56) || (iC == 60) || (iC == 84) || (iC == 88)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 30) || (iR == 58) || (iR == 86)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 30) || (iC == 32) || (iC == 56) || (iC == 58) || (iC == 60) || (iC == 84) || (iC == 86) || (iC == 88) || (iC == 112) || (iC == 114) || (iC == 116)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 29) || (iR == 31) || (iR == 57) || (iR == 59) || (iR == 85) || (iR == 87)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 32) || (iC == 56) || (iC == 60) || (iC == 84) || (iC == 88) || (iC == 112) || (iC == 116)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 28) || (iR == 32) || (iR == 56) || (iR == 60) || (iR == 84) || (iR == 88)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 84) && (iC <= 88)) || ((iC >= 112) && (iC <= 116))) 
				(iRetval = 1)
			    )
			)
		    )
		)
		((iV == 27) 
		    cond(((iR == 116) 
			    when((zerop(iC) || ((iC >= 32) && (iC <= 36)) || ((iC >= 60) && (iC <= 64)) || ((iC >= 88) && (iC <= 92))) 
				(iRetval = 1)
			    )
			) 
			((iR == 114) 
			    when((onep(iC) || ((iC >= 4) && (iC <= 5))) 
				(iRetval = 1)
			    )
			) 
			((iR == 118) 
			    when(((iC == 32) || (iC == 34) || (iC == 36) || (iC == 60) || (iC == 62) || (iC == 64) || (iC == 88) || (iC == 90) || (iC == 92)) 
				(iRetval = 1)
			    )
			) 
			((iR == 115) 
			    when((zerop(iC) || (iC == 2) || ((iC >= 4) && (iC <= 5))) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when((iC == 114) 
				(iRetval = 1)
			    )
			)
			(zerop(iR) 
			    when(((iC >= 115) && (iC <= 116)) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 32) || (iC == 36) || (iC == 60) || (iC == 64) || (iC == 88) || (iC == 92) || ((iC >= 114) && (iC <= 115))) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when((iC == 115) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 32) && (iC <= 36)) || ((iC >= 60) && (iC <= 64)) || ((iC >= 88) && (iC <= 92)) || ((iC >= 114) && (iC <= 115))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 120)) 
			    when((((iC >= 32) && (iC <= 36)) || ((iC >= 60) && (iC <= 64)) || ((iC >= 88) && (iC <= 92))) 
				(iRetval = 1)
			    )
			)
			(((iR == 34) || (iR == 62) || (iR == 90)) 
			    when(((iC == 4) || (iC == 8) || (iC == 32) || (iC == 34) || (iC == 36) || (iC == 60) || (iC == 62) || (iC == 64) || (iC == 88) || (iC == 90) || (iC == 92) || (iC == 116) || (iC == 118) || (iC == 120)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 117) || (iR == 119)) 
			    when(((iC == 32) || (iC == 36) || (iC == 60) || (iC == 64) || (iC == 88) || (iC == 92)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 33) || (iR == 35) || (iR == 61) || (iR == 63) || (iR == 89) || (iR == 91)) 
			    when(((iC == 4) || (iC == 8) || (iC == 32) || (iC == 36) || (iC == 60) || (iC == 64) || (iC == 88) || (iC == 92) || (iC == 116) || (iC == 120)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 32) || (iR == 36) || (iR == 60) || (iR == 64) || (iR == 88) || (iR == 92)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 32) && (iC <= 36)) || ((iC >= 60) && (iC <= 64)) || ((iC >= 88) && (iC <= 92)) || ((iC >= 116) && (iC <= 120))) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 28) 
		    cond(((iR == 122) 
			    when(((iC == 24) || (iC == 26) || (iC == 28) || (iC == 48) || (iC == 50) || (iC == 52) || (iC == 72) || (iC == 74) || (iC == 76) || (iC == 96) || (iC == 98) || (iC == 100)) 
				(iRetval = 1)
			    )
			) 
			((iR == 120) 
			    when((((iC >= 3) && (iC <= 4)) || ((iC >= 24) && (iC <= 28)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 72) && (iC <= 76)) || ((iC >= 96) && (iC <= 100))) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 24) || (iC == 28) || (iC == 48) || (iC == 52) || (iC == 72) || (iC == 76) || (iC == 96) || (iC == 100) || ((iC >= 118) && (iC <= 119))) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when(((iC >= 119) && (iC <= 120)) 
				(iRetval = 1)
			    )
			) 
			((iR == 118) 
			    when((onep(iC) || (iC == 5)) 
				(iRetval = 1)
			    )
			)
			(onep(iR) 
			    when(((iC >= 118) && (iC <= 119)) 
				(iRetval = 1)
			    )
			) 
			((iR == 119) 
			    when((((iC >= 0) && (iC <= 1)) || (iC == 3) || (iC == 5)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 24) && (iC <= 28)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 72) && (iC <= 76)) || ((iC >= 96) && (iC <= 100)) || (iC == 120)) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when((iC == 119) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 124)) 
			    when((((iC >= 24) && (iC <= 28)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 72) && (iC <= 76)) || ((iC >= 96) && (iC <= 100))) 
				(iRetval = 1)
			    )
			)
			(((iR == 7) || (iR == 121) || (iR == 123)) 
			    when(((iC == 24) || (iC == 28) || (iC == 48) || (iC == 52) || (iC == 72) || (iC == 76) || (iC == 96) || (iC == 100)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 26) || (iR == 50) || (iR == 74) || (iR == 98)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 26) || (iC == 28) || (iC == 48) || (iC == 50) || (iC == 52) || (iC == 72) || (iC == 74) || (iC == 76) || (iC == 96) || (iC == 98) || (iC == 100) || (iC == 120) || (iC == 122) || (iC == 124)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 24) || (iR == 28) || (iR == 48) || (iR == 52) || (iR == 72) || (iR == 76) || (iR == 96) || (iR == 100)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 24) && (iC <= 28)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 72) && (iC <= 76)) || ((iC >= 96) && (iC <= 100)) || ((iC >= 120) && (iC <= 124))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 25) || (iR == 27) || (iR == 49) || (iR == 51) || (iR == 73) || (iR == 75) || (iR == 97) || (iR == 99)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 28) || (iC == 48) || (iC == 52) || (iC == 72) || (iC == 76) || (iC == 96) || (iC == 100) || (iC == 120) || (iC == 124)) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 29) 
		    cond(((iR == 123) 
			    when((((iC >= 0) && (iC <= 1)) || (iC == 5)) 
				(iRetval = 1)
			    )
			) 
			((iR == 122) 
			    when((((iC >= 0) && (iC <= 1)) || ((iC >= 3) && (iC <= 5))) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 76) && (iC <= 80)) || ((iC >= 100) && (iC <= 104)) || (iC == 122) || (iC == 124)) 
				(iRetval = 1)
			    )
			) 
			((iR == 126) 
			    when(((iC == 28) || (iC == 30) || (iC == 32) || (iC == 52) || (iC == 54) || (iC == 56) || (iC == 76) || (iC == 78) || (iC == 80) || (iC == 100) || (iC == 102) || (iC == 104)) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when((iC == 122) 
				(iRetval = 1)
			    )
			)
			((iR == 5) 
			    when(((iC == 28) || (iC == 32) || (iC == 52) || (iC == 56) || (iC == 76) || (iC == 80) || (iC == 100) || (iC == 104) || ((iC >= 122) && (iC <= 123))) 
				(iRetval = 1)
			    )
			) 
			((iR == 124) 
			    when((((iC >= 0) && (iC <= 2)) || (iC == 4) || ((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 76) && (iC <= 80)) || ((iC >= 100) && (iC <= 104))) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when((iC == 124) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 128)) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 76) && (iC <= 80)) || ((iC >= 100) && (iC <= 104))) 
				(iRetval = 1)
			    )
			) 
			((zerop(iR) || onep(iR)) 
			    when(((iC >= 122) && (iC <= 124)) 
				(iRetval = 1)
			    )
			)
			(((iR == 7) || (iR == 125) || (iR == 127)) 
			    when(((iC == 28) || (iC == 32) || (iC == 52) || (iC == 56) || (iC == 76) || (iC == 80) || (iC == 100) || (iC == 104)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 30) || (iR == 54) || (iR == 78) || (iR == 102)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 30) || (iC == 32) || (iC == 52) || (iC == 54) || (iC == 56) || (iC == 76) || (iC == 78) || (iC == 80) || (iC == 100) || (iC == 102) || (iC == 104) || (iC == 124) || (iC == 126) || (iC == 128)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 29) || (iR == 31) || (iR == 53) || (iR == 55) || (iR == 77) || (iR == 79) || (iR == 101) || (iR == 103)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 32) || (iC == 52) || (iC == 56) || (iC == 76) || (iC == 80) || (iC == 100) || (iC == 104) || (iC == 124) || (iC == 128)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 28) || (iR == 32) || (iR == 52) || (iR == 56) || (iR == 76) || (iR == 80) || (iR == 100) || (iR == 104)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 76) && (iC <= 80)) || ((iC >= 100) && (iC <= 104)) || ((iC >= 124) && (iC <= 128))) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 30) 
		    cond(((iR == 4) 
			    when((((iC >= 24) && (iC <= 28)) || ((iC >= 50) && (iC <= 54)) || ((iC >= 76) && (iC <= 80)) || ((iC >= 102) && (iC <= 106)) || ((iC >= 127) && (iC <= 128))) 
				(iRetval = 1)
			    )
			) 
			((iR == 128) 
			    when((((iC >= 0) && (iC <= 4)) || ((iC >= 24) && (iC <= 28)) || ((iC >= 50) && (iC <= 54)) || ((iC >= 76) && (iC <= 80)) || ((iC >= 102) && (iC <= 106))) 
				(iRetval = 1)
			    )
			) 
			((iR == 127) 
			    when((onep(iC) || ((iC >= 3) && (iC <= 5))) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 24) || (iC == 28) || (iC == 50) || (iC == 54) || (iC == 76) || (iC == 80) || (iC == 102) || (iC == 106) || ((iC >= 126) && (iC <= 127))) 
				(iRetval = 1)
			    )
			) 
			((iR == 130) 
			    when(((iC == 24) || (iC == 26) || (iC == 28) || (iC == 50) || (iC == 52) || (iC == 54) || (iC == 76) || (iC == 78) || (iC == 80) || (iC == 102) || (iC == 104) || (iC == 106)) 
				(iRetval = 1)
			    )
			)
			((iR == 126) 
			    when((zerop(iC) || (iC == 2) || (iC == 5)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 132)) 
			    when((((iC >= 24) && (iC <= 28)) || ((iC >= 50) && (iC <= 54)) || ((iC >= 76) && (iC <= 80)) || ((iC >= 102) && (iC <= 106))) 
				(iRetval = 1)
			    )
			) 
			((zerop(iR) || (iR == 2)) 
			    when(((iC == 126) || (iC == 128)) 
				(iRetval = 1)
			    )
			) 
			((onep(iR) || (iR == 3)) 
			    when(((iC >= 127) && (iC <= 128)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 129) || (iR == 131)) 
			    when(((iC == 24) || (iC == 28) || (iC == 50) || (iC == 54) || (iC == 76) || (iC == 80) || (iC == 102) || (iC == 106)) 
				(iRetval = 1)
			    )
			)
			(((iR == 26) || (iR == 52) || (iR == 78) || (iR == 104)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 26) || (iC == 28) || (iC == 50) || (iC == 52) || (iC == 54) || (iC == 76) || (iC == 78) || (iC == 80) || (iC == 102) || (iC == 104) || (iC == 106) || (iC == 128) || (iC == 130) || (iC == 132)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 25) || (iR == 27) || (iR == 51) || (iR == 53) || (iR == 77) || (iR == 79) || (iR == 103) || (iR == 105)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 28) || (iC == 50) || (iC == 54) || (iC == 76) || (iC == 80) || (iC == 102) || (iC == 106) || (iC == 128) || (iC == 132)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 24) || (iR == 28) || (iR == 50) || (iR == 54) || (iR == 76) || (iR == 80) || (iR == 102) || (iR == 106)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 24) && (iC <= 28)) || ((iC >= 50) && (iC <= 54)) || ((iC >= 76) && (iC <= 80)) || ((iC >= 102) && (iC <= 106)) || ((iC >= 128) && (iC <= 132))) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 31) 
		    cond(((iR == 131) 
			    when((onep(iC) || ((iC >= 4) && (iC <= 5))) 
				(iRetval = 1)
			    )
			) 
			((iR == 134) 
			    when(((iC == 28) || (iC == 30) || (iC == 32) || (iC == 54) || (iC == 56) || (iC == 58) || (iC == 80) || (iC == 82) || (iC == 84) || (iC == 106) || (iC == 108) || (iC == 110)) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 28) || (iC == 32) || (iC == 54) || (iC == 58) || (iC == 80) || (iC == 84) || (iC == 106) || (iC == 110) || ((iC >= 130) && (iC <= 131))) 
				(iRetval = 1)
			    )
			) 
			((iR == 130) 
			    when(((iC >= 2) && (iC <= 5)) 
				(iRetval = 1)
			    )
			) 
			((iR == 132) 
			    when(((iC == 4) || ((iC >= 28) && (iC <= 32)) || ((iC >= 54) && (iC <= 58)) || ((iC >= 80) && (iC <= 84)) || ((iC >= 106) && (iC <= 110))) 
				(iRetval = 1)
			    )
			)
			((iR == 4) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 54) && (iC <= 58)) || ((iC >= 80) && (iC <= 84)) || ((iC >= 106) && (iC <= 110)) || ((iC >= 130) && (iC <= 132))) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when((iC == 131) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 136)) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 54) && (iC <= 58)) || ((iC >= 80) && (iC <= 84)) || ((iC >= 106) && (iC <= 110))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 2) || (iR == 3)) 
			    when((iC == 130) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 133) || (iR == 135)) 
			    when(((iC == 28) || (iC == 32) || (iC == 54) || (iC == 58) || (iC == 80) || (iC == 84) || (iC == 106) || (iC == 110)) 
				(iRetval = 1)
			    )
			)
			(((iR == 30) || (iR == 56) || (iR == 82) || (iR == 108)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 30) || (iC == 32) || (iC == 54) || (iC == 56) || (iC == 58) || (iC == 80) || (iC == 82) || (iC == 84) || (iC == 106) || (iC == 108) || (iC == 110) || (iC == 132) || (iC == 134) || (iC == 136)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 29) || (iR == 31) || (iR == 55) || (iR == 57) || (iR == 81) || (iR == 83) || (iR == 107) || (iR == 109)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 32) || (iC == 54) || (iC == 58) || (iC == 80) || (iC == 84) || (iC == 106) || (iC == 110) || (iC == 132) || (iC == 136)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 28) || (iR == 32) || (iR == 54) || (iR == 58) || (iR == 80) || (iR == 84) || (iR == 106) || (iR == 110)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 28) && (iC <= 32)) || ((iC >= 54) && (iC <= 58)) || ((iC >= 80) && (iC <= 84)) || ((iC >= 106) && (iC <= 110)) || ((iC >= 132) && (iC <= 136))) 
				(iRetval = 1)
			    )
			)
		    )
		)
		((iV == 32) 
		    cond(((iR == 134) 
			    when((zerop(iC) || (iC == 2)) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 32) || (iC == 36) || (iC == 58) || (iC == 62) || (iC == 84) || (iC == 88) || (iC == 110) || (iC == 114) || (iC == 136)) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when(((iC == 134) || (iC == 136)) 
				(iRetval = 1)
			    )
			) 
			((iR == 138) 
			    when(((iC == 32) || (iC == 34) || (iC == 36) || (iC == 58) || (iC == 60) || (iC == 62) || (iC == 84) || (iC == 86) || (iC == 88) || (iC == 110) || (iC == 112) || (iC == 114)) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when(((iC >= 134) && (iC <= 136)) 
				(iRetval = 1)
			    )
			)
			((iR == 135) 
			    when(((iC >= 1) && (iC <= 2)) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when((iC == 135) 
				(iRetval = 1)
			    )
			) 
			((iR == 136) 
			    when((zerop(iC) || ((iC >= 2) && (iC <= 3)) || (iC == 5) || ((iC >= 32) && (iC <= 36)) || ((iC >= 58) && (iC <= 62)) || ((iC >= 84) && (iC <= 88)) || ((iC >= 110) && (iC <= 114))) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when((iC == 136) 
				(iRetval = 1)
			    )
			) 
			(((iR == 4) || (iR == 8) || (iR == 140)) 
			    when((((iC >= 32) && (iC <= 36)) || ((iC >= 58) && (iC <= 62)) || ((iC >= 84) && (iC <= 88)) || ((iC >= 110) && (iC <= 114))) 
				(iRetval = 1)
			    )
			)
			(((iR == 7) || (iR == 137) || (iR == 139)) 
			    when(((iC == 32) || (iC == 36) || (iC == 58) || (iC == 62) || (iC == 84) || (iC == 88) || (iC == 110) || (iC == 114)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 34) || (iR == 60) || (iR == 86) || (iR == 112)) 
			    when(((iC == 4) || (iC == 8) || (iC == 32) || (iC == 34) || (iC == 36) || (iC == 58) || (iC == 60) || (iC == 62) || (iC == 84) || (iC == 86) || (iC == 88) || (iC == 110) || (iC == 112) || (iC == 114) || (iC == 136) || (iC == 138) || (iC == 140)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 33) || (iR == 35) || (iR == 59) || (iR == 61) || (iR == 85) || (iR == 87) || (iR == 111) || (iR == 113)) 
			    when(((iC == 4) || (iC == 8) || (iC == 32) || (iC == 36) || (iC == 58) || (iC == 62) || (iC == 84) || (iC == 88) || (iC == 110) || (iC == 114) || (iC == 136) || (iC == 140)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 32) || (iR == 36) || (iR == 58) || (iR == 62) || (iR == 84) || (iR == 88) || (iR == 110) || (iR == 114)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 32) && (iC <= 36)) || ((iC >= 58) && (iC <= 62)) || ((iC >= 84) && (iC <= 88)) || ((iC >= 110) && (iC <= 114)) || ((iC >= 136) && (iC <= 140))) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 33) 
		    cond(((iR == 142) 
			    when(((iC == 28) || (iC == 30) || (iC == 32) || (iC == 56) || (iC == 58) || (iC == 60) || (iC == 84) || (iC == 86) || (iC == 88) || (iC == 112) || (iC == 114) || (iC == 116)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 84) && (iC <= 88)) || ((iC >= 112) && (iC <= 116)) || (iC == 138)) 
				(iRetval = 1)
			    )
			) 
			((iR == 138) 
			    when(((iC >= 2) && (iC <= 4)) 
				(iRetval = 1)
			    )
			) 
			((iR == 140) 
			    when((onep(iC) || (iC == 5) || ((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 84) && (iC <= 88)) || ((iC >= 112) && (iC <= 116))) 
				(iRetval = 1)
			    )
			) 
			((iR == 139) 
			    when(((iC >= 1) && (iC <= 3)) 
				(iRetval = 1)
			    )
			)
			(onep(iR) 
			    when(((iC >= 139) && (iC <= 140)) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 28) || (iC == 32) || (iC == 56) || (iC == 60) || (iC == 84) || (iC == 88) || (iC == 112) || (iC == 116) || (iC == 140)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 144)) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 84) && (iC <= 88)) || ((iC >= 112) && (iC <= 116))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 2) || (iR == 3)) 
			    when(((iC >= 138) && (iC <= 139)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 141) || (iR == 143)) 
			    when(((iC == 28) || (iC == 32) || (iC == 56) || (iC == 60) || (iC == 84) || (iC == 88) || (iC == 112) || (iC == 116)) 
				(iRetval = 1)
			    )
			)
			(((iR == 30) || (iR == 58) || (iR == 86) || (iR == 114)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 30) || (iC == 32) || (iC == 56) || (iC == 58) || (iC == 60) || (iC == 84) || (iC == 86) || (iC == 88) || (iC == 112) || (iC == 114) || (iC == 116) || (iC == 140) || (iC == 142) || (iC == 144)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 28) || (iR == 32) || (iR == 56) || (iR == 60) || (iR == 84) || (iR == 88) || (iR == 112) || (iR == 116)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 84) && (iC <= 88)) || ((iC >= 112) && (iC <= 116)) || ((iC >= 140) && (iC <= 144))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 29) || (iR == 31) || (iR == 57) || (iR == 59) || (iR == 85) || (iR == 87) || (iR == 113) || (iR == 115)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 32) || (iC == 56) || (iC == 60) || (iC == 84) || (iC == 88) || (iC == 112) || (iC == 116) || (iC == 140) || (iC == 144)) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 34) 
		    cond(((iR == 4) 
			    when((((iC >= 32) && (iC <= 36)) || ((iC >= 60) && (iC <= 64)) || ((iC >= 88) && (iC <= 92)) || ((iC >= 116) && (iC <= 120)) || (iC == 143)) 
				(iRetval = 1)
			    )
			) 
			((iR == 142) 
			    when(onep(iC) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 32) || (iC == 36) || (iC == 60) || (iC == 64) || (iC == 88) || (iC == 92) || (iC == 116) || (iC == 120) || (iC == 144)) 
				(iRetval = 1)
			    )
			) 
			((iR == 146) 
			    when(((iC == 32) || (iC == 34) || (iC == 36) || (iC == 60) || (iC == 62) || (iC == 64) || (iC == 88) || (iC == 90) || (iC == 92) || (iC == 116) || (iC == 118) || (iC == 120)) 
				(iRetval = 1)
			    )
			) 
			((iR == 144) 
			    when((onep(iC) || (iC == 3) || (iC == 5) || ((iC >= 32) && (iC <= 36)) || ((iC >= 60) && (iC <= 64)) || ((iC >= 88) && (iC <= 92)) || ((iC >= 116) && (iC <= 120))) 
				(iRetval = 1)
			    )
			)
			((iR == 143) 
			    when((((iC >= 0) && (iC <= 2)) || (iC == 4)) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when((iC == 144) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when(((iC >= 142) && (iC <= 144)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 148)) 
			    when((((iC >= 32) && (iC <= 36)) || ((iC >= 60) && (iC <= 64)) || ((iC >= 88) && (iC <= 92)) || ((iC >= 116) && (iC <= 120))) 
				(iRetval = 1)
			    )
			) 
			((zerop(iR) || (iR == 2)) 
			    when((iC == 143) 
				(iRetval = 1)
			    )
			)
			(((iR == 7) || (iR == 145) || (iR == 147)) 
			    when(((iC == 32) || (iC == 36) || (iC == 60) || (iC == 64) || (iC == 88) || (iC == 92) || (iC == 116) || (iC == 120)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 34) || (iR == 62) || (iR == 90) || (iR == 118)) 
			    when(((iC == 4) || (iC == 8) || (iC == 32) || (iC == 34) || (iC == 36) || (iC == 60) || (iC == 62) || (iC == 64) || (iC == 88) || (iC == 90) || (iC == 92) || (iC == 116) || (iC == 118) || (iC == 120) || (iC == 144) || (iC == 146) || (iC == 148)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 32) || (iR == 36) || (iR == 60) || (iR == 64) || (iR == 88) || (iR == 92) || (iR == 116) || (iR == 120)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 32) && (iC <= 36)) || ((iC >= 60) && (iC <= 64)) || ((iC >= 88) && (iC <= 92)) || ((iC >= 116) && (iC <= 120)) || ((iC >= 144) && (iC <= 148))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 33) || (iR == 35) || (iR == 61) || (iR == 63) || (iR == 89) || (iR == 91) || (iR == 117) || (iR == 119)) 
			    when(((iC == 4) || (iC == 8) || (iC == 32) || (iC == 36) || (iC == 60) || (iC == 64) || (iC == 88) || (iC == 92) || (iC == 116) || (iC == 120) || (iC == 144) || (iC == 148)) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 35) 
		    cond(((iR == 146) 
			    when((((iC >= 0) && (iC <= 1)) || ((iC >= 3) && (iC <= 4))) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 28) || (iC == 32) || (iC == 52) || (iC == 56) || (iC == 76) || (iC == 80) || (iC == 100) || (iC == 104) || (iC == 124) || (iC == 128) || (iC == 148)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 76) && (iC <= 80)) || ((iC >= 100) && (iC <= 104)) || ((iC >= 124) && (iC <= 128)) || ((iC >= 146) && (iC <= 147))) 
				(iRetval = 1)
			    )
			) 
			((iR == 148) 
			    when((zerop(iC) || (iC == 2) || (iC == 5) || ((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 76) && (iC <= 80)) || ((iC >= 100) && (iC <= 104)) || ((iC >= 124) && (iC <= 128))) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when(((iC >= 147) && (iC <= 148)) 
				(iRetval = 1)
			    )
			)
			(zerop(iR) 
			    when(((iC >= 146) && (iC <= 148)) 
				(iRetval = 1)
			    )
			) 
			((iR == 147) 
			    when(((iC >= 0) && (iC <= 4)) 
				(iRetval = 1)
			    )
			) 
			((iR == 150) 
			    when(((iC == 28) || (iC == 30) || (iC == 32) || (iC == 52) || (iC == 54) || (iC == 56) || (iC == 76) || (iC == 78) || (iC == 80) || (iC == 100) || (iC == 102) || (iC == 104) || (iC == 124) || (iC == 126) || (iC == 128)) 
				(iRetval = 1)
			    )
			) 
			((onep(iR) || (iR == 3)) 
			    when(((iC >= 146) && (iC <= 147)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 152)) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 76) && (iC <= 80)) || ((iC >= 100) && (iC <= 104)) || ((iC >= 124) && (iC <= 128))) 
				(iRetval = 1)
			    )
			)
			(((iR == 7) || (iR == 149) || (iR == 151)) 
			    when(((iC == 28) || (iC == 32) || (iC == 52) || (iC == 56) || (iC == 76) || (iC == 80) || (iC == 100) || (iC == 104) || (iC == 124) || (iC == 128)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 30) || (iR == 54) || (iR == 78) || (iR == 102) || (iR == 126)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 30) || (iC == 32) || (iC == 52) || (iC == 54) || (iC == 56) || (iC == 76) || (iC == 78) || (iC == 80) || (iC == 100) || (iC == 102) || (iC == 104) || (iC == 124) || (iC == 126) || (iC == 128) || (iC == 148) || (iC == 150) || (iC == 152)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 29) || (iR == 31) || (iR == 53) || (iR == 55) || (iR == 77) || (iR == 79) || (iR == 101) || (iR == 103) || (iR == 125) || (iR == 127)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 32) || (iC == 52) || (iC == 56) || (iC == 76) || (iC == 80) || (iC == 100) || (iC == 104) || (iC == 124) || (iC == 128) || (iC == 148) || (iC == 152)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 28) || (iR == 32) || (iR == 52) || (iR == 56) || (iR == 76) || (iR == 80) || (iR == 100) || (iR == 104) || (iR == 124) || (iR == 128)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 28) && (iC <= 32)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 76) && (iC <= 80)) || ((iC >= 100) && (iC <= 104)) || ((iC >= 124) && (iC <= 128)) || ((iC >= 148) && (iC <= 152))) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 36) 
		    cond(((iR == 5) 
			    when(((iC == 22) || (iC == 26) || (iC == 48) || (iC == 52) || (iC == 74) || (iC == 78) || (iC == 100) || (iC == 104) || (iC == 126) || (iC == 130) || (iC == 152)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 22) && (iC <= 26)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 74) && (iC <= 78)) || ((iC >= 100) && (iC <= 104)) || ((iC >= 126) && (iC <= 130)) || (iC == 152)) 
				(iRetval = 1)
			    )
			) 
			((iR == 154) 
			    when(((iC == 22) || (iC == 24) || (iC == 26) || (iC == 48) || (iC == 50) || (iC == 52) || (iC == 74) || (iC == 76) || (iC == 78) || (iC == 100) || (iC == 102) || (iC == 104) || (iC == 126) || (iC == 128) || (iC == 130)) 
				(iRetval = 1)
			    )
			) 
			((iR == 150) 
			    when((((iC >= 0) && (iC <= 1)) || (iC == 3)) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when(((iC >= 150) && (iC <= 151)) 
				(iRetval = 1)
			    )
			)
			((iR == 151) 
			    when(zerop(iC) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when((iC == 150) 
				(iRetval = 1)
			    )
			) 
			((iR == 152) 
			    when((((iC >= 2) && (iC <= 5)) || ((iC >= 22) && (iC <= 26)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 74) && (iC <= 78)) || ((iC >= 100) && (iC <= 104)) || ((iC >= 126) && (iC <= 130))) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when(((iC == 150) || (iC == 152)) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when((iC == 152) 
				(iRetval = 1)
			    )
			)
			(((iR == 8) || (iR == 156)) 
			    when((((iC >= 22) && (iC <= 26)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 74) && (iC <= 78)) || ((iC >= 100) && (iC <= 104)) || ((iC >= 126) && (iC <= 130))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 153) || (iR == 155)) 
			    when(((iC == 22) || (iC == 26) || (iC == 48) || (iC == 52) || (iC == 74) || (iC == 78) || (iC == 100) || (iC == 104) || (iC == 126) || (iC == 130)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 24) || (iR == 50) || (iR == 76) || (iR == 102) || (iR == 128)) 
			    when(((iC == 4) || (iC == 8) || (iC == 22) || (iC == 24) || (iC == 26) || (iC == 48) || (iC == 50) || (iC == 52) || (iC == 74) || (iC == 76) || (iC == 78) || (iC == 100) || (iC == 102) || (iC == 104) || (iC == 126) || (iC == 128) || (iC == 130) || (iC == 152) || (iC == 154) || (iC == 156)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 22) || (iR == 26) || (iR == 48) || (iR == 52) || (iR == 74) || (iR == 78) || (iR == 100) || (iR == 104) || (iR == 126) || (iR == 130)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 22) && (iC <= 26)) || ((iC >= 48) && (iC <= 52)) || ((iC >= 74) && (iC <= 78)) || ((iC >= 100) && (iC <= 104)) || ((iC >= 126) && (iC <= 130)) || ((iC >= 152) && (iC <= 156))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 23) || (iR == 25) || (iR == 49) || (iR == 51) || (iR == 75) || (iR == 77) || (iR == 101) || (iR == 103) || (iR == 127) || (iR == 129)) 
			    when(((iC == 4) || (iC == 8) || (iC == 22) || (iC == 26) || (iC == 48) || (iC == 52) || (iC == 74) || (iC == 78) || (iC == 100) || (iC == 104) || (iC == 126) || (iC == 130) || (iC == 152) || (iC == 156)) 
				(iRetval = 1)
			    )
			)
		    )
		)
		((iV == 37) 
		    cond((zerop(iR) 
			    when(((iC >= 155) && (iC <= 156)) 
				(iRetval = 1)
			    )
			) 
			(onep(iR) 
			    when(((iC == 154) || (iC == 156)) 
				(iRetval = 1)
			    )
			) 
			((iR == 155) 
			    when((zerop(iC) || (iC == 3)) 
				(iRetval = 1)
			    )
			) 
			((iR == 158) 
			    when(((iC == 26) || (iC == 28) || (iC == 30) || (iC == 52) || (iC == 54) || (iC == 56) || (iC == 78) || (iC == 80) || (iC == 82) || (iC == 104) || (iC == 106) || (iC == 108) || (iC == 130) || (iC == 132) || (iC == 134)) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when((iC == 155) 
				(iRetval = 1)
			    )
			)
			((iR == 154) 
			    when((onep(iC) || (iC == 4)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 26) && (iC <= 30)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 78) && (iC <= 82)) || ((iC >= 104) && (iC <= 108)) || ((iC >= 130) && (iC <= 134)) || (iC == 154) || (iC == 156)) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 26) || (iC == 30) || (iC == 52) || (iC == 56) || (iC == 78) || (iC == 82) || (iC == 104) || (iC == 108) || (iC == 130) || (iC == 134) || (iC == 156)) 
				(iRetval = 1)
			    )
			) 
			((iR == 156) 
			    when((((iC >= 0) && (iC <= 1)) || ((iC >= 4) && (iC <= 5)) || ((iC >= 26) && (iC <= 30)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 78) && (iC <= 82)) || ((iC >= 104) && (iC <= 108)) || ((iC >= 130) && (iC <= 134))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 160)) 
			    when((((iC >= 26) && (iC <= 30)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 78) && (iC <= 82)) || ((iC >= 104) && (iC <= 108)) || ((iC >= 130) && (iC <= 134))) 
				(iRetval = 1)
			    )
			)
			(((iR == 7) || (iR == 157) || (iR == 159)) 
			    when(((iC == 26) || (iC == 30) || (iC == 52) || (iC == 56) || (iC == 78) || (iC == 82) || (iC == 104) || (iC == 108) || (iC == 130) || (iC == 134)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 28) || (iR == 54) || (iR == 80) || (iR == 106) || (iR == 132)) 
			    when(((iC == 4) || (iC == 8) || (iC == 26) || (iC == 28) || (iC == 30) || (iC == 52) || (iC == 54) || (iC == 56) || (iC == 78) || (iC == 80) || (iC == 82) || (iC == 104) || (iC == 106) || (iC == 108) || (iC == 130) || (iC == 132) || (iC == 134) || (iC == 156) || (iC == 158) || (iC == 160)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 27) || (iR == 29) || (iR == 53) || (iR == 55) || (iR == 79) || (iR == 81) || (iR == 105) || (iR == 107) || (iR == 131) || (iR == 133)) 
			    when(((iC == 4) || (iC == 8) || (iC == 26) || (iC == 30) || (iC == 52) || (iC == 56) || (iC == 78) || (iC == 82) || (iC == 104) || (iC == 108) || (iC == 130) || (iC == 134) || (iC == 156) || (iC == 160)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 26) || (iR == 30) || (iR == 52) || (iR == 56) || (iR == 78) || (iR == 82) || (iR == 104) || (iR == 108) || (iR == 130) || (iR == 134)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 26) && (iC <= 30)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 78) && (iC <= 82)) || ((iC >= 104) && (iC <= 108)) || ((iC >= 130) && (iC <= 134)) || ((iC >= 156) && (iC <= 160))) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 38) 
		    cond(((iR == 3) 
			    when(((iC == 158) || (iC == 160)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 30) && (iC <= 34)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 82) && (iC <= 86)) || ((iC >= 108) && (iC <= 112)) || ((iC >= 134) && (iC <= 138)) || ((iC >= 159) && (iC <= 160))) 
				(iRetval = 1)
			    )
			) 
			((iR == 160) 
			    when((((iC >= 0) && (iC <= 1)) || ((iC >= 3) && (iC <= 5)) || ((iC >= 30) && (iC <= 34)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 82) && (iC <= 86)) || ((iC >= 108) && (iC <= 112)) || ((iC >= 134) && (iC <= 138))) 
				(iRetval = 1)
			    )
			) 
			((iR == 159) 
			    when((iC == 4) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 30) || (iC == 34) || (iC == 56) || (iC == 60) || (iC == 82) || (iC == 86) || (iC == 108) || (iC == 112) || (iC == 134) || (iC == 138) || (iC == 160)) 
				(iRetval = 1)
			    )
			)
			((iR == 2) 
			    when((iC == 158) 
				(iRetval = 1)
			    )
			) 
			((iR == 162) 
			    when(((iC == 30) || (iC == 32) || (iC == 34) || (iC == 56) || (iC == 58) || (iC == 60) || (iC == 82) || (iC == 84) || (iC == 86) || (iC == 108) || (iC == 110) || (iC == 112) || (iC == 134) || (iC == 136) || (iC == 138)) 
				(iRetval = 1)
			    )
			) 
			((iR == 158) 
			    when(((iC >= 2) && (iC <= 3)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 164)) 
			    when((((iC >= 30) && (iC <= 34)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 82) && (iC <= 86)) || ((iC >= 108) && (iC <= 112)) || ((iC >= 134) && (iC <= 138))) 
				(iRetval = 1)
			    )
			) 
			((zerop(iR) || onep(iR)) 
			    when((iC == 160) 
				(iRetval = 1)
			    )
			)
			(((iR == 7) || (iR == 161) || (iR == 163)) 
			    when(((iC == 30) || (iC == 34) || (iC == 56) || (iC == 60) || (iC == 82) || (iC == 86) || (iC == 108) || (iC == 112) || (iC == 134) || (iC == 138)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 32) || (iR == 58) || (iR == 84) || (iR == 110) || (iR == 136)) 
			    when(((iC == 4) || (iC == 8) || (iC == 30) || (iC == 32) || (iC == 34) || (iC == 56) || (iC == 58) || (iC == 60) || (iC == 82) || (iC == 84) || (iC == 86) || (iC == 108) || (iC == 110) || (iC == 112) || (iC == 134) || (iC == 136) || (iC == 138) || (iC == 160) || (iC == 162) || (iC == 164)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 31) || (iR == 33) || (iR == 57) || (iR == 59) || (iR == 83) || (iR == 85) || (iR == 109) || (iR == 111) || (iR == 135) || (iR == 137)) 
			    when(((iC == 4) || (iC == 8) || (iC == 30) || (iC == 34) || (iC == 56) || (iC == 60) || (iC == 82) || (iC == 86) || (iC == 108) || (iC == 112) || (iC == 134) || (iC == 138) || (iC == 160) || (iC == 164)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 30) || (iR == 34) || (iR == 56) || (iR == 60) || (iR == 82) || (iR == 86) || (iR == 108) || (iR == 112) || (iR == 134) || (iR == 138)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 30) && (iC <= 34)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 82) && (iC <= 86)) || ((iC >= 108) && (iC <= 112)) || ((iC >= 134) && (iC <= 138)) || ((iC >= 160) && (iC <= 164))) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 39) 
		    cond(((iR == 162) 
			    when((zerop(iC) || (iC == 2) || (iC == 4)) 
				(iRetval = 1)
			    )
			) 
			(zerop(iR) 
			    when((iC == 162) 
				(iRetval = 1)
			    )
			) 
			((iR == 163) 
			    when(((iC >= 3) && (iC <= 4)) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when((iC == 163) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 24) || (iC == 28) || (iC == 52) || (iC == 56) || (iC == 80) || (iC == 84) || (iC == 108) || (iC == 112) || (iC == 136) || (iC == 140) || (iC == 164)) 
				(iRetval = 1)
			    )
			)
			((iR == 164) 
			    when(((iC == 2) || ((iC >= 4) && (iC <= 5)) || ((iC >= 24) && (iC <= 28)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 80) && (iC <= 84)) || ((iC >= 108) && (iC <= 112)) || ((iC >= 136) && (iC <= 140))) 
				(iRetval = 1)
			    )
			) 
			((iR == 2) 
			    when(((iC == 162) || (iC == 164)) 
				(iRetval = 1)
			    )
			) 
			((iR == 166) 
			    when(((iC == 24) || (iC == 26) || (iC == 28) || (iC == 52) || (iC == 54) || (iC == 56) || (iC == 80) || (iC == 82) || (iC == 84) || (iC == 108) || (iC == 110) || (iC == 112) || (iC == 136) || (iC == 138) || (iC == 140)) 
				(iRetval = 1)
			    )
			) 
			((iR == 4) 
			    when((((iC >= 24) && (iC <= 28)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 80) && (iC <= 84)) || ((iC >= 108) && (iC <= 112)) || ((iC >= 136) && (iC <= 140)) || ((iC >= 162) && (iC <= 164))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 8) || (iR == 168)) 
			    when((((iC >= 24) && (iC <= 28)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 80) && (iC <= 84)) || ((iC >= 108) && (iC <= 112)) || ((iC >= 136) && (iC <= 140))) 
				(iRetval = 1)
			    )
			)
			(((iR == 7) || (iR == 165) || (iR == 167)) 
			    when(((iC == 24) || (iC == 28) || (iC == 52) || (iC == 56) || (iC == 80) || (iC == 84) || (iC == 108) || (iC == 112) || (iC == 136) || (iC == 140)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 26) || (iR == 54) || (iR == 82) || (iR == 110) || (iR == 138)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 26) || (iC == 28) || (iC == 52) || (iC == 54) || (iC == 56) || (iC == 80) || (iC == 82) || (iC == 84) || (iC == 108) || (iC == 110) || (iC == 112) || (iC == 136) || (iC == 138) || (iC == 140) || (iC == 164) || (iC == 166) || (iC == 168)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 25) || (iR == 27) || (iR == 53) || (iR == 55) || (iR == 81) || (iR == 83) || (iR == 109) || (iR == 111) || (iR == 137) || (iR == 139)) 
			    when(((iC == 4) || (iC == 8) || (iC == 24) || (iC == 28) || (iC == 52) || (iC == 56) || (iC == 80) || (iC == 84) || (iC == 108) || (iC == 112) || (iC == 136) || (iC == 140) || (iC == 164) || (iC == 168)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 24) || (iR == 28) || (iR == 52) || (iR == 56) || (iR == 80) || (iR == 84) || (iR == 108) || (iR == 112) || (iR == 136) || (iR == 140)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 24) && (iC <= 28)) || ((iC >= 52) && (iC <= 56)) || ((iC >= 80) && (iC <= 84)) || ((iC >= 108) && (iC <= 112)) || ((iC >= 136) && (iC <= 140)) || ((iC >= 164) && (iC <= 168))) 
				(iRetval = 1)
			    )
			)
		    )
		) 
		((iV == 40) 
		    cond((onep(iR) 
			    when(((iC == 166) || (iC == 168)) 
				(iRetval = 1)
			    )
			) 
			((iR == 5) 
			    when(((iC == 28) || (iC == 32) || (iC == 56) || (iC == 60) || (iC == 84) || (iC == 88) || (iC == 112) || (iC == 116) || (iC == 140) || (iC == 144) || (iC == 166) || (iC == 168)) 
				(iRetval = 1)
			    )
			) 
			((iR == 3) 
			    when(((iC >= 167) && (iC <= 168)) 
				(iRetval = 1)
			    )
			) 
			((iR == 168) 
			    when((onep(iC) || (iC == 3) || (iC == 5) || ((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 84) && (iC <= 88)) || ((iC >= 112) && (iC <= 116)) || ((iC >= 140) && (iC <= 144))) 
				(iRetval = 1)
			    )
			) 
			((iR == 167) 
			    when((iC == 3) 
				(iRetval = 1)
			    )
			)
			((iR == 166) 
			    when((((iC >= 0) && (iC <= 2)) || (iC == 5)) 
				(iRetval = 1)
			    )
			) 
			((iR == 170) 
			    when(((iC == 28) || (iC == 30) || (iC == 32) || (iC == 56) || (iC == 58) || (iC == 60) || (iC == 84) || (iC == 86) || (iC == 88) || (iC == 112) || (iC == 114) || (iC == 116) || (iC == 140) || (iC == 142) || (iC == 144)) 
				(iRetval = 1)
			    )
			) 
			((zerop(iR) || (iR == 2)) 
			    when((iC == 166) 
				(iRetval = 1)
			    )
			) 
			(((iR == 7) || (iR == 169) || (iR == 171)) 
			    when(((iC == 28) || (iC == 32) || (iC == 56) || (iC == 60) || (iC == 84) || (iC == 88) || (iC == 112) || (iC == 116) || (iC == 140) || (iC == 144)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 4) || (iR == 8) || (iR == 172)) 
			    when((((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 84) && (iC <= 88)) || ((iC >= 112) && (iC <= 116)) || ((iC >= 140) && (iC <= 144))) 
				(iRetval = 1)
			    )
			)
			(((iR == 30) || (iR == 58) || (iR == 86) || (iR == 114) || (iR == 142)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 30) || (iC == 32) || (iC == 56) || (iC == 58) || (iC == 60) || (iC == 84) || (iC == 86) || (iC == 88) || (iC == 112) || (iC == 114) || (iC == 116) || (iC == 140) || (iC == 142) || (iC == 144) || (iC == 168) || (iC == 170) || (iC == 172)) 
				(iRetval = 1)
			    )
			) 
			(((iR == 28) || (iR == 32) || (iR == 56) || (iR == 60) || (iR == 84) || (iR == 88) || (iR == 112) || (iR == 116) || (iR == 140) || (iR == 144)) 
			    when((((iC >= 4) && (iC <= 5)) || ((iC >= 7) && (iC <= 8)) || ((iC >= 28) && (iC <= 32)) || ((iC >= 56) && (iC <= 60)) || ((iC >= 84) && (iC <= 88)) || ((iC >= 112) && (iC <= 116)) || ((iC >= 140) && (iC <= 144)) || ((iC >= 168) && (iC <= 172))) 
				(iRetval = 1)
			    )
			) 
			(((iR == 29) || (iR == 31) || (iR == 57) || (iR == 59) || (iR == 85) || (iR == 87) || (iR == 113) || (iR == 115) || (iR == 141) || (iR == 143)) 
			    when(((iC == 4) || (iC == 8) || (iC == 28) || (iC == 32) || (iC == 56) || (iC == 60) || (iC == 84) || (iC == 88) || (iC == 112) || (iC == 116) || (iC == 140) || (iC == 144) || (iC == 168) || (iC == 172)) 
				(iRetval = 1)
			    )
			)
		    )
		)
	    )
	)
	iRetval
    )
)
procedure(TBX_BARCODE_MATRIX_Calculate_Mask(sHorMst sVerMst) 
    let((hSelf iMinDtmScore iAllMatrix iMask iBit
	    iBitR iBitMask iHor iVer iVerAnd
	    iVerOr iN3Srch iN4Srch op1 op2
	    k iHorTmp xTc iDemeritN3 iDemeritN4
	    iMatchBeforeNum iMatchNum iMatchAftNum iDemeritN2 lResultA
	    lResultB iN1Srch_partA iN1Srch_partB iN2Srch1_tmp iN2Srch2_tmp
	    iDemeritN1 iDemeritScore iMatchBfrNum
	) 
	(hSelf = (tbx_barcode_matrix_global->self)) 
	(iMinDtmScore = 0) 
	(iAllMatrix = (hSelf["MaxModules"] * hSelf["MaxModules"])) 
	(iMask = 0)
	for(i 0 7 
	    (iBit = (1 << i)) 
	    (iBitR = (~iBit & 255))
	    (iBitMask = vectorToList(makeVector(iAllMatrix iBit))) 
	    (iHor = mapcar('band sHorMst iBitMask)) 
	    (iVer = mapcar('band sVerMst iBitMask)) 
	    (op1 = append(vectorToList(makeVector(hSelf["MaxModules"] 170)) iVer)) 
	    (op2 = append(iVer 
		    vectorToList(makeVector(hSelf["MaxModules"] 170))
		))
	    (iVerAnd = mapcar('band op1 op2)) 
	    (iVerOr = mapcar('bor op1 op2)) 
	    (iHor = mapcar('TBX_BARCODE_UTILS_Bnot iHor)) 
	    (iVer = mapcar('TBX_BARCODE_UTILS_Bnot iVer)) 
	    (iVerAnd = mapcar('TBX_BARCODE_UTILS_Bnot iVerAnd))
	    (iVerOr = mapcar('TBX_BARCODE_UTILS_Bnot iVerOr)) 
	    (iVerAnd = TBX_BARCODE_UTILS_List_Insert(170 iAllMatrix iVerAnd)) 
	    (iVerOr = TBX_BARCODE_UTILS_List_Insert(170 iAllMatrix iVerOr)) 
	    (k = (hSelf["MaxModules"] - 1)) 
	    while((k > 0) 
		(iHor = TBX_BARCODE_UTILS_List_Insert(170 
			(k * hSelf["MaxModules"]) iHor
		    )) 
		(iVer = TBX_BARCODE_UTILS_List_Insert(170 
			(k * hSelf["MaxModules"]) iVer
		    )) 
		(iVerAnd = TBX_BARCODE_UTILS_List_Insert(170 
			(k * hSelf["MaxModules"]) iVerAnd
		    )) 
		(iVerOr = TBX_BARCODE_UTILS_List_Insert(170 
			(k * hSelf["MaxModules"]) iVerOr
		    ))
		--k
	    )
	    (xTc = tconc(nil nil)) 
	    lconc(xTc iHor) 
	    lconc(xTc 
		list(170)
	    ) 
	    lconc(xTc iVer) 
	    (iHor = cdar(xTc))
	    (iN1Srch_partA = list(255 255 255 255 255)) 
	    (iN1Srch_partB = list(iBitR iBitR iBitR iBitR iBitR)) 
	    (iN2Srch1_tmp = list(iBitR iBitR)) 
	    (iN2Srch2_tmp = list(255 255)) 
	    (iN3Srch = list(iBitR 255 iBitR iBitR iBitR
		    255 iBitR
		))
	    (iN4Srch = list(iBitR)) 
	    (iHorTmp = iHor) 
	    (iDemeritN3 = (TBX_BARCODE_UTILS_List_Match(iHorTmp iN3Srch) * 40)) 
	    (iDemeritN4 = (int(abs((((100.0 * (TBX_BARCODE_UTILS_List_Match(iVer iN4Srch) / 
					    (iAllMatrix * 1.0))) - 50.0) / 5.0)
			)
		    ) * 10)) 
	    (iMatchBeforeNum = (length(iVerAnd) + length(iVerOr)))
	    (lResultA = TBX_BARCODE_UTILS_List_Replace_Plus(iVerAnd iN2Srch1_tmp)) 
	    (lResultB = TBX_BARCODE_UTILS_List_Replace_Plus(iVerOr iN2Srch2_tmp)) 
	    (iVerAnd = cadr(lResultA)) 
	    (iVerOr = cadr(lResultB)) 
	    (iMatchNum = (car(lResultA) + car(lResultB)))
	    (iMatchAftNum = (length(iVerAnd) + length(iVerOr))) 
	    (iDemeritN2 = ((iMatchBeforeNum - iMatchAftNum - iMatchNum) * 3)) 
	    (iMatchBfrNum = length(iHor)) 
	    (lResultA = TBX_BARCODE_UTILS_List_Replace_Plus(iHor iN1Srch_partA)) 
	    (lResultB = TBX_BARCODE_UTILS_List_Replace_Plus(iHor iN1Srch_partB))
	    (iMatchNum = (car(lResultA) + car(lResultB))) 
	    (iMatchAftNum = (length(iHor) - ((length(iHor) - length(cadr(lResultA))) + (length(iHor) - length(cadr(lResultB)))))) 
	    (iDemeritN1 = (iMatchBfrNum - iMatchAftNum - (iMatchNum * 2))) 
	    (iDemeritScore = (iDemeritN1 + iDemeritN2 + iDemeritN3 + iDemeritN4)) 
	    when(((iDemeritScore <= iMinDtmScore) || zerop(i)) 
		(iMask = i) 
		(iMinDtmScore = iDemeritScore)
	    )
	) iMask
    )
)
procedure(TBX_BARCODE_MATRIX_Calculate_Version(iTtlBits raPlusWords) 
    let((hMaxDatBits aMaxCodeWords aRemainBits min_match sEcc
	    iVersion result hSelf
	) 
	(hSelf = (tbx_barcode_matrix_global->self)) 
	(hMaxDatBits = makeTable("max_dat_bits_table" nil)) 
	(hMaxDatBits["M"] = listToVector(list(0 128 224 352 512
		    688 864 992 1232 1456
		    1728 2032 2320 2672 2920
		    3320 3624 4056 4504 5016
		    5352 5712 6256 6880 7312
		    8000 8496 9024 9544 10136
		    10984 11640 12328 13048 13800
		    14496 15312 15936 16816 17728
		    18672
		)
	    )) 
	(hMaxDatBits["L"] = listToVector(list(0 152 272 440 640
		    864 1088 1248 1552 1856
		    2192 2592 2960 3424 3688
		    4184 4712 5176 5768 6360
		    6888 7456 8048 8752 9392
		    10208 10960 11744 12248 13048
		    13880 14744 15640 16568 17528
		    18448 19472 20528 21616 22496
		    23648
		)
	    ))
	(hMaxDatBits["H"] = listToVector(list(0 72 128 208 288
		    368 480 528 688 800
		    976 1120 1264 1440 1576
		    1784 2024 2264 2504 2728
		    3080 3248 3536 3712 4112
		    4304 4768 5024 5288 5608
		    5960 6344 6760 7208 7688
		    7888 8432 8768 9136 9776
		    10208
		)
	    )) 
	(hMaxDatBits["Q"] = listToVector(list(0 104 176 272 384
		    496 608 704 880 1056
		    1232 1440 1648 1952 2088
		    2360 2600 2936 3176 3560
		    3880 4096 4544 4912 5312
		    5744 6032 6464 6968 7288
		    7880 8264 8920 9368 9848
		    10288 10832 11408 12016 12656
		    13328
		)
	    )) 
	(aMaxCodeWords = listToVector(list(0 26 44 70 100
		    134 172 196 242 292
		    346 404 466 532 581
		    655 733 815 901 991
		    1085 1156 1258 1364 1474
		    1588 1706 1828 1921 2051
		    2185 2323 2465 2611 2761
		    2876 3034 3196 3362 3532
		    3706
		)
	    )) 
	(aRemainBits = listToVector(list(0 0 7 7 7
		    7 7 0 0 0
		    0 0 0 0 3
		    3 3 3 3 3
		    3 4 4 4 4
		    4 4 4 3 3
		    3 3 3 3 3
		    0 0 0 0 0
		    0
		)
	    )) 
	(sEcc = hSelf["Ecc"])
	unless(hSelf["Version"] 
	    for(vnr 1 40 
		unless(min_match 
		    when((hMaxDatBits[sEcc][vnr] >= (iTtlBits + raPlusWords[vnr])) 
			(min_match = t) 
			(hSelf["Version"] = vnr)
		    )
		)
	    )
	) 
	(iVersion = hSelf["Version"]) 
	(result = list(hMaxDatBits[sEcc][iVersion] 
		raPlusWords[iVersion] 
		aMaxCodeWords[iVersion] 
		aRemainBits[iVersion]
	    )) result
    )
)
procedure(TBX_BARCODE_MATRIX_Callback(form_handle) 
    let((class_name subclass_name file_name file_path) 
	case((form_handle->curField) 
	    ("done" 
		(axlFinishEnterFun)
	    ) 
	    ("cancel" 
		(axlCancelEnterFun)
	    ) 
	    ("text_by_form" 
		when((form_handle->curValue) 
		    (axlFormSetFieldEditable form_handle "text_value" t) 
		    (axlFormSetFieldEditable form_handle "text_file_path" nil) 
		    (axlFormSetFieldEditable form_handle "browse_file" nil) 
		    when(((axlFormGetField form_handle "text_value") != "") 
			TBX_BARCODE_MATRIX_Validate(list(nil 
				'getText t 
				'updateStatus nil
				'dynamicPreview t
			    )
			)
		    )
		)
	    ) 
	    ("text_by_file" 
		when((form_handle->curValue) 
		    (axlFormSetFieldEditable form_handle "text_value" nil) 
		    (axlFormSetFieldEditable form_handle "text_file_path" t) 
		    (axlFormSetFieldEditable form_handle "browse_file" t) 
		    (file_path = (axlFormGetField form_handle "text_file_path"))
		    when(((file_path != "") && isFile(file_path)) 
			TBX_BARCODE_MATRIX_Validate(list(nil 
				'getText t 
				'updateStatus nil
				'dynamicPreview t
			    )
			)
		    )
		)
	    )
	    ("text_value" 
		TBX_BARCODE_MATRIX_Validate(list(nil 
			'getText t 
			'updateStatus nil
			'dynamicPreview t
		    )
		)
	    ) 
	    ("browse_file" 
		(file_name = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
		when(file_name 
		    (axlFormSetField form_handle "text_file_path" file_name) 
		    TBX_BARCODE_MATRIX_Validate(list(nil 
			    'getText t 
			    'updateStatus nil
			    'dynamicPreview t
			)
		    )
		)
	    ) 
	    ("text_file_path" 
		TBX_BARCODE_MATRIX_Validate(list(nil 
			'getText t 
			'updateStatus nil
			'dynamicPreview t
		    )
		)
	    ) 
	    ("class_name" 
		(class_name = (axlMapClassName 
			(form_handle->curValue)
		    )) 
		(axlBuildSubclassPopup form_handle "subclass_name" class_name) 
		if((class_name == "DRAWING FORMAT") then 
		    (subclass_name = "OUTLINE") else 
		    (subclass_name = car((axlSubclasses class_name)))
		) 
		(axlFormSetField form_handle "subclass_name" subclass_name)
	    ) 
	    ("version" 
		TBX_BARCODE_MATRIX_Validate(list(nil 
			'getText nil 
			'updateStatus nil
			'dynamicPreview t
		    )
		)
	    )
	    ("ecc_level" 
		TBX_BARCODE_MATRIX_Validate(list(nil 
			'getText nil 
			'updateStatus nil
			'dynamicPreview t
		    )
		)
	    ) 
	    ("unit_size" 
		when(((form_handle->curValue) < 0.0) 
		    (axlFormSetField form_handle "unit_size" 
			abs((form_handle->curValue))
		    )
		) 
		TBX_BARCODE_MATRIX_Validate(list(nil 
			'getText nil 
			'updateStatus nil
			'dynamicPreview t
		    )
		)
	    ) 
	    ("invert_structure" t) 
	    ("status" 
		TBX_BARCODE_MATRIX_Validate(list(nil 
			'getText nil 
			'updateStatus t
			'dynamicPreview t
		    )
		)
	    ) 
	    ("place" 
		if(TBX_BARCODE_MATRIX_Validate(list(nil 
			    'getText t 
			    'updateStatus t
			    'dynamicPreview t
			)
		    ) then 
		    ((tbx_barcode_matrix_global->eventHandler)->pickOrigin = t) else 
		    printf("Warning: Invalid text to be encoded. Cannot generate data.\n")
		)
	    )
	    ("myhelp" 
		TBX_HELP_Launch("barcode")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_BARCODE_MATRIX_Convert_Alphanum(iDatCnt) 
    let((iDatLen hAlphanumeric result hSelf aDatVal
	    aDatBit
	) 
	(hSelf = (tbx_barcode_matrix_global->self)) 
	(iDatLen = strlen(hSelf["text"])) 
	(aDatVal = makeVector((tbx_barcode_matrix_global->maxArraySize) nil)) 
	(aDatBit = makeVector((tbx_barcode_matrix_global->maxArraySize) nil))
	(aDatVal[iDatCnt] = 2) 
	(aDatBit[iDatCnt] = 4) 
	iDatCnt++ 
	(aDatVal[iDatCnt] = iDatLen) 
	(aDatBit[iDatCnt] = 9)
	(hSelf["WordsPos"] = iDatCnt) 
	(hAlphanumeric = makeTable("alphanumeric_data_table" nil)) 
	(hAlphanumeric["0"] = 0) 
	(hAlphanumeric["1"] = 1) 
	(hAlphanumeric["2"] = 2)
	(hAlphanumeric["3"] = 3) 
	(hAlphanumeric["4"] = 4) 
	(hAlphanumeric["5"] = 5) 
	(hAlphanumeric["6"] = 6) 
	(hAlphanumeric["7"] = 7)
	(hAlphanumeric["8"] = 8) 
	(hAlphanumeric["9"] = 9) 
	(hAlphanumeric["A"] = 10) 
	(hAlphanumeric["B"] = 11) 
	(hAlphanumeric["C"] = 12)
	(hAlphanumeric["D"] = 13) 
	(hAlphanumeric["E"] = 14) 
	(hAlphanumeric["F"] = 15) 
	(hAlphanumeric["G"] = 16) 
	(hAlphanumeric["H"] = 17)
	(hAlphanumeric["I"] = 18) 
	(hAlphanumeric["J"] = 19) 
	(hAlphanumeric["K"] = 20) 
	(hAlphanumeric["L"] = 21) 
	(hAlphanumeric["M"] = 22)
	(hAlphanumeric["N"] = 23) 
	(hAlphanumeric["O"] = 24) 
	(hAlphanumeric["P"] = 25) 
	(hAlphanumeric["Q"] = 26) 
	(hAlphanumeric["R"] = 27)
	(hAlphanumeric["S"] = 28) 
	(hAlphanumeric["T"] = 29) 
	(hAlphanumeric["U"] = 30) 
	(hAlphanumeric["V"] = 31) 
	(hAlphanumeric["W"] = 32)
	(hAlphanumeric["X"] = 33) 
	(hAlphanumeric["Y"] = 34) 
	(hAlphanumeric["Z"] = 35) 
	(hAlphanumeric[" "] = 36) 
	(hAlphanumeric["$"] = 37)
	(hAlphanumeric["%"] = 38) 
	(hAlphanumeric["*"] = 39) 
	(hAlphanumeric["+"] = 40) 
	(hAlphanumeric["-"] = 41) 
	(hAlphanumeric["."] = 42)
	(hAlphanumeric["/"] = 43) 
	(hAlphanumeric[":"] = 44) 
	iDatCnt++ 
	for(i 0 
	    (iDatLen - 1) 
	    if(zerop(mod(i 2)) then 
		(aDatVal[iDatCnt] = hAlphanumeric[substring(hSelf["text"] 
			    (i + 1) 1
			)]) 
		(aDatBit[iDatCnt] = 6) else
		(aDatVal[iDatCnt] = ((aDatVal[iDatCnt] * 45) + hAlphanumeric[substring(hSelf["text"] 
				(i + 1) 1
			    )])) 
		(aDatBit[iDatCnt] = 11) 
		iDatCnt++
	    )
	) 
	when(((aDatBit[iDatCnt] || 0) > 0) 
	    ++iDatCnt
	)
	(result = list(iDatCnt 
		listToVector(list(0 0 0 0 0
			0 0 0 0 0
			2 2 2 2 2
			2 2 2 2 2
			2 2 2 2 2
			2 2 4 4 4
			4 4 4 4 4
			4 4 4 4 4
			4
		    )
		) aDatVal aDatBit
	    )) result
    )
)
procedure(TBX_BARCODE_MATRIX_Convert_Byte(iDatCnt) 
    let((iDatLen symChar result hSelf aDatVal
	    aDatBit
	) 
	(hSelf = (tbx_barcode_matrix_global->self)) 
	(iDatLen = strlen(hSelf["text"])) 
	(aDatVal = makeVector((tbx_barcode_matrix_global->maxArraySize) nil)) 
	(aDatBit = makeVector((tbx_barcode_matrix_global->maxArraySize) nil))
	(aDatVal[iDatCnt] = 4) 
	(aDatBit[iDatCnt] = 4) 
	++iDatCnt 
	(aDatBit[iDatCnt] = 8) 
	(aDatVal[iDatCnt] = iDatLen)
	(hSelf["WordsPos"] = iDatCnt) 
	iDatCnt++ 
	for(i 0 
	    (iDatLen - 1) 
	    (symChar = stringToSymbol(substring(hSelf["text"] 
			(i + 1) 1
		    )
		)) 
	    (aDatVal[iDatCnt] = charToInt(symChar))
	    (aDatBit[iDatCnt] = 8) 
	    iDatCnt++
	) 
	(result = list(iDatCnt 
		listToVector(list(0 0 0 0 0
			0 0 0 0 0
			8 8 8 8 8
			8 8 8 8 8
			8 8 8 8 8
			8 8 8 8 8
			8 8 8 8 8
			8 8 8 8 8
			8
		    )
		) aDatVal aDatBit
	    )) result
    )
)
procedure(TBX_BARCODE_MATRIX_Convert_Num(iDatCnt) 
    let((iDatLen result hSelf aDatVal aDatBit) 
	(hSelf = (tbx_barcode_matrix_global->self)) 
	(iDatLen = strlen(hSelf["text"])) 
	(aDatVal = makeVector((tbx_barcode_matrix_global->maxArraySize) nil)) 
	(aDatBit = makeVector((tbx_barcode_matrix_global->maxArraySize) nil))
	(aDatVal[iDatCnt] = 1) 
	(aDatBit[iDatCnt] = 4) 
	iDatCnt++ 
	(aDatVal[iDatCnt] = iDatLen) 
	(aDatBit[iDatCnt] = 10)
	(hSelf["WordsPos"] = iDatCnt) 
	iDatCnt++ 
	for(i 0 
	    (iDatLen - 1) 
	    if(zerop(mod(i 3)) then 
		(aDatVal[iDatCnt] = atoi(substring(hSelf["text"] 
			    (i + 1) 1
			)
		    )) 
		(aDatBit[iDatCnt] = 4) else
		(aDatVal[iDatCnt] = ((aDatVal[iDatCnt] * 10) + atoi(substring(hSelf["text"] 
				(i + 1) 1
			    )
			))) 
		if(onep(mod(i 3)) then 
		    (aDatBit[iDatCnt] = 7) else 
		    (aDatBit[iDatCnt] = 10)
		    iDatCnt++
		)
	    )
	) 
	when((aDatBit[iDatCnt] && (aDatBit[iDatCnt] > 0)) 
	    ++iDatCnt
	) 
	(result = list(iDatCnt 
		listToVector(list(0 0 0 0 0
			0 0 0 0 0
			2 2 2 2 2
			2 2 2 2 2
			2 2 2 2 2
			2 2 4 4 4
			4 4 4 4 4
			4 4 4 4 4
			4
		    )
		) aDatVal aDatBit
	    ))
	result
    )
)
procedure(TBX_BARCODE_MATRIX_Draw_Geometry(form_handle sym_location sym_inst path_data) 
    let((class_name subclass_name layer rpath poly_list
	    res_list frame_shape
	) 
	(class_name = (axlFormGetField form_handle "class_name")) 
	(subclass_name = (axlFormGetField form_handle "subclass_name")) 
	(layer = strcat(class_name "/" subclass_name)) 
	(axlVisibleLayer layer t)
	when(sym_location 
	    (axlDBTransactionMark 
		(tbx_barcode_matrix_global->transMark)
	    ) 
	    (rpath = (axlPathStart 
		    ((tbx_barcode_matrix_global->curExtents)->ptList) 0.0
		)) 
	    (rpath = (axlPathOffset rpath sym_location)) 
	    (axlDBCreateShape rpath nil 
		(tbx_barcode_matrix_global->sysLayer) nil
		sym_inst
	    )
	    foreach(rp 
		(path_data->unitSquare) 
		(rpath = (axlPathOffset rp sym_location)) 
		(poly_list = cons(car((axlPolyFromDB rpath)) poly_list))
	    ) 
	    if((axlFormGetField form_handle "merge_shapes") then 
		(res_list = (axlPolyOperation 
			car(poly_list) 
			cdr(poly_list) 
			'OR
		    )) else 
		(res_list = poly_list)
	    ) 
	    foreach(pl res_list 
		(axlDBCreateShape pl t layer nil
		    sym_inst
		)
	    ) 
	    when(((path_data->frameBoundary) && (path_data->frameVoid)) 
		(rpath = (axlPathOffset 
			(path_data->frameBoundary) sym_location
		    )) 
		(frame_shape = (axlDBCreateOpenShape rpath t layer nil
			sym_inst
		    )) 
		(rpath = (axlPathOffset 
			(path_data->frameVoid) sym_location
		    )) 
		(axlDBCreateVoid frame_shape rpath)
		(axlDBCreateCloseShape frame_shape)
	    )
	) t
    )
)
procedure(TBX_BARCODE_MATRIX_Encode(form_handle text_data) 
    let((hSelf sText sEcc iVersion iModulesize
	    iDatCnt raPlusWords result iTotalBits iMaxDatBits
	    iCdNumPlus iMaxCodeWords iRemainBits iBitCnt iMaxDatWords
	    aDatBit aDatVal lFormat key lMatX
	    lMatY lMasks lFmtInfX2 lFmtInfY2 lRsEccCodeWord
	    lRso iRsEccWords aMatrixX aMatrixY aMask
	    aRsBlockOrder aFmtInfX2 aFmtInfY2 aRsCalTbl msg
	    llResult iCodeWords aCodeWords iRestBits sBuff
	    iBuffBit iFlg iRsBlock aRsTmp j
	    sRsCodeWords iFirst laRsBlockOrder laCodeWords sRsTmp
	    j_cnt aCont iCodeWord iCodeWordBitNum iMatrixRemain
	    iRemainBitTmp index_a index_b xor_arg sHorMst
	    sVerMst iMask hFmtInf aFmtInfX1 aFmtInfY1
	    aContWk aPixelInfo part1 part2 condResult
	    cfg_file invert_structure colorBg colorFg
	) 
	(sText = text_data) 
	(sEcc = (axlFormGetField form_handle "ecc_level")) 
	(iVersion = atoi((axlFormGetField form_handle "version"))) 
	(iModulesize = 2)
	(invert_structure = (axlFormGetField form_handle "invert_structure")) 
	(tbx_barcode_matrix_global->self = makeTable("self_data_table" nil)) 
	(hSelf = (tbx_barcode_matrix_global->self)) 
	(hSelf["text"] = sText) 
	(hSelf["Ecc"] = sEcc)
	(hSelf["Version"] = iVersion) 
	(hSelf["ModuleSize"] = iModulesize) 
	(iDatCnt = 0) 
	if(rexMatchp("[^0-9]" 
		hSelf["text"]
	    ) then 
	    if(rexMatchp("[^0-9A-Z $*%+-./:]" 
		    hSelf["text"]
		) then 
		(result = TBX_BARCODE_MATRIX_Convert_Byte(iDatCnt)) 
		(iDatCnt = car(result)) 
		(raPlusWords = cadr(result))
		(aDatVal = caddr(result)) 
		(aDatBit = nth(3 result)) else 
		(result = TBX_BARCODE_MATRIX_Convert_Alphanum(iDatCnt)) 
		(iDatCnt = car(result))
		(raPlusWords = cadr(result)) 
		(aDatVal = caddr(result)) 
		(aDatBit = nth(3 result))
	    ) else 
	    (result = TBX_BARCODE_MATRIX_Convert_Num(iDatCnt))
	    (iDatCnt = car(result)) 
	    (raPlusWords = cadr(result)) 
	    (aDatVal = caddr(result)) 
	    (aDatBit = nth(3 result))
	) 
	(iTotalBits = 0)
	for(i 0 
	    (iDatCnt - 1) 
	    (iTotalBits = (iTotalBits + aDatBit[i]))
	) 
	(result = TBX_BARCODE_MATRIX_Calculate_Version(iTotalBits raPlusWords)) 
	(iMaxDatBits = car(result)) 
	(iCdNumPlus = cadr(result)) 
	(iMaxCodeWords = caddr(result))
	(iRemainBits = nth(3 result)) 
	(iTotalBits = (iTotalBits + iCdNumPlus)) 
	(aDatBit[hSelf["WordsPos"]] = (aDatBit[hSelf["WordsPos"]] + iCdNumPlus)) 
	(hSelf["MaxModules"] = (17 + (hSelf["Version"] * 4))) 
	(iBitCnt = ((iMaxCodeWords * 8) + iRemainBits))
	(iMaxDatWords = (iMaxDatBits / 8)) 
	(key = sprintf(nil "qrv%02d%s" 
		hSelf["Version"] 
		hSelf["Ecc"]
	    )) 
	(cfg_file = strcat(axlGetVariable("ALLEGRO_INSTALL_ROOT") "/share/pcb/toolbox/skill/barcode/" 
		(tbx_barcode_matrix_global->cfgMap)[key] ".ile"
	    )) 
	load(cfg_file "floware_package") 
	(lFormat = TBX_BARCODE_UTILS_Build_List(sprintf(nil "a%d" iBitCnt) 3))
	(lFormat = nconc(lFormat 
		list("a15" "a15" "a1" "a128")
	    )) 
	(result = TBX_BARCODE_UTILS_Unpack(lFormat tbx_barcode_matrix_global_qrv)) 
	(lMatX = car(result)) 
	(lMatY = cadr(result)) 
	(lMasks = caddr(result))
	(lFmtInfX2 = nth(3 result)) 
	(lFmtInfY2 = nth(4 result)) 
	(lRsEccCodeWord = nth(5 result)) 
	(lRso = nth(6 result)) 
	(iRsEccWords = car(lRsEccCodeWord))
	(aMatrixX = listToVector(lMatX)) 
	(aMatrixY = listToVector(lMatY)) 
	(aMask = listToVector(lMasks)) 
	(aRsBlockOrder = listToVector(lRso)) 
	(aFmtInfX2 = listToVector(lFmtInfX2))
	(aFmtInfY2 = listToVector(lFmtInfY2)) 
	(key = sprintf(nil "rsc%02d" iRsEccWords)) 
	(cfg_file = strcat(axlGetVariable("ALLEGRO_INSTALL_ROOT") "/share/pcb/toolbox/skill/barcode/" 
		(tbx_barcode_matrix_global->cfgMap)[key] ".ile"
	    )) 
	load(cfg_file "floware_package") 
	(lFormat = TBX_BARCODE_UTILS_Build_List(sprintf(nil "a%d" iRsEccWords) 256))
	(llResult = TBX_BARCODE_UTILS_Unpack(lFormat tbx_barcode_matrix_global_rsc)) 
	(aRsCalTbl = listToVector(llResult)) 
	cond(((iTotalBits <= (iMaxDatBits - 4)) 
		(aDatVal[iDatCnt] = 0) 
		(aDatBit[iDatCnt] = 4)
	    ) 
	    ((iTotalBits < iMaxDatBits) 
		(aDatVal[iDatCnt] = 0) 
		(aDatBit[iDatCnt] = (iMaxDatBits - iTotalBits))
	    ) 
	    ((iTotalBits > iMaxDatBits) 
		(msg = sprintf(nil "Overflow error. version %L\nTotal bits: %d  max bits: %d\n" 
			hSelf["Version"] iTotalBits iMaxDatBits
		    )) 
		(axlUIConfirm msg)
	    )
	) 
	(iCodeWords = 0) 
	(aCodeWords = makeVector((tbx_barcode_matrix_global->maxArraySize) nil))
	(aCodeWords[0] = 0) 
	(iRestBits = 8) 
	for(i 0 iDatCnt 
	    (sBuff = aDatVal[i]) 
	    (iBuffBit = aDatBit[i])
	    (iFlg = 1) 
	    while(onep(iFlg) 
		if((iRestBits > iBuffBit) then 
		    (aCodeWords[iCodeWords] = ((aCodeWords[iCodeWords] << iBuffBit) | sBuff)) 
		    (iRestBits = (iRestBits - iBuffBit)) 
		    (iFlg = 0)
		    else 
		    (iBuffBit = (iBuffBit - iRestBits)) 
		    (aCodeWords[iCodeWords] = ((aCodeWords[iCodeWords] << iRestBits) | (sBuff >> iBuffBit))) 
		    if(zerop(iBuffBit) then 
			(iFlg = 0) else 
			(sBuff = (sBuff & ((1 << iBuffBit) - 1)))
			(iFlg = 1)
		    ) 
		    iCodeWords++
		    when((iCodeWords < (iMaxDatWords - 1)) 
			(aCodeWords[iCodeWords] = 0)
		    ) 
		    (iRestBits = 8)
		)
	    )
	) 
	if((iRestBits != 8) then 
	    (aCodeWords[iCodeWords] = (aCodeWords[iCodeWords] << iRestBits)) else 
	    --iCodeWords
	) 
	when((iCodeWords < (iMaxDatWords - 1)) 
	    (iFlg = 1) 
	    while((iCodeWords < (iMaxDatWords - 1)) 
		++iCodeWords 
		if(onep(iFlg) then 
		    (aCodeWords[iCodeWords] = 236) else 
		    (aCodeWords[iCodeWords] = 17)
		) 
		(iFlg = (iFlg * -1))
	    )
	)
	(iRsBlock = 0) 
	(aRsTmp = makeVector((tbx_barcode_matrix_global->maxArraySize) nil)) 
	(j = 0) 
	for(i 0 
	    (iMaxDatWords - 1) 
	    (aRsTmp[iRsBlock] = append1(aRsTmp[iRsBlock] 
		    aCodeWords[i]
		)) 
	    when((++j >= (aRsBlockOrder[iRsBlock] - iRsEccWords)) 
		(j = 0) 
		++iRsBlock
	    )
	) 
	(laRsBlockOrder = vectorToList(aRsBlockOrder))
	(laCodeWords = TBX_BARCODE_UTILS_Shrink_Array_To(aCodeWords "list")) 
	for(iBlck 0 
	    length(laRsBlockOrder) 
	    (sRsCodeWords = nth(iBlck laRsBlockOrder)) 
	    unless(sRsCodeWords 
		(sRsCodeWords = 0)
	    )
	    if(aRsTmp[iBlck] then 
		(sRsTmp = aRsTmp[iBlck]) else 
		(sRsTmp = list())
	    ) 
	    when((iRsEccWords >= 1) 
		for(i 1 iRsEccWords 
		    (sRsTmp = append1(sRsTmp 0))
		)
	    ) 
	    (j_cnt = (sRsCodeWords - iRsEccWords)) 
	    while((j_cnt >= 1) 
		(iFirst = car(sRsTmp)) 
		if((iFirst != 0) then 
		    (sRsTmp = TBX_BARCODE_UTILS_Bxor(cdr(sRsTmp) 
			    aRsCalTbl[iFirst]
			)) else 
		    (sRsTmp = cdr(sRsTmp))
		) 
		--j_cnt
	    ) 
	    foreach(sRs sRsTmp 
		(laCodeWords = append1(laCodeWords sRs))
	    )
	) 
	(aCodeWords = listToVector(laCodeWords)) 
	(aCont = makeVector(hSelf["MaxModules"] nil)) 
	(hSelf["Cont"] = aCont)
	for(i 0 
	    (hSelf["MaxModules"] - 1) 
	    (aCont[i] = makeVector(hSelf["MaxModules"] 0))
	) 
	for(i 0 
	    (iMaxCodeWords - 1) 
	    (iCodeWord = aCodeWords[i]) 
	    (j_cnt = 7)
	    while((j_cnt >= 0) 
		(iCodeWordBitNum = ((i * 8) + j_cnt)) 
		(aCont[aMatrixX[iCodeWordBitNum]][aMatrixY[iCodeWordBitNum]] = ((255 * (iCodeWord & 1)) ^ aMask[iCodeWordBitNum])) 
		(iCodeWord = (iCodeWord >> 1)) 
		--j_cnt
	    )
	) 
	(iMatrixRemain = iRemainBits) 
	while((iMatrixRemain >= 1) 
	    (iRemainBitTmp = (iMatrixRemain + (iMaxCodeWords * 8))) 
	    if((iRemainBitTmp >= length(aMatrixX)) then 
		(index_a = 0) else 
		(index_a = aMatrixX[iRemainBitTmp])
	    ) 
	    if((iRemainBitTmp >= length(aMatrixY)) then 
		(index_b = 0) else 
		(index_b = aMatrixY[iRemainBitTmp])
	    ) 
	    if((iRemainBitTmp >= length(aMask)) then 
		(xor_arg = 0) else 
		(xor_arg = aMask[iRemainBitTmp])
	    )
	    when((iRemainBitTmp >= length(aMatrixY)) 
		(index_a = 0)
	    ) 
	    (aCont[index_a][index_b] = (255 ^ xor_arg)) 
	    --iMatrixRemain
	) 
	(sHorMst = list())
	(sVerMst = list()) 
	for(n 0 
	    (hSelf["MaxModules"] - 1) 
	    for(p 0 
		(hSelf["MaxModules"] - 1) 
		(sHorMst = append1(sHorMst 
			aCont[p][n]
		    )) 
		(sVerMst = append1(sVerMst 
			aCont[n][p]
		    ))
	    )
	) 
	(iMask = TBX_BARCODE_MATRIX_Calculate_Mask(sHorMst sVerMst)) 
	(hSelf["MaskCont"] = (1 << iMask)) 
	(hFmtInf = makeTable("hFmtInf_table_data" nil))
	(hFmtInf["M"] = listToVector(list("101010000010010" "101000100100101" "101111001111100" "101101101001011" "100010111111001"
		    "100000011001110" "100111110010111" "100101010100000"
		)
	    )) 
	(hFmtInf["L"] = listToVector(list("111011111000100" "111001011110011" "111110110101010" "111100010011101" "110011000101111"
		    "110001100011000" "110110001000001" "110100101110110"
		)
	    )) 
	(hFmtInf["H"] = listToVector(list("001011010001001" "001001110111110" "001110011100111" "001100111010000" "000011101100010"
		    "000001001010101" "000110100001100" "000100000111011"
		)
	    )) 
	(hFmtInf["Q"] = listToVector(list("011010101011111" "011000001101000" "011111100110001" "011101000000110" "010010010110100"
		    "010000110000011" "010111011011010" "010101111101101"
		)
	    )) 
	(aFmtInfX1 = listToVector(list(0 1 2 3 4
		    5 7 8 8 8
		    8 8 8 8 8
		)
	    ))
	(aFmtInfY1 = listToVector(list(8 8 8 8 8
		    8 8 8 7 5
		    4 3 2 1 0
		)
	    )) 
	(aContWk = listToVector(mapcar('atoi 
		    parseString(hFmtInf[hSelf["Ecc"]][iMask] "")
		)
	    )) 
	for(i 0 14 
	    (aCont[aFmtInfX1[i]][aFmtInfY1[i]] = (aContWk[i] * 255)) 
	    (aCont[aFmtInfX2[i]][aFmtInfY2[i]] = (aContWk[i] * 255))
	) 
	(hSelf["Cont"] = aCont) 
	if(invert_structure then 
	    (colorBg = 1) 
	    (colorFg = 0) else
	    (colorBg = 0) 
	    (colorFg = 1)
	)
	(aPixelInfo = makeVector(hSelf["MaxModules"] nil)) 
	for(iY 0 
	    (hSelf["MaxModules"] - 1) 
	    (aPixelInfo[iY] = makeVector(hSelf["MaxModules"] nil)) 
	    for(iX 0 
		(hSelf["MaxModules"] - 1) 
		(part1 = TBX_BARCODE_MATRIX_Calculate_Form(hSelf["Version"] iY iX)) 
		(part2 = (aCont[iX][iY] & hSelf["MaskCont"]))
		(condResult = part1) 
		when(zerop(condResult) 
		    (condResult = part2)
		) 
		unless(condResult 
		    (condResult = 0)
		) 
		if(zerop(condResult) then 
		    (aPixelInfo[iY][iX] = colorBg) else 
		    (aPixelInfo[iY][iX] = colorFg)
		)
	    )
	) aPixelInfo
    )
)
procedure(TBX_BARCODE_MATRIX_Event_Loop() 
    let((eventMask loop event) 
	(axlEventSetStartPopup 
	    'TBX_BARCODE_MATRIX_Popup_Callback
	) 
	(eventMask = list('PICK)) 
	(loop = t) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil nil)) 
	    caseq((event->type) 
		(PICK 
		    if(((tbx_barcode_matrix_global->eventHandler)->pickOrigin) then 
			TBX_BARCODE_MATRIX_Generate((tbx_barcode_matrix_global->formid) 
			    (tbx_barcode_matrix_global->textData) 
			    (event->xy)
			) 
			((tbx_barcode_matrix_global->eventHandler)->pickOrigin = nil) else
			printf("Info: Use Place button or context menu RMB - Place Geom for final QR code generation.\n")
		    )
		) 
		(DONE 
		    (loop = nil) 
		    (axlDBTransactionCommit 
			(tbx_barcode_matrix_global->transMark)
		    ) 
		    (axlClearDynamics) 
		    (axlFormClose 
			(tbx_barcode_matrix_global->formid)
		    )
		) 
		(CANCEL 
		    (loop = nil) 
		    (axlDBTransactionRollback 
			(tbx_barcode_matrix_global->transMark)
		    ) 
		    (axlClearDynamics) 
		    (axlFormClose 
			(tbx_barcode_matrix_global->formid)
		    )
		)
	    )
	)
	(axlEventSetStartPopup)
    )
)
procedure(TBX_BARCODE_MATRIX_Generate(form_handle sTextData sym_location) 
    let((sym_name sym_inst aPixelInfo pathData) 
	(sym_name = "tbx_qrcode") 
	(aPixelInfo = TBX_BARCODE_MATRIX_Encode(form_handle sTextData)) 
	(pathData = TBX_BARCODE_MATRIX_Process(form_handle aPixelInfo)) 
	(axlClearDynamics)
	if(!(axlSelectByName "SYMTYPE" sym_name) then 
	    (axlDBCreateSymDefSkeleton 
		list(sym_name "mechanical") 
		list(list(0 
			(axlMKSConvert -100 "MILS")
		    ) 
		    list((axlMKSConvert 100 "MILS") 0)
		)
	    ) else 
	    (axlClearSelSet)
	) 
	(sym_inst = car((axlDBCreateSymbolSkeleton 
		    list(sym_name "mechanical") sym_location nil 0.0
		    nil
		)
	    )) 
	TBX_BARCODE_MATRIX_Draw_Geometry(form_handle sym_location sym_inst pathData) t
    )
)
procedure(TBX_BARCODE_MATRIX_Get_Text_Data(form_handle) 
    let((file_path lData port line sTextData) 
	if((axlFormGetField form_handle "text_by_file") then 
	    (file_path = (axlFormGetField form_handle "text_file_path")) 
	    (lData = tconc(nil nil)) 
	    if(isFile(file_path) then 
		(port = infile(file_path)) 
		while((line = _gets(port)) 
		    tconc(lData line)
		) 
		close(port)
		(lData = cdar(lData)) 
		(sTextData = buildString(lData "")) else 
		printf("Warning: File %L does not exist.\n" file_path)
	    )
	    else 
	    (sTextData = (axlFormGetField form_handle "text_value"))
	) 
	unless(sTextData 
	    (sTextData = "")
	) sTextData
    )
)
procedure(TBX_BARCODE_MATRIX_Get_Text_Type(sTextData) 
    let((sTextType) 
	when(sTextData 
	    cond((rexMatchp("^[0-9]*$" sTextData) 
		    (sTextType = "numeric")
		) 
		(rexMatchp("^[- $%+./:0-9A-Z]*$" sTextData) 
		    (sTextType = "alphanumeric")
		) 
		(t 
		    (sTextType = "byte")
		)
	    )
	) sTextType
    )
)
procedure(TBX_BARCODE_MATRIX_Init() 
    let((sys_layer valid_classes version version_info cap_info
	    cfg_map max_array_size
	) 
	for(n 1 40 
	    (version = ((4 * n) + 17)) 
	    (version_info = cons(list(sprintf(nil "%d -> (%d x %d)" n version version) 
			sprintf(nil "%d" n)
		    ) version_info
		))
	) 
	(version_info = reverse(version_info)) 
	(cap_info = makeTable("cap_info_table" nil)) 
	(cap_info["1!L"] = list(41 25 17))
	(cap_info["1!M"] = list(34 20 14)) 
	(cap_info["1!Q"] = list(27 16 11)) 
	(cap_info["1!H"] = list(17 10 7)) 
	(cap_info["2!L"] = list(77 47 32)) 
	(cap_info["2!M"] = list(63 38 26))
	(cap_info["2!Q"] = list(48 29 20)) 
	(cap_info["2!H"] = list(34 20 14)) 
	(cap_info["3!L"] = list(127 77 53)) 
	(cap_info["3!M"] = list(101 61 42)) 
	(cap_info["3!Q"] = list(77 47 32))
	(cap_info["3!H"] = list(58 35 24)) 
	(cap_info["4!L"] = list(187 114 78)) 
	(cap_info["4!M"] = list(149 90 62)) 
	(cap_info["4!Q"] = list(111 67 46)) 
	(cap_info["4!H"] = list(82 50 34))
	(cap_info["5!L"] = list(255 154 106)) 
	(cap_info["5!M"] = list(202 122 84)) 
	(cap_info["5!Q"] = list(144 87 60)) 
	(cap_info["5!H"] = list(106 64 44)) 
	(cap_info["6!L"] = list(322 195 134))
	(cap_info["6!M"] = list(255 154 106)) 
	(cap_info["6!Q"] = list(178 108 74)) 
	(cap_info["6!H"] = list(139 84 58)) 
	(cap_info["7!L"] = list(370 224 154)) 
	(cap_info["7!M"] = list(293 178 122))
	(cap_info["7!Q"] = list(207 125 86)) 
	(cap_info["7!H"] = list(154 93 64)) 
	(cap_info["8!L"] = list(461 279 192)) 
	(cap_info["8!M"] = list(365 221 152)) 
	(cap_info["8!Q"] = list(259 157 108))
	(cap_info["8!H"] = list(202 122 84)) 
	(cap_info["9!L"] = list(552 335 230)) 
	(cap_info["9!M"] = list(432 262 180)) 
	(cap_info["9!Q"] = list(312 189 130)) 
	(cap_info["9!H"] = list(235 143 98))
	(cap_info["10!L"] = list(652 395 271)) 
	(cap_info["10!M"] = list(513 311 213)) 
	(cap_info["10!Q"] = list(364 221 151)) 
	(cap_info["10!H"] = list(288 174 119)) 
	(cap_info["11!L"] = list(772 468 321))
	(cap_info["11!M"] = list(604 366 251)) 
	(cap_info["11!Q"] = list(427 259 177)) 
	(cap_info["11!H"] = list(331 200 137)) 
	(cap_info["12!L"] = list(883 535 367)) 
	(cap_info["12!M"] = list(691 419 287))
	(cap_info["12!Q"] = list(489 296 203)) 
	(cap_info["12!H"] = list(374 227 155)) 
	(cap_info["13!L"] = list(1022 619 425)) 
	(cap_info["13!M"] = list(796 483 331)) 
	(cap_info["13!Q"] = list(580 352 241))
	(cap_info["13!H"] = list(427 259 177)) 
	(cap_info["14!L"] = list(1101 667 458)) 
	(cap_info["14!M"] = list(871 528 362)) 
	(cap_info["14!Q"] = list(621 376 258)) 
	(cap_info["14!H"] = list(468 283 194))
	(cap_info["15!L"] = list(1250 758 520)) 
	(cap_info["15!M"] = list(991 600 412)) 
	(cap_info["15!Q"] = list(703 426 292)) 
	(cap_info["15!H"] = list(530 321 220)) 
	(cap_info["16!L"] = list(1408 854 586))
	(cap_info["16!M"] = list(1082 656 450)) 
	(cap_info["16!Q"] = list(775 470 322)) 
	(cap_info["16!H"] = list(602 365 250)) 
	(cap_info["17!L"] = list(1548 938 644)) 
	(cap_info["17!M"] = list(1212 734 504))
	(cap_info["17!Q"] = list(876 531 364)) 
	(cap_info["17!H"] = list(674 408 280)) 
	(cap_info["18!L"] = list(1725 1046 718)) 
	(cap_info["18!M"] = list(1346 816 560)) 
	(cap_info["18!Q"] = list(948 574 394))
	(cap_info["18!H"] = list(746 452 310)) 
	(cap_info["19!L"] = list(1903 1153 792)) 
	(cap_info["19!M"] = list(1500 909 624)) 
	(cap_info["19!Q"] = list(1063 644 442)) 
	(cap_info["19!H"] = list(813 493 338))
	(cap_info["20!L"] = list(2061 1249 858)) 
	(cap_info["20!M"] = list(1600 970 666)) 
	(cap_info["20!Q"] = list(1159 702 482)) 
	(cap_info["20!H"] = list(919 557 382)) 
	(cap_info["21!L"] = list(2232 1352 929))
	(cap_info["21!M"] = list(1708 1035 711)) 
	(cap_info["21!Q"] = list(1224 742 509)) 
	(cap_info["21!H"] = list(969 587 403)) 
	(cap_info["22!L"] = list(2409 1460 1003)) 
	(cap_info["22!M"] = list(1872 1134 779))
	(cap_info["22!Q"] = list(1358 823 565)) 
	(cap_info["22!H"] = list(1056 640 439)) 
	(cap_info["23!L"] = list(2620 1588 1091)) 
	(cap_info["23!M"] = list(2059 1248 857)) 
	(cap_info["23!Q"] = list(1468 890 611))
	(cap_info["23!H"] = list(1108 672 461)) 
	(cap_info["24!L"] = list(2812 1704 1171)) 
	(cap_info["24!M"] = list(2188 1326 911)) 
	(cap_info["24!Q"] = list(1588 963 661)) 
	(cap_info["24!H"] = list(1228 744 511))
	(cap_info["25!L"] = list(3057 1853 1273)) 
	(cap_info["25!M"] = list(2395 1451 997)) 
	(cap_info["25!Q"] = list(1718 1041 715)) 
	(cap_info["25!H"] = list(1286 779 535)) 
	(cap_info["26!L"] = list(3283 1990 1367))
	(cap_info["26!M"] = list(2544 1542 1059)) 
	(cap_info["26!Q"] = list(1804 1094 751)) 
	(cap_info["26!H"] = list(1425 864 593)) 
	(cap_info["27!L"] = list(3517 2132 1465)) 
	(cap_info["27!M"] = list(2701 1637 1125))
	(cap_info["27!Q"] = list(1933 1172 805)) 
	(cap_info["27!H"] = list(1501 910 625)) 
	(cap_info["28!L"] = list(3669 2223 1528)) 
	(cap_info["28!M"] = list(2857 1732 1190)) 
	(cap_info["28!Q"] = list(2085 1263 868))
	(cap_info["28!H"] = list(1581 958 658)) 
	(cap_info["29!L"] = list(3909 2369 1628)) 
	(cap_info["29!M"] = list(3035 1839 1264)) 
	(cap_info["29!Q"] = list(2181 1322 908)) 
	(cap_info["29!H"] = list(1677 1016 698))
	(cap_info["30!L"] = list(4158 2520 1732)) 
	(cap_info["30!M"] = list(3289 1994 1370)) 
	(cap_info["30!Q"] = list(2358 1429 982)) 
	(cap_info["30!H"] = list(1782 1080 742)) 
	(cap_info["31!L"] = list(4417 2677 1840))
	(cap_info["31!M"] = list(3486 2113 1452)) 
	(cap_info["31!Q"] = list(2473 1499 1030)) 
	(cap_info["31!H"] = list(1897 1150 790)) 
	(cap_info["32!L"] = list(4686 2840 1952)) 
	(cap_info["32!M"] = list(3693 2238 1538))
	(cap_info["32!Q"] = list(2670 1618 1112)) 
	(cap_info["32!H"] = list(2022 1226 842)) 
	(cap_info["33!L"] = list(4965 3009 2068)) 
	(cap_info["33!M"] = list(3909 2369 1628)) 
	(cap_info["33!Q"] = list(2805 1700 1168))
	(cap_info["33!H"] = list(2157 1307 898)) 
	(cap_info["34!L"] = list(5253 3183 2188)) 
	(cap_info["34!M"] = list(4134 2506 1722)) 
	(cap_info["34!Q"] = list(2949 1787 1228)) 
	(cap_info["34!H"] = list(2301 1394 958))
	(cap_info["35!L"] = list(5529 3351 2303)) 
	(cap_info["35!M"] = list(4343 2632 1809)) 
	(cap_info["35!Q"] = list(3081 1867 1283)) 
	(cap_info["35!H"] = list(2361 1431 983)) 
	(cap_info["36!L"] = list(5836 3537 2431))
	(cap_info["36!M"] = list(4588 2780 1911)) 
	(cap_info["36!Q"] = list(3244 1966 1351)) 
	(cap_info["36!H"] = list(2524 1530 1051)) 
	(cap_info["37!L"] = list(6153 3729 2563)) 
	(cap_info["37!M"] = list(4775 2894 1989))
	(cap_info["37!Q"] = list(3417 2071 1423)) 
	(cap_info["37!H"] = list(2625 1591 1093)) 
	(cap_info["38!L"] = list(6479 3927 2699)) 
	(cap_info["38!M"] = list(5039 3054 2099)) 
	(cap_info["38!Q"] = list(3599 2181 1499))
	(cap_info["38!H"] = list(2735 1658 1139)) 
	(cap_info["39!L"] = list(6743 4087 2809)) 
	(cap_info["39!M"] = list(5313 3220 2213)) 
	(cap_info["39!Q"] = list(3791 2298 1579)) 
	(cap_info["39!H"] = list(2927 1774 1219))
	(cap_info["40!L"] = list(7089 4296 2953)) 
	(cap_info["40!M"] = list(5596 3391 2331)) 
	(cap_info["40!Q"] = list(3993 2420 1663)) 
	(cap_info["40!H"] = list(3057 1852 1273)) 
	(cfg_map = makeTable("cfg_map_table" nil))
	(cfg_map["qrv01H"] = "cfg01") 
	(cfg_map["qrv01L"] = "cfg02") 
	(cfg_map["qrv01M"] = "cfg03") 
	(cfg_map["qrv01Q"] = "cfg04") 
	(cfg_map["qrv02H"] = "cfg05")
	(cfg_map["qrv02L"] = "cfg06") 
	(cfg_map["qrv02M"] = "cfg07") 
	(cfg_map["qrv02Q"] = "cfg08") 
	(cfg_map["qrv03H"] = "cfg09") 
	(cfg_map["qrv03L"] = "cfg10")
	(cfg_map["qrv03M"] = "cfg11") 
	(cfg_map["qrv03Q"] = "cfg12") 
	(cfg_map["qrv04H"] = "cfg13") 
	(cfg_map["qrv04L"] = "cfg14") 
	(cfg_map["qrv04M"] = "cfg15")
	(cfg_map["qrv04Q"] = "cfg16") 
	(cfg_map["qrv05H"] = "cfg17") 
	(cfg_map["qrv05L"] = "cfg18") 
	(cfg_map["qrv05M"] = "cfg19") 
	(cfg_map["qrv05Q"] = "cfg20")
	(cfg_map["qrv06H"] = "cfg21") 
	(cfg_map["qrv06L"] = "cfg22") 
	(cfg_map["qrv06M"] = "cfg23") 
	(cfg_map["qrv06Q"] = "cfg24") 
	(cfg_map["qrv07H"] = "cfg25")
	(cfg_map["qrv07L"] = "cfg26") 
	(cfg_map["qrv07M"] = "cfg27") 
	(cfg_map["qrv07Q"] = "cfg28") 
	(cfg_map["qrv08H"] = "cfg29") 
	(cfg_map["qrv08L"] = "cfg30")
	(cfg_map["qrv08M"] = "cfg31") 
	(cfg_map["qrv08Q"] = "cfg32") 
	(cfg_map["qrv09H"] = "cfg33") 
	(cfg_map["qrv09L"] = "cfg34") 
	(cfg_map["qrv09M"] = "cfg35")
	(cfg_map["qrv09Q"] = "cfg36") 
	(cfg_map["qrv10H"] = "cfg37") 
	(cfg_map["qrv10L"] = "cfg38") 
	(cfg_map["qrv10M"] = "cfg39") 
	(cfg_map["qrv10Q"] = "cfg40")
	(cfg_map["qrv11H"] = "cfg41") 
	(cfg_map["qrv11L"] = "cfg42") 
	(cfg_map["qrv11M"] = "cfg43") 
	(cfg_map["qrv11Q"] = "cfg44") 
	(cfg_map["qrv12H"] = "cfg45")
	(cfg_map["qrv12L"] = "cfg46") 
	(cfg_map["qrv12M"] = "cfg47") 
	(cfg_map["qrv12Q"] = "cfg48") 
	(cfg_map["qrv13H"] = "cfg49") 
	(cfg_map["qrv13L"] = "cfg50")
	(cfg_map["qrv13M"] = "cfg51") 
	(cfg_map["qrv13Q"] = "cfg52") 
	(cfg_map["qrv14H"] = "cfg53") 
	(cfg_map["qrv14L"] = "cfg54") 
	(cfg_map["qrv14M"] = "cfg55")
	(cfg_map["qrv14Q"] = "cfg56") 
	(cfg_map["qrv15H"] = "cfg57") 
	(cfg_map["qrv15L"] = "cfg58") 
	(cfg_map["qrv15M"] = "cfg59") 
	(cfg_map["qrv15Q"] = "cfg60")
	(cfg_map["qrv16H"] = "cfg61") 
	(cfg_map["qrv16L"] = "cfg62") 
	(cfg_map["qrv16M"] = "cfg63") 
	(cfg_map["qrv16Q"] = "cfg64") 
	(cfg_map["qrv17H"] = "cfg65")
	(cfg_map["qrv17L"] = "cfg66") 
	(cfg_map["qrv17M"] = "cfg67") 
	(cfg_map["qrv17Q"] = "cfg68") 
	(cfg_map["qrv18H"] = "cfg69") 
	(cfg_map["qrv18L"] = "cfg70")
	(cfg_map["qrv18M"] = "cfg71") 
	(cfg_map["qrv18Q"] = "cfg72") 
	(cfg_map["qrv19H"] = "cfg73") 
	(cfg_map["qrv19L"] = "cfg74") 
	(cfg_map["qrv19M"] = "cfg75")
	(cfg_map["qrv19Q"] = "cfg76") 
	(cfg_map["qrv20H"] = "cfg77") 
	(cfg_map["qrv20L"] = "cfg78") 
	(cfg_map["qrv20M"] = "cfg79") 
	(cfg_map["qrv20Q"] = "cfg80")
	(cfg_map["qrv21H"] = "cfg81") 
	(cfg_map["qrv21L"] = "cfg82") 
	(cfg_map["qrv21M"] = "cfg83") 
	(cfg_map["qrv21Q"] = "cfg84") 
	(cfg_map["qrv22H"] = "cfg85")
	(cfg_map["qrv22L"] = "cfg86") 
	(cfg_map["qrv22M"] = "cfg87") 
	(cfg_map["qrv22Q"] = "cfg88") 
	(cfg_map["qrv23H"] = "cfg89") 
	(cfg_map["qrv23L"] = "cfg90")
	(cfg_map["qrv23M"] = "cfg91") 
	(cfg_map["qrv23Q"] = "cfg92") 
	(cfg_map["qrv24H"] = "cfg93") 
	(cfg_map["qrv24L"] = "cfg94") 
	(cfg_map["qrv24M"] = "cfg95")
	(cfg_map["qrv24Q"] = "cfg96") 
	(cfg_map["qrv25H"] = "cfg97") 
	(cfg_map["qrv25L"] = "cfg98") 
	(cfg_map["qrv25M"] = "cfg99") 
	(cfg_map["qrv25Q"] = "cfg100")
	(cfg_map["qrv26H"] = "cfg101") 
	(cfg_map["qrv26L"] = "cfg102") 
	(cfg_map["qrv26M"] = "cfg103") 
	(cfg_map["qrv26Q"] = "cfg104") 
	(cfg_map["qrv27H"] = "cfg105")
	(cfg_map["qrv27L"] = "cfg106") 
	(cfg_map["qrv27M"] = "cfg107") 
	(cfg_map["qrv27Q"] = "cfg108") 
	(cfg_map["qrv28H"] = "cfg109") 
	(cfg_map["qrv28L"] = "cfg110")
	(cfg_map["qrv28M"] = "cfg111") 
	(cfg_map["qrv28Q"] = "cfg112") 
	(cfg_map["qrv29H"] = "cfg113") 
	(cfg_map["qrv29L"] = "cfg114") 
	(cfg_map["qrv29M"] = "cfg115")
	(cfg_map["qrv29Q"] = "cfg116") 
	(cfg_map["qrv30H"] = "cfg117") 
	(cfg_map["qrv30L"] = "cfg118") 
	(cfg_map["qrv30M"] = "cfg119") 
	(cfg_map["qrv30Q"] = "cfg120")
	(cfg_map["qrv31H"] = "cfg121") 
	(cfg_map["qrv31L"] = "cfg122") 
	(cfg_map["qrv31M"] = "cfg123") 
	(cfg_map["qrv31Q"] = "cfg124") 
	(cfg_map["qrv32H"] = "cfg125")
	(cfg_map["qrv32L"] = "cfg126") 
	(cfg_map["qrv32M"] = "cfg127") 
	(cfg_map["qrv32Q"] = "cfg128") 
	(cfg_map["qrv33H"] = "cfg129") 
	(cfg_map["qrv33L"] = "cfg130")
	(cfg_map["qrv33M"] = "cfg131") 
	(cfg_map["qrv33Q"] = "cfg132") 
	(cfg_map["qrv34H"] = "cfg133") 
	(cfg_map["qrv34L"] = "cfg134") 
	(cfg_map["qrv34M"] = "cfg135")
	(cfg_map["qrv34Q"] = "cfg136") 
	(cfg_map["qrv35H"] = "cfg137") 
	(cfg_map["qrv35L"] = "cfg138") 
	(cfg_map["qrv35M"] = "cfg139") 
	(cfg_map["qrv35Q"] = "cfg140")
	(cfg_map["qrv36H"] = "cfg141") 
	(cfg_map["qrv36L"] = "cfg142") 
	(cfg_map["qrv36M"] = "cfg143") 
	(cfg_map["qrv36Q"] = "cfg144") 
	(cfg_map["qrv37H"] = "cfg145")
	(cfg_map["qrv37L"] = "cfg146") 
	(cfg_map["qrv37M"] = "cfg147") 
	(cfg_map["qrv37Q"] = "cfg148") 
	(cfg_map["qrv38H"] = "cfg149") 
	(cfg_map["qrv38L"] = "cfg150")
	(cfg_map["qrv38M"] = "cfg151") 
	(cfg_map["qrv38Q"] = "cfg152") 
	(cfg_map["qrv39H"] = "cfg153") 
	(cfg_map["qrv39L"] = "cfg154") 
	(cfg_map["qrv39M"] = "cfg155")
	(cfg_map["qrv39Q"] = "cfg156") 
	(cfg_map["qrv40H"] = "cfg157") 
	(cfg_map["qrv40L"] = "cfg158") 
	(cfg_map["qrv40M"] = "cfg159") 
	(cfg_map["qrv40Q"] = "cfg160")
	(cfg_map["rsc07"] = "cfg161") 
	(cfg_map["rsc10"] = "cfg162") 
	(cfg_map["rsc13"] = "cfg163") 
	(cfg_map["rsc15"] = "cfg164") 
	(cfg_map["rsc16"] = "cfg165")
	(cfg_map["rsc17"] = "cfg166") 
	(cfg_map["rsc18"] = "cfg167") 
	(cfg_map["rsc20"] = "cfg168") 
	(cfg_map["rsc22"] = "cfg169") 
	(cfg_map["rsc24"] = "cfg170")
	(cfg_map["rsc26"] = "cfg171") 
	(cfg_map["rsc28"] = "cfg172") 
	(cfg_map["rsc30"] = "cfg173") 
	(sys_layer = "PACKAGE GEOMETRY/TBX_BARCODE_OUTLINE") 
	(valid_classes = list((axlMapClassName "ETCH") 
		(axlMapClassName "BOARD GEOMETRY") 
		(axlMapClassName "PACKAGE GEOMETRY") 
		(axlMapClassName "MANUFACTURING") 
		(axlMapClassName "DRAWING FORMAT")
	    ))
	unless((axlIsLayer sys_layer) 
	    (axlLayerCreateNonConductor sys_layer)
	) 
	unless(boundp('tbx_barcode_matrix_global) 
	    iliDefstruct('defstruct(tbx_barcode_matrix_global_struct versionInfo capacityInfo curExtents formid
			sysLayer textData validClasses self cfgMap
			qrv rsc maxArraySize licCheck eventHandler
		    )
	    ) 
	    defvar(tbx_barcode_matrix_global nil)
	) 
	(max_array_size = 5000) 
	if(!tbx_barcode_matrix_global then 
	    (tbx_barcode_matrix_global = (make_tbx_barcode_matrix_global_struct ?versionInfo version_info ?capacityInfo cap_info
		    ?curExtents nil ?formid nil ?sysLayer
		    sys_layer ?textData nil ?validClasses valid_classes
		    ?self nil ?cfgMap cfg_map ?qrv
		    nil ?rsc nil ?maxArraySize max_array_size
		    ?licCheck nil ?eventHandler 
		    ncons(nil)
		)) else 
	    (tbx_barcode_matrix_global->versionInfo = version_info)
	    (tbx_barcode_matrix_global->capacityInfo = cap_info) 
	    (tbx_barcode_matrix_global->curExtents = nil) 
	    (tbx_barcode_matrix_global->formid = nil) 
	    (tbx_barcode_matrix_global->sysLayer = sys_layer) 
	    (tbx_barcode_matrix_global->textData = nil)
	    (tbx_barcode_matrix_global->validClasses = valid_classes) 
	    (tbx_barcode_matrix_global->self = nil) 
	    (tbx_barcode_matrix_global->cfgMap = cfg_map) 
	    (tbx_barcode_matrix_global->qrv = nil) 
	    (tbx_barcode_matrix_global->rsc = nil)
	    (tbx_barcode_matrix_global->maxArraySize = max_array_size) 
	    (tbx_barcode_matrix_global->licCheck = nil) 
	    (tbx_barcode_matrix_global->eventHandler = ncons(nil))
	)
    )
)
procedure(TBX_BARCODE_MATRIX_Init_Defaults() 
    let((cfg_file data default_value file_data) 
	(default_value = ncons(nil)) 
	(default_value->textByForm = t) 
	(default_value->textByFile = nil) 
	(default_value->className = (axlMapClassName "ETCH"))
	(default_value->subclassName = "TOP") 
	(default_value->version = "2") 
	(default_value->ercLevel = "M") 
	(default_value->invertStructure = nil) 
	(default_value->mergeShapes = nil)
	(default_value = TBX_BARCODE_Get_Unit_Defaults("matrix" default_value)) 
	(default_value->invertStructure = nil) 
	(default_value->mergeShapes = nil) 
	(cfg_file = car(TBX_UTIL_Search_Config("barcode.ini" nil nil))) 
	when(cfg_file 
	    (file_data = TBX_UTIL_File_Lineread(cfg_file)) 
	    foreach(entry file_data 
		when((car(entry) == "matrix") 
		    (data = cdr(entry))
		)
	    )
	)
	foreach(entry data 
	    cond((memq(car(entry) 
			list('unitSize)
		    ) 
		    putprop(default_value 
			(axlMKSConvert 
			    cadr(entry) 
			    car((axlDBGetDesignUnits))
			) 
			car(entry)
		    )
		) 
		((car(entry) == 'className) 
		    putprop(default_value 
			(axlMapClassName 
			    cadr(entry)
			) 
			car(entry)
		    )
		) 
		(t 
		    putprop(default_value 
			cadr(entry) 
			car(entry)
		    )
		)
	    )
	) default_value
    )
)
procedure(TBX_BARCODE_MATRIX_Popup_Callback(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Place Geom" 
			'TBX_BARCODE_MATRIX_Popup_Place_Geom
		    ) 
		    list("Done" 
			'TBX_BARCODE_MATRIX_Popup_Done
		    ) 
		    list("Oops" 
			'TBX_BARCODE_MATRIX_Popup_Oops
		    ) 
		    list("Cancel" 
			'TBX_BARCODE_MATRIX_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_BARCODE_MATRIX_Popup_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_BARCODE_MATRIX_Popup_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_BARCODE_MATRIX_Popup_Oops() 
    (axlDBTransactionOops 
	(tbx_barcode_matrix_global->transMark)
    )
)
procedure(TBX_BARCODE_MATRIX_Popup_Place_Geom() 
    if(TBX_BARCODE_MATRIX_Validate(list(nil 
		'getText t 
		'updateStatus t
		'dynamicPreview t
	    )
	) then 
	((tbx_barcode_matrix_global->eventHandler)->pickOrigin = t) else 
	printf("Warning: Invalid text to be encoded. Cannot generate data.\n")
    )
)
procedure(TBX_BARCODE_MATRIX_Process(form_handle aPixelInfo) 
    let((path_list rpath unit_size ul_x ul_y
	    ul_xy cur_ll_x cur_ll_y invert_structure pt_list
	    width path_data
	) 
	(unit_size = (axlFormGetField form_handle "unit_size")) 
	(invert_structure = (axlFormGetField form_handle "invert_structure")) 
	(ul_x = car(((tbx_barcode_matrix_global->curExtents)->origin))) 
	(ul_y = (cadr(((tbx_barcode_matrix_global->curExtents)->origin)) + ((tbx_barcode_matrix_global->curExtents)->height)))
	(path_data = ncons(nil)) 
	when(invert_structure 
	    (width = (((tbx_barcode_matrix_global->curExtents)->width) - (8 * unit_size))) 
	    (pt_list = list(list(ul_x ul_y) 
		    list((ul_x + (8 * unit_size) + width) ul_y) 
		    list((ul_x + (8 * unit_size) + width) 
			(ul_y - (8 * unit_size) - width)
		    ) 
		    list(ul_x 
			(ul_y - (8 * unit_size) - width)
		    ) 
		    list(ul_x ul_y)
		)) 
	    (path_data->frameBoundary = (axlPathStart pt_list 0.0)) 
	    (pt_list = list(list((ul_x + (4 * unit_size)) 
			(ul_y - (4 * unit_size))
		    ) 
		    list((ul_x + (4 * unit_size) + width) 
			(ul_y - (4 * unit_size))
		    ) 
		    list((ul_x + (4 * unit_size) + width) 
			(ul_y - (4 * unit_size) - width)
		    ) 
		    list((ul_x + (4 * unit_size)) 
			(ul_y - (4 * unit_size) - width)
		    ) 
		    list((ul_x + (4 * unit_size)) 
			(ul_y - (4 * unit_size))
		    )
		))
	    (path_data->frameVoid = (axlPathStart pt_list 0.0))
	) 
	(ul_x = (ul_x + (4 * unit_size))) 
	(ul_y = (ul_y - (4 * unit_size))) 
	(ul_xy = (ul_x:ul_y))
	(cur_ll_x = car(ul_xy)) 
	(cur_ll_y = (cadr(ul_xy) - unit_size)) 
	for(y 0 
	    (length(aPixelInfo) - 1) 
	    for(x 0 
		(length(aPixelInfo[y]) - 1) 
		when(onep(aPixelInfo[y][x]) 
		    (rpath = (axlPathStart 
			    list((cur_ll_x:cur_ll_y) 
				((cur_ll_x + unit_size):cur_ll_y) 
				((cur_ll_x + unit_size):(cur_ll_y + unit_size)) 
				(cur_ll_x:(cur_ll_y + unit_size)) 
				(cur_ll_x:cur_ll_y)
			    ) 0.0
			)) 
		    (path_list = cons(rpath path_list))
		) 
		(cur_ll_x = (cur_ll_x + unit_size))
	    ) 
	    (cur_ll_x = car(ul_xy))
	    (cur_ll_y = (cur_ll_y - unit_size))
	) 
	(path_data->unitSquare = path_list) path_data
    )
)
procedure(TBX_BARCODE_MATRIX_Update_Dynamics() 
    let((rpath) 
	(axlClearDynamics) 
	(rpath = (axlPathStart 
		((tbx_barcode_matrix_global->curExtents)->ptList) 0.0
	    )) 
	(axlAddSimpleMoveDynamics 
	    (0.0:0.0) rpath "path"
	) t
    )
)
procedure(TBX_BARCODE_MATRIX_Update_Info_Field(form_handle sTextData) 
    let((qr_version qr_ecc_level key_str cap_info cap_info_str
	    text_type text_info_str
	) 
	(qr_version = (axlFormGetField form_handle "version")) 
	(qr_ecc_level = (axlFormGetField form_handle "ecc_level")) 
	(key_str = upperCase(strcat(qr_version "!" qr_ecc_level))) 
	(cap_info = (tbx_barcode_matrix_global->capacityInfo)[key_str])
	(cap_info_str = sprintf(nil "Numeric: %d  Alphanumeric: %d   Bytes: %d" 
		car(cap_info) 
		cadr(cap_info) 
		caddr(cap_info)
	    )) 
	(axlFormSetField form_handle "capacity_info" cap_info_str) 
	if((sTextData && (strlen(sTextData) > 0)) then 
	    (text_type = TBX_BARCODE_MATRIX_Get_Text_Type(sTextData)) 
	    (text_info_str = sprintf(nil "Chars: %d   Type: %s" 
		    strlen(sTextData) text_type
		)) else
	    (text_info_str = "")
	) 
	(axlFormSetField form_handle "text_info" text_info_str) t
    )
)
procedure(TBX_BARCODE_MATRIX_Validate(arg) 
    let((ok_data) 
	(ok_data = t) 
	when((arg->getText) 
	    (tbx_barcode_matrix_global->textData = TBX_BARCODE_MATRIX_Get_Text_Data((tbx_barcode_matrix_global->formid))) 
	    (ok_data = TBX_BARCODE_MATRIX_Verify_Text((tbx_barcode_matrix_global->formid) 
		    (tbx_barcode_matrix_global->textData)
		))
	) 
	if(ok_data then 
	    when((arg->updateStatus) 
		TBX_BARCODE_MATRIX_Update_Info_Field((tbx_barcode_matrix_global->formid) 
		    (tbx_barcode_matrix_global->textData)
		)
	    ) 
	    when((arg->dynamicPreview) 
		(tbx_barcode_matrix_global->curExtents = TBX_BARCODE_MATRIX_Calculate_Extents((tbx_barcode_matrix_global->formid))) 
		TBX_BARCODE_MATRIX_Update_Dynamics()
	    ) else
	    ((tbx_barcode_matrix_global->eventHandler)->pickOrigin = nil) 
	    (axlClearDynamics) 
	    (axlVisibleUpdate t)
	) ok_data
    )
)
procedure(TBX_BARCODE_MATRIX_Verify_Text(form_handle sTextData) 
    let((ecc_level key_str text_type list_id cnt
	    loop qr_version_minimum qr_version_user ok_text
	) 
	(ok_text = t) 
	if((sTextData && (sTextData != "")) then 
	    when((sTextData && (strlen(sTextData) > 0)) 
		(text_type = TBX_BARCODE_MATRIX_Get_Text_Type(sTextData)) 
		(ecc_level = (axlFormGetField form_handle "ecc_level")) 
		case(text_type 
		    ("numeric" 
			(list_id = 0)
		    ) 
		    ("alphanumeric" 
			(list_id = 1)
		    ) 
		    ("byte" 
			(list_id = 2)
		    ) 
		    (t 
			(list_id = 2)
		    )
		) 
		(loop = t)
		(cnt = 1) 
		while(loop 
		    (key_str = upperCase(sprintf(nil "%d!%s" cnt ecc_level))) 
		    if((nth(list_id 
				(tbx_barcode_matrix_global->capacityInfo)[key_str]
			    ) > strlen(sTextData)) then 
			(loop = nil) 
			(qr_version_minimum = sprintf(nil "%d" cnt)) else
			if((cnt == 40) then 
			    (loop = nil) else 
			    ++cnt
			)
		    )
		) 
		(qr_version_user = (axlFormGetField form_handle "version")) 
		cond((!qr_version_minimum 
			(axlUIConfirm "Warning: Text too long to fit into image") 
			(ok_text = nil)
		    ) 
		    ((atoi(qr_version_user) < atoi(qr_version_minimum)) 
			(axlUIConfirm 
			    sprintf(nil "Warning: Selected version is too small for specified text. Increase at least to version %s" qr_version_minimum)
			) 
			(ok_text = nil)
		    ) 
		    (t t)
		)
	    ) else 
	    (axlUIConfirm "Warning: Specify valid text first")
	    (ok_text = nil)
	) ok_text
    )
)
procedure((TBX_BARCODE_Main \@optional arg) ;ÌõÐÎÂë
    let((FORM_FILE fid lic_check_result VERSION_STR FC_FEATURE
	    FC_VERSION SUB_VERSION port info_file defaultValue
	) 
	(FC_FEATURE = "BARCODE") 
	(FC_VERSION = "17.1") 
	(SUB_VERSION = "02") 
	(VERSION_STR = sprintf(nil "Barcode Generator %s (C)2017" FC_VERSION))
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./barcode_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Barcode Generator information:\n") 
		fprintf(port "====================================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  linear  : Generator for linear barcodes Q39 and Q128\n") 
		fprintf(port "  matrix  : Generator for QRCode\n") 
		fprintf(port "  version : Prints the current version of the module\n") 
		fprintf(port "\n")
		close(port) 
		(axlUIViewFileCreate info_file "Barcode Generator: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    (!arg 
		printf("Warning: Missing argument. Use command \"tbx barcode info\"  for more information.\n")
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (arg 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    case(lowerCase(arg) 
			("linear" 
			    TBX_BARCODE_LINEAR_Init() 
			    (defaultValue = TBX_BARCODE_LINEAR_Init_Defaults()) 
			    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "barcodelinear_main")) 
			    (fid = (axlFormCreate 
				    gensym("tbxbarcodelinear") FORM_FILE 
				    '(e outer) 
				    'TBX_BARCODE_LINEAR_Callback
				    t nil
				))
			    (tbx_barcode_linear_global->formid = fid) 
			    (tbx_barcode_linear_global->licCheck = lic_check_result) 
			    TBX_FORM_Init_Header(fid nil lic_check_result VERSION_STR) 
			    (axlFormBuildPopup fid "class_name" 
				(tbx_barcode_linear_global->validClasses)
			    ) 
			    (axlFormSetField fid "class_name" 
				(defaultValue->className)
			    )
			    (axlBuildSubclassPopup fid "subclass_name" 
				(defaultValue->className)
			    ) 
			    (axlFormSetField fid "subclass_name" 
				(defaultValue->subclassName)
			    ) 
			    (axlFormSetField fid "code39" 
				(defaultValue->code39)
			    ) 
			    (axlFormSetField fid "code128" 
				(defaultValue->code128)
			    ) 
			    (axlFormSetField fid "barcode_height" 
				abs((defaultValue->barcodeHeight))
			    )
			    (axlFormSetField fid "barcode_width" 
				abs((defaultValue->barcodeWidth))
			    ) 
			    (axlFormSetField fid "min_bar_width" 
				abs((defaultValue->minBarWidth))
			    ) 
			    (axlFormSetField fid "fix_min_bar_width" 
				(defaultValue->fixMinBar)
			    ) 
			    (axlFormSetField fid "fix_barcode_width" 
				(defaultValue->fixWidth)
			    ) 
			    (axlFormSetFieldEditable fid "barcode_width" nil)
			    (axlFormSetFieldEditable fid "min_bar_width" t) 
			    (axlFormSetField fid "margin_top_bottom" 
				abs((defaultValue->marginTopBottom))
			    ) 
			    (axlFormSetField fid "margin_left_right" 
				abs((defaultValue->marginLeftRight))
			    ) 
			    (axlFormSetField fid "embed_text" 
				(defaultValue->embedText)
			    ) 
			    (axlFormSetFieldEditable fid "text_block" nil)
			    (axlFormSetField fid "text_block" 
				(defaultValue->textBlock)
			    ) 
			    (axlFormSetField fid "invert_structure" 
				(defaultValue->invertStructure)
			    ) 
			    (tbx_barcode_linear_global->transMark = (axlDBTransactionStart)) 
			    (axlFormDisplay fid) 
			    TBX_BARCODE_LINEAR_Event_Loop()
			    TBX_FORM_Delete(lic_check_result FORM_FILE) 
			    TBX_BARCODE_LINEAR_Cleanup()
			) 
			("matrix" 
			    defvar(tbx_barcode_matrix_global_qrv nil) 
			    defvar(tbx_barcode_matrix_global_rsc nil) 
			    (VERSION_STR = sprintf(nil "QR Code Generator %s (C)2015" FC_VERSION)) 
			    TBX_BARCODE_MATRIX_Init()
			    (defaultValue = TBX_BARCODE_MATRIX_Init_Defaults()) 
			    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "barcodematrix_main")) 
			    (fid = (axlFormCreate 
				    gensym("tbxbarcodematrix") FORM_FILE 
				    '(e outer) 
				    'TBX_BARCODE_MATRIX_Callback
				    t nil
				)) 
			    TBX_FORM_Init_Header(fid "" lic_check_result VERSION_STR) 
			    (tbx_barcode_matrix_global->formid = fid)
			    (tbx_barcode_matrix_global->licCheck = lic_check_result) 
			    (axlFormSetField fid "text_by_form" 
				(defaultValue->textByForm)
			    ) 
			    (axlFormSetField fid "text_by_file" 
				(defaultValue->textByFile)
			    ) 
			    if((defaultValue->textByForm) then 
				(axlFormSetFieldEditable fid "text_value" t) 
				(axlFormSetFieldEditable fid "text_file_path" nil) 
				(axlFormSetFieldEditable fid "browse_file" nil)
				else 
				(axlFormSetFieldEditable fid "text_value" nil) 
				(axlFormSetFieldEditable fid "text_file_path" t) 
				(axlFormSetFieldEditable fid "browse_file" t)
			    ) 
			    (axlFormBuildPopup fid "class_name" 
				(tbx_barcode_matrix_global->validClasses)
			    )
			    (axlFormSetField fid "class_name" 
				(defaultValue->className)
			    ) 
			    (axlBuildSubclassPopup fid "subclass_name" 
				(defaultValue->className)
			    ) 
			    (axlFormSetField fid "subclass_name" 
				(defaultValue->subclassName)
			    ) 
			    (axlFormSetField fid "text_value" "") 
			    (axlFormBuildPopup fid "version" 
				(tbx_barcode_matrix_global->versionInfo)
			    )
			    (axlFormSetField fid "version" 
				(defaultValue->version)
			    ) 
			    (axlFormSetField fid "ecc_level" 
				(defaultValue->ercLevel)
			    ) 
			    (axlFormSetField fid "unit_size" 
				(defaultValue->unitSize)
			    ) 
			    (axlFormSetField fid "invert_structure" 
				(defaultValue->invertStructure)
			    ) 
			    (axlFormSetField fid "merge_shapes" 
				(defaultValue->mergeShapes)
			    )
			    (tbx_barcode_matrix_global->transMark = (axlDBTransactionStart)) 
			    (axlFormDisplay fid) 
			    TBX_BARCODE_MATRIX_Event_Loop() 
			    TBX_FORM_Delete(lic_check_result FORM_FILE)
			)
		    )
		)
	    )
	)
    )
)
procedure(TBX_BARCODE_UTILS_Bnot(x) 
    let((iRet) 
	(iRet = ~x) 
	when((iRet < 0) 
	    (iRet = (256 + iRet))
	) iRet
    )
)
procedure(TBX_BARCODE_UTILS_Build_List(item factor) 
    let((lRet) 
	if((factor >= 1) then 
	    (lRet = tconc(nil nil)) 
	    for(i 1 factor 
		(lRet = tconc(lRet item))
	    ) 
	    (lRet = cdar(lRet))
	    else 
	    (lRet = nil)
	) lRet
    )
)
procedure(TBX_BARCODE_UTILS_Bxor(lA lB) 
    let((len_diff lResult) 
	(len_diff = (length(lA) - length(lB))) 
	cond(((len_diff > 0) 
		for(i 1 len_diff 
		    (lB = append1(lB 0))
		)
	    ) 
	    ((len_diff < 0) 
		for(i 1 len_diff 
		    (lA = append1(lA 0))
		)
	    ) 
	    (t t)
	) 
	(lResult = mapcar('bxor lA lB)) lResult
    )
)
procedure(TBX_BARCODE_UTILS_List_Insert(element position list) 
    do(((tail list 
		cdr(tail)
	    ) 
	    (head nil 
		tconc(head 
		    car(tail)
		)
	    ) 
	    (i position 
		sub1(i)
	    )
	) 
	(zerop(i) 
	    car(lconc(tconc(head element) tail))
	)
    )
)
procedure(TBX_BARCODE_UTILS_List_Match(lData lPat) 
    let((pos iLenData iLenPat ok_match lPatTmp
	    iMatchCnt iRestPat lDataLast posLast
	) 
	(pos = 0) 
	(iLenData = length(lData)) 
	(iLenPat = length(lPat)) 
	(lPatTmp = lPat)
	(iRestPat = iLenPat) 
	(iMatchCnt = 0) 
	while(((pos < iLenData) && ((iLenData - pos) >= iRestPat)) 
	    if((car(lData) == car(lPatTmp)) then 
		unless(ok_match 
		    (ok_match = t) 
		    (lDataLast = lData) 
		    (posLast = pos)
		) 
		(lPatTmp = cdr(lPatTmp)) 
		--iRestPat
		when((ok_match && zerop(iRestPat)) 
		    (lPatTmp = lPat) 
		    (iRestPat = iLenPat) 
		    ++iMatchCnt 
		    (ok_match = nil)
		) else 
		when((ok_match && (iRestPat > 0)) 
		    (lData = lDataLast) 
		    (pos = posLast) 
		    (lPatTmp = lPat) 
		    (iRestPat = iLenPat)
		    (ok_match = nil)
		)
	    ) 
	    (lData = cdr(lData)) 
	    ++pos
	) iMatchCnt
    )
)
procedure(TBX_BARCODE_UTILS_List_Replace_Plus(lData lPat) 
    let((pos iLenData iLenPat ok_match lPatTmp
	    iMatchCnt iRestPat lDataLast posLast char_cnt
	    lRet lDataNew
	) 
	(pos = 0) 
	(iLenData = length(lData)) 
	(iLenPat = length(lPat)) 
	(lPatTmp = lPat)
	(iRestPat = iLenPat) 
	(iMatchCnt = 0) 
	(lDataNew = tconc(nil nil)) 
	while(((pos < iLenData) && ((iLenData - pos) >= iRestPat)) 
	    if((car(lData) == car(lPatTmp)) then 
		unless(ok_match 
		    (ok_match = t) 
		    (lDataLast = lData) 
		    (posLast = pos) 
		    (char_cnt = 0)
		) 
		++char_cnt 
		if(onep(iRestPat) then 
		    (iRestPat = iRestPat) 
		    (lPatTmp = lPatTmp) else
		    (lPatTmp = cdr(lPatTmp)) 
		    --iRestPat
		)
		else 
		when(ok_match 
		    if((char_cnt >= iLenPat) then 
			(lPatTmp = lPat) 
			(iRestPat = iLenPat) 
			++iMatchCnt
			else 
			(lData = lDataLast) 
			(pos = posLast) 
			(lPatTmp = lPat) 
			(iRestPat = iLenPat)
		    ) 
		    (ok_match = nil)
		) 
		tconc(lDataNew 
		    car(lData)
		) 
		(char_cnt = 0)
	    ) 
	    (lData = cdr(lData)) 
	    ++pos
	) 
	if(ok_match then 
	    ++iMatchCnt else 
	    lconc(lDataNew lData)
	)
	(lDataNew = cdar(lDataNew)) 
	(lRet = list(iMatchCnt lDataNew)) lRet
    )
)
procedure(TBX_BARCODE_UTILS_Shrink_Array_To(arr mode) 
    let((lData aRet) 
	(lData = tconc(nil nil)) 
	for(i 0 
	    (length(arr) - 1) 
	    when(arr[i] 
		tconc(lData 
		    arr[i]
		)
	    )
	) 
	(lData = cdar(lData)) 
	if((mode == "array") then 
	    (aRet = listToVector(lData)) else 
	    (aRet = lData)
	)
	aRet
    )
)
procedure(TBX_BARCODE_UTILS_Unpack(lFormat lData) 
    let((llResult lItems x iCnt) 
	(llResult = tconc(nil nil)) 
	foreach(fm lFormat 
	    (iCnt = atoi(substring(fm 2))) 
	    (x = tconc(nil nil)) 
	    for(i 1 iCnt 
		when(car(lData) 
		    tconc(x 
			car(lData)
		    ) 
		    (lData = cdr(lData))
		)
	    )
	    (lItems = cdar(x)) 
	    tconc(llResult lItems)
	) 
	when(lData 
	    tconc(llResult lData)
	) 
	(llResult = cdar(llResult))
	llResult
    )
)
procedure(TBX_BATCHPLOT_Build_Profile_Popup(form_handle plot_info profile_info) 
    let((profile_list profile_name) 
	foreach(key profile_info 
	    (profile_list = cons(key profile_list))
	) 
	foreach(key plot_info 
	    foreach(entry 
		cdr(plot_info[key]) 
		(profile_name = lowerCase(cadr(entry))) 
		unless(member(profile_name profile_list) 
		    (profile_list = cons(profile_name profile_list))
		)
	    )
	) 
	(profile_list = sort(profile_list nil)) 
	(axlFormBuildPopup form_handle "plot_profile" profile_list)
	t
    )
)
procedure(TBX_BATCHPLOT_Callback_Edit(form_handle) 
    let((plotset_name new_id last_item plot_info pdf_name
	    selected_views active_view view_data view_list
	) 
	case((form_handle->curField) 
	    ("done" 
		(plot_info = (tbx_batchplot_data->plotInfo)) 
		(plotset_name = (axlFormGetField form_handle "plotset_name")) 
		(pdf_name = (axlFormGetField form_handle "pdf_name")) 
		rexCompile("^ *")
		rexReplace(pdf_name "" 0) 
		rexCompile(" *$") 
		rexReplace(pdf_name "" 0) 
		when((pdf_name == "") 
		    (pdf_name = "**")
		) 
		(selected_views = TBX_BATCHPLOT_Get_Selected(form_handle))
		foreach(v selected_views 
		    (view_data = cons(list(v 
				(tbx_batchplot_data->curProfile)[v]
			    ) view_data
			))
		) 
		(view_data = reverse(view_data)) 
		(plot_info[plotset_name] = cons(pdf_name view_data)) 
		(tbx_batchplot_data->plotInfo = plot_info) 
		(plotset_name = (axlFormGetField 
			((tbx_batchplot_data->formHandle)->main) "plot_set_list"
		    ))
		(view_list = TBX_BATCHPLOT_Get_View_Items(cdr(plot_info[plotset_name]))) 
		(axlFormListDeleteAll 
		    ((tbx_batchplot_data->formHandle)->main) "view_list_selected"
		) 
		(axlFormSetField 
		    ((tbx_batchplot_data->formHandle)->main) "view_list_selected" view_list
		) 
		(axlFormSetField 
		    ((tbx_batchplot_data->formHandle)->main) "plotset_pdf" pdf_name
		) 
		(axlFormClose form_handle)
		(form_handle->_posindex = nil)
	    ) 
	    ("cancel" 
		(axlFormClose form_handle)
	    ) 
	    ("pdf_name" 
		(pdf_name = (form_handle->curValue)) 
		when((pdf_name != "") 
		    (tbx_batchplot_data->isModified = t) 
		    unless(rexMatchp("[.][pP][dD][fF]$" pdf_name) 
			(pdf_name = strcat(pdf_name ".pdf"))
		    ) 
		    (axlFormSetField form_handle "pdf_name" pdf_name)
		)
	    ) 
	    ("all_views" 
		(selected_views = TBX_BATCHPLOT_Get_Selected(form_handle)) 
		(active_view = (axlFormGetField form_handle "all_views")) 
		unless(member(active_view selected_views) 
		    (tbx_batchplot_data->isModified = t) 
		    (axlFormListAddItem form_handle "selected_views" active_view -1) 
		    (axlFormListAddItem form_handle "selected_views" nil -1) 
		    ((tbx_batchplot_data->curProfile)[active_view] = "default")
		)
	    )
	    ("selected_views" 
		(form_handle->_posindex = (form_handle->curValueInt)) 
		(active_view = (axlFormGetField form_handle "selected_views")) 
		(axlFormSetField form_handle "plot_profile" 
		    (tbx_batchplot_data->curProfile)[active_view]
		)
	    ) 
	    ("plot_profile" 
		(active_view = (axlFormGetField form_handle "selected_views")) 
		when((active_view != "") 
		    (tbx_batchplot_data->isModified = t) 
		    ((tbx_batchplot_data->curProfile)[active_view] = (form_handle->curValue))
		)
	    ) 
	    ("remove" 
		(active_view = (axlFormGetField form_handle "selected_views")) 
		when((active_view != "") 
		    (tbx_batchplot_data->isModified = t) 
		    (axlFormListDeleteItem form_handle "selected_views" active_view) 
		    remove(active_view 
			(tbx_batchplot_data->curProfile)
		    )
		)
	    ) 
	    ("move_up" 
		(active_view = (axlFormGetField form_handle "selected_views")) 
		when((form_handle->_posindex) 
		    if(((form_handle->_posindex) > 0) then 
			(tbx_batchplot_data->isModified = t) 
			(active_view = (axlFormGetField form_handle "selected_views")) 
			(new_id = ((form_handle->_posindex) - 1))
			(axlFormListDeleteItem form_handle "selected_views" 
			    (form_handle->_posindex)
			) 
			(axlFormListAddItem form_handle "selected_views" active_view new_id) 
			(form_handle->_posindex = new_id) 
			(axlFormListSelect form_handle "selected_views" new_id)
		    )
		)
	    ) 
	    ("move_down" 
		when((form_handle->_posindex) 
		    (last_item = (axlFormListGetItem form_handle "selected_views" -1)) 
		    (active_view = (axlFormGetField form_handle "selected_views")) 
		    if((active_view != last_item) then 
			(tbx_batchplot_data->isModified = t) 
			(new_id = ((form_handle->_posindex) + 1)) 
			(axlFormListDeleteItem form_handle "selected_views" 
			    (form_handle->_posindex)
			)
			(axlFormListAddItem form_handle "selected_views" active_view new_id) 
			(form_handle->_posindex = new_id) 
			(axlFormListSelect form_handle "selected_views" new_id)
		    )
		)
	    )
	    ("clear_all" 
		(axlFormListDeleteAll form_handle "selected_views") 
		(form_handle->_posindex = nil) 
		(tbx_batchplot_data->curProfile = makeTable("cur_map_table" nil)) 
		(tbx_batchplot_data->isModified = t)
	    ) 
	    ("myhelp" 
		(axlShell "tbx help  batchplot")
	    ) 
	    (t)
	)
    )
)
procedure(TBX_BATCHPLOT_Callback_Main(form_handle) 
    let((output_file view_item tmp_list pdf_name view_list
	    input_file plot_dir FORM_FILE fid plot_info
	    plotset_name plotset_name_list start_dir new_dir all_views
	    msg
	) 
	case((form_handle->curField) 
	    ("done" 
		TBX_BATCHPLOT_Save_Config((tbx_batchplot_data->cfgFile)) 
		(axlFormClose form_handle) 
		(axlVisibleSet 
		    (tbx_batchplot_data->orgvis)
		) 
		(axlVisibleUpdate t)
	    ) 
	    ("cancel" 
		(axlFormClose form_handle) 
		(axlVisibleSet 
		    (tbx_batchplot_data->orgvis)
		) 
		(axlVisibleUpdate t)
	    ) 
	    ("plot_set_list" 
		(plot_info = (tbx_batchplot_data->plotInfo)) 
		(plotset_name = (axlFormGetField form_handle "plot_set_list")) 
		(pdf_name = car(plot_info[plotset_name])) 
		(view_list = TBX_BATCHPLOT_Get_View_Items(cdr(plot_info[plotset_name])))
		(axlFormSetField form_handle "plotset_pdf" pdf_name) 
		(axlFormListDeleteAll form_handle "view_list_selected") 
		(axlFormSetField form_handle "view_list_selected" view_list)
	    ) 
	    ("view_list_selected" 
		(view_item = (axlFormGetField form_handle "view_list_selected")) 
		unless(rexMatchp(" [*][*]$" view_item) 
		    (axlShell 
			strcat("setwindow form.vf_vis; FORM vf_vis colorview_list " view_item)
		    )
		)
	    )
	    ("add_plotset" 
		(plot_info = (tbx_batchplot_data->plotInfo)) 
		(tmp_list = list()) 
		foreach(key plot_info 
		    (tmp_list = cons(key tmp_list))
		) 
		(plotset_name = (axlEnterString ?prompts 
			list("Enter new plot set name:")
		    ))
		when((plotset_name && (plotset_name != "")) 
		    (tbx_batchplot_data->isModified = t) 
		    rexCompile("^ *") 
		    rexReplace(plotset_name "" 0) 
		    rexCompile(" *$")
		    rexReplace(plotset_name "" 0) 
		    if(!member(lowerCase(plotset_name) tmp_list) then 
			(axlFormListAddItem form_handle "plot_set_list" plotset_name -1) 
			(plot_info[plotset_name] = list()) 
			(tbx_batchplot_data->info = plot_info)
			else 
			(axlUIWPrint form_handle "I - Plotset already exists.")
		    )
		)
	    ) 
	    ("edit_plotset" 
		(tbx_batchplot_data->profileInfo = TBX_BATCHPLOT_Get_Profiles()) 
		(tbx_batchplot_data->plotInfo = TBX_BATCHPLOT_Update_Plot_Configuration((tbx_batchplot_data->plotInfo) 
			(tbx_batchplot_data->viewItems) 
			(tbx_batchplot_data->profileInfo)
		    )) 
		(FORM_FILE = TBX_FORM_Get_Name((tbx_batchplot_data->licCheck) "batchplot_edit")) 
		(fid = (axlFormCreate 
			gensym("tbxbatchplotedit") FORM_FILE 
			'(e outer) 
			'TBX_BATCHPLOT_Callback_Edit
			t
		    ))
		TBX_FORM_Init_Header(fid "Licensed for " 
		    (tbx_batchplot_data->licCheck) 
		    (tbx_batchplot_data->version)
		) 
		TBX_BATCHPLOT_Build_Profile_Popup(fid 
		    (tbx_batchplot_data->plotInfo) 
		    (tbx_batchplot_data->profileInfo)
		) 
		(plotset_name = (axlFormGetField form_handle "plot_set_list")) 
		if((plotset_name != "") then 
		    (all_views = sort(all_views nil)) 
		    (axlFormSetField fid "all_views" 
			(tbx_batchplot_data->viewItems)
		    ) 
		    (plot_info = (tbx_batchplot_data->plotInfo))
		    (pdf_name = car(plot_info[plotset_name])) 
		    (view_list = TBX_BATCHPLOT_Get_View_Items(cdr(plot_info[plotset_name]))) 
		    (tbx_batchplot_data->curProfile = TBX_BATCHPLOT_Get_Profile_Mapping(cdr(plot_info[plotset_name]))) 
		    (axlFormSetField fid "plotset_name" plotset_name) 
		    (axlFormSetField fid "pdf_name" pdf_name)
		    (axlFormSetField fid "selected_views" view_list) 
		    (axlFormDisplay fid) 
		    TBX_FORM_Delete((tbx_batchplot_data->licCheck) FORM_FILE) else 
		    (axlUIWPrint form_handle "I - Select one item before  ")
		)
	    ) 
	    ("clear_setup" 
		(tbx_batchplot_data->isModified = t) 
		(plot_info = (tbx_batchplot_data->plotInfo)) 
		(plotset_name = (axlFormGetField form_handle "plot_set_list")) 
		remove(plotset_name plot_info)
		(axlFormListDeleteItem form_handle "plot_set_list" plotset_name) 
		(axlFormListDeleteAll form_handle "view_list_selected") 
		(axlFormSetField form_handle "plot_set_list" nil) 
		(axlFormSetField form_handle "view_list_selected" nil)
	    ) 
	    ("purge_data" 
		(msg = "") 
		(msg = strcat(msg "This function will remove all invalid views from plotsets.\n")) 
		(msg = strcat(msg "Also all undefined profiles will be reset to \"default\".\n")) 
		(msg = strcat(msg "Do you want to continue?\n"))
		when((axlUIYesNo msg nil 
			'no
		    ) 
		    (tbx_batchplot_data->isModified = t) 
		    TBX_BATCHPLOT_Purge_Data() 
		    (plot_info = (tbx_batchplot_data->plotInfo)) 
		    (plotset_name = (axlFormGetField form_handle "plot_set_list"))
		    when((plotset_name != "") 
			(view_list = TBX_BATCHPLOT_Get_View_Items(cdr(plot_info[plotset_name]))) 
			(axlFormListDeleteAll form_handle "view_list_selected") 
			(axlFormSetField form_handle "view_list_selected" view_list)
		    )
		)
	    ) 
	    ("save_setup" 
		(output_file = (axlDMFileBrowse nil t ?optFilters "Plot configuration (*.cfg)|*.cfg"
			?noSticky t
		    )) 
		when(output_file 
		    TBX_BATCHPLOT_Save_Config(output_file)
		)
	    )
	    ("load_setup" 
		(input_file = (axlDMFileBrowse nil nil ?optFilters "Plot configuration (*.cfg)|*.cfg"
			?noSticky t
		    )) 
		when(input_file 
		    (tbx_batchplot_data->plotInfo = TBX_BATCHPLOT_Get_Plot_Configuration(input_file 
			    (tbx_batchplot_data->viewItems) 
			    (tbx_batchplot_data->profileInfo)
			)) 
		    (tmp_list = TBX_UTIL_Get_Hash_Keys((tbx_batchplot_data->plotInfo) t)) 
		    (axlFormListDeleteAll form_handle "plot_set_list") 
		    (axlFormSetField form_handle "plot_set_list" tmp_list)
		    (axlFormListSelect form_handle "plot_set_list" 0) 
		    (plotset_name = (axlFormGetField form_handle "plot_set_list")) 
		    (view_list = TBX_BATCHPLOT_Get_View_Items(cdr((tbx_batchplot_data->plotInfo)[plotset_name]))) 
		    (axlFormListDeleteAll form_handle "view_list_selected") 
		    (axlFormSetField form_handle "view_list_selected" view_list)
		)
	    ) 
	    ("dir_browse" 
		if(((axlFormGetField form_handle "plot_dir") != "") then 
		    if(isDir((axlFormGetField form_handle "plot_dir")) then 
			(start_dir = (axlFormGetField form_handle "plot_dir")) else 
			printf("Warning: Directory %s  does not exist.\n" 
			    (axlFormGetField form_handle "plot_dir")
			)
			(start_dir = ".")
		    ) else 
		    (start_dir = ".")
		) 
		(new_dir = (axlDMDirectoryBrowse start_dir t ?title "Pick a directory")) 
		when(new_dir 
		    (axlFormSetField form_handle "plot_dir" new_dir)
		)
	    ) 
	    ("define_plot_profiles" 
		TBX_PLOTBASE_Print_Setup_Main((tbx_batchplot_data->licCheck) 
		    (tbx_batchplot_data->version)
		)
	    ) 
	    ("plot_all" 
		(tbx_batchplot_data->profileInfo = TBX_BATCHPLOT_Get_Profiles()) 
		(tbx_batchplot_data->plotInfo = TBX_BATCHPLOT_Update_Plot_Configuration((tbx_batchplot_data->plotInfo) 
			(tbx_batchplot_data->viewItems) 
			(tbx_batchplot_data->profileInfo)
		    )) 
		(plotset_name_list = TBX_UTIL_Get_Hash_Keys((tbx_batchplot_data->plotInfo) t)) 
		(plot_dir = (axlFormGetField form_handle "plot_dir"))
		when((plot_dir && (plot_dir != "") && !isDir(plot_dir)) 
		    createDir(plot_dir)
		) 
		TBX_BATCHPLOT_Run(plotset_name_list plot_dir) 
		(axlVisibleSet 
		    (tbx_batchplot_data->orgvis)
		) 
		(axlVisibleUpdate t)
	    ) 
	    ("plot_selected" 
		(tbx_batchplot_data->profileInfo = TBX_BATCHPLOT_Get_Profiles()) 
		(tbx_batchplot_data->plotInfo = TBX_BATCHPLOT_Update_Plot_Configuration((tbx_batchplot_data->plotInfo) 
			(tbx_batchplot_data->viewItems) 
			(tbx_batchplot_data->profileInfo)
		    )) 
		(plotset_name = (axlFormGetField form_handle "plot_set_list")) 
		if((plotset_name != "") then 
		    (plotset_name_list = list(plotset_name)) 
		    (plot_dir = (axlFormGetField form_handle "plot_dir")) 
		    when((plot_dir && (plot_dir != "") && !isDir(plot_dir)) 
			createDir(plot_dir)
		    )
		    TBX_BATCHPLOT_Run(plotset_name_list plot_dir) 
		    (axlVisibleSet 
			(tbx_batchplot_data->orgvis)
		    ) 
		    (axlVisibleUpdate t) else 
		    (axlUIWPrint form_handle "I - Select one item before  ")
		)
	    )
	    ("myhelp" 
		(axlShell "tbx help  batchplot")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_BATCHPLOT_Data_Integrity(plot_info) 
    let((pdf_name view profile error_list) 
	foreach(key plot_info 
	    (pdf_name = car(plot_info[key])) 
	    foreach(entry 
		cdr(plot_info[key]) 
		(view = car(entry)) 
		(profile = cadr(entry)) 
		when((rexMatchp("[*][*]$" pdf_name) || 
			rexMatchp("[*][*]$" view) || 
			rexMatchp("[*][*]$" profile)) 
		    (error_list = cons(list(key pdf_name view profile) error_list))
		)
	    )
	) 
	(error_list = reverse(error_list)) error_list
    )
)
procedure(TBX_BATCHPLOT_Get_Plot_Configuration(cfg_file view_list profile_info) 
    let((plot_info plotset_name pdf_name data view_data
	    port key key_case view_item view_profile
	) 
	(plot_info = makeTable("plot_info_table" nil)) 
	if(isFile(cfg_file) then 
	    (port = infile(cfg_file)) 
	    (data = car(lineread(port))) 
	    close(port)
	    foreach(entry data 
		(plotset_name = car(entry)) 
		(pdf_name = cadr(entry)) 
		(view_data = list())
		cond(((type(caddr(entry)) == 'string) 
			foreach(v 
			    cddr(entry) 
			    (key = strcat("File: " v)) 
			    (key_case = nil) 
			    foreach(item view_list 
				when((lowerCase(key) == lowerCase(item)) 
				    (key_case = item)
				)
			    )
			    if(key_case then 
				(view_data = cons(list(key_case "default") view_data)) else 
				(view_data = cons(list(strcat(key " **") "default") view_data))
			    )
			) 
			(view_data = reverse(view_data))
		    ) 
		    ((type(caddr(entry)) == 'list) 
			foreach(pair 
			    cddr(entry) 
			    (view_item = car(pair)) 
			    (view_profile = cadr(pair)) 
			    rexCompile("^ ")
			    (view_item = rexReplace(view_item "" 0)) 
			    (view_profile = rexReplace(view_profile "" 0)) 
			    rexCompile("^[Ff][Ii][Ll][Ee] *: *") 
			    (view_item = rexReplace(view_item "File: " 0)) 
			    rexCompile("^[Ff][Ii][Ll][Mm] *: *")
			    (view_item = rexReplace(view_item "Film: " 0)) 
			    rexCompile(" *$") 
			    (view_item = rexReplace(view_item "" 0)) 
			    (view_profile = rexReplace(view_profile "" 0)) 
			    (view_profile = lowerCase(view_profile))
			    unless(member(view_item view_list) 
				(view_item = strcat(view_item " **"))
			    ) 
			    unless(profile_info[view_profile] 
				(view_profile = strcat(view_profile " **"))
			    ) 
			    (view_data = cons(list(view_item view_profile) view_data))
			) 
			(view_data = reverse(view_data))
		    ) 
		    (t 
			printf("Error: Invalid format in  file: %L\n" cfg_file)
		    )
		) 
		(plot_info[plotset_name] = cons(pdf_name view_data))
	    ) else 
	    printf("Configuration file floware/%s does not exist yet. Skipping\n" cfg_file)
	) plot_info
    )
)
procedure(TBX_BATCHPLOT_Get_Profile_Mapping(plotset_views) 
    let((cur_map) 
	(cur_map = makeTable("cur_map_table" nil)) 
	foreach(entry plotset_views 
	    (cur_map[car(entry)] = cadr(entry))
	) cur_map
    )
)
procedure(TBX_BATCHPLOT_Get_Profiles() 
    let((file_list profile_info data) 
	(profile_info = makeTable("profile_info_table" nil)) 
	(file_list = (TBX_UTIL_Search_Config "*.profile" "batchplot" t ?includeWorkDir
		t ?includeRunDir t
	    )) 
	when(file_list 
	    foreach(fn file_list 
		(data = TBX_PLOTBASE_Read_Profile(fn)) 
		if(data then 
		    (profile_info[(data->name)] = data) else 
		    printf("Warning: Invalid data in profile %L" fn)
		)
	    )
	) profile_info
    )
)
procedure(TBX_BATCHPLOT_Get_Selected(fh) 
    let((cnt last_item cur_item ret_list) 
	(cnt = 0) 
	(last_item = (axlFormListGetItem fh "selected_views" -1)) 
	(cur_item = (axlFormListGetItem fh "selected_views" 0)) 
	(ret_list = list())
	if(!last_item then else 
	    if((cur_item == last_item) then 
		(ret_list = list(cur_item)) else 
		while((cur_item != last_item) 
		    (cnt = (cnt + 1)) 
		    (ret_list = cons(cur_item ret_list)) 
		    (cur_item = (axlFormListGetItem fh "selected_views" cnt))
		)
		(ret_list = cons(cur_item ret_list))
	    )
	) 
	(ret_list = reverse(ret_list)) ret_list
    )
)
procedure(TBX_BATCHPLOT_Get_View_Items(plotset_views) 
    let((view_list) 
	foreach(entry plotset_views 
	    (view_list = cons(car(entry) view_list))
	) 
	(view_list = reverse(view_list)) view_list
    )
)
procedure(TBX_BATCHPLOT_Get_Views() 
    let((dir_name s_name view_list full_name) 
	foreach(vdir 
	    parseString(axlGetVariable("viewpath")) 
	    (dir_name = simplifyFilename(vdir)) 
	    (dir_name = (axlOSSlash dir_name)) 
	    when(isDir(dir_name) 
		foreach(i 
		    getDirFiles(dir_name) 
		    if((isFile(strcat(dir_name "/" i)) && 
			    rexMatchp("[.]color$" 
				lowerCase(i)
			    )) then 
			(s_name = i) 
			rexCompile("[.]color") 
			(s_name = rexReplace(s_name "" 0))
			(full_name = strcat("File: " s_name)) 
			unless(member(full_name view_list) 
			    (view_list = cons(full_name view_list))
			)
		    )
		)
	    )
	) 
	foreach(art 
	    ((axlGetParam "artwork")->groupMembers) 
	    (full_name = strcat("Film: " art)) 
	    unless(member(full_name view_list) 
		(view_list = cons(full_name view_list))
	    )
	) 
	(view_list = sort(view_list nil)) view_list
    )
)
procedure(TBX_BATCHPLOT_Init() 
    let((pdf_dir cfg_file cfg_fullpath cfg_fullpath_legacy run_dir) 
	(cfg_fullpath_legacy = strcat(getWorkingDir() "/floware/batchplot_data.txt")) 
	(cfg_file = "batchplot.cfg") 
	(cfg_fullpath = strcat(getWorkingDir() "/" cfg_file)) 
	when((isFile(cfg_fullpath_legacy) && !isFile(cfg_fullpath)) 
	    printf("Note: Legacy configuration file floware/batchplot_data.txt found, move to ./batchplot.cfg\n") 
	    (axlOSFileMove cfg_fullpath_legacy cfg_fullpath)
	)
	(run_dir = strcat(getWorkingDir() "/toolbox.run")) 
	unless(isDir(run_dir) 
	    createDir(run_dir)
	) 
	when(axlGetVariable("FLW_BATCHPLOT_OUTDIR") 
	    printf("Note: Legacy environment variable FLW_BATCHPLOT_OUTDIR found ...\n") 
	    (pdf_dir = axlGetVariable("FLW_BATCHPLOT_OUTDIR"))
	) 
	when(axlGetVariable("TBX_BATCHPLOT_OUTDIR") 
	    printf("Reading environment variable TBX_BATCHPLOT_OUTDIR ...\n") 
	    (pdf_dir = axlGetVariable("TBX_BATCHPLOT_OUTDIR"))
	) 
	when((pdf_dir && (pdf_dir != "")) 
	    rexCompile("/$") 
	    (pdf_dir = rexReplace(pdf_dir "" 0)) 
	    unless(isDir(pdf_dir) 
		unless(createDir(pdf_dir) 
		    printf("Warning: Could not create directory %s\n" pdf_dir) 
		    (pdf_dir = "")
		)
	    )
	)
	unless(boundp('tbx_batchplot_data) 
	    iliDefstruct('defstruct(tbx_batchplot_data_struct plotInfo batchParam printerName outdir
			formHandle cfgFile version orgvis curProfile
			viewItems profileInfo viewlog isModified licCheck
			runDir
		    )
	    ) 
	    defvar(tbx_batchplot_data nil)
	) 
	if(!tbx_batchplot_data then 
	    (tbx_batchplot_data = (make_tbx_batchplot_data_struct ?plotInfo nil ?batchParam nil
		    ?printerName nil ?formHandle 
		    ncons(nil) ?isModified
		    nil ?outdir pdf_dir ?cfgFile cfg_fullpath
		    ?version nil ?orgvis 
		    (axlVisibleGet) ?viewItems
		    nil ?profileInfo nil ?viewlog nil
		    ?curProfile nil ?licCheck nil ?runDir
		    run_dir
		)) else 
	    (tbx_batchplot_data->plotInfo = nil)
	    (tbx_batchplot_data->batchParam = nil) 
	    (tbx_batchplot_data->printerName = nil) 
	    (tbx_batchplot_data->formHandle = ncons(nil)) 
	    (tbx_batchplot_data->isModified = nil) 
	    (tbx_batchplot_data->outdir = pdf_dir)
	    (tbx_batchplot_data->cfgFile = cfg_fullpath) 
	    (tbx_batchplot_data->version = nil) 
	    (tbx_batchplot_data->orgvis = (axlVisibleGet)) 
	    (tbx_batchplot_data->viewItems = nil) 
	    (tbx_batchplot_data->profileInfo = nil)
	    (tbx_batchplot_data->viewlog = nil) 
	    (tbx_batchplot_data->curProfile = nil) 
	    (tbx_batchplot_data->licCheck = nil) 
	    (tbx_batchplot_data->runDir = run_dir)
	)
    )
)
procedure((TBX_BATCHPLOT_Main \@optional arg) 
    let((lic_check_result FORM_FILE fid plotset_list view_list
	    plotset_name VERSION_STR FC_FEATURE FC_VERSION SUB_VERSION
	    info_file port printer_param ok_start_app
	) 
	(FC_FEATURE = "BATCHPLOT") 
	(FC_VERSION = "17.1") 
	(SUB_VERSION = "03") 
	(VERSION_STR = sprintf(nil "Batch Plot %s (C)2017" FC_VERSION))
	(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
	(ok_start_app = t) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./batchplot_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Batchplot information:\n") 
		fprintf(port "=============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version : Prints the current version of the module\n") 
		fprintf(port "\n") 
		fprintf(port "Environment variables:\n") 
		fprintf(port "  TBX_BATCHPLOT_OUTDIR = <relative_path>\n")
		fprintf(port "     Specifies directory where pdf data is written to.\n") 
		fprintf(port "     The default is to write pdf data to brd directory or to honor ads_sdplot.\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Batchplot: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is %s.%s\n" FC_VERSION SUB_VERSION) 
		(ok_start_app = nil)
	    )
	) 
	when((ok_start_app && lic_check_result) 
	    (printer_param = TBX_PLOTBASE_Check_System_Environment()) 
	    when((((printer_param->platform) == "wint") && (printer_param->driver) && (printer_param->command)) 
		(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "batchplot_main")) 
		unless(boundp('tbxBatchplotMainHandle) 
		    defvar(tbxBatchplotMainHandle nil)
		) 
		(fid = (axlFormCreate 
			'tbxBatchplotMainHandle FORM_FILE 
			'(e outer) 
			'TBX_BATCHPLOT_Callback_Main
			t
		    )) 
		when(fid 
		    TBX_BATCHPLOT_Init() 
		    (tbx_batchplot_data->printerParam = printer_param) 
		    (tbx_batchplot_data->viewItems = TBX_BATCHPLOT_Get_Views()) 
		    (tbx_batchplot_data->profileInfo = TBX_BATCHPLOT_Get_Profiles())
		    (tbx_batchplot_data->plotInfo = TBX_BATCHPLOT_Get_Plot_Configuration((tbx_batchplot_data->cfgFile) 
			    (tbx_batchplot_data->viewItems) 
			    (tbx_batchplot_data->profileInfo)
			)) 
		    TBX_FORM_Init_Header(fid "Licensed for " lic_check_result VERSION_STR) 
		    ((tbx_batchplot_data->formHandle)->main = fid) 
		    (tbx_batchplot_data->version = VERSION_STR) 
		    (tbx_batchplot_data->licCheck = lic_check_result)
		    (plotset_list = TBX_UTIL_Get_Hash_Keys((tbx_batchplot_data->plotInfo) t)) 
		    (axlFormSetField fid "plot_set_list" plotset_list) 
		    (axlFormSetField fid "plot_dir" 
			(tbx_batchplot_data->outdir)
		    ) 
		    (axlFormSetField fid "printer_name" 
			((tbx_batchplot_data->printerParam)->driver)
		    ) 
		    when((length(plotset_list) > 0) 
			(axlFormListSelect fid "plot_set_list" 0) 
			(plotset_name = (axlFormGetField fid "plot_set_list")) 
			(view_list = TBX_BATCHPLOT_Get_View_Items(cdr((tbx_batchplot_data->plotInfo)[plotset_name]))) 
			(axlFormSetField fid "view_list_selected" view_list)
			(axlFormSetField fid "plotset_pdf" 
			    car((tbx_batchplot_data->plotInfo)[plotset_name])
			)
		    )
		    (axlFormDisplay fid) 
		    TBX_FORM_Delete(lic_check_result FORM_FILE)
		)
	    )
	)
    )
)
procedure(TBX_BATCHPLOT_Purge_Data() 
    let((view_data_clean pdf_name view_item view_profile plot_info) 
	(plot_info = (tbx_batchplot_data->plotInfo)) 
	foreach(key plot_info 
	    (pdf_name = car(plot_info[key])) 
	    (view_data_clean = list()) 
	    foreach(entry 
		cdr(plot_info[key]) 
		(view_item = car(entry)) 
		(view_profile = cadr(entry)) 
		when(rexMatchp("[*][*]$" view_profile) 
		    (view_profile = "default")
		)
		unless(rexMatchp("[*][*]$" view_item) 
		    (view_data_clean = cons(list(view_item view_profile) view_data_clean))
		)
	    )
	    (view_data_clean = reverse(view_data_clean)) 
	    if(zerop(length(view_data_clean)) then 
		remove(key plot_info) else 
		(view_data_clean = cons(pdf_name view_data_clean))
		(plot_info[key] = view_data_clean)
	    )
	) plot_info
    )
)
procedure(TBX_BATCHPLOT_Run(plotset_list plot_dir) 
    let((pdf_file ps_file ps_list error_list plot_info
	    profile_info port error_report view_name profile_name
	    cnt printer_param output_file script_file tmp_list
	    result
	) 
	(plot_info = (tbx_batchplot_data->plotInfo)) 
	(profile_info = (tbx_batchplot_data->profileInfo)) 
	(printer_param = (tbx_batchplot_data->printerParam)) 
	when((plot_dir == "") 
	    (plot_dir = ".")
	)
	if((length(plot_info) > 0) then 
	    if(isDir(plot_dir) then 
		(error_list = TBX_BATCHPLOT_Data_Integrity(plot_info)) 
		if(!error_list then 
		    foreach(pset plotset_list 
			(ps_list = nil) 
			(cnt = 0) 
			(pdf_file = car(plot_info[pset]))
			(output_file = strcat(plot_dir "/" pdf_file)) 
			foreach(entry 
			    cdr(plot_info[pset]) 
			    (view_name = car(entry)) 
			    (profile_name = cadr(entry)) 
			    (script_file = strcat((tbx_batchplot_data->runDir) "/batchplot_profile_" profile_name ".scr"))
			    (script_file = lowerCase(script_file)) 
			    unless(exists(x tmp_list 
				    (x == script_file)
				) 
				(tmp_list = cons(script_file tmp_list))
			    ) 
			    TBX_PLOTBASE_Print_Setup_Execute(profile_info[profile_name] script_file) 
			    unless(axlGetVariable("FLW_DEBUG") 
				deleteFile(script_file)
			    ) 
			    (ps_file = strcat(pset "_" 
				    sprintf(nil "%02d" cnt) ".ps"
				))
			    (cnt = (cnt + 1)) 
			    (script_file = strcat((tbx_batchplot_data->runDir) "/batchplot_ps_" 
				    cadr(parseString(view_name)) ".scr"
				)) 
			    (script_file = lowerCase(script_file)) 
			    unless(exists(x tmp_list 
				    (x == script_file)
				) 
				(tmp_list = cons(script_file tmp_list))
			    ) 
			    (result = TBX_PLOTBASE_Generate_Postscript(view_name ps_file 
				    (printer_param->driver) 
				    profile_info[profile_name] script_file
				))
			    unless(axlGetVariable("FLW_DEBUG") 
				foreach(fn tmp_list 
				    when(isFile(fn) 
					deleteFile(fn)
				    )
				)
			    ) 
			    when(result 
				if(axlGetVariable("ads_sdplot") then 
				    (ps_list = cons(strcat(axlGetVariable("ads_sdplot") "/" ps_file) ps_list)) else 
				    (ps_list = cons(ps_file ps_list))
				)
			    )
			) 
			if((length(ps_list) > 0) then 
			    (ps_list = sort(ps_list nil)) 
			    if(axlGetVariable("FLW_DEBUG") then 
				TBX_PLOTBASE_Generate_PDF(ps_list output_file printer_param t t) else 
				TBX_PLOTBASE_Generate_PDF(ps_list output_file printer_param t nil)
			    ) else
			    printf("Info: Plotset %L does not contain any data. Skipping PDF generation.\n" pset)
			)
		    ) 
		    (axlVisibleUpdate t) else
		    (error_report = strcat((tbx_batchplot_data->runDir) "/batchplot_error.rpt")) 
		    (port = outfile(error_report "w")) 
		    fprintf(port "Invalid entries (suffix  \"**\") detected. Cannot proceed.\n") 
		    fprintf(port "\n") 
		    fprintf(port "================================================================================\n")
		    fprintf(port "%-15s  %-20s  %-20s  %-10s\n" "Plotset" "PDF File" "View"
			"Profile"
		    ) 
		    fprintf(port "================================================================================\n") 
		    foreach(entry error_list 
			fprintf(port "%-15s  %-20s  %-20s  %-10s\n" 
			    car(entry) 
			    cadr(entry) 
			    caddr(entry)
			    nth(3 entry)
			)
		    ) 
		    fprintf(port "\n") 
		    fprintf(port "Please correct errors before proceeding.\n")
		    close(port) 
		    (axlUIViewFileCreate error_report " Batchplot - Configuration errors" nil) 
		    printf("Warning: Invalid entries ( **) exist. Cannot proceed.\n")
		) else
		printf("Warning: Directory %s does not exist\n" plot_dir)
	    ) else 
	    printf("Warning: Please enter configuration first\n")
	)
    )
)
procedure(TBX_BATCHPLOT_Save_Config(cfg_file) 
    let((port plot_info plotset_name pdf_name view_item
	    view_profile key_list
	) 
	(plot_info = (tbx_batchplot_data->plotInfo)) 
	if((length(plot_info) > 0) then 
	    foreach(key plot_info 
		(key_list = cons(key key_list))
	    ) 
	    (key_list = sort(key_list nil)) 
	    (port = outfile(cfg_file "w"))
	    fprintf(port "(\n") 
	    foreach(key key_list 
		(plotset_name = key) 
		(pdf_name = car(plot_info[key])) 
		fprintf(port "   ( %L   %L\n" plotset_name pdf_name)
		foreach(entry 
		    cdr(plot_info[key]) 
		    (view_item = car(entry)) 
		    (view_profile = cadr(entry)) 
		    rexCompile(" [*][*]$")
		    (view_item = rexReplace(view_item "" 0)) 
		    (view_profile = rexReplace(view_profile "" 0)) 
		    (view_item = sprintf(nil "%L" view_item)) 
		    (view_profile = sprintf(nil "%L" view_profile)) 
		    fprintf(port "      ( %-25s  %-15s )\n" view_item view_profile)
		) 
		fprintf(port "   )\n")
	    ) 
	    fprintf(port ")\n") 
	    close(port) else
	    when(isFile(cfg_file) 
		deleteFile(cfg_file)
	    )
	)
    )
)
procedure(TBX_BATCHPLOT_Update_Plot_Configuration(plot_info view_list profile_info) 
    let((view_data_update pdf_name view_item view_profile) 
	foreach(key plot_info 
	    (pdf_name = car(plot_info[key])) 
	    (view_data_update = list()) 
	    rexCompile(" [*][*]$")
	    foreach(entry 
		cdr(plot_info[key]) 
		(view_item = car(entry)) 
		(view_profile = cadr(entry)) 
		(view_item = rexReplace(view_item "" 0))
		(view_profile = rexReplace(view_profile "" 0)) 
		unless(member(view_item view_list) 
		    (view_item = strcat(view_item " **"))
		) 
		unless(profile_info[view_profile] 
		    (view_profile = strcat(view_profile " **"))
		) 
		(view_data_update = cons(list(view_item view_profile) view_data_update))
	    ) 
	    (view_data_update = reverse(view_data_update)) 
	    (view_data_update = cons(pdf_name view_data_update)) 
	    (plot_info[key] = view_data_update)
	) plot_info
    )
)
procedure(TBX_CAFDRC_Callback(form_handle) 
    let((FORM_FILE fid) 
	case((form_handle->curField) 
	    ("voltage_by_net" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "setup_netclass" nil) else 
		    (axlFormSetFieldEditable form_handle "setup_netclass" t)
		)
	    ) 
	    ("voltage_by_class" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "setup_netclass" t) else 
		    (axlFormSetFieldEditable form_handle "setup_netclass" nil)
		)
	    ) 
	    ("setup_netclass" 
		if((length((tbx_cafdrc_global->classNames)) > 0) then 
		    (FORM_FILE = TBX_FORM_Get_Name((tbx_cafdrc_global->licCheck) "cafdrc_netclass")) 
		    unless(boundp('tbxCafdrcNetclassHandle) 
			defvar(tbxCafdrcNetclassHandle nil)
		    ) 
		    (fid = (axlFormCreate 
			    'tbxCafdrcNetclassHandle FORM_FILE 
			    '(e outer) 
			    'TBX_CAFDRC_NCLS_Callback
			    t nil
			))
		    when(fid 
			TBX_FORM_Init_Header(fid nil 
			    (tbx_cafdrc_global->licCheck) 
			    (tbx_cafdrc_global->versionStr)
			) 
			((tbx_cafdrc_global->formHandle)->ncls = fid) 
			(axlFormDisplay fid) 
			(axlFormGridReset fid "grid")
			TBX_CAFDRC_NCLS_Init_Grid_Cols(fid) 
			TBX_CAFDRC_NCLS_Init_Grid_Rows(fid) 
			(axlFormGridUpdate fid "grid") 
			(axlFormGridEvents fid "grid" 
			    list('cellselect 
				'change
			    )
			) 
			(axlUIWBlock fid)
			TBX_FORM_Delete((tbx_cafdrc_global->licCheck) FORM_FILE)
		    ) else 
		    (axlUIConfirm "Design does not contain any spacing netclasses. Use Constraint Manager in order to group nets into classes.")
		)
	    ) 
	    ("done" 
		TBX_CAFDRC_Save_Rules(form_handle t nil) 
		(axlFormClose form_handle) 
		(axlFinishEnterFun) 
		(axlClearDynamics)
		(axlVisibleUpdate t) 
		(axlShell "generaledit")
	    )
	    ("run_drc" 
		TBX_CAFDRC_Clear_DRC_Markers() 
		TBX_CAFDRC_Run(form_handle 
		    (tbx_cafdrc_global->padLayerSpan)
		)
	    ) 
	    ("clear_drc" 
		TBX_CAFDRC_Clear_DRC_Markers()
	    ) 
	    ("settings" 
		case((form_handle->curValue) 
		    ("save_with_class_spec" 
			TBX_CAFDRC_Save_Rules(form_handle t t)
		    ) 
		    ("save_no_class_spec" 
			TBX_CAFDRC_Save_Rules(form_handle nil t)
		    ) 
		    ("load" 
			TBX_CAFDRC_Load_Rules(form_handle)
		    )
		)
	    ) 
	    ("myhelp" 
		TBX_HELP_Launch("cafdrc")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_CAFDRC_Classify_Padstacks(form_handle) 
    let((voltage_str psInfo ps_list nclass class_voltage
	    nclass_name
	) 
	(psInfo = makeTable("ps_info_table" nil)) 
	(axlVisibleDesign nil) 
	(axlVisibleLayer 
	    (axlMapClassName "PIN") t
	) 
	(axlVisibleLayer 
	    (axlMapClassName "VIA CLASS") t
	)
	(axlSetFindFilter ?enabled 
	    list("noall" "pins" "vias") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	(ps_list = setof(x 
		(axlGetSelSet) 
		(((x->definition)->drillDiameter) > 0.0)
	    )) 
	cond(((axlFormGetField form_handle "voltage_by_net") 
		rexCompile(" *[vV] *$") 
		foreach(ps ps_list 
		    when((((ps->net)->prop)->VOLTAGE) 
			(voltage_str = (((ps->net)->prop)->VOLTAGE)) 
			(voltage_str = rexReplace(voltage_str "" 0)) 
			(psInfo[voltage_str] = cons(ps 
				psInfo[voltage_str]
			    ))
		    )
		)
	    ) 
	    ((axlFormGetField form_handle "voltage_by_class") 
		foreach(ps ps_list 
		    when((ps->net) 
			(nclass = (axlNetClassGet 
				(ps->net) 
				'spacing t
			    )) 
			when(nclass 
			    (nclass_name = upperCase((nclass->name))) 
			    (class_voltage = (tbx_cafdrc_global->classVoltage)[nclass_name]) 
			    when((nclass && class_voltage && (class_voltage != "Undefined")) 
				(voltage_str = sprintf(nil "%L" class_voltage)) 
				(psInfo[voltage_str] = cons(ps 
					psInfo[voltage_str]
				    ))
			    )
			)
		    )
		)
	    ) 
	    (t t)
	)
	psInfo
    )
)
procedure(TBX_CAFDRC_Clear_DRC_Markers() 
    let((orgvis drc_list) 
	(orgvis = (axlVisibleGet)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "drcs") ?onButtons 
	    list("all")
	) 
	(axlVisibleLayer "DRC ERROR CLASS" t) 
	(axlClearSelSet)
	(axlAddSelectAll) 
	(drc_list = setof(x 
		(axlGetSelSet) 
		(((x->name) == "Externally Determined Violation") && ((x->source) == "CAF-DRC"))
	    )) 
	when(drc_list 
	    (axlDeleteObject drc_list)
	) 
	(axlVisibleDesign nil) 
	foreach(lyr 
	    (tbx_cafdrc_global->sysLayers) 
	    (axlVisibleLayer lyr t)
	)
	(axlDeleteByLayer 
	    (tbx_cafdrc_global->sysLayers) 
	    'fixed
	) 
	(axlVisibleSet orgvis) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_CAFDRC_Create_DRC_Marker(obj1 obj2 req_fiber req_base act_value) 
    let((loc1 loc2 result) 
	(req_base = req_base) 
	(result = (axlAirGap obj1 obj2 nil)) 
	if(result then 
	    (loc1 = car(result)) 
	    (loc2 = cadr(result)) else
	    (loc1 = (obj1->xy)) 
	    (loc2 = (obj2->xy))
	) 
	(axlDBCreateExternalDRC 
	    list("CAF-DRC" 
		sprintf(nil "%f" req_fiber)
	    ) loc1 "DRC ERROR CLASS/ALL" 
	    list(obj2 obj1)
	    loc2 
	    sprintf(nil "%s" act_value)
	)
	t
    )
)
procedure((TBX_CAFDRC_Debug \@optional fiber_spacing base_spacing fiber_angle) 
    let((poly_data) 
	foreach(lyr 
	    (tbx_cafdrc_global->sysLayers) 
	    (axlVisibleLayer lyr t)
	) 
	(axlDeleteByLayer 
	    (tbx_cafdrc_global->sysLayers) 
	    'fixed
	) 
	if(fiber_spacing then 
	    (fiber_spacing = atof(fiber_spacing)) else 
	    (fiber_spacing = (axlMKSConvert "2.0 MM" 
		    car((axlDBGetDesignUnits))
		))
	) 
	if(base_spacing then 
	    (base_spacing = atof(base_spacing)) else 
	    (base_spacing = (axlMKSConvert "0.6 MM" 
		    car((axlDBGetDesignUnits))
		))
	)
	if(fiber_angle then 
	    (fiber_angle = atof(fiber_angle)) else 
	    (fiber_angle = 0.0)
	) 
	(axlSetFindFilter ?enabled 
	    list("noall" "pins" "vias") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlSingleSelectBox) 
	printf("Info: Using values Fiber Spacing: %L  Base Spacing: %L  Fiber Angle:%L\n" fiber_spacing base_spacing fiber_angle)
	when((axlGetSelSet) 
	    foreach(pd 
		(axlGetSelSet) 
		(poly_data = TBX_CAFDRC_Get_Hole_Polygon(pd fiber_spacing base_spacing fiber_angle)) 
		foreach(pl poly_data 
		    (axlDBCreateShape pl t 
			car((tbx_cafdrc_global->sysLayers))
		    )
		)
	    )
	)
    )
)
procedure(TBX_CAFDRC_Get_Class_Names() 
    let((class_list) 
	foreach(ncls 
	    ((axlDBGetDesign)->netclass) 
	    when((ncls->spacing) 
		(class_list = cons(upperCase((ncls->name)) class_list))
	    )
	) 
	(class_list = sort(class_list nil)) class_list
    )
)
procedure(TBX_CAFDRC_Get_Hole_Cross(hole_center diameter fiber_spacing base_spacing fiber_angle) 
    let((pt_start pt_end rp_h rp_v poly_h
	    poly_v poly_base hole_poly rpath
	) 
	(pt_start = ((car(hole_center) - fiber_spacing):cadr(hole_center))) 
	(pt_end = ((car(hole_center) + fiber_spacing):cadr(hole_center))) 
	(rp_h = (axlPathStart 
		list(pt_start pt_end) diameter
	    )) 
	(pt_start = (car(hole_center):(cadr(hole_center) - fiber_spacing)))
	(pt_end = (car(hole_center):(cadr(hole_center) + fiber_spacing))) 
	(rp_v = (axlPathStart 
		list(pt_start pt_end) diameter
	    )) 
	(poly_h = car((axlPolyFromDB rp_h ?endCapType 
		    'ROUND ?line2poly
		    t
		)
	    )) 
	(poly_v = car((axlPolyFromDB rp_v ?endCapType 
		    'ROUND ?line2poly
		    t
		)
	    )) 
	if((base_spacing && (base_spacing > 0.0)) then 
	    (rpath = (axlPathStartCircle 
		    list(hole_center 
			((diameter / 2.0) + base_spacing)
		    ) 0.0
		)) 
	    (poly_base = car((axlPolyFromDB rpath))) 
	    (hole_poly = car((axlPolyOperation 
			list(poly_h poly_v) poly_base 
			'OR
		    )
		))
	    else 
	    (hole_poly = car((axlPolyOperation poly_h poly_v 
			'OR
		    )
		))
	)
	when((fiber_angle && (fiber_angle != 0.0)) 
	    (rpath = TBX_DBCORE_Rpath_From_Poly(hole_poly)) 
	    (rpath = TBX_DBCORE_Rotate_Rpath(rpath fiber_angle hole_center nil)) 
	    (hole_poly = car((axlPolyFromDB rpath)))
	) hole_poly
    )
)
procedure(TBX_CAFDRC_Get_Hole_Polygon(pad_inst fiber_spacing base_spacing fiber_angle) 
    let((pad_def hole_data dx dy pad_xy
	    x_pad y_pad x y rpath
	    row_cnt col_cnt spacing_x spacing_y stagger
	    stagger_offset diam xll yll tmp_list
	    c12 c34 slot_height slot_width cross_poly
	    center_list hole_poly hole_center slot_center delta_x
	    delta_y poly_data
	) 
	(pad_def = (pad_inst->definition)) 
	when(((pad_def->drillDiameter) > 0.0) 
	    cond(((((pad_def->holeType) == "circle_drill") && !(pad_def->multiDrillData)) 
		    (x_pad = car((pad_inst->xy))) 
		    (y_pad = cadr((pad_inst->xy))) 
		    (dx = car((pad_def->drillOffset))) 
		    (dy = cadr((pad_def->drillOffset)))
		    (hole_center = ((x_pad + dx):(y_pad + dy))) 
		    when((pad_inst->isMirrored) 
			(hole_center = (axlGeoRotatePt 0.0 hole_center 
				(x_pad:y_pad) t
			    ))
		    ) 
		    when(((pad_inst->rotation) != 0.0) 
			(hole_center = (axlGeoRotatePt 
				(pad_inst->rotation) hole_center 
				(x_pad:y_pad)
			    ))
		    ) 
		    if(fiber_spacing then 
			(hole_poly = TBX_CAFDRC_Get_Hole_Cross(hole_center 
				(pad_def->drillDiameter) fiber_spacing base_spacing fiber_angle
			    )) else 
			(rpath = (axlPathStartCircle 
				list(hole_center 
				    ((pad_def->drillDiameter) / 2.0)
				) 0
			    ))
			(hole_poly = car((axlPolyFromDB rpath)))
		    ) 
		    when(hole_poly 
			(poly_data = list(hole_poly))
		    )
		) 
		((((pad_def->holeType) == "circle_drill") && (pad_def->multiDrillData)) 
		    (x_pad = car((pad_inst->xy))) 
		    (y_pad = cadr((pad_inst->xy))) 
		    (dx = car((pad_def->drillOffset))) 
		    (dy = cadr((pad_def->drillOffset)))
		    (diam = ((pad_def->drillDiameter) / 1.0)) 
		    (row_cnt = car((pad_def->multiDrillData))) 
		    (col_cnt = cadr((pad_def->multiDrillData))) 
		    (spacing_x = caddr((pad_def->multiDrillData))) 
		    (spacing_y = cadddr((pad_def->multiDrillData)))
		    (stagger = nth(4 
			    (pad_def->multiDrillData)
			)) 
		    (xll = ((((col_cnt - 1) / 2.0) * (spacing_x + diam) * -1) + x_pad + dx)) 
		    (yll = ((((row_cnt - 1) / 2.0) * (spacing_y + diam) * -1) + y_pad + dy)) 
		    if(stagger then 
			(stagger_offset = ((spacing_x / 2.0) + (diam / 2.0))) else 
			(stagger_offset = 0.0)
		    ) 
		    for(r 1 row_cnt 
			for(c 1 col_cnt 
			    if(zerop(mod(r 2)) then 
				(x = (xll + ((c - 1) * (spacing_x + diam)) + stagger_offset)) else 
				(x = (xll + ((c - 1) * (spacing_x + diam))))
			    ) 
			    (y = (yll + ((r - 1) * (spacing_y + diam))))
			    (tmp_list = cons((x:y) tmp_list))
			)
		    )
		    foreach(xy tmp_list 
			(hole_center = xy) 
			when((pad_inst->isMirrored) 
			    (hole_center = (axlGeoRotatePt 0.0 hole_center 
				    (x_pad:y_pad) t
				))
			) 
			when(((pad_inst->rotation) != 0.0) 
			    (hole_center = (axlGeoRotatePt 
				    (pad_inst->rotation) hole_center 
				    (x_pad:y_pad)
				))
			)
			(center_list = cons(hole_center center_list))
		    ) 
		    (center_list = reverse(center_list)) 
		    foreach(xy center_list 
			if(fiber_spacing then 
			    (hole_data = cons(TBX_CAFDRC_Get_Hole_Cross(xy 
					(pad_def->drillDiameter) fiber_spacing base_spacing fiber_angle
				    ) hole_data
				)) else 
			    (hole_data = cons(car((axlPolyFromDB 
					    (axlPathStartCircle 
						list(xy 
						    (diam / 2.0)
						) 0
					    )
					)
				    ) hole_data
				))
			)
		    ) 
		    when((hole_data && (length(hole_data) > 1)) 
			(poly_data = (axlPolyOperation 
				car(hole_data) 
				cdr(hole_data) 
				'OR
			    ))
		    )
		) 
		(exists(s 
			list("oval_slot" "oval slot" "rectangle_slot" "rectangle slot") 
			(s == (pad_def->holeType))
		    ) 
		    (pad_xy = (pad_inst->xy)) 
		    (dx = car((pad_def->drillOffset))) 
		    (dy = cadr((pad_def->drillOffset))) 
		    (slot_width = (pad_def->drillFigureWidth))
		    (slot_height = (pad_def->drillFigureHeight)) 
		    (slot_center = ((car(pad_xy) + dx):(cadr(pad_xy) + dy))) 
		    if(fiber_spacing then 
			(cross_poly = TBX_CAFDRC_Get_Slot_Cross(pad_inst fiber_spacing base_spacing fiber_angle)) 
			(poly_data = list(cross_poly)) else
			cond(((slot_width == slot_height) 
				(rpath = (axlPathStartCircle 
					list(slot_center 
					    ((pad_def->drillDiameter) / 2.0)
					) 0.0
				    ))
			    ) 
			    ((slot_width > slot_height) 
				(delta_x = ((slot_width - slot_height) / 2.0)) 
				(c12 = ((car(slot_center) - delta_x):cadr(slot_center))) 
				(c34 = ((car(slot_center) + delta_x):cadr(slot_center))) 
				(rpath = (axlPathStart 
					list(c12 c34) slot_height
				    ))
			    ) 
			    ((slot_width < slot_height) 
				(delta_y = ((slot_height - slot_width) / 2.0)) 
				(c12 = (car(slot_center):(cadr(slot_center) - delta_y))) 
				(c34 = (car(slot_center):(cadr(slot_center) + delta_y))) 
				(rpath = (axlPathStart 
					list(c12 c34) slot_width
				    ))
			    )
			) 
			when((pad_inst->isMirrored) 
			    (rpath = TBX_DBCORE_Rotate_Rpath(rpath 0.0 pad_xy t))
			) 
			when(((pad_inst->rotation) != 0.0) 
			    (rpath = TBX_DBCORE_Rotate_Rpath(rpath 
				    (pad_inst->rotation) pad_xy nil
				))
			) 
			if(exists(s 
				list("oval_slot" "oval slot") 
				(s == (pad_def->holeType))
			    ) then 
			    (poly_data = (axlPolyFromDB rpath ?endCapType 
				    'ROUND ?line2poly
				    t
				)) else 
			    (poly_data = (axlPolyFromDB rpath ?endCapType 
				    'SQUARE ?line2poly
				    t
				))
			)
		    )
		) 
		(t 
		    printf("Do nothing with unknown hole type: %L\n" 
			(pad_def->holeType)
		    )
		)
	    )
	) poly_data
    )
)
procedure(TBX_CAFDRC_Get_Padstack_Layer_Span() 
    let((full_name id layer_number layer_span start_layer
	    end_layer start_id end_id span_list
	) 
	(layer_number = makeTable("layer_number_table" nil)) 
	(layer_span = makeTable("layer_span_table" nil)) 
	(id = 0) 
	foreach(lyr 
	    (axlSubclassRoute) 
	    ++id 
	    (full_name = strcat((axlMapClassName "ETCH") "/" lyr)) 
	    (layer_number[full_name] = id)
	)
	foreach(pdef 
	    ((axlDBGetDesign)->padstacks) 
	    (start_layer = car((pdef->startEnd))) 
	    (end_layer = cadr((pdef->startEnd))) 
	    (span_list = list())
	    (start_id = layer_number[start_layer]) 
	    (end_id = layer_number[end_layer]) 
	    if((start_id == end_id) then 
		(span_list = list(start_id)) else 
		for(i start_id end_id 
		    (span_list = cons(i span_list))
		)
		(span_list = reverse(span_list))
	    ) 
	    (layer_span[(pdef->name)] = span_list)
	) layer_span
    )
)
procedure(TBX_CAFDRC_Get_Slot_Cross(pad_inst fiber_spacing base_spacing fiber_angle) 
    let((pad_def pad_xy pad_mirror pad_rotation slot_center
	    slot_offset slot_width slot_height slot_type delta_x
	    delta_y center_a center_b slot_poly slot_poly_exp_base
	    line_width rpath poly_data slot_cross pt1
	    pt2 pt3 pt4 oval_radius long_axis_angle
	    delta_angle spin_angle PI tangent_pos_a tangent_pos_b
	    tangent_neg_a tangent_neg_b poly_pos poly_neg poly_merge
	    rpath_merge transform_x transform_y center_a_angle center_b_angle
	    sign outer_a outer_a_angle outer_a_x outer_a_y
	    outer_b outer_b_angle outer_b_x outer_b_y
	) 
	(PI = (defMathConstants('mymathconst)->PI)) 
	(pad_def = (pad_inst->definition)) 
	(pad_xy = (pad_inst->xy)) 
	(pad_mirror = (pad_inst->isMirrored))
	(pad_rotation = (pad_inst->rotation)) 
	(slot_offset = (pad_def->drillOffset)) 
	(slot_width = (pad_def->drillFigureWidth)) 
	(slot_height = (pad_def->drillFigureHeight)) 
	(slot_type = (pad_def->holeType))
	(slot_center = ((car(pad_xy) + car(slot_offset)):(cadr(pad_xy) + cadr(slot_offset)))) 
	if((slot_type == "oval_slot") then 
	    if((slot_width != slot_height) then 
		cond(((slot_width > slot_height) 
			(line_width = slot_height) 
			(oval_radius = (slot_height / 2.0)) 
			(long_axis_angle = 0.0) 
			(delta_x = ((slot_width - slot_height) / 2.0))
			(center_a = ((car(slot_center) - delta_x):cadr(slot_center))) 
			(center_b = ((car(slot_center) + delta_x):cadr(slot_center)))
		    ) 
		    ((slot_height > slot_width) 
			(line_width = slot_width) 
			(oval_radius = (slot_width / 2.0)) 
			(long_axis_angle = 90.0) 
			(delta_y = ((slot_height - slot_width) / 2.0))
			(center_a = (car(slot_center):(cadr(slot_center) - delta_y))) 
			(center_b = (car(slot_center):(cadr(slot_center) + delta_y)))
		    )
		) 
		when(pad_mirror 
		    (center_a = (axlGeoRotatePt 0.0 center_a pad_xy t)) 
		    (center_b = (axlGeoRotatePt 0.0 center_b pad_xy t))
		) 
		when((pad_rotation != 0.0) 
		    (center_a = (axlGeoRotatePt pad_rotation center_a pad_xy nil)) 
		    (center_b = (axlGeoRotatePt pad_rotation center_b pad_xy nil))
		)
		(rpath = (axlPathStart 
			list(center_a center_b) line_width
		    )) 
		(slot_poly = car((axlPolyFromDB rpath ?endCapType 
			    'ROUND ?line2poly
			    t
			)
		    )) else 
		(rpath = (axlPathStartCircle 
			list(slot_center 
			    (slot_width / 2.0)
			) 0.0
		    )) 
		(oval_radius = (slot_width / 2.0))
		(long_axis_angle = 0.0) 
		(slot_poly = car((axlPolyFromDB rpath))) 
		(center_a = slot_center) 
		(center_b = slot_center)
	    ) 
	    when((base_spacing && (base_spacing > 0.0)) 
		(slot_poly_exp_base = car((axlPolyExpand slot_poly base_spacing 
			    'ALL_ARC
			)
		    ))
	    ) 
	    (center_a_angle = TBX_GEOM_Get_Vector_Angle(slot_center center_a))
	    (center_b_angle = TBX_GEOM_Get_Vector_Angle(slot_center center_b)) 
	    (outer_a_x = (car(center_a) + (cos(((center_a_angle / 360.0) * 2 * PI)) * oval_radius))) 
	    (outer_a_y = (cadr(center_a) + (sin(((center_a_angle / 360.0) * 2 * PI)) * oval_radius))) 
	    (outer_b_x = (car(center_b) + (cos(((center_b_angle / 360.0) * 2 * PI)) * oval_radius))) 
	    (outer_b_y = (cadr(center_b) + (sin(((center_b_angle / 360.0) * 2 * PI)) * oval_radius)))
	    (long_axis_angle = (long_axis_angle + pad_rotation)) 
	    when((long_axis_angle >= 360.0) 
		(long_axis_angle = (long_axis_angle - 360.0))
	    ) 
	    when((long_axis_angle > 180.0) 
		(long_axis_angle = (long_axis_angle - 180.0))
	    ) 
	    (poly_data = list()) 
	    foreach(fb_angle 
		list(fiber_angle 
		    (fiber_angle + 90.0)
		) 
		(delta_angle = (long_axis_angle - fb_angle)) 
		cond(((delta_angle > 0.0) 
			(spin_angle = (90.0 - delta_angle))
		    ) 
		    ((delta_angle < 0.0) 
			(spin_angle = (-1.0 * (90.0 - abs(delta_angle))))
		    ) 
		    (t 
			(spin_angle = (90.0 - delta_angle))
		    )
		) 
		(outer_a = (axlGeoRotatePt spin_angle 
			(outer_a_x:outer_a_y) center_a nil
		    ))
		(outer_b = (axlGeoRotatePt spin_angle 
			(outer_b_x:outer_b_y) center_b nil
		    )) 
		(transform_x = (cos(((fb_angle / 360.0) * 2 * PI)) * fiber_spacing)) 
		(transform_y = (sin(((fb_angle / 360.0) * 2 * PI)) * fiber_spacing)) 
		(poly_pos = (axlPolyOffset slot_poly 
			(transform_x:transform_y) t
		    )) 
		(poly_neg = (axlPolyOffset slot_poly 
			((- transform_x):(- transform_y)) t
		    ))
		(tangent_pos_a = ((car(outer_a) + transform_x):(cadr(outer_a) + transform_y))) 
		(tangent_pos_b = ((car(outer_b) + transform_x):(cadr(outer_b) + transform_y))) 
		(tangent_neg_a = ((car(outer_a) - transform_x):(cadr(outer_a) - transform_y))) 
		(tangent_neg_b = ((car(outer_b) - transform_x):(cadr(outer_b) - transform_y))) 
		(rpath_merge = (axlPathStart 
			list((car(tangent_pos_a):cadr(tangent_pos_a)) 
			    (car(tangent_pos_b):cadr(tangent_pos_b)) 
			    (car(tangent_neg_b):cadr(tangent_neg_b)) 
			    (car(tangent_neg_a):cadr(tangent_neg_a)) 
			    (car(tangent_pos_a):cadr(tangent_pos_a))
			) 0.0
		    ))
		(poly_merge = car((axlPolyFromDB rpath_merge))) 
		(poly_data = nconc(poly_data 
			list(poly_pos poly_neg poly_merge)
		    ))
	    )
	    else 
	    (pt1 = ((car(slot_center) - (slot_width / 2.0)):(cadr(slot_center) - (slot_height / 2.0)))) 
	    (pt2 = ((car(slot_center) - (slot_width / 2.0)):(cadr(slot_center) + (slot_height / 2.0)))) 
	    (pt3 = ((car(slot_center) + (slot_width / 2.0)):(cadr(slot_center) + (slot_height / 2.0)))) 
	    (pt4 = ((car(slot_center) + (slot_width / 2.0)):(cadr(slot_center) - (slot_height / 2.0))))
	    when(pad_mirror 
		(pt1 = (axlGeoRotatePt 0.0 pt1 pad_xy t)) 
		(pt2 = (axlGeoRotatePt 0.0 pt2 pad_xy t)) 
		(pt3 = (axlGeoRotatePt 0.0 pt3 pad_xy t)) 
		(pt4 = (axlGeoRotatePt 0.0 pt4 pad_xy t))
	    ) 
	    when((pad_rotation != 0.0) 
		(pt1 = (axlGeoRotatePt pad_rotation pt1 pad_xy nil)) 
		(pt2 = (axlGeoRotatePt pad_rotation pt2 pad_xy nil)) 
		(pt3 = (axlGeoRotatePt pad_rotation pt3 pad_xy nil)) 
		(pt4 = (axlGeoRotatePt pad_rotation pt4 pad_xy nil))
	    ) 
	    (rpath = (axlPathStart 
		    list(pt1 pt2 pt3 pt4 pt1) 0.0
		)) 
	    (slot_poly = car((axlPolyFromDB rpath))) 
	    when((base_spacing && (base_spacing > 0.0)) 
		(slot_poly_exp_base = car((axlPolyExpand slot_poly base_spacing 
			    'ALL_ARC
			)
		    ))
	    )
	    cond(((slot_width > slot_height) 
		    (long_axis_angle = 0.0) 
		    (line_width = slot_height) 
		    (outer_a = ((car(slot_center) - (slot_width / 2.0)):cadr(slot_center))) 
		    (outer_b = ((car(slot_center) + (slot_width / 2.0)):cadr(slot_center)))
		) 
		((slot_height > slot_width) 
		    (long_axis_angle = 90.0) 
		    (line_width = slot_width) 
		    (outer_a = (car(slot_center):(cadr(slot_center) - (slot_height / 2.0)))) 
		    (outer_b = (car(slot_center):(cadr(slot_center) + (slot_height / 2.0))))
		)
	    ) 
	    when(pad_mirror 
		(outer_a = (axlGeoRotatePt 0.0 outer_a pad_xy t)) 
		(outer_b = (axlGeoRotatePt 0.0 outer_b pad_xy t))
	    ) 
	    when((pad_rotation != 0.0) 
		(outer_a = (axlGeoRotatePt pad_rotation outer_a pad_xy nil)) 
		(outer_b = (axlGeoRotatePt pad_rotation outer_b pad_xy nil))
	    ) 
	    (outer_a_angle = TBX_GEOM_Get_Vector_Angle(slot_center outer_a)) 
	    (outer_b_angle = TBX_GEOM_Get_Vector_Angle(slot_center outer_b))
	    (long_axis_angle = (long_axis_angle + pad_rotation)) 
	    when((long_axis_angle >= 360.0) 
		(long_axis_angle = (long_axis_angle - 360.0))
	    ) 
	    when((long_axis_angle >= 180.0) 
		(long_axis_angle = (long_axis_angle - 180.0))
	    ) 
	    (poly_data = list()) 
	    foreach(fb_angle 
		list(fiber_angle 
		    (fiber_angle + 90.0)
		) 
		(delta_angle = (long_axis_angle - fb_angle)) 
		cond((((delta_angle >= 0.0) && (delta_angle <= 90)) 
			(sign = 1.0)
		    ) 
		    (((delta_angle > 90.0) && (delta_angle <= 180.0)) 
			(sign = -1.0)
		    ) 
		    (((delta_angle <= 0.0) && (delta_angle >= -90.0)) 
			(sign = -1.0)
		    ) 
		    (((delta_angle < -90.0) && (delta_angle >= -180.0)) 
			(sign = 1.0)
		    )
		) 
		(outer_a_x = (car(outer_a) + (sign * ((cos((((outer_a_angle + 90.0) / 360.0) * 2 * PI)) * line_width) / 2.0))))
		(outer_a_y = (cadr(outer_a) + (sign * ((sin((((outer_a_angle + 90.0) / 360.0) * 2 * PI)) * line_width) / 2.0)))) 
		(outer_b_x = (car(outer_b) + (sign * ((cos((((outer_b_angle + 90.0) / 360.0) * 2 * PI)) * line_width) / 2.0)))) 
		(outer_b_y = (cadr(outer_b) + (sign * ((sin((((outer_b_angle + 90.0) / 360.0) * 2 * PI)) * line_width) / 2.0)))) 
		(transform_x = (cos(((fb_angle / 360.0) * 2 * PI)) * fiber_spacing)) 
		(transform_y = (sin(((fb_angle / 360.0) * 2 * PI)) * fiber_spacing))
		(poly_pos = (axlPolyOffset slot_poly 
			(transform_x:transform_y) t
		    )) 
		(poly_neg = (axlPolyOffset slot_poly 
			((- transform_x):(- transform_y)) t
		    )) 
		(tangent_pos_a = ((outer_a_x + transform_x):(outer_a_y + transform_y))) 
		(tangent_pos_b = ((outer_b_x + transform_x):(outer_b_y + transform_y))) 
		(tangent_neg_a = ((outer_a_x - transform_x):(outer_a_y - transform_y)))
		(tangent_neg_b = ((outer_b_x - transform_x):(outer_b_y - transform_y))) 
		(rpath_merge = (axlPathStart 
			list((car(tangent_pos_a):cadr(tangent_pos_a)) 
			    (car(tangent_pos_b):cadr(tangent_pos_b)) 
			    (car(tangent_neg_b):cadr(tangent_neg_b)) 
			    (car(tangent_neg_a):cadr(tangent_neg_a)) 
			    (car(tangent_pos_a):cadr(tangent_pos_a))
			) 0.0
		    )) 
		(poly_merge = car((axlPolyFromDB rpath_merge))) 
		(poly_data = nconc(poly_data 
			list(poly_pos poly_neg poly_merge)
		    ))
	    )
	) 
	when(slot_poly_exp_base 
	    (poly_data = cons(slot_poly_exp_base poly_data))
	) 
	when(poly_data 
	    (slot_cross = car((axlPolyOperation 
			car(poly_data) 
			cdr(poly_data) 
			'OR
		    )
		))
	) slot_cross
    )
)
procedure(TBX_CAFDRC_Init() 
    let((orgvis cafdrc_layers) 
	(orgvis = (axlVisibleGet)) 
	(cafdrc_layers = list(strcat((axlMapClassName "DRAWING FORMAT") "/CAFDRC_DV1") 
		strcat((axlMapClassName "DRAWING FORMAT") "/CAFDRC_DV2") 
		strcat((axlMapClassName "DRAWING FORMAT") "/CAFDRC_DV3") 
		strcat((axlMapClassName "DRAWING FORMAT") "/CAFDRC_DV4")
	    )) 
	foreach(lyr cafdrc_layers 
	    unless((axlIsLayer lyr) 
		(axlLayerCreateNonConductor lyr)
	    )
	) 
	unless(boundp('tbx_cafdrc_global) 
	    iliDefstruct('defstruct(tbx_cafdrc_global_struct licCheck orgVis sysLayers padLayerSpan
			formHandle versionStr classNames classVoltage
		    )
	    ) 
	    defvar(tbx_cafdrc_global nil)
	)
	if(!tbx_cafdrc_global then 
	    (tbx_cafdrc_global = (make_tbx_cafdrc_global_struct ?licCheck nil ?formHandle 
		    ncons(nil)
		    ?classNames nil ?classVoltage nil ?orgVis
		    orgvis ?sysLayers cafdrc_layers ?padLayerSpan nil
		    ?versionStr nil
		)) else 
	    (tbx_cafdrc_global->licCheck = nil)
	    (tbx_cafdrc_global->formHandle = ncons(nil)) 
	    (tbx_cafdrc_global->classNames = nil) 
	    (tbx_cafdrc_global->classVoltage = nil) 
	    (tbx_cafdrc_global->orgVis = orgvis) 
	    (tbx_cafdrc_global->sysLayers = cafdrc_layers)
	    (tbx_cafdrc_global->padLayerSpan = nil) 
	    (tbx_cafdrc_global->versionStr = nil)
	)
    )
)
procedure(TBX_CAFDRC_Init_Form(form_handle config_data) 
    let((config_units design_units rules active_set fiber_angle
	    group_nets_by fields_dv fields_fiber fields_base cur_fields
	    value
	) 
	(design_units = car((axlDBGetDesignUnits))) 
	(config_units = cadar(setof(entry config_data 
		    eq(car(entry) 
			'units
		    )
		)
	    )) 
	(rules = cdar(setof(entry config_data 
		    eq(car(entry) 
			'rules
		    )
		)
	    )) 
	(active_set = cadar(setof(entry config_data 
		    eq(car(entry) 
			'activeSet
		    )
		)
	    ))
	(fiber_angle = cadar(setof(entry config_data 
		    eq(car(entry) 
			'fiberAngle
		    )
		)
	    )) 
	(group_nets_by = cadar(setof(entry config_data 
		    eq(car(entry) 
			'groupNetsBy
		    )
		)
	    )) 
	foreach(rs rules 
	    case(cadr(rs) 
		("fine" 
		    (fields_dv = list("f_dv1" "f_dv2" "f_dv3" "f_dv4")) 
		    (fields_fiber = list("spc_fiber_f_dv1" "spc_fiber_f_dv2" "spc_fiber_f_dv3" "spc_fiber_f_dv4")) 
		    (fields_base = list("spc_base_f_dv1" "spc_base_f_dv2" "spc_base_f_dv3" "spc_base_f_dv4"))
		) 
		("middle" 
		    (fields_dv = list("m_dv1" "m_dv2" "m_dv3" "m_dv4")) 
		    (fields_fiber = list("spc_fiber_m_dv1" "spc_fiber_m_dv2" "spc_fiber_m_dv3" "spc_fiber_m_dv4")) 
		    (fields_base = list("spc_base_m_dv1" "spc_base_m_dv2" "spc_base_m_dv3" "spc_base_m_dv4"))
		) 
		("rough" 
		    (fields_dv = list("r_dv1" "r_dv2" "r_dv3" "r_dv4")) 
		    (fields_fiber = list("spc_fiber_r_dv1" "spc_fiber_r_dv2" "spc_fiber_r_dv3" "spc_fiber_r_dv4")) 
		    (fields_base = list("spc_base_r_dv1" "spc_base_r_dv2" "spc_base_r_dv3" "spc_base_r_dv4"))
		)
	    ) 
	    foreach(ds 
		cddr(rs) 
		caseq(car(ds) 
		    (diffVoltage 
			(cur_fields = fields_dv)
		    ) 
		    (fiberClearance 
			(cur_fields = fields_fiber)
		    ) 
		    (baseClearance 
			(cur_fields = fields_base)
		    )
		) 
		for(i 0 3 
		    (value = nth(i 
			    cdr(ds)
			)) 
		    if(value then 
			(value = (axlMKSConvert value config_units design_units)) else 
			(value = 0.0)
		    )
		    (axlFormSetField form_handle 
			nth(i cur_fields) value
		    )
		)
	    )
	) 
	unless(active_set 
	    (active_set = "middle")
	) 
	unless(fiber_angle 
	    (fiber_angle = 0.0)
	)
	unless(group_nets_by 
	    (group_nets_by = "voltage")
	) 
	(axlFormSetField form_handle "active_set" active_set) 
	(axlFormSetField form_handle "fiber_angle" fiber_angle) 
	if((group_nets_by == "voltage") then 
	    (axlFormSetField form_handle "voltage_by_net" t) 
	    (axlFormSetFieldEditable form_handle "setup_netclass" nil) else
	    (axlFormSetField form_handle "voltage_by_class" t) 
	    (axlFormSetFieldEditable form_handle "setup_netclass" t)
	) t
    )
)
procedure(TBX_CAFDRC_Load_Rules(form_handle) 
    let((config_file data) 
	(config_file = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
	when((config_file && isFile(config_file)) 
	    printf("Loading configuration file from %L ...\n" config_file) 
	    (data = TBX_UTIL_File_Lineread(config_file)) 
	    (tbx_cafdrc_global->classVoltage = TBX_CAFDRC_Update_Class_Spec(data 
		    (tbx_cafdrc_global->classVoltage)
		)) 
	    TBX_CAFDRC_Init_Form(form_handle data)
	) t
    )
)
procedure((TBX_CAFDRC_Main \@optional arg fiber_spacing base_spacing
	fiber_angle
    ) 
    let((FC_FEATURE FC_VERSION SUB_VERSION FORM_FILE fid
	    lic_check_result VERSION_STR config_data info_file port
	    ok_start_app
	) 
	(FC_FEATURE = "CAFDRC") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "03") 
	(VERSION_STR = sprintf(nil "CAF-DRC %s (C)2017" FC_VERSION))
	(ok_start_app = t) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./cafdrc_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "CAD-DRC information:\n") 
		fprintf(port "=============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  delete  : Removes configuration from database\n") 
		fprintf(port "  version : Prints the current version of the module\n") 
		fprintf(port "  debug   : Generates CAF-DRC polygons for debugging purposes\n") 
		fprintf(port "            Provide optional arguments for fiber spacing, base spacing and fiber angle\n")
		fprintf(port "            e.g. tbx cafdrc debug  2.0 0.5 10.0\n") 
		fprintf(port "            Single window drag operation\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "CAF-DRC: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" VERSION_STR SUB_VERSION) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "reset")) 
		(axlDeleteAttachment "tbx_cafdrc") 
		printf("Removing configuration from database\n") 
		(ok_start_app = nil)
	    ) 
	    (arg 
		printf("Unknown argument %L\n" arg) 
		(ok_start_app = nil)
	    ) 
	    (ok_start_app 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    TBX_CAFDRC_Init() 
		    if((arg && (lowerCase(arg) == "debug")) then 
			TBX_CAFDRC_Debug(fiber_spacing base_spacing fiber_angle) else 
			(tbx_cafdrc_global->padLayerSpan = TBX_CAFDRC_Get_Padstack_Layer_Span())
			(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "cafdrc_main")) 
			unless(boundp('tbxCafdrcMainHandle) 
			    defvar(tbxCafdrcMainHandle nil)
			) 
			(fid = (axlFormCreate 
				'tbxCafdrcMainHandle FORM_FILE 
				'(e outer) 
				'TBX_CAFDRC_Callback
				t
			    )) 
			when(fid 
			    ((tbx_cafdrc_global->formHandle)->main = fid) 
			    (tbx_cafdrc_global->versionStr = VERSION_STR) 
			    (tbx_cafdrc_global->licCheck = lic_check_result) 
			    (tbx_cafdrc_global->classNames = TBX_CAFDRC_Get_Class_Names())
			    (tbx_cafdrc_global->classVoltage = makeTable("class_voltage_info" nil)) 
			    foreach(cls 
				(tbx_cafdrc_global->classNames) 
				((tbx_cafdrc_global->classVoltage)[cls] = "Undefined")
			    ) 
			    (config_data = TBX_CAFDRC_Read_Config()) 
			    (tbx_cafdrc_global->classVoltage = TBX_CAFDRC_Update_Class_Spec(config_data 
				    (tbx_cafdrc_global->classVoltage)
				)) 
			    TBX_FORM_Init_Header(fid nil lic_check_result VERSION_STR)
			    TBX_CAFDRC_Init_Form(fid config_data) 
			    (axlFormDisplay fid) 
			    (axlVisibleUpdate t) 
			    TBX_FORM_Delete(lic_check_result FORM_FILE)
			)
		    )
		)
	    )
	)
    )
)
procedure(TBX_CAFDRC_NCLS_Callback(form_handle) 
    let((a) 
	(a = a) 
	case((form_handle->curField) 
	    ("grid" 
		caseq((form_handle->event) 
		    (cellselect 
			(axlFormGridUpdate form_handle "grid")
		    )
		)
	    ) 
	    ("done" 
		(tbx_cafdrc_global->classVoltage = TBX_CAFDRC_NCLS_Extract_Grid_Data(form_handle)) 
		(axlFormClose form_handle) 
		(axlUIWShow 
		    ((tbx_cafdrc_global->formHandle)->main) 
		    'show
		)
	    ) 
	    ("cancel" t 
		(axlFormClose form_handle) 
		(axlUIWShow 
		    ((tbx_cafdrc_global->formHandle)->main) 
		    'show
		)
	    ) 
	    ("my_help" 
		TBX_HELP_Launch("cafdrc")
	    )
	    (t t)
	)
    )
)
procedure(TBX_CAFDRC_NCLS_Extract_Grid_Data(form_handle) 
    let((cell class_name class_voltage info_data) 
	(info_data = makeTable("info_data_table" nil)) 
	for(i 1 
	    length((tbx_cafdrc_global->classNames)) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 1) 
	    (class_name = ((axlFormGridGetCell form_handle "grid" cell)->value)) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i) 
	    (cell->col = 2)
	    (class_voltage = ((axlFormGridGetCell form_handle "grid" cell)->value)) 
	    when((class_name && class_voltage) 
		rexCompile(" *") 
		(class_voltage = rexReplace(class_voltage "" 0)) 
		rexCompile(" *[vV] *$") 
		(class_voltage = rexReplace(class_voltage "" 0))
		if(atof(class_voltage) then 
		    (info_data[class_name] = atof(class_voltage)) else 
		    (info_data[class_name] = "Undefined")
		)
	    )
	) info_data
    )
)
procedure(TBX_CAFDRC_NCLS_Init_Grid_Cols(form_handle) 
    let((p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 12) 
	(p->fieldLength = 50)
	(p->headText = "Spacing Net Class") 
	(p->scriptLabel = "net_class") 
	(axlFormGridInsertCol form_handle "grid" p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING)
	(p->colWidth = 5) 
	(p->fieldLength = 5) 
	(p->popup = "grid_voltage_popup") 
	(p->headText = "Voltage") 
	(p->scriptLabel = "voltage")
	(axlFormGridInsertCol form_handle "grid" p)
    )
)
procedure(TBX_CAFDRC_NCLS_Init_Grid_Rows(form_handle) 
    (axlFormGridInsertRows form_handle "grid" 0 
	length((tbx_cafdrc_global->classNames))
    ) 
    (axlFormGridSetBatch form_handle "grid" 
	'TBX_CAFDRC_NCLS_Init_Grid_Rows_CB nil
    )
)
procedure(TBX_CAFDRC_NCLS_Init_Grid_Rows_CB(pvt_data) 
    let((cell rownum spacing_class voltage) 
	(pvt_data = pvt_data) 
	(rownum = 1) 
	foreach(cls 
	    (tbx_cafdrc_global->classNames) 
	    (spacing_class = cls) 
	    if((tbx_cafdrc_global->classVoltage)[spacing_class] then 
		(voltage = (tbx_cafdrc_global->classVoltage)[spacing_class]) else 
		(voltage = "Undefined")
	    ) 
	    unless((voltage == "Undefined") 
		(voltage = sprintf(nil "%L" voltage))
	    )
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 1) 
	    (cell->row = rownum) 
	    (cell->value = spacing_class) 
	    (cell->noEdit = t)
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 2) 
	    (cell->row = rownum) 
	    (cell->value = voltage)
	    (axlFormGridBatch cell) 
	    rownum++
	)
    )
)
procedure(TBX_CAFDRC_Read_Config() 
    let((att config_path data) 
	(att = (axlGetAttachment "tbx_cafdrc" 
		'string
	    )) 
	(config_path = car(TBX_UTIL_Search_Config("cafdrc.ini" nil nil))) 
	cond((att 
		(data = car(linereadstring((att->data))))
	    ) 
	    (config_path 
		(data = TBX_UTIL_File_Lineread(config_path)) 
		printf("Reading form settings from %L\n" config_path)
	    ) 
	    (t t)
	) data
    )
)
procedure(TBX_CAFDRC_Run(form_handle pad_layer_span) 
    let((psInfo voltage_list rule_data airgap threshold_distance
	    voltage_a voltage_b victim_list poly_vic poly_agr
	    result delta_voltage caf_poly cur_dv cur_fiber_spacing
	    cur_base_spacing cur_layer orgvis error_detected ps_a_span
	    ps_b_span fiber_angle tmp_list fields_dv fields_fiber
	    fields_base dv_list fiber_list base_list
	) 
	(orgvis = (axlVisibleGet)) 
	case((axlFormGetField form_handle "active_set") 
	    ("fine" 
		(fields_dv = list("f_dv1" "f_dv2" "f_dv3" "f_dv4")) 
		(fields_fiber = list("spc_fiber_f_dv1" "spc_fiber_f_dv2" "spc_fiber_f_dv3" "spc_fiber_f_dv4")) 
		(fields_base = list("spc_base_f_dv1" "spc_base_f_dv2" "spc_base_f_dv3" "spc_base_f_dv4"))
	    ) 
	    ("middle" 
		(fields_dv = list("m_dv1" "m_dv2" "m_dv3" "m_dv4")) 
		(fields_fiber = list("spc_fiber_m_dv1" "spc_fiber_m_dv2" "spc_fiber_m_dv3" "spc_fiber_m_dv4")) 
		(fields_base = list("spc_base_m_dv1" "spc_base_m_dv2" "spc_base_m_dv3" "spc_base_m_dv4"))
	    ) 
	    ("rough" 
		(fields_dv = list("r_dv1" "r_dv2" "r_dv3" "r_dv4")) 
		(fields_fiber = list("spc_fiber_r_dv1" "spc_fiber_r_dv2" "spc_fiber_r_dv3" "spc_fiber_r_dv4")) 
		(fields_base = list("spc_base_r_dv1" "spc_base_r_dv2" "spc_base_r_dv3" "spc_base_r_dv4"))
	    )
	) 
	(dv_list = list((axlFormGetField form_handle 
		    car(fields_dv)
		) 
		(axlFormGetField form_handle 
		    cadr(fields_dv)
		) 
		(axlFormGetField form_handle 
		    caddr(fields_dv)
		) 
		(axlFormGetField form_handle 
		    nth(3 fields_dv)
		)
	    )) 
	(fiber_list = list((axlFormGetField form_handle 
		    car(fields_fiber)
		) 
		(axlFormGetField form_handle 
		    cadr(fields_fiber)
		) 
		(axlFormGetField form_handle 
		    caddr(fields_fiber)
		) 
		(axlFormGetField form_handle 
		    nth(3 fields_fiber)
		)
	    ))
	(base_list = list((axlFormGetField form_handle 
		    car(fields_base)
		) 
		(axlFormGetField form_handle 
		    cadr(fields_base)
		) 
		(axlFormGetField form_handle 
		    caddr(fields_base)
		) 
		(axlFormGetField form_handle 
		    nth(3 fields_base)
		)
	    )) 
	(tmp_list = copy(fiber_list)) 
	(threshold_distance = (car(reverse(sort(tmp_list 
			    'lessp
			)
		    )
		) + (axlMKSConvert "0.5 MM" 
		    car((axlDBGetDesignUnits))
		))) 
	(fiber_angle = (axlFormGetField form_handle "fiber_angle")) 
	(rule_data = list(list(car(dv_list) 
		    car(fiber_list) 
		    car(base_list) 
		    car((tbx_cafdrc_global->sysLayers))
		) 
		list(cadr(dv_list) 
		    cadr(fiber_list) 
		    cadr(base_list) 
		    cadr((tbx_cafdrc_global->sysLayers))
		) 
		list(caddr(dv_list) 
		    caddr(fiber_list) 
		    caddr(base_list) 
		    caddr((tbx_cafdrc_global->sysLayers))
		) 
		list(nth(3 dv_list) 
		    nth(3 fiber_list) 
		    nth(3 base_list) 
		    nth(3 
			(tbx_cafdrc_global->sysLayers)
		    )
		)
	    ))
	(rule_data = sortcar(rule_data 
		'lessp
	    )) 
	(psInfo = TBX_CAFDRC_Classify_Padstacks(form_handle)) 
	foreach(vs psInfo 
	    (voltage_list = cons(vs voltage_list))
	) 
	(voltage_list = sort(voltage_list nil)) 
	when((length(voltage_list) <= 1) 
	    (axlUIConfirm "Warning: Voltage classification not available")
	)
	(voltage_a = car(voltage_list)) 
	while((length(voltage_list) > 1) 
	    (voltage_a = car(voltage_list)) 
	    foreach(vs 
		cdr(voltage_list) 
		(voltage_b = vs) 
		printf("Info: Processing voltage %L against %L\n" voltage_a voltage_b) 
		(delta_voltage = abs((atof(voltage_a) - atof(voltage_b))))
		(cur_dv = nth(3 dv_list)) 
		(cur_fiber_spacing = nth(3 fiber_list)) 
		(cur_base_spacing = nth(3 base_list)) 
		(cur_layer = nth(3 
			(tbx_cafdrc_global->sysLayers)
		    )) 
		foreach(entry 
		    reverse(rule_data) 
		    when((delta_voltage < car(entry)) 
			(cur_dv = car(entry)) 
			(cur_fiber_spacing = cadr(entry)) 
			(cur_base_spacing = caddr(entry)) 
			(cur_layer = nth(3 entry))
		    )
		)
		foreach(ps_a 
		    psInfo[voltage_a] 
		    (ps_a_span = pad_layer_span[(ps_a->name)]) 
		    (caf_poly = makeTable("caf_poly_data" nil)) 
		    (error_detected = nil)
		    if(caf_poly[cur_dv] then 
			(poly_agr = caf_poly[cur_dv]) else 
			(poly_agr = TBX_CAFDRC_Get_Hole_Polygon(ps_a cur_fiber_spacing cur_base_spacing fiber_angle))
			(caf_poly[cur_dv] = poly_agr)
		    ) 
		    (victim_list = nil) 
		    foreach(ps_b 
			psInfo[voltage_b] 
			(airgap = (axlAirGap ps_a ps_b nil 
				'anyLayer
			    )) 
			when((airgap && (airgap < threshold_distance)) 
			    (victim_list = cons(ps_b victim_list))
			)
		    ) 
		    foreach(ps_b victim_list 
			(ps_b_span = pad_layer_span[(ps_b->name)]) 
			when((length(setof(x ps_a_span 
					memq(x ps_b_span)
				    )
				) >= 2) 
			    (poly_vic = TBX_CAFDRC_Get_Hole_Polygon(ps_b nil nil nil)) 
			    (result = (axlPolyOperation poly_agr poly_vic 
				    'AND
				)) 
			    when(car(result) 
				TBX_CAFDRC_Create_DRC_Marker(ps_a ps_b cur_fiber_spacing cur_base_spacing "FAIL") 
				(error_detected = t)
			    )
			)
		    ) 
		    when(error_detected 
			foreach(pl poly_agr 
			    (axlDBCreateShape pl t cur_layer)
			)
		    )
		)
	    ) 
	    (voltage_list = cdr(voltage_list))
	) 
	(axlVisibleSet orgvis) 
	(axlFinishEnterFun) 
	(axlClearSelSet)
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_CAFDRC_Save_Rules(form_handle include_class_spec to_file) 
    let((config_file cfg rule_data set_name fields_dv
	    fields_fiber fields_base tmp_list dv_list fiber_list
	    base_list port class_list data_str
	) 
	(cfg = tconc(nil nil)) 
	tconc(cfg 
	    list('units 
		car((axlDBGetDesignUnits))
	    )
	) 
	(rule_data = tconc(nil nil)) 
	tconc(rule_data 
	    'rules
	)
	foreach(set 
	    list("fine" "middle" "rough") 
	    case(set 
		("fine" 
		    (set_name = "fine") 
		    (fields_dv = list("f_dv1" "f_dv2" "f_dv3" "f_dv4")) 
		    (fields_fiber = list("spc_fiber_f_dv1" "spc_fiber_f_dv2" "spc_fiber_f_dv3" "spc_fiber_f_dv4")) 
		    (fields_base = list("spc_base_f_dv1" "spc_base_f_dv2" "spc_base_f_dv3" "spc_base_f_dv4"))
		) 
		("middle" 
		    (set_name = "middle") 
		    (fields_dv = list("m_dv1" "m_dv2" "m_dv3" "m_dv4")) 
		    (fields_fiber = list("spc_fiber_m_dv1" "spc_fiber_m_dv2" "spc_fiber_m_dv3" "spc_fiber_m_dv4")) 
		    (fields_base = list("spc_base_m_dv1" "spc_base_m_dv2" "spc_base_m_dv3" "spc_base_m_dv4"))
		) 
		("rough" 
		    (set_name = "rough") 
		    (fields_dv = list("r_dv1" "r_dv2" "r_dv3" "r_dv4")) 
		    (fields_fiber = list("spc_fiber_r_dv1" "spc_fiber_r_dv2" "spc_fiber_r_dv3" "spc_fiber_r_dv4")) 
		    (fields_base = list("spc_base_r_dv1" "spc_base_r_dv2" "spc_base_r_dv3" "spc_base_r_dv4"))
		)
	    ) 
	    (dv_list = list('diffVoltage 
		    (axlFormGetField form_handle 
			car(fields_dv)
		    ) 
		    (axlFormGetField form_handle 
			cadr(fields_dv)
		    ) 
		    (axlFormGetField form_handle 
			caddr(fields_dv)
		    ) 
		    (axlFormGetField form_handle 
			nth(3 fields_dv)
		    )
		)) 
	    (fiber_list = list('fiberClearance 
		    (axlFormGetField form_handle 
			car(fields_fiber)
		    ) 
		    (axlFormGetField form_handle 
			cadr(fields_fiber)
		    ) 
		    (axlFormGetField form_handle 
			caddr(fields_fiber)
		    ) 
		    (axlFormGetField form_handle 
			nth(3 fields_fiber)
		    )
		))
	    (base_list = list('baseClearance 
		    (axlFormGetField form_handle 
			car(fields_base)
		    ) 
		    (axlFormGetField form_handle 
			cadr(fields_base)
		    ) 
		    (axlFormGetField form_handle 
			caddr(fields_base)
		    ) 
		    (axlFormGetField form_handle 
			nth(3 fields_base)
		    )
		)) 
	    (tmp_list = list('set set_name dv_list fiber_list base_list)) 
	    tconc(rule_data tmp_list)
	) 
	(rule_data = cdar(rule_data)) 
	tconc(cfg rule_data) 
	tconc(cfg 
	    list('activeSet 
		(axlFormGetField form_handle "active_set")
	    )
	) 
	tconc(cfg 
	    list('fiberAngle 
		(axlFormGetField form_handle "fiber_angle")
	    )
	)
	if((axlFormGetField form_handle "voltage_by_net") then 
	    tconc(cfg 
		list('groupNetsBy "voltage")
	    ) else 
	    tconc(cfg 
		list('groupNetsBy "netclass")
	    )
	) 
	when(include_class_spec 
	    foreach(cls 
		(tbx_cafdrc_global->classVoltage) 
		(class_list = cons(cls class_list))
	    ) 
	    (class_list = sort(class_list nil)) 
	    (tmp_list = tconc(nil nil)) 
	    tconc(tmp_list 
		'netClassSpec
	    )
	    foreach(cls class_list 
		tconc(tmp_list 
		    list(cls 
			(tbx_cafdrc_global->classVoltage)[cls]
		    )
		)
	    ) 
	    (tmp_list = cdar(tmp_list)) 
	    tconc(cfg tmp_list)
	) 
	(cfg = cdar(cfg)) 
	if(to_file then 
	    (config_file = (axlDMFileBrowse "ALLEGRO_TEXT" t ?noSticky t)) 
	    when(config_file 
		(port = outfile(config_file "w")) 
		if(port then 
		    pprint(cfg port) 
		    close(port) 
		    printf("Note: File %L has been written\n" config_file)
		    else 
		    printf("Warning: Could not open %L for write access\n" config_file)
		)
	    ) else
	    (axlDeleteAttachment "tbx_cafdrc") 
	    (data_str = sprintf(nil "%L" cfg)) 
	    (axlCreateAttachment "tbx_cafdrc" nil 1 
		'string
		data_str
	    ) 
	    printf("Info: Storing configuration to database...\n")
	) t
    )
)
procedure(TBX_CAFDRC_Update_Class_Spec(config_data class_voltage) 
    let((class_spec name voltage) 
	(class_spec = cdar(setof(entry config_data 
		    eq(car(entry) 
			'netClassSpec
		    )
		)
	    )) 
	foreach(spec class_spec 
	    (name = nil) 
	    (voltage = nil) 
	    caseq(type(car(spec)) 
		(symbol 
		    (name = upperCase(symbolToString(car(spec))))
		) 
		(string 
		    (name = upperCase(car(spec)))
		)
	    )
	    caseq(type(cadr(spec)) 
		(flonum 
		    (voltage = cadr(spec))
		) 
		(fixnum 
		    (voltage = (cadr(spec) * 1.0))
		) 
		(string 
		    cond((atof(cadr(spec)) 
			    (voltage = atof(cadr(spec)))
			) 
			((lowerCase(cadr(spec)) == "undefined") 
			    (voltage = "Undefined")
			) 
			(t 
			    (voltage = "Undefined")
			)
		    )
		)
	    ) 
	    when((name && voltage && class_voltage[name]) 
		(class_voltage[name] = voltage)
	    )
	) class_voltage
    )
)
procedure(TBX_CHANGENET_Callback(form_handle) 
    let((net_name pattern filtered_items) 
	case((form_handle->curField) 
	    ("net_filter" 
		(pattern = (form_handle->curValue)) 
		(pattern = TBX_UTIL_Regex_From_Shell(pattern t)) 
		(filtered_items = rexMatchList(pattern 
			(tbx_changenet_global->netNames)
		    )) 
		(axlFormListDeleteAll form_handle "net_list")
		(axlFormSetField form_handle "net_list" filtered_items)
	    ) 
	    ("net_list" 
		(net_name = (form_handle->curValue)) 
		(axlFormSetField form_handle "active_net" net_name)
	    )
	)
    )
)
procedure(TBX_CHANGENET_Init() 
    let((net_names) 
	(net_names = mapcar(lambda((x) 
		    (x->name)
		) 
		((axlDBGetDesign)->nets)
	    )) 
	(net_names = sort(net_names nil)) 
	unless(boundp('tbx_changenet_global) 
	    iliDefstruct('defstruct(tbx_changenet_global_struct formID transMark netNames runTime)) 
	    defvar(tbx_changenet_global nil)
	) 
	if(!tbx_changenet_global then 
	    (tbx_changenet_global = (make_tbx_changenet_global_struct ?formID nil ?transMark nil
		    ?netNames net_names ?runTime 
		    ncons(nil)
		)) else 
	    (tbx_changenet_global->formID = nil)
	    (tbx_changenet_global->transMark = nil) 
	    (tbx_changenet_global->netNames = net_names) 
	    (tbx_changenet_global->runTime = ncons(nil))
	)
    )
)
procedure((TBX_CHANGENET_Main \@optional arg) 
    let((lic_check_result info_file FC_FEATURE FC_VERSION SUB_VERSION
	    VERSION_STR port fid FORM_FILE
	) 
	(FC_FEATURE = "CHANGENET") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Assign net to vias/clines %s (C)2017" FC_VERSION))
	(VERSION_STR = VERSION_STR) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./changenet_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Change Net information:\n") 
		fprintf(port "=======================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Change Net: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    printf("For additional help enter: 'tbx help changenet' in console window\n") 
		    TBX_CHANGENET_Init() 
		    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "changenet_mini")) 
		    (fid = (axlMiniStatusLoad 
			    gensym() FORM_FILE 
			    'TBX_CHANGENET_Callback t
			))
		    (tbx_changenet_global->formId = fid) 
		    TBX_FORM_Init_Header(fid nil lic_check_result nil) 
		    (axlFormSetField fid "net_filter" "*") 
		    (axlFormListDeleteAll fid "net_list") 
		    (axlFormSetField fid "net_list" 
			(tbx_changenet_global->netNames)
		    )
		    (axlFormSetField fid "active_net" "<nothing selected>") 
		    (axlFormDisplay fid) 
		    (axlAutoOpenFindFilter) 
		    TBX_CHANGENET_Start() 
		    TBX_FORM_Delete(lic_check_result FORM_FILE)
		)
	    )
	)
    )
)
procedure(TBX_CHANGENET_Popup(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_CHANGENET_Popup_Done
		    ) 
		    list("Pick net" 
			'TBX_CHANGENET_Popup_Pick_Net
		    ) 
		    list("Oops" 
			'TBX_CHANGENET_Popup_Oops
		    ) 
		    list("Cancel" 
			'TBX_CHANGENET_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_CHANGENET_Popup_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_CHANGENET_Popup_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_CHANGENET_Popup_Oops() 
    (axlDBTransactionOops 
	(tbx_changenet_global->transMark)
    )
)
procedure(TBX_CHANGENET_Popup_Pick_Net() 
    ((tbx_changenet_global->runTime)->pickNetMode = t) 
    (axlClearSelSet) 
    (axlSetFindFilter ?enabled 
	list("noall" "pins" "vias" "clines" "shapes") ?onButtons 
	list("all")
    ) t
)
procedure(TBX_CHANGENET_Process(sel_set active_net) 
    let((via_list cline_list cline_start cline_end cline_layer
	    result seg_list rpath fail_list
	) 
	when(sel_set 
	    (via_list = setof(x sel_set 
		    ((x->objType) == "via")
		)) 
	    (cline_list = setof(x sel_set 
		    (((x->objType) == "path") && (x->isEtch))
		)) 
	    (active_net = (axlFormGetField 
		    (tbx_changenet_global->formId) "active_net"
		)) 
	    if((active_net == "<nothing selected>") then 
		printf("Warning: Specify the net name first\n") else 
		(axlDBTransactionMark 
		    (tbx_changenet_global->transMark)
		)
		foreach(v via_list 
		    if((((v->net)->name) == active_net) then 
			printf("Info: Via at %L already conncected to net %L\n" 
			    (v->xy) active_net
			) else 
			(result = (axlChangeNet v active_net))
			if(result then 
			    printf("Info: Connecting via at %L  to net %L\n" 
				(v->xy) active_net
			    ) else 
			    printf("Warning: Could not connect via at %L  to net %L\n" 
				(v->xy) active_net
			    )
			)
		    )
		) 
		(axlDBRefreshId nil) 
		foreach(c cline_list 
		    (seg_list = (c->segments)) 
		    (cline_start = car((car(seg_list)->startEnd))) 
		    (cline_end = cadr((car(reverse(seg_list))->startEnd)))
		    (cline_layer = (c->layer)) 
		    if((((c->net)->name) == active_net) then 
			printf("Info: Cline at from %L to %L already conncected to net %L\n" cline_start cline_end active_net) else 
			when((c->??) 
			    (rpath = (axlDB2Path c)) 
			    (axlDeleteObject c) 
			    (result = (axlDBCreatePath rpath cline_layer active_net)) 
			    (fail_list = setof(x 
				    car(result) 
				    (((x->net)->name) != active_net)
				))
			    when(fail_list 
				printf("Warning: Some segments could not be connected to %L. Iterative selection might resolve the problem.\n" active_net)
			    )
			)
		    )
		)
	    )
	) t
    )
)
procedure(TBX_CHANGENET_Start() 
    let((eventMask loop event net_name odbid
	    start_pick bBox
	) 
	(axlEventSetStartPopup 
	    'TBX_CHANGENET_Popup
	) 
	(eventMask = list('PICK 
		'STARTDRAG 
		'STOPDRAG
	    )) 
	(loop = t) 
	(tbx_changenet_global->transMark = (axlDBTransactionStart))
	printf("Select objects by pick or window\n") 
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    list("noall" "vias" "clines") ?onButtons 
	    list("vias")
	) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil nil)) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(PICK 
		    if(((tbx_changenet_global->runTime)->pickNetMode) then 
			(axlSingleSelectPoint 
			    (event->xy)
			) 
			if(car((axlGetSelSet)) then 
			    (odbid = car((axlGetSelSet))) 
			    (net_name = ((odbid->net)->name)) 
			    (axlFormSetField 
				(tbx_changenet_global->formId) "active_net" net_name
			    )
			    (axlFormSetField 
				(tbx_changenet_global->formId) "net_filter" "*"
			    ) 
			    (axlFormListDeleteAll 
				(tbx_changenet_global->formId) "net_list"
			    ) 
			    (axlFormSetField 
				(tbx_changenet_global->formId) "net_list" 
				(tbx_changenet_global->netNames)
			    ) 
			    (axlFormListSelect 
				(tbx_changenet_global->formId) "net_list" net_name
			    ) 
			    ((tbx_changenet_global->runTime)->pickNetMode = nil)
			    (axlClearSelSet) 
			    (axlSetFindFilter ?enabled 
				list("noall" "vias" "clines") ?onButtons 
				list("vias")
			    ) else 
			    printf("Warning: No net selected\n")
			) else
			(axlClearSelSet) 
			(axlSingleSelectPoint 
			    (event->xy)
			) 
			TBX_CHANGENET_Process((axlGetSelSet) 
			    (axlFormGetField 
				(tbx_changenet_global->formId) "active_net"
			    )
			)
		    )
		) 
		(STARTDRAG 
		    (axlAddSimpleRbandDynamics 
			(event->xy) "box" ?origin 
			(0.0:0.0)
		    ) 
		    (start_pick = (event->xy))
		) 
		(STOPDRAG 
		    (bBox = list(start_pick 
			    (event->xy)
			)) 
		    (axlClearSelSet) 
		    (axlSingleSelectBox bBox) 
		    TBX_CHANGENET_Process((axlGetSelSet) 
			(axlFormGetField 
			    (tbx_changenet_global->formId) "active_net"
			)
		    )
		    (axlClearDynamics)
		) 
		(DONE 
		    (loop = nil) 
		    (axlDBTransactionCommit 
			(tbx_changenet_global->transMark)
		    ) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics)
		)
		(CANCEL 
		    (loop = nil) 
		    (axlDBTransactionRollback 
			(tbx_changenet_global->transMark)
		    ) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_CHANGEWIDTH_Callback(form_handle) 
    let((width_list report_file) 
	case((form_handle->curField) 
	    ("all_on" 
		(axlFormListSelAll form_handle "width_list" t)
	    ) 
	    ("all_off" 
		(axlFormListSelAll form_handle "width_list" nil)
	    ) 
	    ("enable_online_drc" 
		if((form_handle->curValue) then 
		    (axlDBControl 
			'drcEnable t
		    ) else 
		    (axlDBControl 
			'drcEnable nil
		    )
		)
	    ) 
	    ("update_width" 
		((tbx_changewidth_global->findFilter)->on = (axlGetFindFilter t)) 
		(axlDBRefreshId nil) 
		(axlFormListDeleteAll form_handle "width_list") 
		(axlFormSetField form_handle "width_list" 
		    TBX_CHANGEWIDTH_Get_Design_Widths()
		)
		(axlSetFindFilter ?enabled 
		    ((tbx_changewidth_global->findFilter)->en) ?onButtons 
		    ((tbx_changewidth_global->findFilter)->on)
		)
	    )
	    ("highlight_segments" 
		((tbx_changewidth_global->findFilter)->on = (axlGetFindFilter t)) 
		(width_list = mapcar(lambda((x) 
			    atof(x)
			) 
			(axlFormListGetSelItems form_handle "width_list")
		    )) 
		(tbx_changewidth_global->highlightItems = TBX_CHANGEWIDTH_Get_Segments(width_list)) 
		when((tbx_changewidth_global->highlightItems) 
		    (axlHighlightObject 
			(tbx_changewidth_global->highlightItems)
		    )
		)
		(axlSetFindFilter ?enabled 
		    ((tbx_changewidth_global->findFilter)->en) ?onButtons 
		    ((tbx_changewidth_global->findFilter)->on)
		)
	    ) 
	    ("report_segments" 
		((tbx_changewidth_global->findFilter)->on = (axlGetFindFilter t)) 
		(width_list = mapcar(lambda((x) 
			    atof(x)
			) 
			(axlFormListGetSelItems form_handle "width_list")
		    )) 
		(report_file = TBX_CHANGEWIDTH_Report_Segments(width_list)) 
		when(isFile(report_file) 
		    (axlUIViewFileCreate report_file "Segment Report" nil)
		)
		(axlSetFindFilter ?enabled 
		    ((tbx_changewidth_global->findFilter)->en) ?onButtons 
		    ((tbx_changewidth_global->findFilter)->on)
		)
	    ) 
	    ("dehighlight_segments" 
		when((tbx_changewidth_global->highlightItems) 
		    (axlDehighlightObject 
			(tbx_changewidth_global->highlightItems)
		    ) 
		    (axlVisibleUpdate t)
		)
	    ) 
	    ("width_list" t)
	)
    )
)
procedure(TBX_CHANGEWIDTH_Event_Loop(form_handle) 
    let((mypopup new_width width_list change_list seg_width
	    probe_list msg seg_data ok_select_net sel_set
	) 
	(mypopup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_CHANGEWIDTH_Popup_Done
		    ) 
		    list("Probe" 
			'TBX_CHANGEWIDTH_Popup_Probe
		    ) 
		    list("Oops" 
			'TBX_CHANGEWIDTH_Popup_Oops
		    ) 
		    list("Cancel" 
			'TBX_CHANGEWIDTH_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet mypopup) 
	(tbx_changewidth_global->transMark = (axlDBTransactionStart)) 
	(axlClearSelSet)
	(axlSetFindFilter ?enabled 
	    ((tbx_changewidth_global->findFilter)->en) ?onButtons 
	    ((tbx_changewidth_global->findFilter)->on)
	) 
	((tbx_changewidth_global->runTime)->mode = "default") 
	(msg = "Select objects to change  through Pick, Window, Temp Group or Find By Name....") 
	printf("%s\n" msg) 
	while((axlSelect ?prompt msg) 
	    (change_list = nil) 
	    when((axlGetSelSet) 
		(sel_set = (axlGetSelSet)) 
		(axlClearSelSet) 
		cond(((((tbx_changewidth_global->runTime)->mode) == "default") 
			when((tbx_changewidth_global->highlightItems) 
			    (axlDehighlightObject 
				(tbx_changewidth_global->highlightItems)
			    ) 
			    (axlVisibleUpdate t)
			) 
			(new_width = (axlFormGetField form_handle "new_width")) 
			(width_list = mapcar(lambda((x) 
				    atof(x)
				) 
				(axlFormListGetSelItems form_handle "width_list")
			    )) 
			(ok_select_net = nil)
			when((length(setof(x sel_set 
					((x->objType) == "net")
				    )
				) > 0) 
			    (ok_select_net = t)
			) 
			(seg_data = TBX_CHANGEWIDTH_Get_Seg_Data(sel_set t)) 
			if(seg_data then 
			    if((length(width_list) > 0) then 
				if((length(width_list) == (tbx_changewidth_global->widthCnt)) then 
				    (axlDBTransactionMark 
					(tbx_changewidth_global->transMark)
				    ) 
				    (axlChangeWidth seg_data new_width) else
				    foreach(db seg_data 
					cond(((((db->objType) == "path") && (db->isSameWidth)) 
						when(member((car((db->segments))->width) width_list) 
						    (change_list = cons(db change_list))
						)
					    ) 
					    ((((db->objType) == "path") && !(db->isSameWidth)) 
						foreach(seg 
						    (db->segments) 
						    when(member((seg->width) width_list) 
							(change_list = cons(seg change_list))
						    )
						)
					    ) 
					    ((((db->objType) == "line") || ((db->objType) == "arc")) 
						when(member((db->width) width_list) 
						    (change_list = cons(db change_list))
						)
					    )
					)
				    ) 
				    when(change_list 
					when(ok_select_net 
					    printf("Note: When selecting nets, change operation only applies to segments on visible layers.\n")
					) 
					(axlChangeWidth change_list new_width)
				    )
				) else 
				printf("Warning: Please select at least one entry in width list.\n")
			    ) else 
			    printf("No clines selected.\n")
			)
		    ) 
		    ((((tbx_changewidth_global->runTime)->mode) == "probe") 
			(probe_list = nil) 
			(ok_select_net = nil) 
			when((length(setof(x sel_set 
					((x->objType) == "net")
				    )
				) > 0) 
			    (ok_select_net = t)
			) 
			(seg_data = TBX_CHANGEWIDTH_Get_Seg_Data(sel_set t))
			foreach(db seg_data 
			    cond(((((db->objType) == "path") && (db->isSameWidth)) 
				    (seg_width = (car((db->segments))->width)) 
				    unless(member(seg_width probe_list) 
					(probe_list = cons(seg_width probe_list))
				    )
				) 
				((((db->objType) == "path") && !(db->isSameWidth)) 
				    foreach(seg 
					(db->segments) 
					(seg_width = (seg->width)) 
					unless(member(seg_width probe_list) 
					    (probe_list = cons(seg_width probe_list))
					)
				    )
				) 
				((((db->objType) == "line") || ((db->objType) == "arc")) 
				    (seg_width = (db->width)) 
				    unless(member(seg_width probe_list) 
					(probe_list = cons(seg_width probe_list))
				    )
				)
			    )
			) 
			(probe_list = mapcar(lambda((x) 
				    sprintf(nil "%L" x)
				) probe_list
			    )) 
			(axlFormListSelAll form_handle "width_list" nil) 
			if((length(probe_list) > 0) then 
			    when((ok_select_net && (length(probe_list) > 1)) 
				printf("Info: Multiple widths found due to net selection. For single cline probing disable nets in find filter\n")
			    ) 
			    foreach(w probe_list 
				(axlFormListSelect form_handle "width_list" w)
			    ) else
			    t
			) 
			(axlClearSelSet)
			((tbx_changewidth_global->runTime)->mode = "default")
		    ) 
		    (t t)
		)
	    )
	)
    )
)
procedure(TBX_CHANGEWIDTH_Get_Design_Widths() 
    let((WTABLE width width_list width_list_str ff_en_orig
	    ff_on_orig sel_set
	) 
	(WTABLE = makeTable("wtable_data" nil)) 
	(ff_en_orig = cons("noall" 
		(axlGetFindFilter nil)
	    )) 
	(ff_on_orig = (axlGetFindFilter t)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "clines") ?onButtons 
	    list("all")
	)
	(axlClearSelSet) 
	(axlAddSelectAll) 
	(sel_set = (axlGetSelSet)) 
	(axlClearSelSet) 
	foreach(cl sel_set 
	    if((cl->isSameWidth) then 
		(width = (car((cl->segments))->width)) 
		(WTABLE[width] = t) else
		foreach(cls 
		    (cl->segments) 
		    (width = (cls->width)) 
		    (WTABLE[width] = t)
		)
	    )
	)
	foreach(key WTABLE 
	    (width_list = cons(key width_list))
	) 
	(axlSetFindFilter ?enabled ff_en_orig ?onButtons ff_on_orig) 
	(width_list = sort(width_list 
		'lessp
	    )) 
	(width_list_str = mapcar(lambda((x) 
		    sprintf(nil "%L" x)
		) width_list
	    )) width_list_str
    )
)
procedure(TBX_CHANGEWIDTH_Get_Seg_Data(sel_set vis_only) 
    let((tmp_list path_data net_list vis_layers layer_name) 
	(path_data = setof(x sel_set 
		(((x->objType) == "path") || ((x->objType) == "line") || ((x->objType) == "arc"))
	    )) 
	(net_list = setof(x sel_set 
		((x->objType) == "net")
	    )) 
	foreach(nt net_list 
	    foreach(br 
		(nt->branches) 
		(tmp_list = setof(x 
			(br->children) 
			((x->objType) == "path")
		    )) 
		(path_data = nconc(path_data tmp_list))
	    )
	) 
	when(vis_only 
	    foreach(lyr 
		(axlSubclassRoute) 
		(layer_name = strcat((axlMapClassName "ETCH") "/" lyr)) 
		when((axlIsVisibleLayer layer_name) 
		    (vis_layers = cons(layer_name vis_layers))
		)
	    ) 
	    (path_data = setof(x path_data 
		    member((x->layer) vis_layers)
		))
	)
	path_data
    )
)
procedure(TBX_CHANGEWIDTH_Get_Segments(width_list) 
    let((ff_en_orig ff_on_orig seg_list sel_set) 
	(ff_en_orig = cons("noall" 
		(axlGetFindFilter nil)
	    )) 
	(ff_on_orig = (axlGetFindFilter t)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "clines") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet)
	(axlAddSelectAll) 
	(sel_set = (axlGetSelSet)) 
	(axlClearSelSet) 
	foreach(cl sel_set 
	    if((cl->isSameWidth) then 
		when(member((car((cl->segments))->width) width_list) 
		    (seg_list = cons(cl seg_list))
		) else 
		foreach(cls 
		    (cl->segments) 
		    when(member((cls->width) width_list) 
			(seg_list = cons(cls seg_list))
		    )
		)
	    )
	) 
	(axlSetFindFilter ?enabled ff_en_orig ?onButtons ff_on_orig)
	seg_list
    )
)
procedure(TBX_CHANGEWIDTH_Init() 
    let((msg find_filter) 
	(msg = "Select on or more entries in order to act on segments with given width only") 
	(find_filter = ncons(nil)) 
	(find_filter->en = list("noall" "nameform" "nets" "clines" "clinesegs")) 
	(find_filter->on = list("all"))
	unless(boundp('tbx_changewidth_global) 
	    iliDefstruct('defstruct(tbx_changewidth_global_struct formId transMark runTime msgInfo
			highlightItems widthCnt licCheck findFilter
		    )
	    ) 
	    defvar(tbx_changewidth_global nil)
	) 
	if(!tbx_changewidth_global then 
	    (tbx_changewidth_global = (make_tbx_changewidth_global_struct ?formId nil ?transMark nil
		    ?runTime 
		    ncons(nil) ?msgInfo msg ?highlightItems
		    nil ?widthCnt nil ?licCheck nil
		    ?findFilter find_filter
		)) else 
	    (tbx_changewidth_global->formId = nil)
	    (tbx_changewidth_global->transMark = nil) 
	    (tbx_changewidth_global->runTime = ncons(nil)) 
	    (tbx_changewidth_global->msgInfo = msg) 
	    (tbx_changewidth_global->highlightItems = nil) 
	    (tbx_changewidth_global->widthCnt = nil)
	    (tbx_changewidth_global->licCheck = nil) 
	    (tbx_changewidth_global->findFilter = find_filter)
	)
    )
)
procedure((TBX_CHANGEWIDTH_Main \@optional arg) 
    let((lic_check_result info_file FC_FEATURE VERSION_STR FC_VERSION
	    SUB_VERSION port fid FORM_FILE width_list
	    record acc
	) 
	(FC_FEATURE = "CHANGEWIDTH") 
	(FC_VERSION = "17.2") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Change width %s (C)2017" FC_VERSION))
	(VERSION_STR = VERSION_STR) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./changewidth_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Change Width information:\n") 
		fprintf(port "=======================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Change Width: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    TBX_CHANGEWIDTH_Init() 
		    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "changewidth_mini")) 
		    (fid = (axlMiniStatusLoad 
			    gensym() FORM_FILE 
			    'TBX_CHANGEWIDTH_Callback
			)) 
		    (tbx_changewidth_global->formId = fid)
		    (tbx_changewidth_global->licCheck = lic_check_result) 
		    TBX_FORM_Init_Header(fid nil lic_check_result nil) 
		    (record = "changewidth") 
		    (acc = cadr((axlDBGetDesignUnits))) 
		    (axlFormSetDecimal fid "new_width" acc)
		    (axlFormSetField fid "new_width" 
			TBX_SESSION_Get_Param(record "new_width" 0.0 t)
		    ) 
		    if((axlDBControl 
			    'drcEnable
			) then 
			(axlFormSetField fid "enable_online_drc" t) else 
			(axlFormSetField fid "enable_online_drc" nil)
		    ) 
		    (axlFormListDeleteAll fid "width_list") 
		    (width_list = TBX_CHANGEWIDTH_Get_Design_Widths()) 
		    (tbx_changewidth_global->widthCnt = length(width_list))
		    (axlFormSetField fid "width_list" width_list) 
		    (axlFormDisplay fid) 
		    printf("For additional help enter: 'tbx help changewidth' in console window\n") 
		    (axlAutoOpenFindFilter) 
		    TBX_CHANGEWIDTH_Event_Loop(fid)
		    TBX_FORM_Delete(lic_check_result FORM_FILE)
		)
	    )
	)
    )
)
procedure(TBX_CHANGEWIDTH_Popup_Cancel() 
    (axlDBTransactionRollback 
	(tbx_changewidth_global->transMark)
    ) 
    (axlCancelEnterFun) 
    (axlUIPopupSet nil) 
    (axlClearDynamics)
)
procedure(TBX_CHANGEWIDTH_Popup_Done() 
    let((rec session_param) 
	(rec = "changewidth") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	putprop(session_param[rec] 
	    (axlFormGetField 
		(tbx_changewidth_global->formId) "new_width"
	    ) 
	    stringToSymbol("new_width")
	)
	putprop(session_param[rec] 
	    car((axlDBGetDesignUnits)) 
	    stringToSymbol("units")
	) 
	(axlDBTransactionCommit 
	    (tbx_changewidth_global->transMark)
	) 
	(axlFinishEnterFun) 
	(axlUIPopupSet nil) 
	(axlClearDynamics)
    )
)
procedure(TBX_CHANGEWIDTH_Popup_Oops() 
    (axlDBTransactionOops 
	(tbx_changewidth_global->transMark)
    )
)
procedure(TBX_CHANGEWIDTH_Popup_Probe() 
    ((tbx_changewidth_global->runTime)->mode = "probe")
)
procedure(TBX_CHANGEWIDTH_Report_Segments(width_list) 
    let((report_file ff_en_orig ff_on_orig port seg_width
	    width start_xy end_xy key_list seg_data
	    sel_set
	) 
	(ff_en_orig = cons("noall" 
		(axlGetFindFilter nil)
	    )) 
	(ff_on_orig = (axlGetFindFilter t)) 
	(seg_data = makeTable("seg_data_table" nil)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "clinesegs") ?onButtons 
	    list("all")
	)
	(axlClearSelSet) 
	(axlAddSelectAll) 
	(sel_set = (axlGetSelSet)) 
	(axlClearSelSet) 
	foreach(seg sel_set 
	    (seg_width = (seg->width)) 
	    when(exists(x width_list 
		    (x == seg_width)
		) 
		(seg_data[seg_width] = cons(seg 
			seg_data[seg_width]
		    ))
	    )
	)
	foreach(key seg_data 
	    (key_list = cons(key key_list))
	) 
	(key_list = sort(key_list 
		'lessp
	    )) 
	(report_file = strcat(getWorkingDir() "/tbx_changewidth_segment_report.txt")) 
	(port = outfile(report_file "w")) 
	fprintf(port "%-15s  %-20s  %-20s  %s\n" "Width" "Start" "End"
	    "Layer"
	)
	fprintf(port "==========================================================================================\n") 
	foreach(wd key_list 
	    foreach(seg 
		seg_data[wd] 
		(width = sprintf(nil "%L" 
			(seg->width)
		    )) 
		(start_xy = sprintf(nil "%L" 
			car((seg->startEnd))
		    )) 
		(end_xy = sprintf(nil "%L" 
			cadr((seg->startEnd))
		    ))
		fprintf(port "%-15s  %-20s  %-20s  %s\n" width start_xy end_xy
		    (seg->layer)
		)
	    ) 
	    fprintf(port "\n")
	) 
	close(port) 
	(axlSetFindFilter ?enabled ff_en_orig ?onButtons ff_on_orig) report_file
    )
)
procedure(TBX_CLASSCOLOR_Build_Dynamics(legend_extents) 
    let((design_box design_ll design_ll_x design_ll_y box_ll_x
	    box_ll_y box_ur_x box_ur_y origin_x origin_y
	    mypath box_width box_height
	) 
	(box_width = car(legend_extents)) 
	(box_height = cadr(legend_extents)) 
	(design_box = ((axlGetParam "paramDesign")->bBox)) 
	(design_ll = car(design_box))
	(design_ll_x = car(design_ll)) 
	(design_ll_y = cadr(design_ll)) 
	(origin_x = design_ll_x) 
	(origin_y = (design_ll_y + box_height)) 
	(box_ll_x = design_ll_x)
	(box_ll_y = design_ll_y) 
	(box_ur_x = (design_ll_x + box_width)) 
	(box_ur_y = (design_ll_y + box_height)) 
	(axlClearDynamics) 
	(mypath = (axlPathStart 
		list((box_ll_x:box_ll_y) 
		    (box_ur_x:box_ll_y) 
		    (box_ur_x:box_ur_y) 
		    (box_ll_x:box_ur_y) 
		    (box_ll_x:box_ll_y)
		) 0.1
	    ))
	(axlAddSimpleMoveDynamics 
	    (origin_x:origin_y) mypath "path"
	) mypath
    )
)
procedure(TBX_CLASSCOLOR_Calculate_Legend(class_names config block_nr) 
    let((block_param sym_width sym_height col_1_x col_1_y
	    col_2_x col_2_y title_info content_info line_info
	    line_start line_end sep_x result max_name_length
	    shape_width shape_height
	) 
	(block_param = (axlGetParam 
		strcat("paramTextBlock:" block_nr)
	    )) 
	(sym_height = ((length(config) + 1) * (block_param->height) * 2)) 
	(max_name_length = strlen("CLASS")) 
	foreach(key config 
	    when((strlen(key) > max_name_length) 
		(max_name_length = strlen(key))
	    )
	)
	(sym_width = (((max_name_length + 9) * (block_param->width)) + ((max_name_length + 9) * (block_param->charSpace)))) 
	(col_1_x = (0.5 * (block_param->width))) 
	(col_1_y = ((block_param->height) + (0.5 * (block_param->height)))) 
	(col_2_x = (((max_name_length + 4) * (block_param->width)) + ((max_name_length + 3) * (block_param->charSpace)))) 
	(col_2_y = col_1_y)
	(shape_width = ((3 * (block_param->width)) + (2 * (block_param->charSpace)))) 
	(shape_height = (block_param->height)) 
	(title_info = list(list("CLASS" block_nr 
		    (col_1_x:col_1_y)
		) 
		list("COLOR" block_nr 
		    ((col_2_x - (block_param->width) - (block_param->charSpace)):col_2_y)
		)
	    )) 
	foreach(cls class_names 
	    (col_1_y = (col_1_y + (2 * (block_param->height)))) 
	    (col_2_y = col_1_y) 
	    (content_info = cons(list(list(cls block_nr 
			    (col_1_x:col_1_y)
			) 
			list((col_2_x:col_2_y) shape_width shape_height)
		    ) content_info
		))
	) 
	(content_info = reverse(content_info))
	(line_info = cons(list(list(0.0 0.0) 
		    list(sym_width 0.0)
		) line_info
	    )) 
	(line_info = cons(list(list(sym_width 0.0) 
		    list(sym_width sym_height)
		) line_info
	    )) 
	(line_info = cons(list(list(sym_width sym_height) 
		    list(0.0 sym_height)
		) line_info
	    )) 
	(line_info = cons(list(list(0.0 sym_height) 
		    list(0.0 0.0)
		) line_info
	    )) 
	(line_start = list(0.0 
		(2.0 * (block_param->height))
	    ))
	(line_end = list(sym_width 
		(2.0 * (block_param->height))
	    )) 
	(line_info = cons(list(line_start line_end) line_info)) 
	(sep_x = (((max_name_length + 2) * (block_param->width)) + ((max_name_length + 1.5) * (block_param->charSpace)))) 
	(line_info = cons(list(list(sep_x 0.0) 
		    list(sep_x sym_height)
		) line_info
	    )) 
	(result = list(nil 
		'content content_info 
		'titleInfo title_info
		'lineInfo line_info 
		'extents 
		list(sym_width sym_height)
	    ))
	result
    )
)
procedure(TBX_CLASSCOLOR_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_CLASSCOLOR_Clear_Colors() 
    (axlClearObjectCustomColor 
	((axlDBGetDesign)->nets)
    )
)
procedure(TBX_CLASSCOLOR_Colorize_Groups(group_info) 
    let((group_name group_dbid group_color) 
	foreach(entry group_info 
	    (group_name = car(entry)) 
	    (group_color = cadr(entry)) 
	    (group_dbid = car((axlSelectByName "GROUP" group_name)))
	    when(group_dbid 
		(axlCustomColorObject group_dbid group_color)
	    )
	) 
	(axlClearSelSet) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_CLASSCOLOR_Create_Legend(sym_location legend_data) 
    let((sym_name sym_inst msg_str group_info total_width
	    total_height
	) 
	(sym_name = "tbx_classcolor_legend") 
	(total_width = car((legend_data->extents))) 
	(total_height = cadr((legend_data->extents))) 
	if(sym_location then 
	    if(TBX_CLASSCOLOR_Fit_to_Canvas(sym_location total_width total_height) then 
		foreach(grp 
		    (axlSelectByName "GROUP" "TBX_CLASSCOLOR_*" t) 
		    (axlDBDisbandGroup grp)
		) 
		(axlDBRefreshId nil) 
		when((tbx_classcolor_global->legendSymbols) 
		    (axlDeleteObject 
			(tbx_classcolor_global->legendSymbols)
		    ) 
		    (axlDBRefreshId nil)
		)
		(axlDBCreateSymDefSkeleton 
		    list(sym_name "format") 
		    list(list(0 
			    (axlMKSConvert -100 "MILS")
			) 
			list((axlMKSConvert 100 "MILS") 0)
		    )
		) 
		(sym_inst = car((axlDBCreateSymbolSkeleton 
			    list(sym_name "format") sym_location nil 0.0
			    nil
			)
		    )) 
		(group_info = TBX_CLASSCOLOR_Draw_Geometry(sym_location sym_inst 
			(tbx_classcolor_global->config) legend_data 
			(tbx_classcolor_global->legendLayer)
		    )) 
		TBX_CLASSCOLOR_Colorize_Groups(group_info) else
		(msg_str = "Warning: Symbol graphics do not fit into canvas area.\nReposition symbol or change parameters") 
		(axlUIConfirm msg_str)
	    ) else 
	    printf("Warning: Cannot create symbol instance due to missing xy coordinate\n")
	)
	t
    )
)
procedure(TBX_CLASSCOLOR_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_CLASSCOLOR_Draw_Debug_Rectangle(box_ul width height sym_inst) 
    let((box_ll_x box_ll_y box_ur_x box_ur_y) 
	when(box_ul 
	    (box_ll_x = car(box_ul)) 
	    (box_ll_y = (cadr(box_ul) - height)) 
	    (box_ur_x = (car(box_ul) + width)) 
	    (box_ur_y = cadr(box_ul))
	    (axlDBCreateRectangle 
		list((box_ll_x:box_ll_y) 
		    (box_ur_x:box_ur_y)
		) nil 
		(tbx_classcolor_global->legendLayer) nil
		sym_inst
	    )
	) t
    )
)
procedure(TBX_CLASSCOLOR_Draw_Geometry(sym_location sym_inst config legend_data legend_layer) 
    let((geom_ul_x geom_ul_y line_start line_end start_x
	    start_y end_x end_y class_name group_name
	    group_dbid group_cnt group_info rpath txt_orient
	    text_value text_block text_xy final_x final_y
	    box_ll_x box_ll_y box_ur_x box_ur_y shape_ll_xy
	    result text_entry shape_entry
	) 
	(geom_ul_x = car(sym_location)) 
	(geom_ul_y = cadr(sym_location)) 
	foreach(entry 
	    (legend_data->lineInfo) 
	    (line_start = car(entry)) 
	    (line_end = cadr(entry)) 
	    (start_x = (geom_ul_x + car(line_start)))
	    (start_y = (geom_ul_y - cadr(line_start))) 
	    (end_x = (geom_ul_x + car(line_end))) 
	    (end_y = (geom_ul_y - cadr(line_end))) 
	    (rpath = (axlPathStart 
		    list((start_x:start_y) 
			(end_x:end_y)
		    ) 0.0
		)) 
	    (axlDBCreatePath rpath legend_layer nil sym_inst)
	) 
	foreach(entry 
	    (legend_data->titleInfo) 
	    (text_value = car(entry)) 
	    (text_block = cadr(entry)) 
	    (text_xy = caddr(entry))
	    (final_x = (geom_ul_x + car(text_xy))) 
	    (final_y = (geom_ul_y - cadr(text_xy))) 
	    (txt_orient = (make_axlTextOrientation ?textBlock text_block ?rotation 0.0
		    ?mirrored nil ?justify "left"
		)) 
	    (axlDBCreateText text_value 
		(final_x:final_y) txt_orient legend_layer
		sym_inst
	    )
	)
	(group_cnt = 0) 
	foreach(entry 
	    (legend_data->content) 
	    (text_entry = car(entry)) 
	    (class_name = car(text_entry)) 
	    (text_block = cadr(text_entry))
	    (text_xy = caddr(text_entry)) 
	    (final_x = (geom_ul_x + car(text_xy))) 
	    (final_y = (geom_ul_y - cadr(text_xy))) 
	    (txt_orient = (make_axlTextOrientation ?textBlock text_block ?rotation 0.0
		    ?mirrored nil ?justify "left"
		)) 
	    (axlDBCreateText class_name 
		(final_x:final_y) txt_orient legend_layer
		sym_inst
	    )
	    (shape_entry = cadr(entry)) 
	    (shape_ll_xy = car(shape_entry)) 
	    (box_ll_x = (geom_ul_x + car(shape_ll_xy))) 
	    (box_ll_y = (geom_ul_y - cadr(shape_ll_xy))) 
	    (box_ur_x = (box_ll_x + cadr(shape_entry)))
	    (box_ur_y = (box_ll_y + caddr(shape_entry))) 
	    (result = (axlDBCreateRectangle 
		    list((box_ll_x:box_ll_y) 
			(box_ur_x:box_ur_y)
		    ) t legend_layer nil
		    sym_inst
		)) 
	    when((result && config[class_name]) 
		(group_name = sprintf(nil "TBX_CLASSCOLOR_%d" 
			++group_cnt
		    )) 
		(group_dbid = (axlDBCreateGroup group_name "generic" nil)) 
		(axlDBAddGroupObjects group_dbid 
		    car(result)
		) 
		(group_info = cons(list(group_name 
			    config[class_name]
			) group_info
		    ))
	    )
	) group_info
    )
)
procedure(TBX_CLASSCOLOR_Event_Loop(form_handle) 
    let((loop event) 
	(loop = t) 
	(axlEventSetStartPopup 
	    'TBX_CLASSCOLOR_Popup_Callback
	) 
	(tbx_classcolor_global->transMark = (axlDBTransactionStart)) 
	while(loop 
	    (event = (axlEnterEvent 
		    list('PICK) nil nil
		)) 
	    caseq((event->type) 
		(PICK 
		    when(((tbx_classcolor_global->runTime)->waitForPick) 
			TBX_CLASSCOLOR_Create_Legend((event->xy) 
			    (tbx_classcolor_global->legendData)
			) 
			((tbx_classcolor_global->runTime)->waitForPick = nil) 
			(axlClearDynamics)
		    )
		) 
		(DONE 
		    (axlDBTransactionCommit 
			(tbx_classcolor_global->transMark)
		    ) 
		    (axlFormClose form_handle) 
		    (axlClearDynamics) 
		    (loop = nil)
		) 
		(CANCEL 
		    (axlDBTransactionOops 
			(tbx_classcolor_global->transMark)
		    ) 
		    (axlDBTransactionCommit 
			(tbx_classcolor_global->transMark)
		    ) 
		    (axlFormClose form_handle) 
		    (axlClearDynamics)
		    (loop = nil)
		)
	    )
	)
	(axlEventSetStartPopup)
    )
)
procedure(TBX_CLASSCOLOR_Extract_Grid_Data(form_handle) 
    let((cell class_name class_color config) 
	(config = makeTable("config_table" nil)) 
	for(i 1 
	    length((tbx_classcolor_global->classNames)) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 1) 
	    (class_name = ((axlFormGridGetCell form_handle "grid" cell)->value)) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i) 
	    (cell->col = 2)
	    (class_color = ((axlFormGridGetCell form_handle "grid" cell)->value)) 
	    when((class_name && class_color) 
		(config[class_name] = class_color)
	    )
	) config
    )
)
procedure(TBX_CLASSCOLOR_Fit_to_Canvas(location_ul width height) 
    let((design_box design_ll design_ll_x design_ll_y design_ur
	    design_ur_x design_ur_y sym_ll_x sym_ll_y sym_ur_x
	    sym_ur_y return_value
	) 
	(design_box = ((axlGetParam "paramDesign")->bBox)) 
	(design_ll = car(design_box)) 
	(design_ll_x = car(design_ll)) 
	(design_ll_y = cadr(design_ll))
	(design_ur = cadr(design_box)) 
	(design_ur_x = car(design_ur)) 
	(design_ur_y = cadr(design_ur)) 
	(sym_ll_x = car(location_ul)) 
	(sym_ll_y = (cadr(location_ul) - height))
	(sym_ur_x = (car(location_ul) + width)) 
	(sym_ur_y = cadr(location_ul)) 
	if(((sym_ll_x > design_ll_x) && (sym_ll_y > design_ll_y) && (sym_ur_x < design_ur_x) && (sym_ur_y < design_ur_y)) then 
	    (return_value = t) else 
	    (return_value = nil)
	) return_value
    )
)
procedure(TBX_CLASSCOLOR_Form_Callback(fh) 
    let((cell color_id data output_file input_file
	    port class_name net_list block_id sym_location
	) 
	case((fh->curField) 
	    ("grid" 
		caseq((fh->event) 
		    (cellselect 
			cond(((onep((fh->col)) || ((fh->col) == 2)) 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 2) 
				(cell->row = (fh->row)) 
				(color_id = ((axlFormGridGetCell fh "grid" cell)->value))
				(axlFormSetField fh "current_color" color_id)
			    ) 
			    (((fh->col) == 3) 
				(color_id = car((axlCVFColorChooserDlg 1))) 
				when(color_id 
				    (cell = (axlFormGridNewCell)) 
				    (cell->col = 1) 
				    (cell->row = (fh->row)) 
				    (class_name = ((axlFormGridGetCell fh "grid" cell)->value))
				    ((tbx_classcolor_global->config)[class_name] = color_id) 
				    (cell = (axlFormGridNewCell)) 
				    (cell->col = 2) 
				    (cell->row = (fh->row)) 
				    (cell->value = "")
				    (cell->noEdit = t) 
				    (cell->backColor = color_id) 
				    (axlFormSetField fh "grid" cell)
				)
			    )
			) 
			(axlFormGridUpdate fh "grid")
		    )
		)
	    ) 
	    ("save_config" 
		(output_file = (axlDMFileBrowse "ALLEGRO_TEXT" t)) 
		when(output_file 
		    TBX_CLASSCOLOR_Save_Config((tbx_classcolor_global->config) output_file)
		)
	    ) 
	    ("load_config" 
		(input_file = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
		when(input_file 
		    (port = infile(input_file)) 
		    (data = car(lineread(port))) 
		    close(port) 
		    foreach(entry data 
			(class_name = upperCase(car(entry))) 
			(color_id = cadr(entry)) 
			when((tbx_classcolor_global->config)[class_name] 
			    ((tbx_classcolor_global->config)[class_name] = color_id)
			)
		    )
		    for(r 1 
			length((tbx_classcolor_global->classNames)) 
			(cell = (axlFormGridNewCell)) 
			(cell->col = 1)
			(cell->row = r) 
			(class_name = ((axlFormGridGetCell fh "grid" cell)->value)) 
			when((tbx_classcolor_global->config)[class_name] 
			    (cell = (axlFormGridNewCell)) 
			    (cell->col = 2) 
			    (cell->row = r) 
			    (cell->value = "")
			    (cell->noEdit = t) 
			    (cell->backColor = (tbx_classcolor_global->config)[class_name]) 
			    (axlFormSetField fh "grid" cell)
			)
		    ) 
		    (axlFormGridUpdate fh "grid")
		)
	    ) 
	    ("done" 
		TBX_CLASSCOLOR_Save_Config((tbx_classcolor_global->config) nil) 
		(axlFinishEnterFun)
	    )
	    ("apply_class_color" 
		(axlDBTransactionMark 
		    (tbx_classcolor_global->transMark)
		) 
		(axlClearObjectCustomColor 
		    ((axlDBGetDesign)->nets)
		) 
		(tbx_classcolor_global->nets = TBX_CLASSCOLOR_Get_Nets()) 
		foreach(cls 
		    (tbx_classcolor_global->config) 
		    (color_id = (tbx_classcolor_global->config)[cls]) 
		    (net_list = (tbx_classcolor_global->nets)[cls]) 
		    printf("Setting color %L for class: %L  number of nets: %L\n" color_id cls 
			length(net_list)
		    )
		    (axlCustomColorObject net_list color_id)
		)
		(axlVisibleLayer 
		    (tbx_classcolor_global->legendLayer) t
		) 
		(axlVisibleUpdate t) 
		(tbx_classcolor_global->legendSymbols = TBX_CLASSCOLOR_Get_Legend_Symbols()) 
		if((axlFormGetField fh "update_legend") then 
		    (block_id = sprintf(nil "%d" 
			    (axlFormGetField fh "text_block")
			)) 
		    (tbx_classcolor_global->legendData = TBX_CLASSCOLOR_Calculate_Legend((tbx_classcolor_global->classNames) 
			    (tbx_classcolor_global->config) block_id
			)) 
		    (sym_location = nil)
		    if((tbx_classcolor_global->legendSymbols) then 
			(sym_location = (car((tbx_classcolor_global->legendSymbols))->xy)) 
			TBX_CLASSCOLOR_Create_Legend(sym_location 
			    (tbx_classcolor_global->legendData)
			) else
			((tbx_classcolor_global->runTime)->waitForPick = t) 
			TBX_CLASSCOLOR_Build_Dynamics(((tbx_classcolor_global->legendData)->extents))
		    ) else 
		    when((tbx_classcolor_global->legendSymbols) 
			(axlUIConfirm "Warning: Color Legend symbol already exists and might get out of date.")
		    )
		) 
		(axlVisibleUpdate t)
	    ) 
	    ("my_help" 
		(axlShell "tbx help classcolor")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_CLASSCOLOR_Get_Class_Names() 
    let((class_list) 
	foreach(ncls 
	    ((axlDBGetDesign)->netclass) 
	    when((ncls->spacing) 
		(class_list = cons(upperCase((ncls->name)) class_list))
	    )
	) 
	(class_list = sort(class_list nil)) 
	(class_list = append1(class_list "UNASSIGNED")) class_list
    )
)
procedure(TBX_CLASSCOLOR_Get_Config(class_list) 
    let((att data att_info config color_id
	    default_id
	) 
	(att_info = makeTable("att_info_table" nil)) 
	(config = makeTable("config_table" nil)) 
	(default_id = makeTable("default_id_table" nil)) 
	(default_id[1] = 1)
	(default_id[2] = 17) 
	(default_id[3] = 33) 
	(default_id[4] = 49) 
	(default_id[5] = 65) 
	(default_id[6] = 81)
	(att = (axlGetAttachment "tbx_classcolor" 
		'string
	    )) 
	when(att 
	    (data = car(linereadstring((att->data)))) 
	    foreach(entry data 
		when((length(entry) == 2) 
		    (att_info[car(entry)] = cadr(entry))
		)
	    )
	) 
	(color_id = 0) 
	foreach(cls class_list 
	    if(att_info[cls] then 
		(config[cls] = att_info[cls]) else 
		++color_id
		if(default_id[color_id] then 
		    (config[cls] = default_id[color_id]) else 
		    (config[cls] = color_id)
		)
	    )
	) config
    )
)
procedure(TBX_CLASSCOLOR_Get_Legend_Symbols() 
    let((sym_name sym_list_tbx sym_list_legacy sym_list) 
	(sym_name = "tbx_classcolor_legend") 
	(sym_list_tbx = (axlSelectByName "SYMTYPE" sym_name)) 
	(axlClearSelSet) 
	(sym_list_legacy = (axlSelectByName "SYMTYPE" "flw_classcolor_legend"))
	(axlClearSelSet) 
	(sym_list = nconc(sym_list_tbx sym_list_legacy)) 
	when(sym_list 
	    when((length(sym_list) > 1) 
		printf("Warning: More than 1 instances of %L found. Will take the first one as reference for symbol location\n" sym_name)
	    )
	) 
	(axlClearSelSet) sym_list
    )
)
procedure(TBX_CLASSCOLOR_Get_Nets() 
    let((net_table nclass nclass_name) 
	(net_table = makeTable("net_table_data" nil)) 
	foreach(net 
	    ((axlDBGetDesign)->nets) 
	    (nclass = (axlNetClassGet net 
		    'spacing t
		)) 
	    if(nclass then 
		(nclass_name = upperCase((nclass->name))) 
		(net_table[nclass_name] = cons(net 
			net_table[nclass_name]
		    )) else
		(nclass_name = "UNASSIGNED") 
		(net_table[nclass_name] = cons(net 
			net_table[nclass_name]
		    ))
	    )
	) net_table
    )
)
procedure(TBX_CLASSCOLOR_Init() 
    let((legend_layer) 
	(legend_layer = "MANUFACTURING/TBX_COLORLEGEND") 
	unless((axlIsLayer legend_layer) 
	    (axlLayerCreateNonConductor legend_layer)
	) 
	unless(boundp('tbx_classcolor_global) 
	    iliDefstruct('defstruct(tbx_classcolor_global_struct formId config nets legendLayer
			classNames licCheck runTime legendData
		    )
	    ) 
	    defvar(tbx_classcolor_global nil)
	) 
	if(!tbx_classcolor_global then 
	    (tbx_classcolor_global = (make_tbx_classcolor_global_struct ?formId nil ?config nil
		    ?nets nil ?legendLayer legend_layer ?classNames
		    nil ?licCheck nil ?runTime 
		    ncons(nil)
		    ?legendData nil
		)) else 
	    (tbx_classcolor_global->formId = nil)
	    (tbx_classcolor_global->config = nil) 
	    (tbx_classcolor_global->nets = nil) 
	    (tbx_classcolor_global->legendLayer = legend_layer) 
	    (tbx_classcolor_global->classNames = nil) 
	    (tbx_classcolor_global->licCheck = nil)
	    (tbx_classcolor_global->runTime = ncons(nil)) 
	    (tbx_classcolor_global->legendData = nil)
	)
	t
    )
)
procedure(TBX_CLASSCOLOR_Init_Grid_Cols(form_handle) 
    let((p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 14) 
	(p->fieldLength = 50)
	(p->headText = "Spacing Net Class") 
	(p->scriptLabel = "net_class") 
	(axlFormGridInsertCol form_handle "grid" p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING)
	(p->colWidth = 3) 
	(p->fieldLength = 5) 
	(p->headText = "Color") 
	(p->scriptLabel = "color_id") 
	(axlFormGridInsertCol form_handle "grid" p)
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 2) 
	(p->fieldLength = 10) 
	(p->headText = "")
	(p->scriptLabel = "color_chooser") 
	(axlFormGridInsertCol form_handle "grid" p)
    )
)
procedure(TBX_CLASSCOLOR_Init_Grid_Rows(form_handle) 
    if(zerop((tbx_classcolor_global->netInfo)) then 
	(axlFormGridInsertRows form_handle "grid" 0 1) else 
	(axlFormGridInsertRows form_handle "grid" 0 
	    length((tbx_classcolor_global->config))
	)
	(axlFormGridSetBatch form_handle "grid" 
	    'TBX_CLASSCOLOR_Init_Grid_Rows_CB nil
	)
    )
)
procedure(TBX_CLASSCOLOR_Init_Grid_Rows_CB(pvt_data) 
    let((cell rownum class_name class_color) 
	(pvt_data = pvt_data) 
	(rownum = 1) 
	foreach(cls 
	    (tbx_classcolor_global->classNames) 
	    (class_name = cls) 
	    (class_color = (tbx_classcolor_global->config)[cls]) 
	    (cell = (axlFormGridNewCell))
	    (cell->col = 1) 
	    (cell->row = rownum) 
	    (cell->value = class_name) 
	    (cell->noEdit = t) 
	    (cell->backColor = 'white)
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 2) 
	    (cell->row = rownum) 
	    (cell->value = "")
	    (cell->noEdit = t) 
	    (cell->backColor = class_color) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 3)
	    (cell->row = rownum) 
	    (cell->value = "...") 
	    (cell->noEdit = t) 
	    (axlFormGridBatch cell) 
	    rownum++
	)
    )
)
procedure((TBX_CLASSCOLOR_Main \@optional arg) 
    let((lic_check_result fid FORM_FILE FC_FEATURE FC_VERSION
	    SUB_VERSION VERSION_STR info_file port ok_start_app
	    legend_symbol text_block update_legend result
	) 
	(FC_FEATURE = "CLASSCOLOR") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Class Color %s (C)2017" FC_VERSION))
	(ok_start_app = t) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./classcolor_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Class Color information:\n") 
		fprintf(port "=============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  reset   : Deletes configuration from database. Default settings will be used after launch\n") 
		fprintf(port "  version : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port)
		(axlUIViewFileCreate info_file "Class Color: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "reset")) 
		when((axlUIYesNo "Delete configuration from database?" nil 
			'no
		    ) 
		    printf("Deleting configuration from database...\n") 
		    (axlDeleteAttachment "tbx_classcolor")
		) 
		(ok_start_app = nil)
	    ) 
	    (arg 
		(ok_start_app = nil)
	    )
	) 
	when(ok_start_app 
	    (lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
	    when(lic_check_result 
		(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "classcolor_main")) 
		unless(boundp('tbxClasscolorMainHandle) 
		    defvar(tbxClasscolorMainHandle nil)
		) 
		(fid = (axlFormCreate 
			'tbxClasscolorMainHandle FORM_FILE 
			'(e outer) 
			'TBX_CLASSCOLOR_Form_Callback
			t
		    )) 
		when(fid 
		    TBX_CLASSCOLOR_Init() 
		    TBX_UTIL_Migrate("flw_classcolor" "tbx_classcolor") 
		    (tbx_classcolor_global->classNames = TBX_CLASSCOLOR_Get_Class_Names()) 
		    (axlDBDisplayControl 
			'customColorEnabled t
		    )
		    if((tbx_classcolor_global->classNames) then 
			(tbx_classcolor_global->config = TBX_CLASSCOLOR_Get_Config((tbx_classcolor_global->classNames))) 
			(tbx_classcolor_global->formId = fid) 
			(tbx_classcolor_global->licCheck = lic_check_result)
			TBX_FORM_Init_Header(fid nil lic_check_result VERSION_STR) 
			(axlFormSetFieldLimits fid "text_block" 1 
			    (axlDBGetTextBlockCount)
			) 
			(legend_symbol = car(TBX_CLASSCOLOR_Get_Legend_Symbols())) 
			(text_block = 2) 
			when(legend_symbol 
			    (update_legend = t) 
			    (result = (axlDBGetAttachedText legend_symbol)) 
			    when(result 
				(text_block = atoi((car(result)->textBlock)))
			    )
			)
			(axlFormSetField fid "text_block" text_block) 
			(axlFormSetField fid "update_legend" update_legend) 
			(axlFormDisplay fid) 
			(axlFormGridReset fid "grid") 
			TBX_CLASSCOLOR_Init_Grid_Cols(fid)
			TBX_CLASSCOLOR_Init_Grid_Rows(fid) 
			(axlFormGridUpdate fid "grid") 
			(axlFormGridEvents fid "grid" 
			    list('cellselect 
				'change
			    )
			) 
			TBX_CLASSCOLOR_Event_Loop(fid) 
			TBX_FORM_Delete(lic_check_result FORM_FILE)
			else 
			(axlUIConfirm "Warning: Design does not contain any spacing classes.\nCannot proceed.\n")
		    )
		)
	    )
	)
    )
)
procedure(TBX_CLASSCOLOR_Oops() 
    (axlDBTransactionOops 
	(tbx_classcolor_global->transMark)
    )
)
procedure(TBX_CLASSCOLOR_Popup_Callback(event) 
    let((popid) 
	(event = event) 
	(popid = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_CLASSCOLOR_Done
		    ) 
		    list("Oops" 
			'TBX_CLASSCOLOR_Oops
		    ) 
		    list("Cancel" 
			'TBX_CLASSCOLOR_Cancel
		    ) 
		    list("Clear Net Colors" 
			'TBX_CLASSCOLOR_Clear_Colors
		    ) 
		    list("Remove Legend" 
			'TBX_CLASSCOLOR_Remove_Legend
		    )
		)
	    )) 
	(axlUIPopupSet popid)
    )
)
procedure(TBX_CLASSCOLOR_Remove_Legend() 
    let((sym_list) 
	(sym_list = (axlSelectByName "SYMTYPE" "tbx_classcolor_legend")) 
	(axlClearSelSet) 
	when(sym_list 
	    (axlDeleteObject sym_list)
	) 
	(axlDBRefreshId nil)
	t
    )
)
procedure(TBX_CLASSCOLOR_Save_Config(config output_file) 
    let((port data data_str) 
	foreach(cls config 
	    (data = cons(list(cls 
			config[cls]
		    ) data
		))
	) 
	(data = sortcar(data nil)) 
	if(output_file then 
	    (port = outfile(output_file)) 
	    fprintf(port "(\n") 
	    foreach(entry data 
		fprintf(port "   %L\n" entry)
	    )
	    fprintf(port ")\n") 
	    close(port) else 
	    (axlDeleteAttachment "tbx_classcolor") 
	    (data_str = sprintf(nil "%L" data))
	    (axlCreateAttachment "tbx_classcolor" nil 1 
		'string
		data_str
	    )
	) t
    )
)
procedure(TBX_COILADV_Break_Turn_Path(turn_path break_path refpoint angle_range) 
    let((seg_list start_xy width end_xy center
	    type clockwise radius result pseudo_seg
	    new_path loop pt_angle match_list pt_intersect
	    break_seg rp
	) 
	(seg_list = (axlPathGetPathSegs break_path)) 
	(start_xy = (axlPathSegGetEndPoint 
		car(seg_list)
	    )) 
	(width = (axlPathSegGetWidth 
		cadr(seg_list)
	    )) 
	(end_xy = (axlPathSegGetEndPoint 
		cadr(seg_list)
	    ))
	(break_seg = list(nil 
		'objType "line" 
		'width width
		'startEnd 
		list(start_xy end_xy)
	    )) 
	(rp = (axlPathStart 
		list(car((break_seg->startEnd)) 
		    cadr((break_seg->startEnd))
		) 0.0
	    )) 
	(result = (axlDBCreatePath rp 
		(tbx_coiladv_data->tmpLayer)
	    )) 
	(break_seg = car((caar(result)->segments))) 
	(seg_list = (axlPathGetPathSegs turn_path))
	(start_xy = (axlPathSegGetEndPoint 
		car(seg_list)
	    )) 
	(new_path = (axlPathStart 
		list(start_xy) 0.0
	    )) 
	(seg_list = cdr(seg_list)) 
	(loop = t) 
	while((loop && seg_list) 
	    (width = (axlPathSegGetWidth 
		    car(seg_list)
		)) 
	    (end_xy = (axlPathSegGetEndPoint 
		    car(seg_list)
		)) 
	    (center = (axlPathSegGetArcCenter 
		    car(seg_list)
		)) 
	    if(center then 
		(type = "arc") 
		(clockwise = nil) 
		when((axlPathSegGetArcClockwise 
			car(seg_list)
		    ) 
		    (clockwise = t)
		)
		(radius = (axlDistance center end_xy)) else 
		(type = "line")
	    )
	    if((type == "line") then 
		(pseudo_seg = list(nil 
			'objType "line" 
			'width width
			'startEnd 
			list(start_xy end_xy)
		    )) 
		(rp = (axlPathStart 
			list(car((pseudo_seg->startEnd)) 
			    cadr((pseudo_seg->startEnd))
			) 0.0
		    )) 
		(result = (axlDBCreatePath rp 
			(tbx_coiladv_data->tmpLayer)
		    ))
		(pseudo_seg = car((caar(result)->segments))) else 
		(pseudo_seg = list(nil 
			'objType "arc" 
			'width width
			'startEnd 
			list(start_xy end_xy) 
			'xy center 
			'radius
			radius 
			'isClockwise clockwise 
			'isCircle nil
		    )) 
		(rp = (axlPathStart 
			list(car((pseudo_seg->startEnd))) 0.0
		    )) 
		(rp = (axlPathArcCenter rp 
			(pseudo_seg->width) 
			cadr((pseudo_seg->startEnd)) 
			(pseudo_seg->isClockwise)
			(pseudo_seg->xy)
		    ))
		(result = (axlDBCreatePath rp 
			(tbx_coiladv_data->tmpLayer)
		    )) 
		(pseudo_seg = car((caar(result)->segments)))
	    ) 
	    (result = TBX_GEOM_Get_Intersection(pseudo_seg break_seg t nil)) 
	    if(result then 
		if((type == "line") then 
		    (new_path = (axlPathLine new_path width 
			    car(result)
			)) 
		    (loop = nil) else
		    foreach(isec result 
			(pt_angle = car(TBX_GEOM_Get_Vector_Info(isec refpoint))) 
			when(((pt_angle >= car(angle_range)) && (pt_angle <= cadr(angle_range))) 
			    (match_list = cons(list((axlDistance isec refpoint) isec) match_list))
			)
		    ) 
		    (match_list = sortcar(match_list 
			    'lessp
			)) 
		    (pt_intersect = cadar(match_list)) 
		    if(pt_intersect then 
			(new_path = (axlPathArcCenter new_path width pt_intersect clockwise
				center
			    )) 
			(loop = nil) else
			(new_path = (axlPathArcCenter new_path width end_xy clockwise
				center
			    ))
		    )
		) else 
		if((type == "line") then 
		    (new_path = (axlPathLine new_path width end_xy)) else 
		    (new_path = (axlPathArcCenter new_path width end_xy clockwise
			    center
			))
		)
	    ) 
	    (axlDeleteObject pseudo_seg) 
	    (seg_list = cdr(seg_list))
	    (start_xy = end_xy)
	)
	(axlDeleteObject break_seg) new_path
    )
)
procedure(TBX_COILADV_CORE_TYPE1_Calculate(param) 
    let((w_half h_half offset_x path_data rp
	    result sym_box line_width
	) 
	(result = ncons(nil)) 
	(line_width = (axlMKSConvert "0.1 MM" 
		car((axlDBGetDesignUnits))
	    )) 
	(w_half = ((param->symbolWidth) / 2.0)) 
	(h_half = ((param->symbolHeight) / 2.0))
	(rp = (axlPathStart 
		list(((- w_half):(- h_half)) 
		    (w_half:(- h_half)) 
		    (w_half:h_half) 
		    ((- w_half):h_half) 
		    ((- w_half):(- h_half))
		) line_width
	    )) 
	(path_data = cons(list(rp 
		    'outlinePath
		) path_data
	    )) 
	(sym_box = TBX_UTIL_Get_Extents(list(rp) ?axlPathCenter t)) 
	(w_half = ((param->coreWidth) / 2.0)) 
	(h_half = ((param->coreHeight) / 2.0))
	(offset_x = ((- (param->coreDistance)) / 2.0)) 
	(rp = (axlPathStart 
		list(((offset_x - w_half):(- h_half)) 
		    ((offset_x + w_half):(- h_half)) 
		    ((offset_x + w_half):h_half) 
		    ((offset_x - w_half):h_half) 
		    ((offset_x - w_half):(- h_half))
		) line_width
	    )) 
	(path_data = cons(list(rp 
		    'outlinePath
		) path_data
	    )) 
	(rp = (axlPathStart 
		list(((offset_x - w_half):(- h_half)) 
		    ((offset_x + w_half):(- h_half)) 
		    ((offset_x + w_half):h_half) 
		    ((offset_x - w_half):h_half) 
		    ((offset_x - w_half):(- h_half))
		) 0.0
	    )) 
	(path_data = cons(list(rp 
		    'keepoutShape
		) path_data
	    ))
	(w_half = ((param->coreWidth) / 2.0)) 
	(h_half = ((param->coreHeight) / 2.0)) 
	(offset_x = ((param->coreDistance) / 2.0)) 
	(rp = (axlPathStart 
		list(((offset_x - w_half):(- h_half)) 
		    ((offset_x + w_half):(- h_half)) 
		    ((offset_x + w_half):h_half) 
		    ((offset_x - w_half):h_half) 
		    ((offset_x - w_half):(- h_half))
		) line_width
	    )) 
	(path_data = cons(list(rp 
		    'outlinePath
		) path_data
	    ))
	(rp = (axlPathStart 
		list(((offset_x - w_half):(- h_half)) 
		    ((offset_x + w_half):(- h_half)) 
		    ((offset_x + w_half):h_half) 
		    ((offset_x - w_half):h_half) 
		    ((offset_x - w_half):(- h_half))
		) 0.0
	    )) 
	(path_data = cons(list(rp 
		    'keepoutShape
		) path_data
	    )) 
	(rp = (axlPathStartCircle 
		list((0:0) 
		    (param->coreRadius)
		) line_width
	    )) 
	(path_data = cons(list(rp 
		    'outlinePath
		) path_data
	    )) 
	(rp = (axlPathStartCircle 
		list((0:0) 
		    (param->coreRadius)
		) 0.0
	    ))
	(path_data = cons(list(rp 
		    'keepoutShape
		) path_data
	    )) 
	when(path_data 
	    (result->path = path_data) 
	    (result->bBox = sym_box)
	) result
    )
)
procedure(TBX_COILADV_CORE_TYPE1_Callback(form_handle) 
    let((msg core_type) 
	(core_type = (form_handle->coreType)) 
	case((form_handle->curField) 
	    ("symbolWidth" 
		putprop((tbx_coiladv_data->coreParam)[core_type] 
		    (form_handle->curValue) 
		    'symbolWidth
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("symbolHeight" 
		putprop((tbx_coiladv_data->coreParam)[core_type] 
		    (form_handle->curValue) 
		    'symbolHeight
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("coreWidth" 
		putprop((tbx_coiladv_data->coreParam)[core_type] 
		    (form_handle->curValue) 
		    'coreWidth
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("coreHeight" 
		putprop((tbx_coiladv_data->coreParam)[core_type] 
		    (form_handle->curValue) 
		    'coreHeight
		) 
		TBX_COILADV_Update_Dynamics()
	    )
	    ("coreDistance" 
		putprop((tbx_coiladv_data->coreParam)[core_type] 
		    (form_handle->curValue) 
		    'coreDistance
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("coreRadius" 
		putprop((tbx_coiladv_data->coreParam)[core_type] 
		    (form_handle->curValue) 
		    'coreRadius
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("done" 
		(msg = msg) 
		(axlFormClose form_handle)
	    ) 
	    ("cancel" 
		(axlFormClose form_handle)
	    ) 
	    ("my_help" 
		(axlShell "tbx help coiladv")
	    )
	    (t t)
	)
    )
)
procedure(TBX_COILADV_Calculate_Pad_Shape(leg_size hypo_radius endcap_width corner_radius) 
    let((pt1 pt2 pt3 w_half rp_pad) 
	(pt1 = (leg_size:0)) 
	(pt2 = (0:(- leg_size))) 
	(pt3 = (leg_size:(- leg_size))) 
	(hypo_radius = hypo_radius)
	(w_half = (endcap_width / 2.0)) 
	when((corner_radius <= 0.0) 
	    (corner_radius = 0.0)
	) 
	(rp_pad = (axlPathStart 
		list(((car(pt1) - w_half):cadr(pt1))) 0.0
	    )) 
	(rp_pad = (axlPathArcAngle rp_pad 0.0 
		(car(pt2):(cadr(pt2) + w_half)) t
		90.0
	    )) 
	(rp_pad = (axlPathArcAngle rp_pad 0.0 
		(car(pt2):(cadr(pt2) - w_half)) nil
		180.0
	    ))
	(rp_pad = (axlPathLine rp_pad 0.0 
		((car(pt3) - corner_radius):(cadr(pt3) - w_half))
	    )) 
	if((corner_radius > 0.0) then 
	    (rp_pad = (axlPathArcAngle rp_pad 0.0 
		    ((car(pt3) + w_half):(cadr(pt3) + corner_radius)) nil
		    90.0
		)) else 
	    (rp_pad = (axlPathLine rp_pad 0.0 
		    ((car(pt3) + w_half):(cadr(pt3) - w_half))
		))
	) 
	(rp_pad = (axlPathLine rp_pad 0.0 
		((car(pt1) + w_half):cadr(pt1))
	    )) 
	(rp_pad = (axlPathArcAngle rp_pad 0.0 
		((car(pt1) - w_half):cadr(pt1)) nil
		180.0
	    )) rp_pad
    )
)
procedure(TBX_COILADV_Calculate_Triangle_Shape(leg_size_x leg_size_y radius_a radius_b) 
    let((pt_1 pt_2 pt_3 alpha alpha_rad
	    angle_diff trim_size vec_12 vec_23 vec_31
	    clockwise rp angle_span PI start_xy
	    arc_start_xy arc_end_xy
	) 
	(PI = ((tbx_coiladv_data->constants)->PI)) 
	(pt_1 = (0.0:0.0)) 
	(pt_2 = (leg_size_x:0.0)) 
	(pt_3 = (0.0:leg_size_y))
	(vec_12 = TBX_MATH_Get_Vector(pt_1 pt_2)) 
	(vec_23 = TBX_MATH_Get_Vector(pt_2 pt_3)) 
	(vec_31 = TBX_MATH_Get_Vector(pt_3 pt_1)) 
	when((radius_a < 0.0) 
	    (radius_a = 0.0)
	) 
	(start_xy = ((car(pt_1) + radius_a):cadr(pt_1)))
	(rp = (axlPathStart 
		list(start_xy) 0.0
	    )) 
	(angle_diff = TBX_MATH_Get_Angle_Between_Vectors(vec_12 vec_23)) 
	(clockwise = nil) 
	when((angle_diff < 0.0) 
	    (clockwise = t)
	) 
	(alpha = ((180.0 - abs(angle_diff)) / 2.0))
	(alpha_rad = ((alpha / 360.0) * 2 * PI)) 
	(trim_size = (radius_b / tan(alpha_rad))) 
	(arc_start_xy = TBX_MATH_Add_Vector(pt_1 
		list(vec_12 
		    (TBX_MATH_Transform_Vector vec_12 ?scale -1.0 ?size
			trim_size
		    )
		)
	    )) 
	(arc_end_xy = TBX_MATH_Add_Vector(pt_2 
		list((TBX_MATH_Transform_Vector vec_23 ?scale 1.0 ?size
			trim_size
		    )
		)
	    )) 
	(rp = (axlPathLine rp 0.0 arc_start_xy))
	(angle_span = (2.0 * (180.0 - 90 - alpha))) 
	(rp = (axlPathArcAngle rp 0.0 arc_end_xy clockwise
		angle_span
	    )) 
	(angle_diff = TBX_MATH_Get_Angle_Between_Vectors(vec_23 vec_31)) 
	(clockwise = nil) 
	when((angle_diff < 0.0) 
	    (clockwise = t)
	)
	(alpha = ((180.0 - abs(angle_diff)) / 2.0)) 
	(alpha_rad = ((alpha / 360.0) * 2 * PI)) 
	(trim_size = (radius_b / tan(alpha_rad))) 
	(arc_start_xy = TBX_MATH_Add_Vector(pt_2 
		list(vec_23 
		    (TBX_MATH_Transform_Vector vec_23 ?scale -1.0 ?size
			trim_size
		    )
		)
	    )) 
	(arc_end_xy = TBX_MATH_Add_Vector(pt_3 
		list((TBX_MATH_Transform_Vector vec_31 ?scale 1.0 ?size
			trim_size
		    )
		)
	    ))
	(rp = (axlPathLine rp 0.0 arc_start_xy)) 
	(angle_span = (2.0 * (180.0 - 90 - alpha))) 
	(rp = (axlPathArcAngle rp 0.0 arc_end_xy clockwise
		angle_span
	    )) 
	(rp = (axlPathLine rp 0.0 
		(car(pt_1):(cadr(pt_1) + radius_a))
	    )) 
	when((radius_a > 0.0) 
	    (rp = (axlPathArcAngle rp 0.0 start_xy clockwise
		    90.0
		))
	)
	rp
    )
)
procedure(TBX_COILADV_Callback(form_handle) 
    let((core_type spiral_type active_layer package_name comp_dbid
	    cfg_data
	) 
	case((form_handle->curField) 
	    ("refdes" 
		(comp_dbid = car((axlSelectByName "COMPONENT" 
			    (form_handle->curValue)
			)
		    )) 
		(package_name = ((comp_dbid->compdef)->package)) 
		(axlFormSetField form_handle "core_type" package_name) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("core_type" 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("specify_core_param" 
		(core_type = upperCase((axlFormGetField form_handle "core_type"))) 
		(cfg_data = TBX_COILADV_Get_Implementation(core_type 
			(tbx_coiladv_data->coreParam) 
			(tbx_coiladv_data->cfgCoreType)
		    )) 
		when(cfg_data 
		    TBX_COILADV_Specify_Core_Param(core_type 
			(cfg_data->form) 
			(cfg_data->callback)
		    )
		)
	    ) 
	    ("spiral_type" 
		TBX_COILADV_Update_Dynamics()
	    )
	    ("specify_spiral_param" 
		(spiral_type = upperCase((axlFormGetField form_handle "spiral_type"))) 
		(cfg_data = TBX_COILADV_Get_Implementation(spiral_type 
			(tbx_coiladv_data->spiralParam) 
			(tbx_coiladv_data->cfgSpiralType)
		    )) 
		when(cfg_data 
		    TBX_COILADV_Specify_Spiral_Param(spiral_type 
			(cfg_data->form) 
			(cfg_data->callback)
		    )
		)
	    ) 
	    ("subclass" 
		(active_layer = (axlDBControl 
			'activeLayer
		    )) 
		(axlVisibleLayer active_layer t) 
		(axlVisibleUpdate t) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_COILADV_Create_Symbol(refdes origin core_data coil_data) 
    let((rpath comp_dbid pin_list subclass symbol_extents
	    package_name offset symdef symdef_names syminst
	    net1 net2 net_rf result poly
	    sym_ll sym_ur
	) 
	(net_rf = "RFETCHSHAPENET") 
	(net1 = "SIG1") 
	(net2 = "SIG2") 
	unless((axlSelectByName "NET" net_rf) 
	    (axlDBCreateNet net_rf)
	)
	(comp_dbid = car((axlSelectByName "COMPONENT" refdes))) 
	when(comp_dbid 
	    (pin_list = (comp_dbid->pins)) 
	    (net1 = ((car(pin_list)->net)->name)) 
	    (net2 = ((cadr(pin_list)->net)->name)) 
	    (axlDBAddProp pin_list 
		list("NET_SHORT" 
		    strcat(net_rf ":" net1 ":" net2)
		)
	    )
	    (package_name = ((comp_dbid->compdef)->package)) 
	    (symdef_names = mapcar(lambda((x) 
			(x->name)
		    ) 
		    ((axlDBGetDesign)->symdefs)
		)) 
	    (symbol_extents = (TBX_UTIL_Get_Extents 
		    list((core_data->bBox) 
			(coil_data->bBox)
		    ) ?margin 
		    ((tbx_coiladv_data->constants)->boxMargin) ?axlPathCenter
		    t
		)) 
	    unless(member(package_name symdef_names) 
		(symdef = TBX_COILADV_Create_Symbol_Definition(package_name 
			(core_data->bBox)
		    )) 
		(symdef = symdef)
	    ) 
	    unless((axlSelectByName "REFDES" refdes) 
		(result = (axlDBCreateSymbol refdes origin nil 0.0)) 
		when(result 
		    (syminst = car(result))
		)
	    )
	    when(syminst 
		(subclass = cadr(parseString((axlDBControl 
				'activeLayer
			    ) "/"
			)
		    )) 
		(subclass = subclass) 
		(symbol_extents = (TBX_UTIL_Get_Extents 
			list((core_data->bBox) 
			    (coil_data->bBox)
			) ?margin 
			((tbx_coiladv_data->constants)->boxMargin) ?axlPathCenter
			t
		    )) 
		(sym_ll = car(symbol_extents))
		(sym_ur = cadr(symbol_extents)) 
		(symbol_extents = list(((car(sym_ll) + car(origin)):(cadr(sym_ll) + cadr(origin))) 
			((car(sym_ur) + car(origin)):(cadr(sym_ur) + cadr(origin)))
		    )) 
		(axlDBCreateRectangle symbol_extents t "PACKAGE GEOMETRY/PLACE_BOUND_TOP" nil
		    syminst
		) 
		foreach(entry 
		    (coil_data->path) 
		    (rpath = (axlPathOffset 
			    car(entry) origin
			)) 
		    caseq(cadr(entry) 
			(etchPath 
			    (poly = car((axlPolyFromDB rpath ?endCapType 
					'ROUND ?line2poly
					t
				    )
				)) 
			    when(poly 
				(axlDBCreateShape poly t 
				    (axlDBControl 
					'activeLayer
				    ) nil
				    syminst
				)
			    )
			) 
			(etchShape 
			    (axlDBCreateShape rpath t 
				(axlDBControl 
				    'activeLayer
				) nil
				syminst
			    )
			)
		    )
		) 
		foreach(entry 
		    (core_data->path) 
		    (rpath = (axlPathOffset 
			    car(entry) origin
			)) 
		    caseq(cadr(entry) 
			(outlinePath 
			    (axlDBCreatePath rpath "PACKAGE GEOMETRY/ASSEMBLY_TOP" 
				'line syminst
			    )
			) 
			(keepoutShape 
			    (axlDBCreateShape rpath t "ROUTE KEEPOUT/ALL" nil
				syminst
			    )
			)
		    )
		)
		when(syminst 
		    (axlDBAddProp syminst 
			list(list("UNFIXED_PINS" t))
		    ) 
		    (axlDBRefreshId syminst) 
		    foreach(pn 
			(syminst->pins) 
			(offset = nil) 
			case((pn->number) 
			    ("1" 
				(offset = (coil_data->xyStart))
			    ) 
			    ("2" 
				(offset = (coil_data->xyEnd))
			    )
			) 
			when(offset 
			    (axlTransformObject pn ?move offset)
			)
		    ) 
		    (axlDBDeleteProp syminst 
			list("UNFIXED_PINS")
		    )
		    (axlDBAddProp syminst 
			list(list("LOCKED" t))
		    ) 
		    (axlDBRefreshId syminst)
		) 
		foreach(ch 
		    (syminst->etchChildren) 
		    (axlChangeNet ch net_rf)
		)
	    )
	) t
    )
)
procedure(TBX_COILADV_Create_Symbol_Definition(package_name extents) 
    let((padstack pin1_constructor pin2_constructor symdef txtorient) 
	(padstack = TBX_COILADV_Get_Padstack("TOP")) 
	(pin1_constructor = (make_axlPinData ?number "1" ?padstack 
		(padstack->name)
		?origin 
		(0.0:0.0) ?rotation 0.0
	    )) 
	(pin2_constructor = (make_axlPinData ?number "2" ?padstack 
		(padstack->name)
		?origin 
		(0.0:0.0) ?rotation 0.0
	    )) 
	(symdef = (axlDBCreateSymDefSkeleton 
		list(package_name "package") extents 
		list(pin1_constructor pin2_constructor)
	    ))
	(txtorient = (make_axlTextOrientation ?textBlock "3" ?rotation 0.0
		?mirrored nil ?justify "left"
	    )) 
	(axlDBCreateText "L*" 
	    (0.0:0.0) txtorient "REF DES/ASSEMBLY_TOP"
	    symdef
	) symdef
    )
)
procedure(TBX_COILADV_Event_Loop() 
    let((eventMask loop event refdes refdes_names
	    comp_dbid
	) 
	(axlEventSetStartPopup 
	    'TBX_COILADV_Popup_Callback
	) 
	(eventMask = list('PICK)) 
	(loop = t) 
	(tbx_coiladv_data->transMark = (axlDBTransactionStart))
	(tbx_coiladv_data->transMarkPath = (axlDBTransactionStart)) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil t)) 
	    caseq((event->type) 
		(PICK 
		    (refdes = (axlFormGetField 
			    ((tbx_coiladv_data->formId)->mini) "refdes"
			)) 
		    TBX_COILADV_Create_Symbol(refdes 
			(event->xy) 
			(tbx_coiladv_data->coreData) 
			(tbx_coiladv_data->spiralData)
		    ) 
		    (axlClearSelSet) 
		    (axlDBRefreshId nil)
		    (refdes_names = TBX_COILADV_Get_Refdes()) 
		    when((refdes_names && (car(refdes_names) != "<empty>")) 
			(axlFormBuildPopup 
			    ((tbx_coiladv_data->formId)->mini) "refdes" refdes_names
			) 
			(comp_dbid = car(setof(c 
				    ((axlDBGetDesign)->components) 
				    ((c->name) == car(refdes_names))
				)
			    )) 
			(axlFormSetField 
			    ((tbx_coiladv_data->formId)->mini) "core_type" 
			    ((comp_dbid->compdef)->package)
			) 
			TBX_COILADV_Update_Dynamics()
		    )
		) 
		(DONE 
		    (axlDBTransactionCommit 
			(tbx_coiladv_data->transMark)
		    ) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    when(((tbx_coiladv_data->formId)->coreParam) 
			(axlFormClose 
			    ((tbx_coiladv_data->formId)->coreParam)
			)
		    )
		    when(((tbx_coiladv_data->formId)->spiralParam) 
			(axlFormClose 
			    ((tbx_coiladv_data->formId)->spiralParam)
			)
		    ) 
		    (loop = nil)
		) 
		(CANCEL 
		    (axlDBTransactionOops 
			(tbx_coiladv_data->transMark)
		    ) 
		    (axlDBTransactionCommit 
			(tbx_coiladv_data->transMark)
		    ) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics)
		    (loop = nil)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_COILADV_Get_Implementation(name param cfg) 
    let((implementation cfg_data) 
	(implementation = (param[name]->implementation)) 
	if(implementation then 
	    (cfg_data = cfg[implementation]) 
	    unless(cfg_data 
		(axlUIConfirm 
		    sprintf(nil "Warning: Undefined implementation details %L" implementation)
		)
	    ) else
	    (axlUIConfirm 
		sprintf(nil "Warning: Missing implementation for %L" name)
	    )
	) cfg_data
    )
)
procedure(TBX_COILADV_Get_Padstack(subclass) 
    let((oct_size padstack_name padstack match_list pad_list) 
	(padstack_name = strcat("CP_COILADV_" subclass)) 
	(match_list = setof(x 
		((axlDBGetDesign)->padstacks) 
		(upperCase((x->name)) == padstack_name)
	    )) 
	if((length(match_list) > 0) then 
	    (padstack = car(match_list)) else 
	    (oct_size = (axlMKSConvert "25 UM" 
		    car((axlDBGetDesignUnits))
		))
	    (pad_list = list((make_axlPadStackPad ?layer subclass ?type 
			'REGULAR
			?figure 
			'OCTAGON ?figureSize 
			(oct_size:oct_size)
		    )
		)) 
	    (padstack = (axlDBCreatePadStack padstack_name nil pad_list t))
	) padstack
    )
)
procedure(TBX_COILADV_Get_Refdes() 
    let((refdes refdes_list) 
	foreach(cmp 
	    ((axlDBGetDesign)->components) 
	    when(memq('ISRFELEMENT 
		    (((cmp->compdef)->prop)->?)
		) 
		(refdes = (cmp->name)) 
		if(((cmp->symbol)->xy) then 
		    printf("Component %L already placed.\n" refdes) else 
		    (refdes_list = cons(refdes refdes_list))
		)
	    )
	) 
	unless(refdes_list 
	    (refdes_list = list("<empty>"))
	) 
	(refdes_list = sort(refdes_list nil)) refdes_list
    )
)
procedure(TBX_COILADV_Get_Types(lib) 
    let((name_list) 
	foreach(key lib 
	    (name_list = cons(key name_list))
	) 
	unless(name_list 
	    (name_list = list("<empty>"))
	) 
	(name_list = sort(name_list nil)) name_list
    )
)
procedure(TBX_COILADV_Init() 
    let((tmp_layer env_org constants cfgCoreType cfgSpiralType) 
	(constants = ncons(nil)) 
	(constants->PI = (defMathConstants('mymathconst)->PI)) 
	(constants->boxMargin = (axlMKSConvert "0.1 MM" 
		car((axlDBGetDesignUnits))
	    )) 
	(cfgSpiralType = makeTable("cfg_spiral_type" nil))
	(cfgSpiralType["RND"] = list(nil 
		'form "tbx_coiladv_spiral_rnd.form" 
		'callback 
		'TBX_COILADV_SPIRAL_RND_Callback
		'calc 
		'TBX_COILADV_SPIRAL_RND_Calculate
	    )) 
	(cfgSpiralType["S90"] = list(nil 
		'form "tbx_coiladv_spiral_s90.form" 
		'callback 
		'TBX_COILADV_SPIRAL_S90_Callback
		'calc 
		'TBX_COILADV_SPIRAL_S90_Calculate
	    )) 
	(cfgCoreType = makeTable("cfg_core_type" nil)) 
	(cfgCoreType["TYPE1"] = list(nil 
		'form "tbx_coiladv_core_type1.form" 
		'callback 
		'TBX_COILADV_CORE_TYPE1_Callback
		'calc 
		'TBX_COILADV_CORE_TYPE1_Calculate
	    )) 
	(tmp_layer = "MANUFACTURING/TMP_DRAFTING")
	unless((axlIsLayer tmp_layer) 
	    (axlLayerCreateNonConductor tmp_layer)
	) 
	TBX_DBDISPLAY_Set_Layer_Color(tmp_layer 
	    list(255 255 255) 
	    list(255 0 0)
	) 
	unless(axlGetVariable("DISABLE_OPENGL") 
	    unless(axlGetVariable("STATIC_SHAPES_FILL_SOLID") t 
		(env_org = cons(list("STATIC_SHAPES_FILL_SOLID" nil) env_org))
	    )
	) 
	unless(boundp('tbx_coiladv_data) 
	    iliDefstruct('defstruct(tbx_coiladv_data_struct versionStr transMark formId licCheck
			coreParam spiralParam tmpLayer coreData spiralData
			constants cfgCoreType cfgSpiralType
		    )
	    ) 
	    defvar(tbx_coiladv_data nil)
	) 
	if(!tbx_coiladv_data then 
	    (tbx_coiladv_data = (make_tbx_coiladv_data_struct ?versionStr nil ?transMark nil
		    ?tmpLayer tmp_layer ?formId 
		    ncons(nil) ?licCheck
		    nil ?coreParam nil ?spiralParam nil
		    ?coreData nil ?spiralData nil ?constants
		    constants ?cfgCoreType cfgCoreType ?cfgSpiralType cfgSpiralType
		)) else 
	    (tbx_coiladv_data->versionStr = nil)
	    (tbx_coiladv_data->transMark = nil) 
	    (tbx_coiladv_data->tmpLayer = tmp_layer) 
	    (tbx_coiladv_data->formId = ncons(nil)) 
	    (tbx_coiladv_data->licCheck = nil) 
	    (tbx_coiladv_data->coreParam = nil)
	    (tbx_coiladv_data->spiralParam = nil) 
	    (tbx_coiladv_data->coreData = nil) 
	    (tbx_coiladv_data->spiralData = nil) 
	    (tbx_coiladv_data->constants = constants) 
	    (tbx_coiladv_data->cfgCoreType = cfgCoreType)
	    (tbx_coiladv_data->cfgSpiralType = cfgSpiralType)
	)
    )
)
procedure((TBX_COILADV_Main \@optional arg) 
    let((info_file FC_FEATURE VERSION_STR FC_VERSION SUB_VERSION
	    port FORM_FILE fid cfg_file refdes_names
	    core_names coil_names comp_dbid package_name lic_check_result
	) 
	(FC_FEATURE = "COILADV") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Advanced Coil Designer %s (C)2017" FC_VERSION))
	(FC_FEATURE = FC_FEATURE) 
	(VERSION_STR = VERSION_STR) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./coiladv_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Advanced Coil Designer information:\n") 
		fprintf(port "===============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Advanced Coil Designer: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    ((arg && (lowerCase(arg) == "reset")) 
		when((axlUIYesNo "Delete configuration from database?" nil 
			'no
		    ) t
		)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    TBX_COILADV_Init() 
		    (tbx_coiladv_data->versionStr = VERSION_STR) 
		    (cfg_file = car(TBX_UTIL_Search_Config("core_param.cfg" "coiladv" nil ?includeWorkDir t))) 
		    (tbx_coiladv_data->coreParam = TBX_COILADV_Read_Configuration(cfg_file))
		    (cfg_file = car(TBX_UTIL_Search_Config("spiral_param.cfg" "coiladv" nil ?includeWorkDir t))) 
		    (tbx_coiladv_data->spiralParam = TBX_COILADV_Read_Configuration(cfg_file)) 
		    if((axlOKToProceed t) then 
			printf("INFO: Function is still prototype and not fully released yet.\n") 
			(refdes_names = TBX_COILADV_Get_Refdes()) 
			if((refdes_names && (car(refdes_names) != "<empty>")) then 
			    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "coiladv_mini")) 
			    (fid = (axlMiniStatusLoad 
				    gensym() FORM_FILE 
				    'TBX_COILADV_Callback nil
				)) 
			    ((tbx_coiladv_data->formId)->mini = fid)
			    (tbx_coiladv_data->licCheck = lic_check_result) 
			    (axlDBControl 
				'activeLayer 
				strcat((axlMapClassName "ETCH") "/TOP")
			    ) 
			    (axlFormBuildPopup fid "refdes" refdes_names) 
			    (axlFormSetField fid "refdes" 
				car(refdes_names)
			    ) 
			    (core_names = TBX_COILADV_Get_Types((tbx_coiladv_data->coreParam)))
			    (axlFormBuildPopup fid "core_type" core_names) 
			    (comp_dbid = car((axlSelectByName "COMPONENT" 
					car(refdes_names)
				    )
				)) 
			    (package_name = ((comp_dbid->compdef)->package)) 
			    (axlFormSetField fid "core_type" package_name) 
			    (coil_names = TBX_COILADV_Get_Types((tbx_coiladv_data->spiralParam)))
			    (axlFormBuildPopup fid "spiral_type" coil_names) 
			    (axlFormSetField fid "spiral_type" 
				car(coil_names)
			    ) 
			    (axlFormDisplay fid) 
			    (axlAutoOpenFindFilter) 
			    TBX_COILADV_Update_Dynamics()
			    TBX_COILADV_Event_Loop() else 
			    (axlUIConfirm "Design does not contain any coil device in the netlist. Refer to documentation for more details.")
			)
			else 
			printf("Warning: Finish active command first\n")
		    ) 
		    printf("For additional help enter: 'tbx help coiladv' in console window\n")
		)
	    )
	)
    )
)
procedure(TBX_COILADV_Normalize_Angle(cur_angle) 
    let((new_angle factor) 
	(factor = 1.0) 
	(new_angle = cur_angle) 
	when((new_angle < 0) 
	    (factor = -1.0)
	) 
	(new_angle = abs(new_angle))
	(new_angle = (new_angle - (floor((new_angle / 360.0)) * 360.0))) 
	(new_angle = (new_angle * factor)) 
	when((new_angle < 0) 
	    (new_angle = (360.0 + new_angle))
	) new_angle
    )
)
procedure(TBX_COILADV_Popup_Callback(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_COILADV_RMB_Done
		    ) 
		    list("Toggle" 
			'TBX_COILADV_RMB_Toggle
		    ) 
		    list("Finish" 
			'TBX_COILADV_RMB_Finish
		    ) 
		    list("Oops" 
			'TBX_COILADV_RMB_Oops
		    ) 
		    list("Cancel" 
			'TBX_COILADV_RMB_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_COILADV_RMB_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_COILADV_RMB_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_COILADV_RMB_Finish() 
    (axlDBTransactionMark 
	(tbx_coiladv_data->transMark)
    )
)
procedure(TBX_COILADV_RMB_Oops() 
    (axlDBTransactionOops 
	(tbx_coiladv_data->transMark)
    )
)
procedure(TBX_COILADV_RMB_Toggle() 
    let((form_handle) 
	(form_handle = (tbx_coiladv_data->Formid)) 
	when((axlFormGetField form_handle "add_connect") 
	    (axlShell "toggle")
	)
    )
)
procedure(TBX_COILADV_Read_Configuration(cfg_file) 
    let((port data config name param_name
	    param_value arr design_units
	) 
	(design_units = car((axlDBGetDesignUnits))) 
	if((isFile(cfg_file) && isReadable(cfg_file)) then 
	    (config = makeTable("config_table" nil)) 
	    printf("Reading settings from %L\n" cfg_file) 
	    (port = infile(cfg_file))
	    (data = car(lineread(port))) 
	    foreach(sec data 
		(name = upperCase(car(sec))) 
		(config[name] = ncons(nil)) 
		foreach(prm 
		    cdr(sec) 
		    (param_name = car(prm)) 
		    (param_value = cadr(prm)) 
		    when((type(param_value) == 'string) 
			(param_value = upperCase(param_value)) 
			(arr = parseString(param_value)) 
			when(((length(arr) == 2) && atof(car(arr)) && member(cadr(arr) 
				    list("UM" "MM" "CM" "INCHES" "IN"
					"MILS" "MIL" "MILLIMETERS"
				    )
				)) 
			    (param_value = (axlMKSConvert param_value design_units))
			)
		    )
		    putprop(config[name] param_value param_name)
		)
	    ) 
	    close(port) else 
	    printf("Error: Cannot read access configuration file %L\n" cfg_file)
	) config
    )
)
procedure(TBX_COILADV_SPIRAL_RND_Calculate(param) 
    let((path_data rp_coil_full rp_coil_partial rp_leader_start rp_leader_exit
	    width spacing turn_start_x turn_start_y nr_of_turns
	    inner_radius PI center_a center_b radius_diff
	    radius_a radius_b angle_rad clockwise angle_start
	    angle_exit full_turns break_line_start break_line_end break_path
	    angle_range tmp_path_data rp rp_type leg_size
	    endcap_width corner_radius coil_box offset rp_pad_corner
	    box_ll box_ur pt_ur pt_ul pt_ll
	    pt_lr rp_pad_ur rp_pad_ul rp_pad_ll rp_pad_lr
	    result coil_start_xy coil_end_xy rp_coil_box
	) 
	(PI = ((tbx_coiladv_data->constants)->PI)) 
	(result = ncons(nil)) 
	(width = (param->windingWidth)) 
	(spacing = (param->windingSpace))
	(inner_radius = (param->radiusR1)) 
	(nr_of_turns = (param->nrOfTurns)) 
	(clockwise = (param->clockwise)) 
	(angle_start = (param->angleStart)) 
	(angle_exit = (param->angleExit))
	(radius_diff = ((width + spacing) / 2.0)) 
	(center_a = (0.0:0.0)) 
	(center_b = ((car(center_a) + radius_diff):cadr(center_a))) 
	(radius_a = (inner_radius + (width / 2.0))) 
	(radius_b = (radius_a + radius_diff))
	(turn_start_x = (car(center_a) + radius_a)) 
	(turn_start_y = cadr(center_a)) 
	(coil_start_xy = (turn_start_x:turn_start_y)) 
	(leg_size = (turn_start_x - car(center_b))) 
	(endcap_width = width)
	(corner_radius = (axlMKSConvert "1.0 MM" 
		car((axlDBGetDesignUnits))
	    )) 
	(rp_coil_full = (axlPathStart 
		list((turn_start_x:turn_start_y)) 0.0
	    )) 
	if((angle_exit == 0.0) then 
	    (full_turns = nr_of_turns) else 
	    (full_turns = (nr_of_turns - 1))
	) 
	(rp_leader_start = (axlPathStart 
		list(center_a 
		    (turn_start_x:turn_start_y)
		) 0.0
	    )) 
	(rp_leader_exit = (axlPathStart 
		list(center_a 
		    (turn_start_x:turn_start_y)
		) 0.0
	    ))
	for(i 1 full_turns 
	    (rp_coil_full = (axlPathArcCenter rp_coil_full width 
		    ((car(center_a) - radius_a):cadr(center_a)) nil
		    center_a
		)) 
	    (rp_coil_full = (axlPathArcCenter rp_coil_full width 
		    ((car(center_b) + radius_b):cadr(center_b)) nil
		    center_b
		))
	    (radius_a = (radius_a + width + spacing)) 
	    (radius_b = (radius_a + radius_diff)) 
	    (coil_end_xy = ((car(center_a) + radius_a):cadr(center_a)))
	) 
	when((angle_exit > 0.0) 
	    (rp_coil_partial = (axlPathStart 
		    list(coil_end_xy) 0.0
		)) 
	    (rp_coil_partial = (axlPathArcCenter rp_coil_partial width 
		    ((car(center_a) - radius_a):cadr(center_a)) nil
		    center_a
		)) 
	    (rp_coil_partial = (axlPathArcCenter rp_coil_partial width 
		    ((car(center_b) + radius_b):cadr(center_b)) nil
		    center_b
		)) 
	    (angle_rad = ((angle_exit / 360.0) * 2 * PI))
	    (break_line_start = center_a) 
	    (break_line_end = (((cos(angle_rad) * radius_a) + car(center_a)):((sin(angle_rad) * radius_a) + cadr(center_a)))) 
	    (break_path = (axlPathStart 
		    list(break_line_start break_line_end) 0.2
		)) 
	    (angle_range = list((floor((angle_exit / 90.0)) * 90) 
		    (ceiling((angle_exit / 90.0)) * 90)
		)) 
	    (rp_coil_partial = TBX_COILADV_Break_Turn_Path(rp_coil_partial break_path center_a angle_range))
	    if((rp_coil_partial && (length((axlPathGetLastPathSeg rp_coil_partial)) > 1)) then 
		(coil_end_xy = (axlPathSegGetEndPoint 
			(axlPathGetLastPathSeg rp_coil_partial)
		    )) else 
		(rp_coil_partial = nil)
	    )
	) 
	if(rp_coil_partial then 
	    (coil_box = TBX_UTIL_Get_Extents(list(rp_coil_full rp_coil_partial) ?axlPathCenter t)) else 
	    (coil_box = TBX_UTIL_Get_Extents(list(rp_coil_full) ?axlPathCenter t))
	) 
	(rp_pad_corner = TBX_COILADV_Calculate_Triangle_Shape(leg_size leg_size corner_radius 
		(endcap_width / 2.0)
	    )) 
	(box_ll = car(coil_box))
	(box_ur = cadr(coil_box)) 
	(rp_coil_box = (axlPathStart 
		list((car((lowerLeft coil_box)):
			cadr((lowerLeft coil_box))) 
		    (car((upperRight coil_box)):
			cadr((lowerLeft coil_box))) 
		    (car((upperRight coil_box)):
			cadr((upperRight coil_box))) 
		    (car((lowerLeft coil_box)):
			cadr((upperRight coil_box))) 
		    (car((lowerLeft coil_box)):
			cadr((lowerLeft coil_box)))
		) 0.0
	    )) 
	(offset = 0.0) 
	(pt_ur = ((car(box_ur) - offset):(cadr(box_ur) - offset))) 
	(pt_ul = ((car(box_ll) + offset):(cadr(box_ur) - offset)))
	(pt_ll = ((car(box_ll) + offset):(cadr(box_ll) + offset))) 
	(pt_lr = ((car(box_ur) + offset):(cadr(box_ll) + offset))) 
	when(rp_pad_corner 
	    (rp_pad_ur = (axlPathOffset rp_pad_corner center_a)) 
	    (rp_pad_ur = TBX_DBCORE_Rotate_Rpath(rp_pad_ur 180.0 center_a nil)) 
	    (rp_pad_ur = (axlPathOffset rp_pad_ur pt_ur)) 
	    (rp_pad_ul = (axlPathOffset rp_pad_corner center_a))
	    (rp_pad_ul = TBX_DBCORE_Rotate_Rpath(rp_pad_ul 270.0 center_a nil)) 
	    (rp_pad_ul = (axlPathOffset rp_pad_ul pt_ul)) 
	    (rp_pad_ll = (axlPathOffset rp_pad_corner center_a)) 
	    (rp_pad_ll = (axlPathOffset rp_pad_ll pt_ll)) 
	    (rp_pad_lr = (axlPathOffset rp_pad_corner center_a))
	    (rp_pad_lr = TBX_DBCORE_Rotate_Rpath(rp_pad_lr 90.0 center_a nil)) 
	    (rp_pad_lr = (axlPathOffset rp_pad_lr pt_lr))
	) 
	when((angle_start > 0.0) 
	    (rp_coil_full = TBX_DBCORE_Rotate_Rpath(rp_coil_full angle_start center_a nil)) 
	    (rp_leader_start = TBX_DBCORE_Rotate_Rpath(rp_leader_start angle_start center_a nil)) 
	    (rp_pad_ur = TBX_DBCORE_Rotate_Rpath(rp_pad_ur angle_start center_a nil)) 
	    (rp_pad_ul = TBX_DBCORE_Rotate_Rpath(rp_pad_ul angle_start center_a nil))
	    (rp_pad_ll = TBX_DBCORE_Rotate_Rpath(rp_pad_ll angle_start center_a nil)) 
	    (rp_pad_lr = TBX_DBCORE_Rotate_Rpath(rp_pad_lr angle_start center_a nil)) 
	    (rp_coil_box = TBX_DBCORE_Rotate_Rpath(rp_coil_box angle_start center_a nil)) 
	    (coil_start_xy = (axlGeoRotatePt angle_start coil_start_xy center_a nil)) 
	    (coil_end_xy = (axlGeoRotatePt angle_start coil_end_xy center_a nil))
	) 
	when(((angle_start + angle_exit) > 0.0) 
	    (rp_leader_exit = TBX_DBCORE_Rotate_Rpath(rp_leader_exit 
		    (angle_start + angle_exit) center_a nil
		))
	)
	(tmp_path_data = list(list(rp_coil_full 
		    'etchPath
		) 
		list(rp_pad_ur 
		    'etchShape
		) 
		list(rp_pad_ul 
		    'etchShape
		) 
		list(rp_pad_ll 
		    'etchShape
		) 
		list(rp_pad_lr 
		    'etchShape
		)
		list(rp_leader_start 
		    'doc
		) 
		list(rp_leader_exit 
		    'doc
		) 
		list(rp_coil_box 
		    'doc
		)
	    )) 
	when(rp_coil_partial 
	    (rp_coil_partial = TBX_DBCORE_Rotate_Rpath(rp_coil_partial angle_start center_a nil)) 
	    (tmp_path_data = cons(list(rp_coil_partial 
			'etchPath
		    ) tmp_path_data
		))
	) 
	if(clockwise then 
	    foreach(entry tmp_path_data 
		(rp = car(entry)) 
		(rp_type = cadr(entry)) 
		(rp = TBX_DBCORE_Rotate_Rpath(rp 0.0 center_a t))
		(rp = TBX_DBCORE_Rotate_Rpath(rp 
			(-2 * (90.0 - angle_start)) center_a nil
		    )) 
		(path_data = cons(list(rp rp_type) path_data))
	    ) 
	    (coil_start_xy = (axlGeoRotatePt 0.0 coil_start_xy center_a t)) 
	    (coil_end_xy = (axlGeoRotatePt 0.0 coil_end_xy center_a t))
	    (coil_start_xy = (axlGeoRotatePt 
		    (-2 * (90.0 - angle_start)) coil_start_xy center_a nil
		)) 
	    (coil_end_xy = (axlGeoRotatePt 
		    (-2 * (90.0 - angle_start)) coil_end_xy center_a nil
		)) else 
	    (path_data = tmp_path_data)
	) 
	(result->xyStart = coil_start_xy) 
	(result->xyEnd = coil_end_xy)
	(result->path = path_data) 
	(result->bBox = coil_box) result
    )
)
procedure(TBX_COILADV_SPIRAL_RND_Callback(form_handle) 
    let((msg angle spiral_type) 
	(spiral_type = (form_handle->spiralType)) 
	case((form_handle->curField) 
	    ("radiusR1" 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] 
		    (form_handle->curValue) 
		    'radiusR1
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("windingSpace" 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] 
		    (form_handle->curValue) 
		    'windingSpace
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("windingWidth" 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] 
		    (form_handle->curValue) 
		    'windingWidth
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("nrOfTurns" 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] 
		    (form_handle->curValue) 
		    'nrOfTurns
		) 
		TBX_COILADV_Update_Dynamics()
	    )
	    ("angleStart" 
		(angle = TBX_COILADV_Normalize_Angle((form_handle->curValue))) 
		(axlFormSetField form_handle "angleStart" angle) 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] angle 
		    'angleStart
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("angleExit" 
		(angle = TBX_COILADV_Normalize_Angle((form_handle->curValue))) 
		(axlFormSetField form_handle "angleExit" angle) 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] angle 
		    'angleExit
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("clockwise" 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] 
		    (form_handle->curValue) 
		    'clockwise
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("done" 
		(msg = msg) 
		(axlFormClose form_handle)
	    ) 
	    ("cancel" 
		(axlFormClose form_handle)
	    )
	    ("my_help" 
		(axlShell "tbx help coiladv")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_COILADV_SPIRAL_S90_Calculate(param) 
    let((path_data rp_coil_full rp_coil_partial rp_leader_start rp_leader_exit
	    width spacing turn_start_x turn_start_y nr_of_turns
	    inner_radius PI center_a center_b radius_diff
	    radius_a radius_b turn_end_x turn_end_y angle_rad
	    radius_r2 clockwise angle_start angle_exit full_turns
	    break_line_start break_line_end break_path angle_range tmp_path_data
	    rp rp_type leg_size hypo_radius endcap_width
	    corner_radius coil_box offset rp_pad rp_pad_corner
	    box_ll box_ur pt_ur pt_ul pt_ll
	    rp_pad_inner rp_pad_ur rp_pad_ul rp_pad_ll result
	    coil_start_xy coil_end_xy rp_coil_box
	) 
	(PI = ((tbx_coiladv_data->constants)->PI)) 
	(result = ncons(nil)) 
	(width = (param->windingWidth)) 
	(spacing = (param->windingSpace))
	(inner_radius = (param->radiusR1)) 
	(nr_of_turns = (param->nrOfTurns)) 
	(radius_r2 = (param->radiusR2)) 
	(clockwise = (param->clockwise)) 
	(angle_start = (param->angleStart))
	(angle_exit = (param->angleExit)) 
	(radius_diff = ((width + spacing) / 2.0)) 
	(center_a = (0.0:0.0)) 
	(center_b = ((car(center_a) + radius_diff):cadr(center_a))) 
	(radius_a = (inner_radius + (width / 2.0)))
	(radius_b = (radius_a + radius_diff)) 
	(turn_start_x = (car(center_a) + radius_a)) 
	(turn_start_y = cadr(center_a)) 
	(coil_start_xy = (turn_start_x:turn_start_y)) 
	(leg_size = (turn_start_x - car(center_b)))
	(hypo_radius = (inner_radius + radius_diff)) 
	(endcap_width = width) 
	(corner_radius = (radius_r2 - spacing - width)) 
	(rp_coil_full = (axlPathStart 
		list((turn_start_x:turn_start_y)) 0.0
	    )) 
	if((angle_exit == 0.0) then 
	    (full_turns = nr_of_turns) else 
	    (full_turns = (nr_of_turns - 1))
	)
	(rp_leader_start = (axlPathStart 
		list(center_a 
		    (turn_start_x:turn_start_y)
		) 0.0
	    )) 
	(rp_leader_exit = (axlPathStart 
		list(center_a 
		    (turn_start_x:turn_start_y)
		) 0.0
	    )) 
	for(i 1 full_turns 
	    (rp_coil_full = (axlPathArcCenter rp_coil_full width 
		    ((car(center_a) - radius_a):cadr(center_a)) nil
		    center_a
		)) 
	    (rp_coil_full = (axlPathArcCenter rp_coil_full width 
		    (car(center_b):(cadr(center_b) - radius_b)) nil
		    center_b
		))
	    (rp_coil_full = (axlPathLine rp_coil_full width 
		    (((car(center_b) + radius_b) - radius_r2):(cadr(center_b) - radius_b))
		)) 
	    (rp_coil_full = (axlPathArcAngle rp_coil_full width 
		    ((car(center_b) + radius_b):((cadr(center_b) - radius_b) + radius_r2)) nil
		    90.0
		)) 
	    (turn_end_x = (car(center_b) + radius_b)) 
	    (turn_end_y = cadr(center_b)) 
	    (rp_coil_full = (axlPathLine rp_coil_full width 
		    (turn_end_x:turn_end_y)
		))
	    (radius_a = (radius_a + width + spacing)) 
	    (radius_b = (radius_a + radius_diff)) 
	    (radius_r2 = (radius_r2 + width + spacing)) 
	    (coil_end_xy = (radius_a:cadr(coil_start_xy)))
	) 
	when((angle_exit > 0.0) 
	    (rp_coil_partial = (axlPathStart 
		    list((turn_end_x:turn_end_y)) 0.0
		)) 
	    (rp_coil_partial = (axlPathArcCenter rp_coil_partial width 
		    ((car(center_a) - radius_a):cadr(center_a)) nil
		    center_a
		)) 
	    (rp_coil_partial = (axlPathArcCenter rp_coil_partial width 
		    (car(center_b):(cadr(center_b) - radius_b)) nil
		    center_b
		)) 
	    (rp_coil_partial = (axlPathLine rp_coil_partial width 
		    (((car(center_b) + radius_b) - radius_r2):(cadr(center_b) - radius_b))
		))
	    (rp_coil_partial = (axlPathArcAngle rp_coil_partial width 
		    ((car(center_b) + radius_b):((cadr(center_b) - radius_b) + radius_r2)) nil
		    90.0
		)) 
	    (rp_coil_partial = (axlPathLine rp_coil_partial width 
		    ((car(center_b) + radius_b):cadr(center_b))
		)) 
	    (angle_rad = ((angle_exit / 360.0) * 2 * PI)) 
	    (break_line_start = center_a) 
	    (break_line_end = (((cos(angle_rad) * radius_a) + car(center_a)):((sin(angle_rad) * radius_a) + cadr(center_a))))
	    (break_path = (axlPathStart 
		    list(break_line_start break_line_end) 0.2
		)) 
	    (angle_range = list((floor((angle_exit / 90.0)) * 90) 
		    (ceiling((angle_exit / 90.0)) * 90)
		)) 
	    (rp_coil_partial = TBX_COILADV_Break_Turn_Path(rp_coil_partial break_path center_a angle_range)) 
	    if((rp_coil_partial && (length((axlPathGetLastPathSeg rp_coil_partial)) > 1)) then 
		(coil_end_xy = (axlPathSegGetEndPoint 
			(axlPathGetLastPathSeg rp_coil_partial)
		    )) else 
		(rp_coil_partial = nil)
	    )
	) 
	if(rp_coil_partial then 
	    (coil_box = TBX_UTIL_Get_Extents(list(rp_coil_full rp_coil_partial) ?axlPathCenter t)) else 
	    (coil_box = TBX_UTIL_Get_Extents(list(rp_coil_full) ?axlPathCenter t))
	)
	(rp_pad = TBX_COILADV_Calculate_Pad_Shape(leg_size hypo_radius endcap_width corner_radius)) 
	(rp_pad_corner = TBX_COILADV_Calculate_Triangle_Shape(leg_size leg_size corner_radius 
		(endcap_width / 2.0)
	    )) 
	(box_ll = car(coil_box)) 
	(box_ur = cadr(coil_box)) 
	(rp_coil_box = (axlPathStart 
		list((car((lowerLeft coil_box)):
			cadr((lowerLeft coil_box))) 
		    (car((upperRight coil_box)):
			cadr((lowerLeft coil_box))) 
		    (car((upperRight coil_box)):
			cadr((upperRight coil_box))) 
		    (car((lowerLeft coil_box)):
			cadr((upperRight coil_box))) 
		    (car((lowerLeft coil_box)):
			cadr((lowerLeft coil_box)))
		) 0.0
	    ))
	(offset = 0.0) 
	(pt_ur = ((car(box_ur) - offset):(cadr(box_ur) - offset))) 
	(pt_ul = ((car(box_ll) + offset):(cadr(box_ur) - offset))) 
	(pt_ll = ((car(box_ll) + offset):(cadr(box_ll) + offset))) 
	when(rp_pad 
	    (rp_pad_inner = (axlPathOffset rp_pad center_b)) 
	    (rp_pad_ur = (axlPathOffset rp_pad_corner center_a)) 
	    (rp_pad_ur = TBX_DBCORE_Rotate_Rpath(rp_pad_ur 180.0 center_a nil)) 
	    (rp_pad_ur = (axlPathOffset rp_pad_ur pt_ur))
	    (rp_pad_ul = (axlPathOffset rp_pad_corner center_a)) 
	    (rp_pad_ul = TBX_DBCORE_Rotate_Rpath(rp_pad_ul 270.0 center_a nil)) 
	    (rp_pad_ul = (axlPathOffset rp_pad_ul pt_ul)) 
	    (rp_pad_ll = (axlPathOffset rp_pad_corner center_a)) 
	    (rp_pad_ll = (axlPathOffset rp_pad_ll pt_ll))
	)
	when((angle_start > 0.0) 
	    (rp_coil_full = TBX_DBCORE_Rotate_Rpath(rp_coil_full angle_start center_a nil)) 
	    (rp_leader_start = TBX_DBCORE_Rotate_Rpath(rp_leader_start angle_start center_a nil)) 
	    (rp_pad_inner = TBX_DBCORE_Rotate_Rpath(rp_pad_inner angle_start center_a nil)) 
	    (rp_pad_ur = TBX_DBCORE_Rotate_Rpath(rp_pad_ur angle_start center_a nil))
	    (rp_pad_ul = TBX_DBCORE_Rotate_Rpath(rp_pad_ul angle_start center_a nil)) 
	    (rp_pad_ll = TBX_DBCORE_Rotate_Rpath(rp_pad_ll angle_start center_a nil)) 
	    (rp_coil_box = TBX_DBCORE_Rotate_Rpath(rp_coil_box angle_start center_a nil)) 
	    (coil_start_xy = (axlGeoRotatePt angle_start coil_start_xy center_a nil)) 
	    (coil_end_xy = (axlGeoRotatePt angle_start coil_end_xy center_a nil))
	) 
	(tmp_path_data = list(list(rp_coil_full 
		    'etchPath
		) 
		list(rp_pad_inner 
		    'etchShape
		) 
		list(rp_pad_ur 
		    'etchShape
		) 
		list(rp_pad_ul 
		    'etchShape
		) 
		list(rp_pad_ll 
		    'etchShape
		)
		list(rp_leader_start 
		    'doc
		) 
		list(rp_coil_box 
		    'doc
		)
	    )) 
	when(rp_coil_partial 
	    (rp_coil_partial = TBX_DBCORE_Rotate_Rpath(rp_coil_partial angle_start center_a nil)) 
	    (tmp_path_data = cons(list(rp_coil_partial 
			'etchPath
		    ) tmp_path_data
		))
	) 
	when(((angle_start + angle_exit) > 0.0) 
	    (rp_leader_exit = TBX_DBCORE_Rotate_Rpath(rp_leader_exit 
		    (angle_start + angle_exit) center_a nil
		)) 
	    (tmp_path_data = cons(list(rp_leader_exit 
			'doc
		    ) tmp_path_data
		))
	) 
	if(clockwise then 
	    foreach(entry tmp_path_data 
		(rp = car(entry)) 
		(rp_type = cadr(entry)) 
		(rp = TBX_DBCORE_Rotate_Rpath(rp 0.0 center_a t))
		(rp = TBX_DBCORE_Rotate_Rpath(rp 
			(-2 * (90.0 - angle_start)) center_a nil
		    )) 
		(path_data = cons(list(rp rp_type) path_data))
	    ) 
	    (coil_start_xy = (axlGeoRotatePt 0.0 coil_start_xy center_a t)) 
	    (coil_end_xy = (axlGeoRotatePt 0.0 coil_end_xy center_a t))
	    (coil_start_xy = (axlGeoRotatePt 
		    (-2 * (90.0 - angle_start)) coil_start_xy center_a nil
		)) 
	    (coil_end_xy = (axlGeoRotatePt 
		    (-2 * (90.0 - angle_start)) coil_end_xy center_a nil
		)) else 
	    (path_data = tmp_path_data)
	)
	(result->xyStart = coil_start_xy) 
	(result->xyEnd = coil_end_xy) 
	(result->path = path_data) 
	(result->bBox = coil_box) result
    )
)
procedure(TBX_COILADV_SPIRAL_S90_Callback(form_handle) 
    let((msg angle spiral_type) 
	(spiral_type = (form_handle->spiralType)) 
	case((form_handle->curField) 
	    ("radiusR1" 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] 
		    (form_handle->curValue) 
		    'radiusR1
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("windingSpace" 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] 
		    (form_handle->curValue) 
		    'windingSpace
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("windingWidth" 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] 
		    (form_handle->curValue) 
		    'windingWidth
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("nrOfTurns" 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] 
		    (form_handle->curValue) 
		    'nrOfTurns
		) 
		TBX_COILADV_Update_Dynamics()
	    )
	    ("angleStart" 
		(angle = TBX_COILADV_Normalize_Angle((form_handle->curValue))) 
		(axlFormSetField form_handle "angleStart" angle) 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] angle 
		    'angleStart
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("angleExit" 
		(angle = TBX_COILADV_Normalize_Angle((form_handle->curValue))) 
		(axlFormSetField form_handle "angleExit" angle) 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] angle 
		    'angleExit
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("clockwise" 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] 
		    (form_handle->curValue) 
		    'clockwise
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("angleTheta" 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] 
		    (form_handle->curValue) 
		    'angleTheta
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("lengthL1" 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] 
		    (form_handle->curValue) 
		    'lengthL1
		) 
		TBX_COILADV_Update_Dynamics()
	    )
	    ("lengthL2" 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] 
		    (form_handle->curValue) 
		    'lengthL2
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("radiusR2" 
		putprop((tbx_coiladv_data->spiralParam)[spiral_type] 
		    (form_handle->curValue) 
		    'radiusR2
		) 
		TBX_COILADV_Update_Dynamics()
	    ) 
	    ("done" 
		(msg = msg) 
		(axlFormClose form_handle)
	    ) 
	    ("cancel" 
		(axlFormClose form_handle)
	    ) 
	    ("my_help" 
		(axlShell "tbx help coiladv")
	    )
	    (t t)
	)
    )
)
procedure(TBX_COILADV_Specify_Core_Param(core_type form_file callback_procedure) 
    let((fid field_name title_string) 
	unless(boundp('tbxCoreTypeHandle) 
	    defvar(tbxCoreTypeHandle nil)
	) 
	(title_string = strcat(core_type " parameters")) 
	(title_string = title_string) 
	(fid = (axlFormCreate 
		'tbxCoreTypeHandle form_file 
		'(e outer) callback_procedure
		t
	    ))
	when(fid 
	    foreach(prm 
		((tbx_coiladv_data->coreParam)[core_type]->?) 
		(field_name = symbolToString(prm)) 
		(axlFormSetField fid field_name 
		    get((tbx_coiladv_data->coreParam)[core_type] prm)
		)
	    ) 
	    putprop(fid core_type 
		'coreType
	    ) 
	    ((tbx_coiladv_data->formId)->coreParam = fid) 
	    TBX_COILADV_Update_Dynamics()
	    (axlFormDisplay fid)
	)
    )
)
procedure(TBX_COILADV_Specify_Spiral_Param(spiral_type form_file callback_procedure) 
    let((fid field_name title_string) 
	unless(boundp('tbxCoilTypeHandle) 
	    defvar(tbxCoilTypeHandle nil)
	) 
	(title_string = strcat(spiral_type " parameters")) 
	(title_string = title_string) 
	(fid = (axlFormCreate 
		'tbxCoilTypeHandle form_file 
		'(e outer) callback_procedure
		t
	    ))
	when(fid 
	    foreach(prm 
		((tbx_coiladv_data->spiralParam)[spiral_type]->?) 
		(field_name = symbolToString(prm)) 
		(axlFormSetField fid field_name 
		    get((tbx_coiladv_data->spiralParam)[spiral_type] prm)
		)
	    ) 
	    putprop(fid spiral_type 
		'spiralType
	    ) 
	    ((tbx_coiladv_data->formId)->spiralParam = fid) 
	    TBX_COILADV_Update_Dynamics()
	    (axlFormDisplay fid)
	)
    )
)
procedure(TBX_COILADV_Update_Dynamics() 
    let((refdes core_type spiral_type rpath cfg_data
	    comp_dbid
	) 
	(core_type = (axlFormGetField 
		((tbx_coiladv_data->formId)->mini) "core_type"
	    )) 
	(spiral_type = (axlFormGetField 
		((tbx_coiladv_data->formId)->mini) "spiral_type"
	    )) 
	(refdes = (axlFormGetField 
		((tbx_coiladv_data->formId)->mini) "refdes"
	    )) 
	(core_type = upperCase(core_type))
	(spiral_type = upperCase(spiral_type)) 
	(axlClearDynamics) 
	(comp_dbid = car(setof(c 
		    ((axlDBGetDesign)->components) 
		    ((c->name) == refdes)
		)
	    )) 
	unless((tbx_coiladv_data->coreParam)[((comp_dbid->compdef)->package)] 
	    printf("Warning: Missing configuration for Refdes %L with package %L." refdes 
		((comp_dbid->compdef)->package)
	    )
	) 
	when((core_type != "") 
	    (cfg_data = TBX_COILADV_Get_Implementation(core_type 
		    (tbx_coiladv_data->coreParam) 
		    (tbx_coiladv_data->cfgCoreType)
		)) 
	    when(cfg_data 
		(tbx_coiladv_data->coreData = funcall((cfg_data->calc) 
			(tbx_coiladv_data->coreParam)[core_type]
		    ))
	    ) 
	    (cfg_data = TBX_COILADV_Get_Implementation(spiral_type 
		    (tbx_coiladv_data->spiralParam) 
		    (tbx_coiladv_data->cfgSpiralType)
		)) 
	    when(cfg_data 
		(tbx_coiladv_data->spiralData = funcall((cfg_data->calc) 
			(tbx_coiladv_data->spiralParam)[spiral_type]
		    ))
	    )
	    when((tbx_coiladv_data->coreData) 
		foreach(entry 
		    ((tbx_coiladv_data->coreData)->path) 
		    (rpath = car(entry)) 
		    when((length((axlPathGetLastPathSeg rpath)) > 1) 
			when((cadr(entry) == 'outlinePath) 
			    (axlAddSimpleMoveDynamics 
				(0:0) rpath "path" ?color
				"PACKAGE GEOMETRY/ASSEMBLY_TOP"
			    )
			)
		    )
		)
	    ) 
	    when(((tbx_coiladv_data->spiralData)->path) 
		foreach(entry 
		    ((tbx_coiladv_data->spiralData)->path) 
		    (rpath = car(entry)) 
		    when((length((axlPathGetLastPathSeg rpath)) > 1) 
			if(((cadr(entry) == 'etchPath) || (cadr(entry) == 'etchShape)) then 
			    (axlAddSimpleMoveDynamics 
				(0:0) rpath "path" ?color
				'activeLayerColor
			    ) else 
			    (axlAddSimpleMoveDynamics 
				(0:0) rpath "path"
			    )
			)
		    )
		)
	    )
	)
    )
)
procedure(TBX_COILDES_Build_Shape_Poly(spiral_start_xy spiral_type cap_style_inner) 
    let((rpath result seg_poly_list poly_info ok_inner_offset
	    ok_outer_offset cap_a_poly cap_b_poly cap_a_path cap_b_path
	    clockwise center pt_start pt_end angle
	    angle_rad line_width spiral_end_xy pt_start_mod pt_end_mod
	    pt_x pt_y off_angle_rad offset ok_offset
	    axl_cap_style tmp_path
	) 
	(rpath = (axlPathOffset 
		((tbx_coildes_data->coilInfo)->path) spiral_start_xy
	    )) 
	(axl_cap_style = 'ROUND) 
	(ok_inner_offset = nil) 
	(ok_outer_offset = nil)
	(seg_poly_list = list()) 
	cond((((spiral_type == "octagon") || (spiral_type == "rectangle_mitered")) 
		(off_angle_rad = ((22.5 / 360.0) * 2 * (tbx_coildes_data->PI))) 
		when((cap_style_inner == "vertex") 
		    (axl_cap_style = 'SQUARE) 
		    (ok_inner_offset = t) 
		    (ok_outer_offset = t)
		)
	    ) 
	    ((spiral_type == "hexagon") 
		(off_angle_rad = ((30.0 / 360.0) * 2 * (tbx_coildes_data->PI))) 
		when((cap_style_inner == "vertex") 
		    (axl_cap_style = 'SQUARE) 
		    (ok_inner_offset = t) 
		    (ok_outer_offset = t)
		)
	    ) 
	    ((spiral_type == "rectangle") 
		(ok_inner_offset = nil) 
		when((cap_style_inner == "vertex") 
		    (axl_cap_style = 'SQUARE) 
		    (ok_outer_offset = t)
		)
	    ) 
	    ((spiral_type == "rectangle_rounded") 
		(ok_inner_offset = nil) 
		(ok_outer_offset = nil)
	    ) 
	    ((spiral_type == "rounded") 
		(ok_inner_offset = nil) 
		(ok_outer_offset = nil)
	    )
	) 
	(pt_start = spiral_start_xy) 
	(spiral_end_xy = (axlPathSegGetEndPoint 
		(axlPathGetLastPathSeg rpath)
	    )) 
	foreach(rseg 
	    cdr((axlPathGetPathSegs rpath)) 
	    (pt_end = (axlPathSegGetEndPoint rseg)) 
	    (line_width = (axlPathSegGetWidth rseg)) 
	    (pt_start_mod = pt_start)
	    (pt_end_mod = pt_end) 
	    (ok_offset = nil) 
	    when((ok_outer_offset && ((axlGeo2Str pt_start) == 
			(axlGeo2Str spiral_start_xy))) 
		(angle = TBX_GEOM_Get_Vector_Angle(pt_start pt_end)) 
		(angle_rad = ((angle / 360.0) * 2 * (tbx_coildes_data->PI))) 
		(pt_x = (car(pt_start) + ((cos(angle_rad) * line_width) / 2.0))) 
		(pt_y = (cadr(pt_start) + ((sin(angle_rad) * line_width) / 2.0)))
		(pt_start_mod = (pt_x:pt_y)) 
		(ok_offset = t)
	    ) 
	    when((ok_outer_offset && ((axlGeo2Str pt_end) == 
			(axlGeo2Str spiral_end_xy))) 
		(angle = (TBX_GEOM_Get_Vector_Angle(pt_start pt_end) + 180.0)) 
		(angle_rad = ((angle / 360.0) * 2 * (tbx_coildes_data->PI))) 
		(pt_x = (car(pt_end) + ((cos(angle_rad) * line_width) / 2.0))) 
		(pt_y = (cadr(pt_end) + ((sin(angle_rad) * line_width) / 2.0)))
		(pt_end_mod = (pt_x:pt_y)) 
		(ok_offset = t)
	    ) 
	    when((ok_inner_offset && ((axlGeo2Str pt_start) != 
			(axlGeo2Str spiral_start_xy))) 
		(offset = ((line_width / 2.0) * (1 - tan(off_angle_rad)))) 
		(angle = TBX_GEOM_Get_Vector_Angle(pt_start pt_end)) 
		(angle_rad = ((angle / 360.0) * 2 * (tbx_coildes_data->PI))) 
		(pt_x = (car(pt_start) + (cos(angle_rad) * offset)))
		(pt_y = (cadr(pt_start) + (sin(angle_rad) * offset))) 
		(pt_start_mod = (pt_x:pt_y)) 
		(ok_offset = t)
	    )
	    when((ok_inner_offset && ((axlGeo2Str pt_end) != 
			(axlGeo2Str spiral_end_xy))) 
		(offset = ((line_width / 2.0) * (1 - tan(off_angle_rad)))) 
		(angle = TBX_GEOM_Get_Vector_Angle(pt_start pt_end)) 
		(angle_rad = ((angle / 360.0) * 2 * (tbx_coildes_data->PI))) 
		(pt_x = (car(pt_end) - (cos(angle_rad) * offset)))
		(pt_y = (cadr(pt_end) - (sin(angle_rad) * offset))) 
		(pt_end_mod = (pt_x:pt_y)) 
		(ok_offset = t)
	    ) 
	    if(ok_offset then 
		(result = (axlDBCreatePath 
			(axlPathStart 
			    list(pt_start_mod pt_end_mod) line_width
			) 
			(tbx_coildes_data->tmpLayer)
		    )) else 
		(center = (axlPathSegGetArcCenter rseg))
		if(center then 
		    (clockwise = (axlPathSegGetArcClockwise rseg)) 
		    (tmp_path = (axlPathStart 
			    list(pt_start) 0.0
			)) 
		    (tmp_path = (axlPathArcCenter tmp_path line_width pt_end clockwise
			    center
			))
		    (result = (axlDBCreatePath tmp_path 
			    (tbx_coildes_data->tmpLayer)
			)) else 
		    (result = (axlDBCreatePath 
			    (axlPathStart 
				list(pt_start_mod pt_end_mod) line_width
			    ) 
			    (tbx_coildes_data->tmpLayer)
			))
		)
	    ) 
	    foreach(dbid 
		car(result) 
		foreach(seg 
		    (dbid->segments) 
		    when(((seg->width) != 0.0) 
			foreach(p 
			    (axlPolyFromDB seg ?endCapType axl_cap_style) 
			    (seg_poly_list = cons(p seg_poly_list))
			)
		    )
		) 
		(axlDeleteObject dbid)
	    ) 
	    (pt_start = pt_end)
	)
	if(onep(length(seg_poly_list)) then 
	    (poly_info = seg_poly_list) else 
	    (poly_info = (axlPolyOperation 
		    cdr(seg_poly_list) 
		    list(car(seg_poly_list)) 
		    'OR
		))
	) 
	(cap_a_path = (axlPathOffset 
		((tbx_coildes_data->coilInfo)->startCap) spiral_start_xy
	    )) 
	(cap_b_path = (axlPathOffset 
		((tbx_coildes_data->coilInfo)->endCap) spiral_start_xy
	    )) 
	(cap_a_poly = car((axlPolyFromDB cap_a_path))) 
	(cap_b_poly = car((axlPolyFromDB cap_b_path)))
	(poly_info = (axlPolyOperation poly_info 
		list(cap_a_poly cap_b_poly) 
		'OR
	    )) poly_info
    )
)
procedure(TBX_COILDES_Cache_Param(form_handle) 
    let((rec session_param field_list) 
	(rec = "coildes") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	(field_list = list("etch_layer" "route_keepout_layer" "add_route_keepout" "route_keepout_offset" "convert_to_shape"
		"shape_inner_endcap" "shape_outer_endcap" "first_padstack_name" "second_padstack_name" "add_first_padstack"
		"add_second_padstack" "rnd_line_width" "rnd_line_spacing" "rnd_inner_diameter_x" "rnd_nr_of_turns"
		"rnd_rotation" "rnd_cw_direction" "rect_line_width" "rect_line_spacing" "rect_inner_diameter_x"
		"rect_inner_diameter_y" "rect_nr_of_turns" "rect_rotation" "rect_cw_direction" "rect_change_corner"
		"rect_corner_style" "rect_corner_size" "oct_line_width" "oct_line_spacing" "oct_inner_diameter_x"
		"oct_nr_of_turns" "oct_rotation" "oct_cw_direction" "hex_line_width" "hex_line_spacing"
		"hex_inner_diameter_x" "hex_nr_of_turns" "hex_rotation" "hex_cw_direction"
	    ))
	foreach(fn field_list 
	    putprop(session_param[rec] 
		(axlFormGetField form_handle fn) 
		stringToSymbol(fn)
	    )
	) 
	putprop(session_param[rec] 
	    car((axlDBGetDesignUnits)) 
	    stringToSymbol("units")
	) t
    )
)
procedure(TBX_COILDES_Calculate_Hexagon_Spiral() 
    let((form_handle dest dest_x dest_y rpath
	    diam_x width spacing nr_of_turns rotation
	    cw_direction center_offset c_right c_left h_right
	    h_right_base h_right_next h_left h_left_base r_right
	    r_left dy_right dy_right_next dy_left r_right_inner
	    r_left_inner calc_width calc_height pt_list start_xy
	    end_xy result kppath kp_list keepout_offset
	    cap_outer_style cap_a_path cap_b_path
	) 
	(form_handle = (tbx_coildes_data->formid)) 
	(dest = (0.0:0.0)) 
	(diam_x = (axlFormGetField form_handle "hex_inner_diameter_x")) 
	(width = (axlFormGetField form_handle "hex_line_width"))
	(spacing = (axlFormGetField form_handle "hex_line_spacing")) 
	(nr_of_turns = (axlFormGetField form_handle "hex_nr_of_turns")) 
	(rotation = (axlFormGetField form_handle "hex_rotation")) 
	(cw_direction = (axlFormGetField form_handle "hex_cw_direction")) 
	(keepout_offset = (axlFormGetField form_handle "route_keepout_offset"))
	(cap_outer_style = (axlFormGetField form_handle "shape_outer_endcap")) 
	(dest_x = car(dest)) 
	(dest_y = cadr(dest)) 
	(start_xy = dest) 
	(center_offset = ((width + spacing) / (2.0 * cos(((30.0 * 2.0 * (tbx_coildes_data->PI)) / 360.0)))))
	(h_right_base = ((diam_x / 2.0) + (0.25 * (width - spacing)))) 
	(h_left_base = (h_right_base + ((width + spacing) / 2.0))) 
	(r_right_inner = ((h_right_base - (width / 2.0)) / cos(((30.0 * 2.0 * (tbx_coildes_data->PI)) / 360.0)))) 
	(r_left_inner = ((h_left_base - (width / 2.0)) / cos(((30.0 * 2.0 * (tbx_coildes_data->PI)) / 360.0)))) 
	(calc_width = (diam_x + (((2 * nr_of_turns) + 1) * width) + (((2 * nr_of_turns) - 1) * spacing)))
	(calc_height = (r_left_inner + r_right_inner + center_offset + (((2 * nr_of_turns * width) + (((2 * nr_of_turns) - 2.0) * spacing)) / cos(((30.0 * 2.0 * (tbx_coildes_data->PI)) / 360.0))))) 
	(c_right = list((dest_x - h_right_base) dest_y)) 
	(c_left = list((dest_x - h_right_base) 
		(dest_y - center_offset)
	    )) 
	(pt_list = cons(list(start_xy "line" nil nil) pt_list)) 
	for(n 1 nr_of_turns 
	    (h_right = (h_right_base + ((n - 1) * (width + spacing)))) 
	    (h_right_next = (h_right + width + spacing))
	    (h_left = (h_right + ((width + spacing) / 2.0))) 
	    (r_right = (h_right / cos(((30.0 * 2.0 * (tbx_coildes_data->PI)) / 360.0)))) 
	    (r_left = (h_left / cos(((30.0 * 2.0 * (tbx_coildes_data->PI)) / 360.0)))) 
	    (dy_right = (h_right * tan(((30.0 * 2.0 * (tbx_coildes_data->PI)) / 360.0)))) 
	    (dy_right_next = (h_right_next * tan(((30.0 * 2.0 * (tbx_coildes_data->PI)) / 360.0))))
	    (dy_left = (h_left * tan(((30.0 * 2.0 * (tbx_coildes_data->PI)) / 360.0)))) 
	    (pt_list = cons(list(((car(c_right) + h_right):(cadr(c_right) + dy_right)) "line" nil nil) pt_list)) 
	    (pt_list = cons(list((car(c_right):(cadr(c_right) + r_right)) "line" nil nil) pt_list)) 
	    (pt_list = cons(list(((car(c_left) - h_left):(cadr(c_left) + dy_left)) "line" nil nil) pt_list)) 
	    (pt_list = cons(list(((car(c_left) - h_left):(cadr(c_left) - dy_left)) "line" nil nil) pt_list))
	    (pt_list = cons(list((car(c_left):(cadr(c_left) - r_left)) "line" nil nil) pt_list)) 
	    (pt_list = cons(list(((car(c_right) + h_right_next):(cadr(c_right) - dy_right_next)) "line" nil nil) pt_list)) 
	    (pt_list = cons(list(((car(c_right) + h_right_next):dest_y) "line" nil nil) pt_list))
	)
	(end_xy = caar(pt_list)) 
	(pt_list = reverse(pt_list)) 
	(h_right = (h_right_base - (0.5 * width) - keepout_offset)) 
	(h_right_next = (h_right + width + spacing)) 
	(h_left = (h_right + ((width + spacing) / 2.0)))
	(r_right = (h_right / cos(((30.0 * 2.0 * (tbx_coildes_data->PI)) / 360.0)))) 
	(r_left = (h_left / cos(((30.0 * 2.0 * (tbx_coildes_data->PI)) / 360.0)))) 
	(dy_right = (h_right * tan(((30.0 * 2.0 * (tbx_coildes_data->PI)) / 360.0)))) 
	(dy_right_next = (h_right_next * tan(((30.0 * 2.0 * (tbx_coildes_data->PI)) / 360.0)))) 
	(dy_left = (h_left * tan(((30.0 * 2.0 * (tbx_coildes_data->PI)) / 360.0))))
	(kp_list = cons(list(((car(c_right) + h_right):(cadr(c_right) + dy_right)) "line" nil nil) kp_list)) 
	(kp_list = cons(list((car(c_right):(cadr(c_right) + r_right)) "line" nil nil) kp_list)) 
	(kp_list = cons(list(((car(c_left) - h_left):(cadr(c_left) + dy_left)) "line" nil nil) kp_list)) 
	(kp_list = cons(list(((car(c_left) - h_left):(cadr(c_left) - dy_left)) "line" nil nil) kp_list)) 
	(kp_list = cons(list((car(c_left):(cadr(c_left) - r_left)) "line" nil nil) kp_list))
	(kp_list = cons(list(((car(c_right) + h_right):(cadr(c_left) - dy_right_next)) "line" nil nil) kp_list)) 
	(kp_list = cons(list(((car(c_right) + h_right):(cadr(c_right) + dy_right)) "line" nil nil) kp_list)) 
	(kp_list = reverse(kp_list)) 
	(result = TBX_COILDES_Calculate_StartEnd_Caps(start_xy end_xy width cap_outer_style)) 
	(cap_a_path = car(result))
	(cap_b_path = cadr(result)) 
	(cap_a_path = TBX_COILDES_Transform_Rpath(cap_a_path rotation cw_direction dest)) 
	(cap_b_path = TBX_COILDES_Transform_Rpath(cap_b_path rotation cw_direction dest)) 
	(pt_list = TBX_COILDES_Transform(pt_list dest rotation cw_direction)) 
	(kp_list = TBX_COILDES_Transform(kp_list dest rotation cw_direction))
	(start_xy = caar(pt_list)) 
	(end_xy = caar(reverse(pt_list))) 
	(rpath = TBX_COILDES_Create_AXL_Path(pt_list width)) 
	(kppath = TBX_COILDES_Create_AXL_Path(kp_list 0.0)) 
	(tbx_coildes_data->coilInfo = list(nil 
		'path rpath 
		'sizeX calc_width
		'sizeY calc_height 
		'startXY start_xy 
		'endXY
		end_xy 
		'keepoutPath kppath 
		'startCap cap_a_path
		'endCap cap_b_path
	    ))
    )
)
procedure(TBX_COILDES_Calculate_Octagon_Spiral() 
    let((form_handle dest dest_x dest_y rpath
	    kppath diam_x width spacing nr_of_turns
	    rotation cw_direction cu cl ru
	    rl offu offl seg1 seg2
	    isec last_y poly poly_shrink poly_start
	    calc_width calc_height pt_list kp_list start_xy
	    end_xy xy keepout_offset result pt_x
	    pt_y cap_outer_style cap_a_path cap_b_path design_center
	) 
	(design_center = TBX_UTIL_Get_Box_Center(((axlGetParam "paramDesign")->bBox))) 
	(form_handle = (tbx_coildes_data->formid)) 
	(dest = (0.0:0.0)) 
	(diam_x = (axlFormGetField form_handle "oct_inner_diameter_x"))
	(width = (axlFormGetField form_handle "oct_line_width")) 
	(spacing = (axlFormGetField form_handle "oct_line_spacing")) 
	(nr_of_turns = (axlFormGetField form_handle "oct_nr_of_turns")) 
	(rotation = (axlFormGetField form_handle "oct_rotation")) 
	(cw_direction = (axlFormGetField form_handle "oct_cw_direction"))
	(keepout_offset = (axlFormGetField form_handle "route_keepout_offset")) 
	(cap_outer_style = (axlFormGetField form_handle "shape_outer_endcap")) 
	(calc_width = (diam_x + (((2 * nr_of_turns) + 1) * width) + (((2 * nr_of_turns) - 1) * spacing))) 
	(calc_height = (diam_x + (((2 * nr_of_turns) + 0.5) * width) + (((2 * nr_of_turns) - 1.5) * spacing))) 
	(dest_x = car(dest))
	(dest_y = cadr(dest)) 
	(start_xy = dest) 
	(cu = list((dest_x - ((diam_x / 2.0) + (width / 2.0))) dest_y)) 
	(cl = list((car(cu) + ((width + spacing) / 2.0)) dest_y)) 
	(pt_list = cons(list(start_xy "line" nil nil) pt_list))
	for(n 1 nr_of_turns 
	    (ru = ((diam_x / 2.0) + ((n - 1) * (width + spacing)) + (0.5 * width))) 
	    (rl = (ru + ((width + spacing) / 2.0)))
	    (offu = (ru * tan(((22.5 * 2 * (tbx_coildes_data->PI)) / 360.0)))) 
	    (offl = (rl * tan(((22.5 * 2 * (tbx_coildes_data->PI)) / 360.0)))) 
	    (pt_list = cons(list(((car(cu) + ru):(cadr(cu) + offu)) "line" nil nil) pt_list)) 
	    (pt_list = cons(list(((car(cu) + offu):(cadr(cu) + ru)) "line" nil nil) pt_list)) 
	    (pt_list = cons(list(((car(cu) - offu):(cadr(cu) + ru)) "line" nil nil) pt_list))
	    (pt_list = cons(list(((car(cu) - ru):(cadr(cu) + offu)) "line" nil nil) pt_list)) 
	    (pt_list = cons(list(((car(cl) - rl):(cadr(cl) - offl)) "line" nil nil) pt_list)) 
	    (pt_list = cons(list(((car(cl) - offl):(cadr(cl) - rl)) "line" nil nil) pt_list)) 
	    (pt_list = cons(list(((car(cl) + offl):(cadr(cl) - rl)) "line" nil nil) pt_list)) 
	    (pt_list = cons(list(((car(cl) + rl):(cadr(cl) - offl)) "line" nil nil) pt_list))
	    (pt_list = cons(list(((car(cl) + rl):dest_y) "line" nil nil) pt_list))
	) 
	(end_xy = caar(pt_list)) 
	(pt_list = reverse(pt_list)) 
	(ru = (diam_x / 2.0)) 
	(rl = (ru + ((width + spacing) / 2.0)))
	(offu = (ru * tan(((22.5 * 2 * (tbx_coildes_data->PI)) / 360.0)))) 
	(offl = (rl * tan(((22.5 * 2 * (tbx_coildes_data->PI)) / 360.0)))) 
	(seg1 = list(((car(cu) + ru):(cadr(cu) - rl)) 
		((car(cu) + ru):(cadr(cu) + rl))
	    )) 
	(seg2 = list(((car(cl) + offl):(cadr(cl) - rl)) 
		((car(cl) + rl + (width / 2.0)):((cadr(cl) - offl) + (width / 2.0)))
	    )) 
	(result = (axl_ol_ol2 seg1 seg2))
	when(result 
	    (isec = cadr(result)) 
	    (last_y = cadr(isec))
	) 
	(kp_list = cons(list(((car(cu) + ru):(cadr(cu) + offu)) "line" nil nil) kp_list)) 
	(kp_list = cons(list(((car(cu) + offu):(cadr(cu) + ru)) "line" nil nil) kp_list)) 
	(kp_list = cons(list(((car(cu) - offu):(cadr(cu) + ru)) "line" nil nil) kp_list)) 
	(kp_list = cons(list(((car(cu) - ru):(cadr(cu) + offu)) "line" nil nil) kp_list))
	(kp_list = cons(list(((car(cl) - rl):(cadr(cl) - offl)) "line" nil nil) kp_list)) 
	(kp_list = cons(list(((car(cl) - offl):(cadr(cl) - rl)) "line" nil nil) kp_list)) 
	(kp_list = cons(list(((car(cl) + offl):(cadr(cl) - rl)) "line" nil nil) kp_list)) 
	(kp_list = cons(list(((car(cu) + ru):last_y) "line" nil nil) kp_list)) 
	(kp_list = cons(list(((car(cu) + ru):(cadr(cl) + offu)) "line" nil nil) kp_list))
	kp_list 
	reverse(kp_list) 
	(kppath = (axlPathStart 
		list(caar(kp_list)) 0.0
	    )) 
	foreach(entry 
	    cdr(kp_list) 
	    (xy = car(entry)) 
	    (kppath = (axlPathLine kppath 0.0 xy))
	) 
	(poly = car((axlPolyFromDB 
		    (axlPathOffset kppath design_center)
		)
	    ))
	when((keepout_offset >= 0.0) 
	    (poly_shrink = car((axlPolyExpand 
			list(poly) 
			(-1.0 * keepout_offset) 
			'NONE
		    )
		)) 
	    (kp_list = list()) 
	    (poly_start = caar((poly_shrink->vertices))) 
	    foreach(vtx 
		(poly_shrink->vertices) 
		(pt_x = caar(vtx)) 
		(pt_y = cadar(vtx)) 
		(kp_list = cons(list(((pt_x - car(design_center)):(pt_y - cadr(design_center))) "line" nil nil) kp_list))
	    )
	    (kp_list = cons(list(((car(poly_start) - car(design_center)):(cadr(poly_start) - cadr(design_center))) "line" nil nil) kp_list))
	) 
	(result = TBX_COILDES_Calculate_StartEnd_Caps(start_xy end_xy width cap_outer_style)) 
	(cap_a_path = car(result)) 
	(cap_b_path = cadr(result)) 
	(cap_a_path = TBX_COILDES_Transform_Rpath(cap_a_path rotation cw_direction dest))
	(cap_b_path = TBX_COILDES_Transform_Rpath(cap_b_path rotation cw_direction dest)) 
	(pt_list = TBX_COILDES_Transform(pt_list dest rotation cw_direction)) 
	(kp_list = TBX_COILDES_Transform(kp_list dest rotation cw_direction)) 
	(start_xy = caar(pt_list)) 
	(end_xy = caar(reverse(pt_list)))
	(rpath = TBX_COILDES_Create_AXL_Path(pt_list width)) 
	(kppath = TBX_COILDES_Create_AXL_Path(kp_list 0.0)) 
	(tbx_coildes_data->coilInfo = list(nil 
		'path rpath 
		'sizeX calc_width
		'sizeY calc_height 
		'startXY start_xy 
		'endXY
		end_xy 
		'keepoutPath kppath 
		'startCap cap_a_path
		'endCap cap_b_path
	    ))
    )
)
procedure(TBX_COILDES_Calculate_Rectangle_Spiral() 
    let((form_handle dest dest_x dest_y rpath
	    diam_x diam_x_base diam_y diam_y_base radius
	    radius_base miter_len miter_len_base trim_len p1_x
	    p1_y p2_x p2_y p3_x p3_y
	    p4_x p4_y width spacing nr_of_turns
	    rotation cw_direction calc_width calc_height pt_list
	    start_xy end_xy mode corner_size_base origin_x
	    origin_y hn keepout_offset kppath result
	    kp_list cap_outer_style cap_a_path cap_b_path
	) 
	(form_handle = (tbx_coildes_data->formid)) 
	(dest = (0.0:0.0)) 
	(mode = "default") 
	when((axlFormGetField form_handle "rect_change_corner") 
	    case(lowerCase((axlFormGetField form_handle "rect_corner_style")) 
		("miter" 
		    (mode = "miter")
		) 
		("radius" 
		    (mode = "radius")
		) 
		(t 
		    (mode = "default")
		)
	    )
	)
	(diam_x_base = (axlFormGetField form_handle "rect_inner_diameter_x")) 
	(diam_y_base = (axlFormGetField form_handle "rect_inner_diameter_y")) 
	(width = (axlFormGetField form_handle "rect_line_width")) 
	(spacing = (axlFormGetField form_handle "rect_line_spacing")) 
	(nr_of_turns = (axlFormGetField form_handle "rect_nr_of_turns"))
	(rotation = (axlFormGetField form_handle "rect_rotation")) 
	(cw_direction = (axlFormGetField form_handle "rect_cw_direction")) 
	(corner_size_base = (axlFormGetField form_handle "rect_corner_size")) 
	(keepout_offset = (axlFormGetField form_handle "route_keepout_offset")) 
	(cap_outer_style = (axlFormGetField form_handle "shape_outer_endcap"))
	(radius_base = corner_size_base) 
	(miter_len_base = corner_size_base) 
	(hn = (miter_len_base / (2.0 * tan(((22.5 * 2.0 * (tbx_coildes_data->PI)) / 360.0))))) 
	(calc_width = (diam_x_base + (((2 * nr_of_turns) + 1) * width) + (((2 * nr_of_turns) - 1) * spacing))) 
	(calc_height = (diam_y_base + (2 * nr_of_turns * width) + (((2 * nr_of_turns) - 2.0) * spacing)))
	(dest_x = car(dest)) 
	(dest_y = cadr(dest)) 
	(pt_list = cons(list(dest "line" nil nil) pt_list)) 
	(origin_x = (dest_x - (diam_x_base / 2.0) - (width / 2.0))) 
	(origin_y = dest_y)
	(start_xy = dest) 
	for(n 1 nr_of_turns 
	    (diam_x = (diam_x_base + ((n - 1) * 2.0 * (width + spacing)))) 
	    (diam_y = (diam_y_base + ((n - 1) * 2.0 * (width + spacing))))
	    (miter_len = ((miter_len_base * (((n - 1) * (width + spacing)) + hn)) / hn)) 
	    (trim_len = (miter_len / sqrt(2.0))) 
	    (radius = (radius_base + ((n - 1) * (width + spacing)))) 
	    (p1_x = (origin_x + (diam_x / 2.0) + (width / 2.0))) 
	    (p1_y = (origin_y + (diam_y / 2.0) + (width / 2.0)))
	    (p2_x = (origin_x - (diam_x / 2.0) - (width / 2.0))) 
	    (p2_y = (origin_y + (diam_y / 2.0) + (width / 2.0))) 
	    (p3_x = (origin_x - (diam_x / 2.0) - (width / 2.0))) 
	    (p3_y = (origin_y - (diam_y / 2.0) - (width / 2.0))) 
	    (p4_x = (origin_x + (diam_x / 2.0) + (width / 2.0) + width + spacing))
	    (p4_y = (origin_y - (diam_y / 2.0) - (width / 2.0))) 
	    case(mode 
		("default" 
		    (pt_list = cons(list((p1_x:p1_y) "line" nil nil) pt_list)) 
		    (pt_list = cons(list((p2_x:p2_y) "line" nil nil) pt_list)) 
		    (pt_list = cons(list((p3_x:p3_y) "line" nil nil) pt_list)) 
		    (pt_list = cons(list((p4_x:p4_y) "line" nil nil) pt_list))
		    (pt_list = cons(list((p4_x:dest_y) "line" nil nil) pt_list))
		) 
		("radius" 
		    (pt_list = cons(list((p1_x:(p1_y - radius)) "line" nil nil) pt_list)) 
		    (pt_list = cons(list(((p1_x - radius):p1_y) "arc" radius cw_direction) pt_list)) 
		    (pt_list = cons(list(((p2_x + radius):p2_y) "line" nil nil) pt_list)) 
		    (pt_list = cons(list((p2_x:(p2_y - radius)) "arc" radius cw_direction) pt_list))
		    (pt_list = cons(list((p3_x:(p3_y + radius)) "line" nil nil) pt_list)) 
		    (pt_list = cons(list(((p3_x + radius):p3_y) "arc" radius cw_direction) pt_list)) 
		    (pt_list = cons(list(((p4_x - radius):p4_y) "line" nil nil) pt_list)) 
		    (pt_list = cons(list((p4_x:(p4_y + radius)) "arc" radius cw_direction) pt_list)) 
		    (pt_list = cons(list((p4_x:dest_y) "line" nil nil) pt_list))
		) 
		("miter" 
		    (pt_list = cons(list((p1_x:(p1_y - trim_len)) "line" nil nil) pt_list)) 
		    (pt_list = cons(list(((p1_x - trim_len):p1_y) "line" nil nil) pt_list)) 
		    (pt_list = cons(list(((p2_x + trim_len):p2_y) "line" nil nil) pt_list)) 
		    (pt_list = cons(list((p2_x:(p2_y - trim_len)) "line" nil nil) pt_list))
		    (pt_list = cons(list((p3_x:(p3_y + trim_len)) "line" nil nil) pt_list)) 
		    (pt_list = cons(list(((p3_x + trim_len):p3_y) "line" nil nil) pt_list)) 
		    (pt_list = cons(list(((p4_x - trim_len):p4_y) "line" nil nil) pt_list)) 
		    (pt_list = cons(list((p4_x:(p4_y + trim_len)) "line" nil nil) pt_list)) 
		    (pt_list = cons(list((p4_x:dest_y) "line" nil nil) pt_list))
		)
	    )
	) 
	(end_xy = caar(pt_list)) 
	(pt_list = reverse(pt_list)) 
	(diam_x = (diam_x_base - (2.0 * keepout_offset)))
	(diam_y = (diam_y_base - (2.0 * keepout_offset))) 
	(miter_len = ((miter_len_base * (hn - (width / 2.0) - keepout_offset)) / hn)) 
	(trim_len = (miter_len / sqrt(2.0))) 
	(radius = (radius_base - keepout_offset - (width / 2.0))) 
	(p1_x = (origin_x + (diam_x / 2.0)))
	(p1_y = (origin_y + (diam_y / 2.0))) 
	(p2_x = (origin_x - (diam_x / 2.0))) 
	(p2_y = (origin_y + (diam_y / 2.0))) 
	(p3_x = (origin_x - (diam_x / 2.0))) 
	(p3_y = (origin_y - (diam_y / 2.0)))
	(p4_x = (origin_x + (diam_x / 2.0))) 
	(p4_y = (origin_y - (diam_y / 2.0))) 
	case(mode 
	    ("default" 
		(kp_list = cons(list((p1_x:p1_y) "line" nil nil) kp_list)) 
		(kp_list = cons(list((p2_x:p2_y) "line" nil nil) kp_list)) 
		(kp_list = cons(list((p3_x:p3_y) "line" nil nil) kp_list)) 
		(kp_list = cons(list((p4_x:p4_y) "line" nil nil) kp_list))
		(kp_list = cons(list((p1_x:p1_y) "line" nil nil) kp_list))
	    ) 
	    ("radius" 
		if((radius > 0.0) then 
		    (kp_list = cons(list((p1_x:(p1_y - radius)) "line" nil nil) kp_list)) 
		    (kp_list = cons(list(((p1_x - radius):p1_y) "arc" radius cw_direction) kp_list)) 
		    (kp_list = cons(list(((p2_x + radius):p2_y) "line" nil nil) kp_list))
		    (kp_list = cons(list((p2_x:(p2_y - radius)) "arc" radius cw_direction) kp_list)) 
		    (kp_list = cons(list((p3_x:(p3_y + radius)) "line" nil nil) kp_list)) 
		    (kp_list = cons(list(((p3_x + radius):p3_y) "arc" radius cw_direction) kp_list)) 
		    (kp_list = cons(list(((p4_x - radius):p4_y) "line" nil nil) kp_list)) 
		    (kp_list = cons(list((p4_x:(p4_y + radius)) "arc" radius cw_direction) kp_list))
		    (kp_list = cons(list((p1_x:(p1_y - radius)) "line" nil nil) kp_list)) else 
		    (kp_list = cons(list((p1_x:p1_y) "line" nil nil) kp_list)) 
		    (kp_list = cons(list((p2_x:p2_y) "line" nil nil) kp_list)) 
		    (kp_list = cons(list((p3_x:p3_y) "line" nil nil) kp_list))
		    (kp_list = cons(list((p4_x:p4_y) "line" nil nil) kp_list)) 
		    (kp_list = cons(list((p1_x:p1_y) "line" nil nil) kp_list))
		)
	    ) 
	    ("miter" 
		if((miter_len > 0.0) then 
		    (kp_list = cons(list((p1_x:(p1_y - trim_len)) "line" nil nil) kp_list)) 
		    (kp_list = cons(list(((p1_x - trim_len):p1_y) "line" nil nil) kp_list)) 
		    (kp_list = cons(list(((p2_x + trim_len):p2_y) "line" nil nil) kp_list))
		    (kp_list = cons(list((p2_x:(p2_y - trim_len)) "line" nil nil) kp_list)) 
		    (kp_list = cons(list((p3_x:(p3_y + trim_len)) "line" nil nil) kp_list)) 
		    (kp_list = cons(list(((p3_x + trim_len):p3_y) "line" nil nil) kp_list)) 
		    (kp_list = cons(list(((p4_x - trim_len):p4_y) "line" nil nil) kp_list)) 
		    (kp_list = cons(list((p4_x:(p4_y + trim_len)) "line" nil nil) kp_list))
		    (kp_list = cons(list((p1_x:(p1_y - trim_len)) "line" nil nil) kp_list)) else 
		    (kp_list = cons(list((p1_x:p1_y) "line" nil nil) kp_list)) 
		    (kp_list = cons(list((p2_x:p2_y) "line" nil nil) kp_list)) 
		    (kp_list = cons(list((p3_x:p3_y) "line" nil nil) kp_list))
		    (kp_list = cons(list((p4_x:p3_y) "line" nil nil) kp_list)) 
		    (kp_list = cons(list((p1_x:p1_y) "line" nil nil) kp_list))
		)
	    )
	) 
	(kp_list = reverse(kp_list)) 
	(result = TBX_COILDES_Calculate_StartEnd_Caps(start_xy end_xy width cap_outer_style))
	(cap_a_path = car(result)) 
	(cap_b_path = cadr(result)) 
	(cap_a_path = TBX_COILDES_Transform_Rpath(cap_a_path rotation cw_direction dest)) 
	(cap_b_path = TBX_COILDES_Transform_Rpath(cap_b_path rotation cw_direction dest)) 
	(pt_list = TBX_COILDES_Transform(pt_list dest rotation cw_direction))
	(kp_list = TBX_COILDES_Transform(kp_list dest rotation cw_direction)) 
	(start_xy = caar(pt_list)) 
	(end_xy = caar(reverse(pt_list))) 
	(rpath = TBX_COILDES_Create_AXL_Path(pt_list width)) 
	(kppath = TBX_COILDES_Create_AXL_Path(kp_list 0.0))
	(tbx_coildes_data->coilInfo = list(nil 
		'path rpath 
		'sizeX calc_width
		'sizeY calc_height 
		'startXY start_xy 
		'endXY
		end_xy 
		'keepoutPath kppath 
		'startCap cap_a_path
		'endCap cap_b_path
	    ))
    )
)
procedure(TBX_COILDES_Calculate_Round_Spiral() 
    let((form_handle dest dest_x dest_y cu
	    cl ru rl rpath diam_x
	    width spacing nr_of_turns radius rotation
	    cw_direction calc_width calc_height pt_list start_xy
	    end_xy kppath keepout_offset result cap_outer_style
	    cap_a_path cap_b_path kp_list
	) 
	(form_handle = (tbx_coildes_data->formid)) 
	(dest = (0.0:0.0)) 
	(diam_x = (axlFormGetField form_handle "rnd_inner_diameter_x")) 
	(width = (axlFormGetField form_handle "rnd_line_width"))
	(spacing = (axlFormGetField form_handle "rnd_line_spacing")) 
	(nr_of_turns = (axlFormGetField form_handle "rnd_nr_of_turns")) 
	(rotation = (axlFormGetField form_handle "rnd_rotation")) 
	(cw_direction = (axlFormGetField form_handle "rnd_cw_direction")) 
	(keepout_offset = (axlFormGetField form_handle "route_keepout_offset"))
	(cap_outer_style = (axlFormGetField form_handle "shape_outer_endcap")) 
	(calc_width = (diam_x + (((2 * nr_of_turns) + 1) * width) + (((2 * nr_of_turns) - 1) * spacing))) 
	(calc_height = (diam_x + (((2 * nr_of_turns) + 0.5) * width) + (((2 * nr_of_turns) - 1.5) * spacing))) 
	(dest_x = car(dest)) 
	(dest_y = cadr(dest))
	(start_xy = dest) 
	(cu = list((dest_x - ((diam_x / 2.0) + (width / 2.0))) dest_y)) 
	(cl = list((car(cu) + ((width + spacing) / 2.0)) dest_y)) 
	(pt_list = cons(list(dest "line" nil nil) pt_list)) 
	for(n 1 nr_of_turns 
	    (ru = ((diam_x / 2.0) + ((n - 1) * (width + spacing)) + (0.5 * width))) 
	    (rl = (ru + ((width + spacing) / 2.0)))
	    (pt_list = cons(list(((car(cu) - ru):cadr(cu)) "arc" ru cw_direction) pt_list)) 
	    (pt_list = cons(list(((car(cl) + rl):cadr(cl)) "arc" rl cw_direction) pt_list))
	)
	(end_xy = caar(pt_list)) 
	(pt_list = reverse(pt_list)) 
	(radius = ((diam_x / 2.0) - keepout_offset)) 
	(kp_list = list()) 
	(kp_list = cons(list(((car(cu) + ((diam_x / 2.0) - keepout_offset)):cadr(cu)) "line" nil nil) kp_list))
	(kp_list = cons(list(((car(cu) - ((diam_x / 2.0) - keepout_offset)):cadr(cu)) "arc" radius nil) kp_list)) 
	(kp_list = cons(list(((car(cu) + ((diam_x / 2.0) - keepout_offset)):cadr(cu)) "arc" radius nil) kp_list)) 
	(kp_list = reverse(kp_list)) 
	(result = TBX_COILDES_Calculate_StartEnd_Caps(start_xy end_xy width cap_outer_style)) 
	(cap_a_path = car(result))
	(cap_b_path = cadr(result)) 
	(cap_a_path = TBX_COILDES_Transform_Rpath(cap_a_path rotation cw_direction dest)) 
	(cap_b_path = TBX_COILDES_Transform_Rpath(cap_b_path rotation cw_direction dest)) 
	(pt_list = TBX_COILDES_Transform(pt_list dest rotation cw_direction)) 
	(kp_list = TBX_COILDES_Transform(kp_list dest rotation cw_direction))
	(start_xy = caar(pt_list)) 
	(end_xy = caar(reverse(pt_list))) 
	(rpath = TBX_COILDES_Create_AXL_Path(pt_list width)) 
	(kppath = TBX_COILDES_Create_AXL_Path(kp_list 0.0)) 
	(tbx_coildes_data->coilInfo = list(nil 
		'path rpath 
		'sizeX calc_width
		'sizeY calc_height 
		'startXY start_xy 
		'endXY
		end_xy 
		'keepoutPath kppath 
		'startCap cap_a_path
		'endCap cap_b_path
	    ))
    )
)
procedure(TBX_COILDES_Calculate_StartEnd_Caps(start_xy end_xy width cap_style) 
    let((cap_a cap_b offset result radius
	    w_half start_x start_y end_x end_y
	) 
	(w_half = (width / 2.0)) 
	(radius = w_half) 
	(start_x = car(start_xy)) 
	(start_y = cadr(start_xy))
	(end_x = car(end_xy)) 
	(end_y = cadr(end_xy)) 
	case(cap_style 
	    ("square" 
		(cap_a = (axlPathStart 
			list(((start_x - w_half):start_y)) 0.0
		    )) 
		(cap_a = (axlPathLine cap_a 0.0 
			((start_x - w_half):(start_y - w_half))
		    )) 
		(cap_a = (axlPathLine cap_a 0.0 
			((start_x + w_half):(start_y - w_half))
		    )) 
		(cap_a = (axlPathLine cap_a 0.0 
			((start_x + w_half):start_y)
		    ))
		(cap_a = (axlPathArcAngle cap_a 0.0 
			((start_x - w_half):start_y) nil
			180.0
		    )) 
		(cap_b = (axlPathStart 
			list(((end_x - w_half):end_y)) 0.0
		    )) 
		(cap_b = (axlPathLine cap_b 0.0 
			((end_x - w_half):(end_y + w_half))
		    )) 
		(cap_b = (axlPathLine cap_b 0.0 
			((end_x + w_half):(end_y + w_half))
		    )) 
		(cap_b = (axlPathLine cap_b 0.0 
			((end_x + w_half):end_y)
		    ))
		(cap_b = (axlPathArcAngle cap_b 0.0 
			((end_x - w_half):end_y) t
			180.0
		    ))
	    ) 
	    ("octagon" 
		(offset = (w_half * tan(((22.5 * 2 * (tbx_coildes_data->PI)) / 360.0)))) 
		(cap_a = (axlPathStart 
			list(((start_x - w_half):start_y)) 0.0
		    )) 
		(cap_a = (axlPathLine cap_a 0.0 
			((start_x - w_half):(start_y - offset))
		    )) 
		(cap_a = (axlPathLine cap_a 0.0 
			((start_x - offset):(start_y - w_half))
		    ))
		(cap_a = (axlPathLine cap_a 0.0 
			((start_x + offset):(start_y - w_half))
		    )) 
		(cap_a = (axlPathLine cap_a 0.0 
			((start_x + w_half):(start_y - offset))
		    )) 
		(cap_a = (axlPathLine cap_a 0.0 
			((start_x + w_half):start_y)
		    )) 
		(cap_a = (axlPathArcAngle cap_a 0.0 
			((start_x - w_half):start_y) nil
			180.0
		    )) 
		(cap_b = (axlPathStart 
			list(((end_x + w_half):end_y)) 0.0
		    ))
		(cap_b = (axlPathLine cap_b 0.0 
			((end_x + w_half):(end_y + offset))
		    )) 
		(cap_b = (axlPathLine cap_b 0.0 
			((end_x + offset):(end_y + w_half))
		    )) 
		(cap_b = (axlPathLine cap_b 0.0 
			((end_x - offset):(end_y + w_half))
		    )) 
		(cap_b = (axlPathLine cap_b 0.0 
			((end_x - w_half):(end_y + offset))
		    )) 
		(cap_b = (axlPathLine cap_b 0.0 
			((end_x - w_half):end_y)
		    ))
		(cap_b = (axlPathArcAngle cap_b 0.0 
			((end_x + w_half):end_y) nil
			180.0
		    ))
	    ) 
	    ("round" 
		(cap_a = (axlPathStart 
			list(((start_x - radius):start_y)) 0.0
		    )) 
		(cap_a = (axlPathArcAngle cap_a 0.0 
			((start_x + radius):start_y) nil
			180.0
		    )) 
		(cap_a = (axlPathArcAngle cap_a 0.0 
			((start_x - radius):start_y) nil
			180.0
		    )) 
		(cap_b = (axlPathStart 
			list(((end_x - radius):end_y)) 0.0
		    ))
		(cap_b = (axlPathArcAngle cap_b 0.0 
			((end_x + radius):end_y) nil
			180.0
		    )) 
		(cap_b = (axlPathArcAngle cap_b 0.0 
			((end_x - radius):end_y) nil
			180.0
		    ))
	    ) 
	    (t t)
	) 
	(result = list(cap_a cap_b)) result
    )
)
procedure(TBX_COILDES_Callback(form_handle) 
    let((tab_name tmp diam_x cur_layer first_via
	    second_via via_list
	) 
	case((form_handle->curField) 
	    ("rnd_line_width" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("rnd_line_spacing" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("rnd_inner_diameter_x" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("rnd_scale" 
		(tmp = ((axlFormGetField form_handle "rnd_line_width") * 
			(form_handle->curValue))) 
		(axlFormSetField form_handle "rnd_line_width" tmp) 
		(tmp = ((axlFormGetField form_handle "rnd_line_spacing") * 
			(form_handle->curValue))) 
		(axlFormSetField form_handle "rnd_line_spacing" tmp)
		(tmp = ((axlFormGetField form_handle "rnd_inner_diameter_x") * 
			(form_handle->curValue))) 
		(axlFormSetField form_handle "rnd_inner_diameter_x" tmp) 
		TBX_COILDES_Update_Dynamics() 
		(axlFormSetField form_handle "rnd_scale" 1.0)
	    )
	    ("rnd_nr_of_turns" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("rnd_rotation" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("rnd_cw_direction" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("rect_line_width" 
		TBX_COILDES_Rectangle_Param_Cross_Check("width") 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("rect_line_spacing" 
		TBX_COILDES_Rectangle_Param_Cross_Check("spacing") 
		TBX_COILDES_Update_Dynamics()
	    )
	    ("rect_inner_diameter_x" 
		TBX_COILDES_Rectangle_Param_Cross_Check("diam_x") 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("rect_inner_diameter_y" 
		TBX_COILDES_Rectangle_Param_Cross_Check("diam_y") 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("rect_nr_of_turns" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("rect_rotation" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("rect_scale" 
		(tmp = ((axlFormGetField form_handle "rect_line_width") * 
			(form_handle->curValue))) 
		(axlFormSetField form_handle "rect_line_width" tmp) 
		(tmp = ((axlFormGetField form_handle "rect_line_spacing") * 
			(form_handle->curValue))) 
		(axlFormSetField form_handle "rect_line_spacing" tmp)
		(tmp = ((axlFormGetField form_handle "rect_inner_diameter_x") * 
			(form_handle->curValue))) 
		(axlFormSetField form_handle "rect_inner_diameter_x" tmp) 
		(tmp = ((axlFormGetField form_handle "rect_inner_diameter_y") * 
			(form_handle->curValue))) 
		(axlFormSetField form_handle "rect_inner_diameter_y" tmp) 
		TBX_COILDES_Rectangle_Param_Cross_Check("scale")
		TBX_COILDES_Update_Dynamics() 
		(axlFormSetField form_handle "rect_scale" 1.0)
	    )
	    ("rect_cw_direction" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("rect_change_corner" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "rect_corner_style" t) 
		    (axlFormSetFieldEditable form_handle "rect_corner_size" t) else
		    (axlFormSetFieldEditable form_handle "rect_corner_style" nil) 
		    (axlFormSetFieldEditable form_handle "rect_corner_size" nil)
		) 
		TBX_COILDES_Check_Endcap_Style((tbx_coildes_data->activeTab)) 
		TBX_COILDES_Update_Diagram() 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("rect_corner_style" 
		TBX_COILDES_Rectangle_Param_Cross_Check("corner_style") 
		TBX_COILDES_Update_Diagram() 
		TBX_COILDES_Check_Endcap_Style((tbx_coildes_data->activeTab)) 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("rect_corner_size" 
		TBX_COILDES_Rectangle_Param_Cross_Check("corner_size") 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("oct_line_width" 
		TBX_COILDES_Update_Dynamics()
	    )
	    ("oct_line_spacing" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("oct_inner_diameter_x" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("oct_scale" 
		(tmp = ((axlFormGetField form_handle "oct_line_width") * 
			(form_handle->curValue))) 
		(axlFormSetField form_handle "oct_line_width" tmp) 
		(tmp = ((axlFormGetField form_handle "oct_line_spacing") * 
			(form_handle->curValue))) 
		(axlFormSetField form_handle "oct_line_spacing" tmp)
		(tmp = ((axlFormGetField form_handle "oct_inner_diameter_x") * 
			(form_handle->curValue))) 
		(axlFormSetField form_handle "oct_inner_diameter_x" tmp) 
		TBX_COILDES_Update_Dynamics() 
		(axlFormSetField form_handle "oct_scale" 1.0)
	    ) 
	    ("oct_nr_of_turns" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("oct_rotation" 
		TBX_COILDES_Update_Dynamics()
	    )
	    ("oct_cw_direction" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("hex_line_width" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("hex_line_spacing" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("hex_inner_diameter_x" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("hex_scale" 
		(tmp = ((axlFormGetField form_handle "hex_line_width") * 
			(form_handle->curValue))) 
		(axlFormSetField form_handle "hex_line_width" tmp) 
		(tmp = ((axlFormGetField form_handle "hex_line_spacing") * 
			(form_handle->curValue))) 
		(axlFormSetField form_handle "hex_line_spacing" tmp)
		(tmp = ((axlFormGetField form_handle "hex_inner_diameter_x") * 
			(form_handle->curValue))) 
		(axlFormSetField form_handle "hex_inner_diameter_x" tmp) 
		TBX_COILDES_Update_Dynamics() 
		(axlFormSetField form_handle "hex_scale" 1.0)
	    )
	    ("hex_nr_of_turns" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("hex_rotation" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("hex_cw_direction" 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("coiltab" 
		(axlClearDynamics) 
		(tab_name = lowerCase((form_handle->curValue))) 
		cond((rexMatchp("round" tab_name) 
			(tbx_coildes_data->activeTab = "round")
		    ) 
		    (rexMatchp("rectangle" tab_name) 
			(tbx_coildes_data->activeTab = "rectangle")
		    ) 
		    (rexMatchp("octagon" tab_name) 
			(tbx_coildes_data->activeTab = "octagon")
		    ) 
		    (rexMatchp("hexagon" tab_name) 
			(tbx_coildes_data->activeTab = "hexagon")
		    )
		) 
		TBX_COILDES_Update_Diagram()
		TBX_COILDES_Check_Endcap_Style((tbx_coildes_data->activeTab)) 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("etch_layer" 
		(cur_layer = (form_handle->curValue)) 
		(via_list = TBX_COILDES_Get_Available_Vias(cur_layer)) 
		(first_via = (axlFormGetField form_handle "first_padstack_name")) 
		(second_via = (axlFormGetField form_handle "second_padstack_name"))
		(axlFormBuildPopup form_handle "first_padstack_name" via_list) 
		(axlFormBuildPopup form_handle "second_padstack_name" via_list) 
		unless(exists(x via_list 
			(upperCase(first_via) == x)
		    ) 
		    (first_via = car(via_list))
		) 
		unless(exists(x via_list 
			(upperCase(second_via) == x)
		    ) 
		    (second_via = car(via_list))
		) 
		(axlFormSetField form_handle "first_padstack_name" first_via)
		(axlFormSetField form_handle "second_padstack_name" second_via)
	    )
	    ("add_route_keepout" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "route_keepout_layer" t) 
		    (axlFormSetFieldEditable form_handle "route_keepout_offset" t) else
		    (axlFormSetFieldEditable form_handle "route_keepout_layer" nil) 
		    (axlFormSetFieldEditable form_handle "route_keepout_offset" nil)
		) 
		TBX_COILDES_Update_Diagram() 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("route_keepout_offset" 
		case((tbx_coildes_data->activeTab) 
		    ("round" 
			(diam_x = (axlFormGetField form_handle "rnd_inner_diameter_x")) 
			when((((diam_x / 2.0) - (form_handle->curValue)) <= 0.0) 
			    (axlUIWPrint form_handle 
				'warn "Offset too large"
			    ) 
			    (axlFormSetField form_handle "route_keepout_offset" 
				((diam_x / 2.0) - ((1.0 * 10.0) / (10.0**cadr((axlDBGetDesignUnits)))))
			    )
			)
		    ) 
		    ("rectangle" 
			TBX_COILDES_Rectangle_Param_Cross_Check("keepout_offset")
		    ) 
		    ("octagon" 
			(diam_x = (axlFormGetField form_handle "oct_inner_diameter_x")) 
			when((((diam_x / 2.0) - (form_handle->curValue)) <= 0.0) 
			    (axlUIWPrint form_handle 
				'warn "Offset too large"
			    ) 
			    (axlFormSetField form_handle "route_keepout_offset" 
				((diam_x / 2.0) - ((1.0 * 10.0) / (10.0**cadr((axlDBGetDesignUnits)))))
			    )
			)
		    ) 
		    ("hexagon" 
			TBX_COILDES_Hexagon_Param_Cross_Check("keepout_offset")
		    )
		) 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("convert_to_shape" 
		TBX_COILDES_Check_Endcap_Style((tbx_coildes_data->activeTab)) 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("shape_inner_endcap" 
		TBX_COILDES_Check_Endcap_Style((tbx_coildes_data->activeTab)) 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("shape_outer_endcap" 
		TBX_COILDES_Check_Endcap_Style((tbx_coildes_data->activeTab)) 
		TBX_COILDES_Update_Dynamics()
	    )
	    ("add_first_padstack" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "first_padstack_name" t) else 
		    (axlFormSetFieldEditable form_handle "first_padstack_name" nil)
		) 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("add_second_padstack" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "second_padstack_name" t) else 
		    (axlFormSetFieldEditable form_handle "second_padstack_name" nil)
		) 
		TBX_COILDES_Update_Dynamics()
	    ) 
	    ("place_geom" 
		TBX_COILDES_Update_Dynamics() 
		((tbx_coildes_data->eventHandler)->pickOrigin = t)
	    ) 
	    ("done" 
		(axlFinishEnterFun)
	    ) 
	    ("cancel" 
		(axlCancelEnterFun)
	    )
	    ("myhelp" 
		TBX_HELP_Launch("coildes")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_COILDES_Check_Endcap_Style(active_tab) 
    let((form_handle) 
	(form_handle = (tbx_coildes_data->formid)) 
	if((axlFormGetField form_handle "convert_to_shape") then 
	    (axlFormSetFieldEditable form_handle "shape_inner_endcap" t) 
	    (axlFormSetFieldEditable form_handle "shape_outer_endcap" t) 
	    when(((active_tab == "round") || ((active_tab == "rectangle") && (axlFormGetField form_handle "rect_change_corner") && 
			((axlFormGetField form_handle "rect_corner_style") == "radius"))) 
		(axlFormSetFieldEditable form_handle "shape_inner_endcap" nil)
	    )
	    else 
	    (axlFormSetFieldEditable form_handle "shape_inner_endcap" nil) 
	    (axlFormSetFieldEditable form_handle "shape_outer_endcap" nil)
	)
    )
)
procedure(TBX_COILDES_Cleanup() 
    let((param) 
	(axlVisibleLayer 
	    (tbx_coildes_data->tmpLayer) t
	) 
	(axlDeleteByLayer 
	    (tbx_coildes_data->tmpLayer)
	) 
	(param = (axlLayerGet 
		(tbx_coildes_data->tmpLayer)
	    )) 
	when(param 
	    (axlDeleteObject param)
	)
	(axlVisibleUpdate t) 
	(axlDBRefreshId nil)
    )
)
procedure(TBX_COILDES_Create_AXL_Path(pt_list width) 
    let((rp xy path_type radius cw_direction) 
	(rp = (axlPathStart 
		list(caar(pt_list)) 0.0
	    )) 
	foreach(entry 
	    cdr(pt_list) 
	    (xy = car(entry)) 
	    (path_type = cadr(entry)) 
	    (radius = caddr(entry))
	    (cw_direction = nth(3 entry)) 
	    case(path_type 
		("line" 
		    (rp = (axlPathLine rp width xy))
		) 
		("arc" 
		    (rp = (axlPathArcRadius rp width xy cw_direction
			    nil radius
			))
		)
	    )
	) rp
    )
)
procedure(TBX_COILDES_Draw_Spiral(xy_location) 
    let((rpath form_handle layer poly_info padstack_name
	    rotation start_x start_y end_x end_y
	    inner_endcap_style kp_layer kp_path spiral_type
	) 
	(form_handle = (tbx_coildes_data->formid)) 
	(axlClearDynamics) 
	case((tbx_coildes_data->activeTab) 
	    ("round" 
		(spiral_type = "round") 
		TBX_COILDES_Calculate_Round_Spiral()
	    ) 
	    ("rectangle" 
		(spiral_type = "rectangle") 
		when((axlFormGetField form_handle "rect_change_corner") 
		    if((lowerCase((axlFormGetField form_handle "rect_corner_style")) == "miter") then 
			(spiral_type = "rectangle_mitered") else 
			(spiral_type = "rectangle_rounded")
		    )
		) 
		TBX_COILDES_Calculate_Rectangle_Spiral()
	    ) 
	    ("octagon" 
		(spiral_type = "octagon") 
		TBX_COILDES_Calculate_Octagon_Spiral()
	    ) 
	    ("hexagon" 
		(spiral_type = "hexagon") 
		TBX_COILDES_Calculate_Hexagon_Spiral()
	    )
	) 
	(axlAddSimpleMoveDynamics 
	    (0:0) 
	    ((tbx_coildes_data->coilInfo)->path) "path"
	)
	when((axlFormGetField form_handle "add_route_keepout") 
	    (axlAddSimpleMoveDynamics 
		(0:0) 
		((tbx_coildes_data->coilInfo)->keepoutPath) "path"
	    )
	) 
	(axlDBTransactionMark 
	    (tbx_coildes_data->transMark)
	) 
	(rpath = (axlPathOffset 
		((tbx_coildes_data->coilInfo)->path) xy_location
	    )) 
	(layer = strcat((axlMapClassName "ETCH") "/" 
		(axlFormGetField form_handle "etch_layer")
	    )) 
	if((axlFormGetField form_handle "convert_to_shape") then 
	    (inner_endcap_style = (axlFormGetField form_handle "shape_inner_endcap")) 
	    (poly_info = TBX_COILDES_Build_Shape_Poly(xy_location spiral_type inner_endcap_style)) 
	    (axlDBCreateShape 
		car(poly_info) t layer
	    )
	    else 
	    (axlDBCreatePath rpath layer)
	)
	unless((axlIsVisibleLayer layer) 
	    (axlVisibleLayer layer t)
	) 
	when((axlFormGetField form_handle "add_route_keepout") 
	    (kp_path = (axlPathOffset 
		    ((tbx_coildes_data->coilInfo)->keepoutPath) xy_location
		)) 
	    (kp_layer = strcat((axlMapClassName "ROUTE KEEPOUT") "/" 
		    (axlFormGetField form_handle "route_keepout_layer")
		)) 
	    (axlVisibleLayer kp_layer t) 
	    (axlDBCreateShape kp_path t kp_layer)
	) 
	when((axlFormGetField form_handle "add_first_padstack") 
	    (padstack_name = (axlFormGetField form_handle "first_padstack_name")) 
	    (start_x = (car(((tbx_coildes_data->coilInfo)->startXY)) + car(xy_location))) 
	    (start_y = (cadr(((tbx_coildes_data->coilInfo)->startXY)) + cadr(xy_location))) 
	    (axlDBCreateVia padstack_name 
		(start_x:start_y) nil nil
		rotation nil
	    )
	) 
	when((axlFormGetField form_handle "add_second_padstack") 
	    (padstack_name = (axlFormGetField form_handle "second_padstack_name")) 
	    (end_x = (car(((tbx_coildes_data->coilInfo)->endXY)) + car(xy_location))) 
	    (end_y = (cadr(((tbx_coildes_data->coilInfo)->endXY)) + cadr(xy_location))) 
	    (axlDBCreateVia padstack_name 
		(end_x:end_y) nil nil
		rotation nil
	    )
	) 
	(axlVisibleUpdate t)
    )
)
procedure(TBX_COILDES_Event_Loop() 
    let((eventMask loop event) 
	(axlEventSetStartPopup 
	    'TBX_COILDES_Popup_Callback
	) 
	(eventMask = list('PICK)) 
	(loop = t) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil nil)) 
	    caseq((event->type) 
		(PICK 
		    if(((tbx_coildes_data->eventHandler)->pickOrigin) then 
			TBX_COILDES_Draw_Spiral((event->xy)) 
			(axlClearDynamics) 
			((tbx_coildes_data->eventHandler)->pickOrigin = nil)
			else 
			printf("Info: Use Place button or context menu RMB - Place Geom for final spiral structure.\n")
		    )
		) 
		(DONE 
		    (loop = nil) 
		    (axlDBTransactionCommit 
			(tbx_coildes_data->transMark)
		    ) 
		    (axlClearDynamics) 
		    TBX_COILDES_Cache_Param((tbx_coildes_data->formid))
		    (axlFormClose 
			(tbx_coildes_data->formid)
		    )
		) 
		(CANCEL 
		    (loop = nil) 
		    (axlDBTransactionOops 
			(tbx_coildes_data->transMark)
		    ) 
		    (axlDBTransactionCommit 
			(tbx_coildes_data->transMark)
		    ) 
		    (axlClearDynamics)
		    (axlClearDynamics) 
		    (axlFormClose 
			(tbx_coildes_data->formid)
		    )
		)
	    )
	)
	(axlEventSetStartPopup)
    )
)
procedure(TBX_COILDES_Get_Available_Vias(layer_name) 
    let((via_list cnt layerId start_layer end_layer
	    start_id end_id cur_id
	) 
	(cnt = 0) 
	(layerId = makeTable("layer_id_table" nil)) 
	foreach(lyr 
	    (axlSubclassRoute) 
	    (layerId[lyr] = ++cnt)
	) 
	(cur_id = layerId[layer_name])
	foreach(v 
	    (axlGetAllViaList) 
	    (start_layer = car((v->startEnd))) 
	    (end_layer = cadr((v->startEnd))) 
	    (start_layer = cadr(parseString(start_layer "/")))
	    (end_layer = cadr(parseString(end_layer "/"))) 
	    (start_id = layerId[start_layer]) 
	    (end_id = layerId[end_layer]) 
	    when(((start_id <= cur_id) && (cur_id <= end_id)) 
		(via_list = cons(upperCase((v->name)) via_list))
	    )
	) 
	(via_list = sort(via_list nil)) 
	when(zerop(length(via_list)) 
	    (via_list = list("<No via available>"))
	) via_list
    )
)
procedure(TBX_COILDES_Hexagon_Param_Cross_Check(param) 
    let((form_handle diam_x width spacing keepout_offset
	    h_right
	) 
	(form_handle = (tbx_coildes_data->formid)) 
	(diam_x = (axlFormGetField form_handle "hex_inner_diameter_x")) 
	(width = (axlFormGetField form_handle "hex_line_width")) 
	(spacing = (axlFormGetField form_handle "hex_line_spacing"))
	(keepout_offset = (axlFormGetField form_handle "route_keepout_offset")) 
	(h_right = (((diam_x / 2.0) + (0.25 * (width - spacing))) - (width / 2.0))) 
	when(((h_right - keepout_offset) <= 0.0) 
	    (axlFormSetField form_handle "route_keepout_offset" 
		(h_right - ((1.0 * 10.0) / (10.0**cadr((axlDBGetDesignUnits)))))
	    ) 
	    when((param == "keepout_offset") 
		(axlUIWPrint form_handle 
		    'warn "Offset too large"
		)
	    )
	)
    )
)
procedure(TBX_COILDES_Init() 
    let((mth tmp_layer) 
	(mth = 'const) 
	defMathConstants(mth) 
	(tmp_layer = "MANUFACTURING/TMP_DRAFTING") 
	unless((axlIsLayer tmp_layer) 
	    (axlLayerCreateNonConductor tmp_layer)
	)
	unless(boundp('tbx_coildes_data) 
	    iliDefstruct('defstruct(tbx_coildes_data_struct PI transMark formid activeTab
			coilInfo tmpLayer licCheck eventHandler
		    )
	    ) 
	    defvar(tbx_coildes_data nil)
	) 
	if(!tbx_coildes_data then 
	    (tbx_coildes_data = (make_tbx_coildes_data_struct ?activeTab nil ?coilInfo nil
		    ?PI 
		    (const.PI) ?transMark nil ?formid
		    nil ?tmpLayer tmp_layer ?licCheck nil
		    ?eventHandler 
		    ncons(nil)
		)) else 
	    (tbx_coildes_data->activeTab = nil)
	    (tbx_coildes_data->coilInfo = nil) 
	    (tbx_coildes_data->PI = (const.PI)) 
	    (tbx_coildes_data->transMark = nil) 
	    (tbx_coildes_data->formid = nil) 
	    (tbx_coildes_data->tmpLayer = tmp_layer)
	    (tbx_coildes_data->licCheck = nil) 
	    (tbx_coildes_data->eventHandler = ncons(nil))
	)
    )
)
procedure(TBX_COILDES_Init_Form(form_handle) 
    let((via_list width_default spacing_default diam_default cfg
	    design_precision field_name default_value unit_convert cur_layer
	    first_via second_via default_via factor design_type
	    COND_TOP_LAYER
	) 
	(factor = 1.0) 
	(design_type = upperCase((axlDesignType t))) 
	when(((design_type == "MCM") || (design_type == "SIP")) 
	    (factor = 4.0)
	) 
	(axlBuildSubclassPopup form_handle "etch_layer" 
	    (axlMapClassName "ETCH")
	)
	(axlBuildSubclassPopup form_handle "route_keepout_layer" 
	    (axlMapClassName "ROUTE KEEPOUT")
	) 
	(width_default = (TBX_UTIL_Smart_Convert("1.0 MM" "40.0 MILS") / factor)) 
	(spacing_default = (TBX_UTIL_Smart_Convert("1.0 MM" "40.0 MILS") / factor)) 
	(diam_default = (TBX_UTIL_Smart_Convert("10.0 MM" "400.0 MILS") / factor)) 
	(axlFormSetField form_handle "rnd_extents_info" "----")
	(axlFormSetField form_handle "rect_extents_info" "----") 
	(axlFormSetField form_handle "oct_extents_info" "----") 
	(axlFormSetField form_handle "hex_extents_info" "----") 
	(axlFormSetField form_handle "rnd_scale" 1.0) 
	(axlFormSetField form_handle "rect_scale" 1.0)
	(axlFormSetField form_handle "oct_scale" 1.0) 
	(axlFormSetField form_handle "hex_scale" 1.0) 
	(COND_TOP_LAYER = (axlConductorTopLayer)) 
	(cfg = list(list("etch_layer" COND_TOP_LAYER nil) 
		list("route_keepout_layer" "ALL" nil) 
		list("add_route_keepout" nil nil) 
		list("route_keepout_offset" 0.0 t) 
		list("convert_to_shape" nil nil)
		list("shape_inner_endcap" "round" nil) 
		list("shape_outer_endcap" "round" nil) 
		list("add_first_padstack" nil nil) 
		list("add_second_padstack" nil nil) 
		list("rnd_line_width" width_default t)
		list("rnd_line_spacing" spacing_default t) 
		list("rnd_inner_diameter_x" 
		    (TBX_UTIL_Smart_Convert("6.0 MM" "240.0 MILS") / factor) t
		) 
		list("rnd_nr_of_turns" 3 nil) 
		list("rnd_rotation" 0.0 nil) 
		list("rnd_cw_direction" nil nil)
		list("rect_line_width" width_default t) 
		list("rect_line_spacing" spacing_default t) 
		list("rect_inner_diameter_x" diam_default t) 
		list("rect_inner_diameter_y" diam_default t) 
		list("rect_nr_of_turns" 3 nil)
		list("rect_rotation" 0.0 nil) 
		list("rect_cw_direction" nil nil) 
		list("rect_change_corner" nil nil) 
		list("rect_corner_style" "miter" nil) 
		list("rect_corner_size" 
		    (diam_default / 4.0) t
		)
		list("oct_line_width" width_default t) 
		list("oct_line_spacing" spacing_default t) 
		list("oct_inner_diameter_x" diam_default t) 
		list("oct_nr_of_turns" 3 nil) 
		list("oct_rotation" 0.0 nil)
		list("oct_cw_direction" nil nil) 
		list("hex_line_width" width_default t) 
		list("hex_line_spacing" spacing_default t) 
		list("hex_inner_diameter_x" diam_default t) 
		list("hex_nr_of_turns" 3 nil)
		list("hex_rotation" 0.0 nil) 
		list("hex_cw_direction" nil nil)
	    )) 
	(design_precision = cadr((axlDBGetDesignUnits)))
	foreach(entry cfg 
	    (field_name = car(entry)) 
	    (default_value = cadr(entry)) 
	    (unit_convert = caddr(entry))
	    (axlFormSetField form_handle field_name 
		TBX_SESSION_Get_Param("coildes" field_name default_value unit_convert)
	    ) 
	    when(unit_convert 
		(axlFormSetDecimal form_handle field_name design_precision)
	    )
	) 
	(cur_layer = (axlFormGetField form_handle "etch_layer")) 
	(via_list = TBX_COILDES_Get_Available_Vias(cur_layer)) 
	(default_via = car(via_list)) 
	(axlFormBuildPopup form_handle "first_padstack_name" via_list)
	(axlFormBuildPopup form_handle "second_padstack_name" via_list) 
	(first_via = TBX_SESSION_Get_Param("coildes" "first_padstack_name" default_via)) 
	(second_via = TBX_SESSION_Get_Param("coildes" "second_padstack_name" default_via)) 
	unless(exists(x via_list 
		(upperCase(first_via) == x)
	    ) 
	    (first_via = default_via)
	) 
	unless(exists(x via_list 
		(upperCase(second_via) == x)
	    ) 
	    (second_via = default_via)
	)
	(axlFormSetField form_handle "first_padstack_name" first_via) 
	(axlFormSetField form_handle "second_padstack_name" second_via) 
	if((axlFormGetField form_handle "add_route_keepout") then 
	    (axlFormSetFieldEditable form_handle "route_keepout_layer" t) 
	    (axlFormSetFieldEditable form_handle "route_keepout_offset" t) else
	    (axlFormSetFieldEditable form_handle "route_keepout_layer" nil) 
	    (axlFormSetFieldEditable form_handle "route_keepout_offset" nil)
	) 
	TBX_COILDES_Check_Endcap_Style((tbx_coildes_data->activeTab)) 
	if((axlFormGetField form_handle "add_first_padstack") then 
	    (axlFormSetFieldEditable form_handle "first_padstack_name" t) else 
	    (axlFormSetFieldEditable form_handle "first_padstack_name" nil)
	)
	if((axlFormGetField form_handle "add_second_padstack") then 
	    (axlFormSetFieldEditable form_handle "second_padstack_name" t) else 
	    (axlFormSetFieldEditable form_handle "second_padstack_name" nil)
	) 
	if((axlFormGetField form_handle "rect_change_corner") then 
	    (axlFormSetFieldEditable form_handle "rect_corner_style" t) 
	    (axlFormSetFieldEditable form_handle "rect_corner_size" t) else
	    (axlFormSetFieldEditable form_handle "rect_corner_style" nil) 
	    (axlFormSetFieldEditable form_handle "rect_corner_size" nil)
	)
    )
)
procedure((TBX_COILDES_Main \@optional arg) 
    let((lic_check_result info_file VERSION_STR FC_FEATURE FC_VERSION
	    SUB_VERSION port FORM_FILE fid
	) 
	(FC_FEATURE = "COILDES") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Coil Desginer %s (C)2017" FC_VERSION))
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./coildes_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Coil Designer information:\n") 
		fprintf(port "===============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version      : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Coil Designer: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    TBX_COILDES_Init() 
		    if((axlOKToProceed t) then 
			(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "coildes_main")) 
			(fid = (axlFormCreate 
				gensym("tbxcoildesmain") FORM_FILE 
				'(e outer) 
				'TBX_COILDES_Callback
				t nil
			    )) 
			(tbx_coildes_data->formid = fid)
			(tbx_coildes_data->licCheck = lic_check_result) 
			(tbx_coildes_data->activeTab = "round") 
			TBX_FORM_Init_Header(fid "Licensed for " lic_check_result VERSION_STR) 
			(axlVisibleLayer 
			    (tbx_coildes_data->tmpLayer) t
			) 
			(axlDeleteByLayer 
			    (tbx_coildes_data->tmpLayer)
			)
			TBX_COILDES_Init_Form(fid) 
			TBX_COILDES_Update_Dynamics() 
			(tbx_coildes_data->transMark = (axlDBTransactionStart)) 
			TBX_COILDES_Update_Diagram() 
			(axlFormDisplay fid)
			TBX_COILDES_Event_Loop() 
			TBX_COILDES_Cleanup() 
			TBX_FORM_Delete(lic_check_result FORM_FILE) else 
			printf("Warning: Finish active command first\n")
		    )
		)
	    )
	)
    )
)
procedure(TBX_COILDES_Popup_Callback(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Place Geom" 
			'TBX_COILDES_Popup_Place_Geom
		    ) 
		    list("Show Preview" 
			'TBX_COILDES_Popup_Show_Preview
		    ) 
		    list("Clear Preview" 
			'TBX_COILDES_Popup_Clear_Preview
		    ) 
		    list("Done" 
			'TBX_COILDES_Popup_Done
		    ) 
		    list("Oops" 
			'TBX_COILDES_Popup_Oops
		    )
		    list("Cancel" 
			'TBX_COILDES_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_COILDES_Popup_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_COILDES_Popup_Clear_Preview() 
    (axlClearDynamics)
)
procedure(TBX_COILDES_Popup_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_COILDES_Popup_Oops() 
    (axlDBTransactionOops 
	(tbx_coildes_data->transMark)
    )
)
procedure(TBX_COILDES_Popup_Place_Geom() 
    TBX_COILDES_Update_Dynamics() 
    ((tbx_coildes_data->eventHandler)->pickOrigin = t)
)
procedure(TBX_COILDES_Popup_Show_Preview() 
    TBX_COILDES_Update_Dynamics()
)
procedure(TBX_COILDES_Rectangle_Param_Cross_Check(param) 
    let((form_handle diam_x diam_y diam_y_min width
	    spacing corner_size min_stub max_radius max_miter
	    keepout_width keepout_height keepout_offset
	) 
	(form_handle = (tbx_coildes_data->formid)) 
	(diam_x = (axlFormGetField form_handle "rect_inner_diameter_x")) 
	(diam_y = (axlFormGetField form_handle "rect_inner_diameter_y")) 
	(width = (axlFormGetField form_handle "rect_line_width"))
	(spacing = (axlFormGetField form_handle "rect_line_spacing")) 
	(corner_size = (axlFormGetField form_handle "rect_corner_size")) 
	(keepout_offset = (axlFormGetField form_handle "route_keepout_offset")) 
	(diam_y_min = (width + spacing)) 
	when((corner_size == 0.0) 
	    (corner_size = (1.0 / (10.0**cadr((axlDBGetDesignUnits))))) 
	    (axlFormSetField form_handle "rect_corner_size" corner_size) 
	    (axlUIWPrint form_handle 
		'warn 
		sprintf(nil "Size must be at least %f" corner_size)
	    )
	)
	when((diam_y < diam_y_min) 
	    (axlFormSetField form_handle "rect_inner_diameter_y" diam_y_min) 
	    when((param == "diam_y") 
		(axlUIWPrint form_handle 
		    'warn "Diameter y must be at least width + spacing"
		)
	    ) 
	    (diam_y = diam_y_min)
	) 
	(keepout_width = (diam_x - (2 * keepout_offset))) 
	(keepout_height = (diam_y - (2 * keepout_offset))) 
	when(((keepout_width <= 0.0) || (keepout_height <= 0.0)) 
	    (axlFormSetField form_handle "route_keepout_offset" 
		(min((diam_x / 2.0) 
			(diam_y / 2.0)
		    ) - ((1.0 * 10.0) / (10.0**cadr((axlDBGetDesignUnits)))))
	    ) 
	    when((param == "keepout_offset") 
		(axlUIWPrint form_handle 
		    'warn "Offset too large"
		)
	    )
	) 
	(min_stub = min(((diam_y / 2.0) + (width / 2.0)) 
		((diam_x / 2.0) + (width / 2.0))
	    ))
	(max_radius = min_stub) 
	(max_miter = (sqrt(2.0) * min_stub)) 
	case(lowerCase((axlFormGetField form_handle "rect_corner_style")) 
	    ("miter" 
		when((corner_size > max_miter) 
		    (axlFormSetField form_handle "rect_corner_size" max_miter) 
		    when((param == "corner_size") 
			(axlUIWPrint form_handle 
			    'warn 
			    sprintf(nil "Miter length must not exceed %L. change xy extents to higher values" max_miter)
			)
		    )
		)
	    ) 
	    ("radius" 
		when((corner_size > max_radius) 
		    (axlFormSetField form_handle "rect_corner_size" max_radius) 
		    when((param == "corner_size") 
			(axlUIWPrint form_handle 
			    'warn 
			    sprintf(nil "Radius must not exceed %L, change Diam xy extents to higher values" max_radius)
			)
		    )
		)
	    )
	)
    )
)
procedure(TBX_COILDES_Transform(pt_list origin rotation mirror) 
    let((list_new arg1 arg2 arg3 xy_new) 
	(list_new = list()) 
	if(((rotation > 0.0) || mirror) then 
	    foreach(entry pt_list 
		(xy_new = car(entry)) 
		(arg1 = cadr(entry)) 
		(arg2 = caddr(entry))
		(arg3 = nth(3 entry)) 
		if((xy_new == origin) then 
		    (list_new = cons(list(xy_new arg1 arg2 arg3) list_new)) else 
		    when(mirror 
			(xy_new = (axlGeoRotatePt 0.0 xy_new origin t))
		    )
		    when((rotation > 0.0) 
			(xy_new = (axlGeoRotatePt rotation xy_new origin))
		    ) 
		    (list_new = cons(list(xy_new arg1 arg2 arg3) list_new))
		)
	    ) 
	    (list_new = reverse(list_new)) else
	    (list_new = pt_list)
	)
    )
)
procedure(TBX_COILDES_Transform_Rpath(rpath rotation clockwise origin) 
    let((rpath_new) 
	(rpath_new = rpath) 
	when(clockwise 
	    (rpath_new = TBX_DBCORE_Rotate_Rpath(rpath_new 0.0 origin t)) t
	) 
	when((rotation != 0.0) 
	    (rpath_new = TBX_DBCORE_Rotate_Rpath(rpath_new rotation origin nil))
	) rpath_new
    )
)
procedure(TBX_COILDES_Update_Diagram() 
    let((form_handle field_name image_name type_ext corner_ext
	    keepout_ext
	) 
	(form_handle = (tbx_coildes_data->formid)) 
	if((axlFormGetField form_handle "add_route_keepout") then 
	    (keepout_ext = "_kp") else 
	    (keepout_ext = "")
	) 
	case((tbx_coildes_data->activeTab) 
	    ("round" 
		(field_name = "rnd_coil_image") 
		(type_ext = "_rnd") 
		(corner_ext = "")
	    ) 
	    ("rectangle" 
		(field_name = "rect_coil_image") 
		(type_ext = "_rect") 
		if((axlFormGetField form_handle "rect_change_corner") then 
		    case((axlFormGetField form_handle "rect_corner_style") 
			("miter" 
			    (corner_ext = "_mc")
			) 
			("radius" 
			    (corner_ext = "_rc")
			)
		    ) else 
		    (corner_ext = "")
		)
	    ) 
	    ("octagon" 
		(field_name = "oct_coil_image") 
		(type_ext = "_oct") 
		(corner_ext = "")
	    ) 
	    ("hexagon" 
		(field_name = "hex_coil_image") 
		(type_ext = "_hex") 
		(corner_ext = "")
	    )
	) 
	(image_name = strcat("tbx_coildes" type_ext corner_ext keepout_ext))
	(axlFormSetField form_handle field_name image_name)
    )
)
procedure(TBX_COILDES_Update_Dynamics() 
    let((form_handle size_str extents_field) 
	(form_handle = (tbx_coildes_data->formid)) 
	(axlClearDynamics) 
	case(lowerCase((tbx_coildes_data->activeTab)) 
	    ("round" 
		TBX_COILDES_Calculate_Round_Spiral() 
		(extents_field = "rnd_extents_info")
	    ) 
	    ("rectangle" 
		TBX_COILDES_Calculate_Rectangle_Spiral() 
		(extents_field = "rect_extents_info")
	    ) 
	    ("octagon" 
		TBX_COILDES_Calculate_Octagon_Spiral() 
		(extents_field = "oct_extents_info")
	    ) 
	    ("hexagon" 
		TBX_COILDES_Calculate_Hexagon_Spiral() 
		(extents_field = "hex_extents_info")
	    )
	) 
	(axlAddSimpleMoveDynamics 
	    (0:0) 
	    ((tbx_coildes_data->coilInfo)->path) "path"
	)
	when((axlFormGetField form_handle "add_route_keepout") 
	    (axlAddSimpleMoveDynamics 
		(0:0) 
		((tbx_coildes_data->coilInfo)->keepoutPath) "path"
	    )
	) 
	(size_str = sprintf(nil "%.3f X %.3f" 
		((tbx_coildes_data->coilInfo)->sizeX) 
		((tbx_coildes_data->coilInfo)->sizeY)
	    )) 
	(axlFormSetField form_handle extents_field size_str)
    )
)
procedure(TBX_CPM_Determine_Project_File(\@optional 
	(verbose 
	    't
	)
    ) 
    let((parse_proj_file cpm_file root_dir check_dir work_dir
	    cpm_list
	) 
	(work_dir = getWorkingDir()) 
	(root_dir = (axlOSSlash 
		simplifyFilename("/")
	    )) 
	if(((axlOSSlash 
		    simplifyFilename(work_dir)
		) == root_dir) then 
	    (check_dir = nil) else 
	    if(((axlOSSlash 
			simplifyFilename(strcat(work_dir "/.."))
		    ) == root_dir) then 
		(check_dir = nil) else 
		if(((axlOSSlash 
			    simplifyFilename(strcat(work_dir "/../.."))
			) == root_dir) then 
		    (check_dir = nil) else 
		    (check_dir = (axlOSSlash 
			    simplifyFilename(strcat(work_dir "/../../.."))
			))
		)
	    )
	) 
	if(check_dir then 
	    if((check_dir == root_dir) then 
		when(verbose 
		    printf("Warning: Program will ignore cpm files which are located in root directories such as %L\n" root_dir)
		) else 
		foreach(i 
		    getDirFiles(check_dir) 
		    when(((i != ".") && (i != "..")) 
			(parse_proj_file = parseString(i ".")) 
			when(((length(parse_proj_file) >= 2) && (upperCase(car(last(parse_proj_file))) == "CPM")) 
			    (cpm_list = cons(i cpm_list))
			)
		    )
		)
		if(cpm_list then 
		    if(onep(length(cpm_list)) then 
			(cpm_file = sprintf(nil "%s/%s" check_dir 
				car(cpm_list)
			    )) else 
			when(verbose 
			    printf("Warning: Multiple  cpm files found in %L...\n" check_dir)
			)
		    ) else 
		    when(verbose 
			printf("Warning: No cpm file found in %L\n" check_dir)
		    )
		)
	    ) else 
	    when(verbose 
		printf("Warning: Cannot validate ../../.. from current working directory. No cpm file found\n")
	    )
	)
	cpm_file
    )
)
procedure(TBX_CPM_Parse_Customvar_Line(str split_subname) 
    let((arr var_name var_value var_subname ret_list) 
	rexCompile("'") 
	(str = rexReplace(str "" 0)) 
	rexCompile("\"") 
	(str = rexReplace(str "" 0))
	(arr = parseString(str)) 
	if((length(arr) >= 1) then 
	    (var_name = car(arr)) 
	    if(cadr(arr) then 
		(var_value = buildString(cdr(arr) " ")) else 
		(var_value = "")
	    ) 
	    if(split_subname then 
		rexCompile("__") 
		(var_name = rexReplace(var_name "!" 0)) 
		(arr = parseString(var_name "!"))
		cond((onep(length(arr)) 
			(var_name = car(arr)) 
			(var_subname = "BASE")
		    ) 
		    ((length(arr) == 2) 
			(var_name = car(arr)) 
			(var_subname = cadr(arr))
		    ) 
		    ((length(arr) > 2) 
			(arr = reverse(arr)) 
			(var_subname = car(arr)) 
			(arr = cdr(arr)) 
			(arr = reverse(arr))
			(var_name = buildString(arr "__"))
		    )
		) 
		rexCompile("^ *") 
		(var_name = rexReplace(var_name "" 0)) 
		rexCompile(" *$") 
		(var_name = rexReplace(var_name "" 0))
		rexCompile(" +") 
		(var_name = rexReplace(var_name "_" 0)) 
		rexCompile("^ *") 
		(var_subname = rexReplace(var_subname "" 0)) 
		rexCompile(" *$")
		(var_subname = rexReplace(var_subname "" 0)) 
		rexCompile(" +") 
		(var_subname = rexReplace(var_subname "_" 0)) 
		(ret_list = list(var_name var_subname var_value)) else
		rexCompile("^ *") 
		(var_name = rexReplace(var_name "" 0)) 
		rexCompile(" *$") 
		(var_name = rexReplace(var_name "" 0)) 
		rexCompile(" +")
		(var_name = rexReplace(var_name "_" 0)) 
		(ret_list = list(var_name var_value))
	    )
	    else 
	    (ret_list = nil)
	) ret_list
    )
)
procedure(TBX_CPM_Read_Project_File(cpm_file split_subname) 
    let((inport line str match data
	    info
	) 
	(info = list()) 
	(inport = infile(cpm_file)) 
	while((line = _gets(inport)) 
	    (str = upperCase(line)) 
	    cond((rexMatchp("^ *START_CUSTOMVAR" str) 
		    (match = t)
		) 
		(rexMatchp("^ *END_CUSTOMVAR" str) 
		    (match = nil)
		) 
		(match 
		    (data = TBX_CPM_Parse_Customvar_Line(str split_subname)) 
		    when(data 
			(info = cons(data info))
		    )
		) 
		(t t)
	    )
	) 
	close(inport)
	(info = reverse(info))
    )
)
procedure(TBX_CROSSCOPY_Cache_Param(form_handle) 
    let((rec session_param) 
	(rec = "crosscopy") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "delete") 
	    stringToSymbol("delete")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "shape_mode") 
	    stringToSymbol("shape_mode")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "void_mode") 
	    stringToSymbol("void_mode")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "pad_mode") 
	    stringToSymbol("pad_mode")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "convert_to_shape") 
	    stringToSymbol("convert_to_shape")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "endcap_type") 
	    stringToSymbol("endcap_type")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "figure_boundary") 
	    stringToSymbol("figure_boundary")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "merge_all") 
	    stringToSymbol("merge_all")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "merge_by_net") 
	    stringToSymbol("merge_by_net")
	) t
    )
)
procedure(TBX_CROSSCOPY_Callback(form_handle) 
    let((msg) 
	case((form_handle->curField) 
	    ("shape_mode" 
		case((form_handle->curValue) 
		    ("fill_shape" 
			(axlFormSetFieldEditable form_handle "void_mode" t)
		    ) 
		    ("unfill_shape" 
			(axlFormSetField form_handle "void_mode" "exclude_voids") 
			(axlFormSetFieldEditable form_handle "void_mode" nil)
		    ) 
		    ("decompose_shape" 
			(axlFormSetFieldEditable form_handle "void_mode" t)
		    ) 
		    (t 
			printf("Unknown argument for shape_mode in Callback: %L\n" 
			    (form_handle->curValue)
			)
		    )
		)
	    ) 
	    ("pad_mode" 
		if(((form_handle->curValue) == "testpoint_figure") then 
		    (axlFormSetFieldEditable form_handle "pad_mode_info" t) else 
		    (axlFormSetFieldEditable form_handle "pad_mode_info" nil)
		)
	    ) 
	    ("pad_mode_info" 
		(msg = "") 
		(msg = strcat(msg "By default testpoint figures are copied as octagon shapes. The actual figures will be considered when probe types ")) 
		(msg = strcat(msg "had been saved to a file called \"probe_types.csv\" in Testprep Parameter form using \"Save types to file\". ")) 
		(msg = strcat(msg "Ensure that probe types are up to date, resequence if necessary. "))
		(msg = strcat(msg "Furthermore only visible probe layers will be processed.")) 
		(axlUIConfirm msg)
	    ) 
	    ("convert_to_shape" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "endcap_type" t) else 
		    (axlFormSetFieldEditable form_handle "endcap_type" nil)
		)
	    )
	    ("merge_all" 
		when((form_handle->curValue) 
		    (axlFormSetField form_handle "merge_by_net" nil)
		)
	    ) 
	    ("merge_by_net" 
		when((form_handle->curValue) 
		    (axlFormSetField form_handle "merge_all" nil)
		)
	    ) 
	    ("toggle_destination_layer" 
		if(!(tbx_crosscopy_data->visList) then 
		    (tbx_crosscopy_data->visList = (axlVisibleGet)) 
		    (axlVisibleDesign nil) 
		    (axlFormSetField form_handle "subcolor" t)
		    (axlVisibleLayer 
			(axlDBControl 
			    'activeLayer
			) t
		    ) else 
		    (axlFormSetField form_handle "subcolor" nil) 
		    (axlVisibleSet 
			(tbx_crosscopy_data->visList)
		    ) 
		    (tbx_crosscopy_data->visList = nil)
		) 
		(axlVisibleUpdate t)
	    )
	)
    )
)
procedure(TBX_CROSSCOPY_Cancel() 
    (axlDBTransactionRollback 
	(tbx_crosscopy_data->mark)
    ) 
    (axlCancelEnterFun)
)
procedure(TBX_CROSSCOPY_Cleanup() 
    let((userdata) 
	when((axlFormGetField 
		(tbx_crosscopy_data->formid) "trim_cline"
	    ) 
	    (tbx_crosscopy_data->FF_enabled = (axlGetFindFilter nil)) 
	    (tbx_crosscopy_data->FF_onButtons = (axlGetFindFilter t))
	) 
	(axlCloseFindFilter) 
	(axlClearSelSet) 
	(userdata = (axlUIGetUserData))
	(axlFormClose 
	    (tbx_crosscopy_data->formid)
	) 
	(axlUIPopupSet 
	    (userdata->oldPopupId)
	) 
	remprop(userdata 
	    'oldPopupId
	)
    )
)
procedure(TBX_CROSSCOPY_Copy_Figure(struct destination_layer figure_boundary_mode) 
    let((fg_poly fill_style) 
	(fg_poly = car(TBX_DBCORE_Poly_From_Figure(struct))) 
	when(fg_poly 
	    (fill_style = nil) 
	    cond(((figure_boundary_mode == "fill_shape") 
		    (fill_style = t)
		) 
		((figure_boundary_mode == "unfill_shape") 
		    (fill_style = nil)
		)
	    ) 
	    (axlDBCreateShape fg_poly fill_style destination_layer)
	)
    )
)
procedure(TBX_CROSSCOPY_Copy_Path(seg_list dest_layer) 
    let((mypath) 
	(mypath = TBX_CROSSCOPY_Create_Path(seg_list)) 
	(axlDBCreatePath mypath dest_layer)
    )
)
procedure(TBX_CROSSCOPY_Copy_Shape(struct dest_layer shape_mode void_mode) 
    let((poly_list mypath oshape shape_dbid) 
	cond((((struct->objType) == "polygon") 
		(shape_dbid = struct)
	    ) 
	    ((((struct->objType) == "shape") && !(struct->shapeIsBoundary)) 
		(shape_dbid = struct)
	    ) 
	    ((((struct->objType) == "shape") && (struct->shapeIsBoundary)) 
		(shape_dbid = struct)
	    ) 
	    (t 
		printf("Unknown shape type\n") 
		(shape_dbid = struct)
	    )
	) 
	cond(((shape_mode == "fill_shape") 
		if((void_mode == "include_voids") then 
		    if((shape_dbid->shapeAuto) then 
			foreach(autoshape 
			    (shape_dbid->shapeAuto) 
			    (poly_list = (axlPolyFromDB autoshape)) 
			    (axlDBCreateShape 
				car(poly_list) t dest_layer
			    )
			) else 
			(poly_list = (axlPolyFromDB shape_dbid))
			(axlDBCreateShape 
			    car(poly_list) t dest_layer
			)
		    ) else 
		    (mypath = TBX_CROSSCOPY_Create_Path((shape_dbid->segments)))
		    (oshape = (axlDBCreateOpenShape mypath t dest_layer)) 
		    (axlDBCreateCloseShape oshape)
		)
	    ) 
	    ((shape_mode == "unfill_shape") 
		(mypath = TBX_CROSSCOPY_Create_Path((shape_dbid->segments))) 
		(oshape = (axlDBCreateOpenShape mypath nil dest_layer)) 
		(axlDBCreateCloseShape oshape)
	    ) 
	    ((shape_mode == "decompose_shape") 
		if((void_mode == "include_voids") then 
		    (mypath = TBX_CROSSCOPY_Create_Path((shape_dbid->segments))) 
		    (axlDBCreatePath mypath dest_layer) 
		    foreach(void_dbid 
			(shape_dbid->voids) 
			(mypath = TBX_CROSSCOPY_Create_Path((void_dbid->segments))) 
			(axlDBCreatePath mypath dest_layer)
		    )
		    when((shape_dbid->shapeAuto) 
			foreach(autoshape 
			    (shape_dbid->shapeAuto) 
			    foreach(void_dbid 
				(autoshape->voids) 
				(mypath = TBX_CROSSCOPY_Create_Path((void_dbid->segments))) 
				(axlDBCreatePath mypath dest_layer)
			    )
			)
		    ) else 
		    (mypath = TBX_CROSSCOPY_Create_Path((shape_dbid->segments))) 
		    (axlDBCreatePath mypath dest_layer)
		)
	    )
	)
    )
)
procedure(TBX_CROSSCOPY_Copy_Text(text_dbid destination_layer) 
    let((text_str text_block text_rotation text_mirrored text_justify
	    myorient text_xy
	) 
	(text_str = (text_dbid->text)) 
	(text_block = (text_dbid->textBlock)) 
	(text_xy = (text_dbid->xy)) 
	(text_rotation = (text_dbid->rotation))
	(text_mirrored = (text_dbid->isMirrored)) 
	(text_justify = (text_dbid->justify)) 
	(myorient = (make_axlTextOrientation ?textBlock text_block ?rotation text_rotation
		?mirrored text_mirrored ?justify text_justify
	    )) 
	(axlDBCreateText text_str text_xy myorient destination_layer
	    nil
	)
    )
)
procedure(TBX_CROSSCOPY_Create_Path(seg_list) 
    let((mypath) 
	foreach(i seg_list 
	    if(((i->objType) == "line") then 
		if(!mypath then 
		    (mypath = (axlPathStart 
			    (i->startEnd) 
			    (i->width)
			)) else 
		    (mypath = (axlPathLine mypath 
			    (i->width) 
			    cadr((i->startEnd))
			))
		) else 
		if(!mypath then 
		    (mypath = (axlPathStart 
			    list(car((i->startEnd)))
			)) 
		    (mypath = (axlPathArcCenter mypath 
			    (i->width) 
			    cadr((i->startEnd)) 
			    (i->isClockwise)
			    (i->xy)
			)) else
		    (mypath = (axlPathArcCenter mypath 
			    (i->width) 
			    cadr((i->startEnd)) 
			    (i->isClockwise)
			    (i->xy)
			))
		)
	    )
	) mypath
    )
)
procedure(TBX_CROSSCOPY_Define_Popup() 
    let((userdata) 
	(userdata = (axlUIGetUserData)) 
	putprop(userdata 
	    (userdata->popupId) 
	    'oldPopupId
	) 
	(axlUIPopupSet 
	    (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_CROSSCOPY_Done
		    ) 
		    list("Oops" 
			'TBX_CROSSCOPY_Oops
		    ) 
		    list("Cancel" 
			'TBX_CROSSCOPY_Cancel
		    )
		)
	    )
	)
    )
)
procedure(TBX_CROSSCOPY_Done() 
    (axlDBTransactionCommit 
	(tbx_crosscopy_data->mark)
    ) 
    (axlFinishEnterFun)
)
procedure(TBX_CROSSCOPY_Event_Loop() 
    let((shape_mode void_mode pad_mode line_to_shape endcap_type
	    merge_mode delete_org_data figure_boundary_mode destination_layer param
	    selection_set
	) 
	(tbx_crosscopy_data->mark = (axlDBTransactionStart)) 
	while((axlSelect) 
	    (shape_mode = (axlFormGetField 
		    (tbx_crosscopy_data->formid) "shape_mode"
		)) 
	    (void_mode = (axlFormGetField 
		    (tbx_crosscopy_data->formid) "void_mode"
		)) 
	    (pad_mode = (axlFormGetField 
		    (tbx_crosscopy_data->formid) "pad_mode"
		)) 
	    (endcap_type = stringToSymbol((axlFormGetField 
			(tbx_crosscopy_data->formid) "endcap_type"
		    )
		))
	    (figure_boundary_mode = (axlFormGetField 
		    (tbx_crosscopy_data->formid) "figure_boundary"
		)) 
	    if((axlFormGetField 
		    (tbx_crosscopy_data->formid) "convert_to_shape"
		) then 
		(line_to_shape = t) else 
		(line_to_shape = nil)
	    ) 
	    (merge_mode = "no_merge") 
	    when((axlFormGetField 
		    (tbx_crosscopy_data->formid) "merge_all"
		) 
		(merge_mode = "merge_all")
	    ) 
	    when((axlFormGetField 
		    (tbx_crosscopy_data->formid) "merge_by_net"
		) 
		(merge_mode = "merge_by_net")
	    )
	    if((axlFormGetField 
		    (tbx_crosscopy_data->formid) "delete"
		) then 
		(delete_org_data = t) else 
		(delete_org_data = nil)
	    ) 
	    (param = ncons(nil)) 
	    (param->shapeMode = shape_mode) 
	    (param->voidMode = void_mode) 
	    (param->padMode = pad_mode)
	    (param->lineToShape = line_to_shape) 
	    (param->endcapType = endcap_type) 
	    (param->figureBoundaryMode = figure_boundary_mode) 
	    (param->destinationLayer = destination_layer) 
	    (tbx_crosscopy_data->FF_onButtons = cons("noall" 
		    (axlGetFindFilter t)
		))
	    (axlDBTransactionMark 
		(tbx_crosscopy_data->mark)
	    ) 
	    (destination_layer = (axlDBControl 
		    'activeLayer
		)) 
	    (selection_set = (axlGetSelSet)) 
	    (axlClearSelSet) 
	    case(merge_mode 
		("merge_by_net" 
		    TBX_CROSSCOPY_Process_Data_Merge_Net_Mode(selection_set param)
		) 
		("merge_all" 
		    TBX_CROSSCOPY_Process_Data_Merge_Default_Mode(selection_set param)
		) 
		(t 
		    TBX_CROSSCOPY_Process_Data_No_Merge(selection_set param)
		)
	    )
	    when((selection_set && delete_org_data) 
		(axlDeleteObject selection_set)
	    ) 
	    (axlDBRefreshId nil)
	)
    )
)
procedure(TBX_CROSSCOPY_Generate_Merged_Shapes(poly_data void_data hole_data destination_layer) 
    let((oshape poly_data_new cnt ok_void delete_shape
	    cutout_poly cutout_data loop
	) 
	if((length(poly_data) >= 2) then 
	    (poly_data_new = (axlPolyOperation 
		    cdr(poly_data) 
		    list(car(poly_data)) 
		    'OR
		)) else 
	    (poly_data_new = poly_data)
	) 
	(cutout_data = tconc(nil nil)) 
	lconc(cutout_data hole_data) 
	lconc(cutout_data void_data)
	(cutout_data = cdar(cutout_data)) 
	foreach(shape_poly poly_data_new 
	    (oshape = (axlDBCreateOpenShape shape_poly t destination_layer)) 
	    (delete_shape = nil) 
	    (loop = t)
	    (cnt = 0) 
	    while((loop && (cnt < length(cutout_data))) 
		(cutout_poly = nth(cnt cutout_data)) 
		(ok_void = nil) 
		when(car((axlPolyOperation shape_poly cutout_poly 
			    'AND
			)
		    ) 
		    (ok_void = t)
		) 
		unless(car((axlPolyOperation shape_poly cutout_poly 
			    'ANDNOT
			)
		    ) 
		    (delete_shape = t)
		)
		if(delete_shape then 
		    (axlDeleteObject oshape) 
		    (loop = nil) else
		    when(ok_void 
			(axlDBCreateVoid oshape cutout_poly)
		    )
		) 
		++cnt
	    ) 
	    unless(delete_shape 
		(axlDBCreateCloseShape oshape)
	    )
	)
    )
)
procedure(TBX_CROSSCOPY_Get_Line_Poly_Info(segment_list merge_data endcap_type) 
    let((seg_poly_list poly_info result zero_width_objects) 
	(seg_poly_list = list()) 
	(zero_width_objects = list()) 
	foreach(seg segment_list 
	    if(((seg->width) == 0.0) then 
		(zero_width_objects = cons(seg zero_width_objects)) else 
		foreach(p 
		    (axlPolyFromDB seg ?endCapType endcap_type) 
		    (seg_poly_list = cons(p seg_poly_list))
		)
	    )
	) 
	if(merge_data then 
	    if(onep(length(seg_poly_list)) then 
		(poly_info = seg_poly_list) else 
		(poly_info = (axlPolyOperation 
			cdr(seg_poly_list) 
			list(car(seg_poly_list)) 
			'OR
		    ))
	    ) else 
	    (poly_info = seg_poly_list)
	)
	(result = list(poly_info zero_width_objects)) result
    )
)
procedure(TBX_CROSSCOPY_Get_Padstack_Hole_Info(pad_inst) 
    let((pad_def circle_path hole_data dx dy
	    x_pad y_pad x y newpt
	    row_cnt col_cnt spacing_x spacing_y stagger
	    stagger_offset diam xll yll tmp_list
	    c12 c34 p1 p2 p3
	    p4 slot_height slot_width h w
	    center_list point_list slot_path cw
	) 
	(pad_def = (pad_inst->definition)) 
	(hole_data = list()) 
	(center_list = list()) 
	(point_list = list())
	(tmp_list = list()) 
	when(((pad_def->drillDiameter) > 0.0) 
	    cond((((lowerCase((pad_def->holeType)) == "circle_drill") && !(pad_def->multiDrillData)) 
		    (x_pad = car((pad_inst->xy))) 
		    (y_pad = cadr((pad_inst->xy))) 
		    (dx = car((pad_def->drillOffset))) 
		    (dy = cadr((pad_def->drillOffset)))
		    (newpt = list((x_pad + dx) 
			    (y_pad + dy)
			)) 
		    when((pad_inst->isMirrored) 
			(newpt = (axlGeoRotatePt 0.0 newpt 
				(x_pad:y_pad) t
			    ))
		    ) 
		    when(((pad_inst->rotation) != 0.0) 
			(newpt = (axlGeoRotatePt 
				(pad_inst->rotation) newpt 
				(x_pad:y_pad)
			    ))
		    ) 
		    (circle_path = (axlPathStartCircle 
			    list(newpt 
				((pad_def->drillDiameter) / 2.0)
			    ) 0
			)) 
		    (hole_data = cons(car((axlPolyFromDB circle_path)) hole_data))
		) 
		(((lowerCase((pad_def->holeType)) == "circle_drill") && (pad_def->multiDrillData)) 
		    (x_pad = car((pad_inst->xy))) 
		    (y_pad = cadr((pad_inst->xy))) 
		    (dx = car((pad_def->drillOffset))) 
		    (dy = cadr((pad_def->drillOffset)))
		    (diam = ((pad_def->drillDiameter) / 1.0)) 
		    (row_cnt = car((pad_def->multiDrillData))) 
		    (col_cnt = cadr((pad_def->multiDrillData))) 
		    (spacing_x = caddr((pad_def->multiDrillData))) 
		    (spacing_y = cadddr((pad_def->multiDrillData)))
		    (stagger = nth(4 
			    (pad_def->multiDrillData)
			)) 
		    (xll = ((((col_cnt - 1) / 2.0) * (spacing_x + diam) * -1) + x_pad + dx)) 
		    (yll = ((((row_cnt - 1) / 2.0) * (spacing_y + diam) * -1) + y_pad + dy)) 
		    if(stagger then 
			(stagger_offset = ((spacing_x / 2.0) + (diam / 2.0))) else 
			(stagger_offset = 0.0)
		    ) 
		    for(r 1 row_cnt 
			for(c 1 col_cnt 
			    if(zerop(mod(r 2)) then 
				(x = (xll + ((c - 1) * (spacing_x + diam)) + stagger_offset)) else 
				(x = (xll + ((c - 1) * (spacing_x + diam))))
			    ) 
			    (y = (yll + ((r - 1) * (spacing_y + diam))))
			    (tmp_list = cons((x:y) tmp_list))
			)
		    )
		    foreach(xy tmp_list 
			(newpt = xy) 
			when((pad_inst->isMirrored) 
			    (newpt = (axlGeoRotatePt 0.0 newpt 
				    (x_pad:y_pad) t
				))
			) 
			when(((pad_inst->rotation) != 0.0) 
			    (newpt = (axlGeoRotatePt 
				    (pad_inst->rotation) newpt 
				    (x_pad:y_pad)
				))
			)
			(center_list = cons(newpt center_list))
		    ) 
		    (center_list = reverse(center_list)) 
		    foreach(xy center_list 
			(hole_data = cons(car((axlPolyFromDB 
					(axlPathStartCircle 
					    list(xy 
						(diam / 2.0)
					    ) 0
					)
				    )
				) hole_data
			    ))
		    )
		) 
		(((lowerCase((pad_def->holeType)) == "oval_slot") || (lowerCase((pad_def->holeType)) == "rectangle_slot")) 
		    (x_pad = car((pad_inst->xy))) 
		    (y_pad = cadr((pad_inst->xy))) 
		    (dx = car((pad_def->drillOffset))) 
		    (dy = cadr((pad_def->drillOffset)))
		    (slot_width = (pad_def->drillFigureWidth)) 
		    (slot_height = (pad_def->drillFigureHeight)) 
		    (x = (x_pad + dx)) 
		    (y = (y_pad + dy)) 
		    if((slot_width != slot_height) then 
			(w = (slot_width / 2.0)) 
			(h = (slot_height / 2.0)) 
			if((slot_width > slot_height) then 
			    when((lowerCase((pad_def->holeType)) == "oval_slot") 
				(w = ((slot_width - slot_height) / 2.0))
			    ) 
			    (c12 = list(((- w) + x) 
				    (0.0 + y)
				)) 
			    (c34 = list((w + x) 
				    (0.0 + y)
				))
			    (p1 = list(((- w) + x) 
				    (h + y)
				)) 
			    (p2 = list(((- w) + x) 
				    ((- h) + y)
				)) 
			    (p3 = list((w + x) 
				    ((- h) + y)
				)) 
			    (p4 = list((w + x) 
				    (h + y)
				)) else
			    when((lowerCase((pad_def->holeType)) == "oval_slot") 
				(h = ((slot_height - slot_width) / 2.0))
			    ) 
			    (c12 = list((0.0 + x) 
				    ((- h) + y)
				)) 
			    (c34 = list((0.0 + x) 
				    (h + y)
				)) 
			    (p1 = list(((- w) + x) 
				    ((- h) + y)
				)) 
			    (p2 = list((w + x) 
				    ((- h) + y)
				))
			    (p3 = list((w + x) 
				    (h + y)
				)) 
			    (p4 = list(((- w) + x) 
				    (h + y)
				))
			)
			(point_list = list()) 
			foreach(xy 
			    list(c12 c34 p1 p2 p3
				p4
			    ) 
			    (newpt = xy) 
			    if((pad_inst->isMirrored) then 
				(cw = t) 
				(newpt = (axlGeoRotatePt 0.0 newpt 
					(x_pad:y_pad) t
				    )) else
				(cw = nil)
			    ) 
			    when(((pad_inst->rotation) != 0.0) 
				(newpt = (axlGeoRotatePt 
					(pad_inst->rotation) newpt 
					(x_pad:y_pad)
				    ))
			    )
			    (point_list = cons(newpt point_list))
			) 
			(point_list = reverse(point_list)) 
			(c12 = car(point_list)) 
			(c34 = cadr(point_list))
			(p1 = caddr(point_list)) 
			(p2 = nth(3 point_list)) 
			(p3 = nth(4 point_list)) 
			(p4 = nth(5 point_list)) 
			if((lowerCase((pad_def->holeType)) == "oval_slot") then 
			    (slot_path = (axlPathStart 
				    list(p1) 0.0
				)) 
			    (slot_path = (axlPathArcCenter slot_path 0.0 p2 cw
				    c12
				)) 
			    (slot_path = (axlPathLine slot_path 0.0 p3))
			    (slot_path = (axlPathArcCenter slot_path 0.0 p4 cw
				    c34
				)) 
			    (slot_path = (axlPathLine slot_path 0.0 p1)) else 
			    (slot_path = (axlPathStart 
				    list(p1 p2 p3 p4 p1) 0.0
				))
			)
			(hole_data = cons(car((axlPolyFromDB slot_path)) hole_data)) else 
			(newpt = (x:y)) 
			when((pad_inst->isMirrored) 
			    (newpt = (axlGeoRotatePt 0.0 newpt 
				    (x_pad:y_pad) t
				))
			) 
			when(((pad_inst->rotation) != 0.0) 
			    (newpt = (axlGeoRotatePt 
				    (pad_inst->rotation) newpt 
				    (x_pad:y_pad)
				))
			)
			(circle_path = (axlPathStartCircle 
				list(newpt 
				    ((pad_def->drillDiameter) / 2.0)
				) 0
			    )) 
			(hole_data = cons(car((axlPolyFromDB circle_path)) hole_data))
		    )
		) 
		(t 
		    printf("Do nothing with unknown hole type\n")
		)
	    )
	) hole_data
    )
)
procedure(TBX_CROSSCOPY_Get_Padstack_Poly_Info(pad_inst) 
    let((class_name lay_id full_name poly_list pad_poly_data
	    final_poly_list
	) 
	(poly_list = list()) 
	case(upperCase((pad_inst->objType)) 
	    ("PIN" 
		(class_name = "PIN")
	    ) 
	    ("VIA" 
		(class_name = "VIA CLASS")
	    ) 
	    (t 
		printf("Warning: Invalid type: %s\n" 
		    (pad_inst->objType)
		)
	    )
	) 
	foreach(layer 
	    ((axlGetParam 
		    strcat("paramLayerGroup:" class_name)
		)->groupMembers) 
	    (full_name = strcat(class_name "/" layer)) 
	    (lay_id = (axlLayerGet full_name)) 
	    (pad_poly_data = (axlPolyFromDB pad_inst ?layer full_name ?padType
		    'REGULAR
		))
	    when((pad_poly_data && (lay_id->visible)) 
		(poly_list = cons(car(pad_poly_data) poly_list))
	    )
	) 
	(final_poly_list = (axlPolyOperation 
		cdr(poly_list) 
		list(car(poly_list)) 
		'OR
	    ))
	final_poly_list
    )
)
procedure(TBX_CROSSCOPY_Get_Shape_Poly_Info(shape_dbid void_mode) 
    let((poly_list void_list result) 
	(poly_list = tconc(nil nil)) 
	(void_list = tconc(nil nil)) 
	if((void_mode == "include_voids") then 
	    if((shape_dbid->shapeAuto) then 
		foreach(ashape 
		    (shape_dbid->shapeAuto) 
		    lconc(poly_list 
			(axlPolyFromDB ashape)
		    )
		) else 
		lconc(poly_list 
		    (axlPolyFromDB 
			(axlDB2Path shape_dbid)
		    )
		)
	    ) 
	    foreach(vd 
		(shape_dbid->voids) 
		lconc(void_list 
		    (axlPolyFromDB 
			(axlDB2Path vd)
		    )
		)
	    ) else
	    lconc(poly_list 
		(axlPolyFromDB 
		    (axlDB2Path shape_dbid)
		)
	    )
	) 
	(poly_list = cdar(poly_list))
	(void_list = cdar(void_list)) 
	(result = list(poly_list void_list)) result
    )
)
procedure(TBX_CROSSCOPY_Get_Testpoint_Figure_Info(padinst probe_figure) 
    let((probe_side probe_layer pad_layer pad_poly_data class_name
	    bbox width height size figure_name
	    figure_poly_data fig_dpl
	) 
	when((padinst->testPoint) 
	    (probe_side = cadr(parseString((padinst->testPoint) "/"))) 
	    (probe_layer = strcat((axlMapClassName "MANUFACTURING") "/PROBE_" probe_side)) 
	    when((axlIsVisibleLayer probe_layer) 
		case(upperCase((padinst->objType)) 
		    ("PIN" 
			(class_name = "PIN")
		    ) 
		    ("VIA" 
			(class_name = "VIA CLASS")
		    )
		) 
		(pad_layer = strcat(class_name "/" probe_side)) 
		(pad_poly_data = (axlPolyFromDB padinst ?layer pad_layer ?padType
			'REGULAR
		    )) 
		when(pad_poly_data 
		    (bbox = (car(pad_poly_data)->bBox)) 
		    (width = abs((car((upperRight bbox)) - 
				car((lowerLeft bbox)))
			)) 
		    (height = abs((cadr((upperRight bbox)) - 
				cadr((lowerLeft bbox)))
			)) 
		    (size = min(width height))
		    (figure_name = "OCTAGON") 
		    when((((padinst->prop)->TESTPOINT_PROBE_TYPE) && probe_figure[((padinst->prop)->TESTPOINT_PROBE_TYPE)]) 
			(figure_name = probe_figure[((padinst->prop)->TESTPOINT_PROBE_TYPE)])
		    ) 
		    (fig_dpl = list(nil 
			    'objType "figure" 
			    'figureName figure_name
			    'width size 
			    'height size 
			    'xy
			    (padinst->xy) 
			    'rotation 0.0
			)) 
		    (figure_poly_data = TBX_DBCORE_Poly_From_Figure(fig_dpl))
		)
	    )
	) figure_poly_data
    )
)
procedure(TBX_CROSSCOPY_Init() 
    unless(boundp('tbx_crosscopy_data) 
	iliDefstruct('defstruct(tbx_crosscopy_data_struct FF_enabled FF_onButtons formid mark
		    visList probeFigure
		)
	) 
	defvar(tbx_crosscopy_data nil)
    ) 
    if(!tbx_crosscopy_data then 
	(tbx_crosscopy_data = (make_tbx_crosscopy_data_struct ?FF_enabled 
		list("shapes" "boundary_shapes" "dynthemals" "lines" "clines"
		    "clinesegs" "linesegs" "text" "pins" "vias"
		    "figures"
		) ?FF_onButtons 
		list("shapes" "lines" "clines" "clinesegs" "linesegs"
		    "text" "pins" "vias" "figures"
		)
		?formid nil ?mark nil ?visList
		nil ?probeFigure nil
	    )) else 
	(tbx_crosscopy_data->formid = nil)
	(tbx_crosscopy_data->mark = nil) 
	(tbx_crosscopy_data->visList = nil) 
	(tbx_crosscopy_data->probeFigure = nil)
    )
)
procedure((TBX_CROSSCOPY_Main \@optional arg) 
    let((lic_check_result FORM_FILE fid FC_FEATURE FC_VERSION
	    SUB_VERSION VERSION_STR port info_file record
	) 
	(FC_FEATURE = "CROSSCOPY") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Cross Copy %s (C)2017" FC_VERSION))
	(VERSION_STR = VERSION_STR) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./crosscopy_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Cross Copy information:\n") 
		fprintf(port "===============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Cross Copy: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    printf("For additional help enter: 'tbx help crosscopy' in console window\n") 
		    TBX_CROSSCOPY_Init() 
		    (tbx_crosscopy_data->probeFigure = TBX_CROSSCOPY_Read_Probe_Type_Configuration()) 
		    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "crosscopy_mini"))
		    unless(boundp('tbxCrosscopyMini) 
			defvar(tbxCrosscopyMini nil)
		    ) 
		    (fid = (axlMiniStatusLoad 
			    'tbxCrosscopyMini FORM_FILE 
			    'TBX_CROSSCOPY_Callback nil
			)) 
		    (tbx_crosscopy_data->formid = fid) 
		    TBX_FORM_Init_Header(fid nil lic_check_result nil) 
		    (axlDBControl 
			'activeLayer 
			strcat((axlMapClassName "BOARD GEOMETRY") "/ASSEMBLY_NOTES")
		    )
		    (record = "crosscopy") 
		    (axlFormSetField fid "delete" 
			TBX_SESSION_Get_Param(record "delete" nil)
		    ) 
		    (axlFormSetField fid "shape_mode" 
			TBX_SESSION_Get_Param(record "shape_mode" "fill_shape")
		    ) 
		    (axlFormSetField fid "void_mode" 
			TBX_SESSION_Get_Param(record "void_mode" "include_voids")
		    ) 
		    (axlFormSetField fid "pad_mode" 
			TBX_SESSION_Get_Param(record "pad_mode" "pad_only")
		    )
		    (axlFormSetField fid "convert_to_shape" 
			TBX_SESSION_Get_Param(record "convert_to_shape" nil)
		    ) 
		    (axlFormSetField fid "endcap_type" 
			TBX_SESSION_Get_Param(record "endcap_type" "ROUND")
		    ) 
		    (axlFormSetField fid "figure_boundary" 
			TBX_SESSION_Get_Param(record "figure_boundary" "fill_shape")
		    ) 
		    (axlFormSetField fid "merge_all" 
			TBX_SESSION_Get_Param(record "merge_all" nil)
		    ) 
		    (axlFormSetField fid "merge_by_net" 
			TBX_SESSION_Get_Param(record "merge_by_net" nil)
		    )
		    if((axlFormGetField fid "convert_to_shape") then 
			(axlFormSetFieldEditable fid "endcap_type" t) else 
			(axlFormSetFieldEditable fid "endcap_type" nil)
		    ) 
		    if(((axlFormGetField fid "pad_mode") == "testpoint_figure") then 
			(axlFormSetFieldEditable fid "pad_mode_info" t) else 
			(axlFormSetFieldEditable fid "pad_mode_info" nil)
		    ) 
		    (axlFormDisplay fid) 
		    TBX_FORM_Delete(lic_check_result FORM_FILE) 
		    TBX_CROSSCOPY_Define_Popup()
		    (axlClearSelSet) 
		    (axlSetFindFilter ?enabled 
			cons("noall" 
			    (tbx_crosscopy_data->FF_enabled)
			) ?onButtons 
			cons("noall" 
			    (tbx_crosscopy_data->FF_onButtons)
			)
		    ) 
		    (axlAutoOpenFindFilter) 
		    TBX_CROSSCOPY_Event_Loop() 
		    TBX_CROSSCOPY_Cache_Param(fid)
		    TBX_CROSSCOPY_Cleanup()
		)
	    )
	)
    )
)
procedure(TBX_CROSSCOPY_Oops() 
    (axlDBTransactionOops 
	(tbx_crosscopy_data->mark)
    ) 
    (axlDBRefreshId nil) 
    (axlDBCheck 
	'general
    ) 
    (axlClearSelSet)
)
procedure(TBX_CROSSCOPY_Process_Data_Merge_Default_Mode(selection_set cmd_param) 
    let((hole_data void_data poly_data other_items result
	    probe_figure shape_mode void_mode pad_mode line_to_shape
	    endcap_type figure_boundary_mode destination_layer
	) 
	(shape_mode = (cmd_param->shapeMode)) 
	(void_mode = (cmd_param->voidMode)) 
	(pad_mode = (cmd_param->padMode)) 
	(line_to_shape = (cmd_param->lineToShape))
	(endcap_type = (cmd_param->endcapType)) 
	(figure_boundary_mode = (cmd_param->figureBoundaryMode)) 
	(destination_layer = (cmd_param->destinationLayer)) 
	(probe_figure = (tbx_crosscopy_data->probeFigure)) 
	(hole_data = tconc(nil nil))
	(poly_data = tconc(nil nil)) 
	(other_items = tconc(nil nil)) 
	foreach(item selection_set 
	    cond(((((item->objType) == "via") || ((item->objType) == "pin")) 
		    case(pad_mode 
			("pad_and_hole" 
			    lconc(poly_data 
				TBX_CROSSCOPY_Get_Padstack_Poly_Info(item)
			    ) 
			    lconc(hole_data 
				TBX_CROSSCOPY_Get_Padstack_Hole_Info(item)
			    )
			) 
			("pad_only" 
			    lconc(poly_data 
				TBX_CROSSCOPY_Get_Padstack_Poly_Info(item)
			    )
			) 
			("hole_only" 
			    lconc(poly_data 
				TBX_CROSSCOPY_Get_Padstack_Hole_Info(item)
			    )
			) 
			("testpoint_figure" 
			    lconc(poly_data 
				TBX_CROSSCOPY_Get_Testpoint_Figure_Info(item probe_figure)
			    )
			)
		    )
		) 
		(((item->objType) == "path") 
		    if(line_to_shape then 
			(result = TBX_CROSSCOPY_Get_Line_Poly_Info((item->segments) t endcap_type)) 
			lconc(poly_data 
			    car(result)
			) 
			lconc(other_items 
			    cadr(result)
			)
			else 
			tconc(other_items item)
		    )
		) 
		((((item->objType) == "line") || ((item->objType) == "arc")) 
		    if(line_to_shape then 
			(result = TBX_CROSSCOPY_Get_Line_Poly_Info(list(item) t endcap_type)) 
			lconc(poly_data 
			    car(result)
			) 
			lconc(other_items 
			    cadr(result)
			)
			else 
			tconc(other_items item)
		    )
		) 
		((((item->objType) == "shape") || ((item->objType) == "polygon")) 
		    if((shape_mode == "fill_shape") then 
			(result = TBX_CROSSCOPY_Get_Shape_Poly_Info(item void_mode)) 
			lconc(poly_data 
			    car(result)
			) 
			lconc(void_data 
			    cadr(result)
			)
			else 
			tconc(other_items item)
		    )
		) 
		(t 
		    tconc(other_items item)
		)
	    )
	) 
	(poly_data = cdar(poly_data)) 
	(hole_data = cdar(hole_data))
	(void_data = cdar(void_data)) 
	TBX_CROSSCOPY_Generate_Merged_Shapes(poly_data void_data hole_data destination_layer) 
	(other_items = cdar(other_items)) 
	TBX_UTIL_Check_Figures(other_items) 
	foreach(struct other_items 
	    cond((((struct->objType) == "path") 
		    TBX_CROSSCOPY_Copy_Path((struct->segments) destination_layer)
		) 
		((((struct->objType) == "line") || ((struct->objType) == "arc")) 
		    TBX_CROSSCOPY_Copy_Path(list(struct) destination_layer)
		) 
		(((struct->objType) == "text") 
		    TBX_CROSSCOPY_Copy_Text(struct destination_layer)
		) 
		(((struct->objType) == "figure") 
		    TBX_CROSSCOPY_Copy_Figure(struct destination_layer figure_boundary_mode)
		) 
		((((struct->objType) == "shape") || ((struct->objType) == "polygon")) 
		    TBX_CROSSCOPY_Copy_Shape(struct destination_layer shape_mode void_mode)
		)
		(t t)
	    )
	)
	t
    )
)
procedure(TBX_CROSSCOPY_Process_Data_Merge_Net_Mode(selection_set cmd_param) 
    let((hole_data poly_data void_data other_items poly_list
	    hole_list net_name result void_list probe_figure
	    shape_mode void_mode pad_mode line_to_shape endcap_type
	    figure_boundary_mode destination_layer
	) 
	(shape_mode = (cmd_param->shapeMode)) 
	(void_mode = (cmd_param->voidMode)) 
	(pad_mode = (cmd_param->padMode)) 
	(line_to_shape = (cmd_param->lineToShape))
	(endcap_type = (cmd_param->endcapType)) 
	(figure_boundary_mode = (cmd_param->figureBoundaryMode)) 
	(destination_layer = (cmd_param->destinationLayer)) 
	(probe_figure = (tbx_crosscopy_data->probeFigure)) 
	(hole_data = makeTable("hole_data_table" nil))
	(poly_data = makeTable("poly_data_table" nil)) 
	(void_data = makeTable("void_data_table" nil)) 
	(other_items = tconc(nil nil)) 
	foreach(net 
	    ((axlDBGetDesign)->nets) 
	    (poly_data[(net->name)] = tconc(nil nil)) 
	    (hole_data[(net->name)] = tconc(nil nil)) 
	    (void_data[(net->name)] = tconc(nil nil))
	) 
	(poly_data[""] = tconc(nil nil))
	(hole_data[""] = tconc(nil nil)) 
	(void_data[""] = tconc(nil nil)) 
	foreach(item selection_set 
	    cond(((((item->objType) == "via") || ((item->objType) == "pin")) 
		    (net_name = ((item->net)->name)) 
		    unless(net_name 
			(net_name = "")
		    ) 
		    case(pad_mode 
			("pad_and_hole" 
			    lconc(poly_data[net_name] 
				TBX_CROSSCOPY_Get_Padstack_Poly_Info(item)
			    ) 
			    lconc(hole_data[net_name] 
				TBX_CROSSCOPY_Get_Padstack_Hole_Info(item)
			    )
			) 
			("pad_only" 
			    lconc(poly_data[net_name] 
				TBX_CROSSCOPY_Get_Padstack_Poly_Info(item)
			    )
			) 
			("hole_only" 
			    lconc(poly_data[net_name] 
				TBX_CROSSCOPY_Get_Padstack_Hole_Info(item)
			    )
			) 
			("testpoint_figure" 
			    lconc(poly_data[net_name] 
				TBX_CROSSCOPY_Get_Testpoint_Figure_Info(item probe_figure)
			    )
			)
		    )
		) 
		(((item->objType) == "path") 
		    if(line_to_shape then 
			(net_name = ((item->net)->name)) 
			unless(net_name 
			    (net_name = "")
			) 
			(result = TBX_CROSSCOPY_Get_Line_Poly_Info((item->segments) t endcap_type))
			lconc(poly_data[net_name] 
			    car(result)
			) 
			lconc(other_items 
			    cadr(result)
			) else 
			tconc(other_items item)
		    )
		) 
		((((item->objType) == "line") || ((item->objType) == "arc")) 
		    if(line_to_shape then 
			(net_name = ((item->net)->name)) 
			unless(net_name 
			    (net_name = "")
			) 
			(result = TBX_CROSSCOPY_Get_Line_Poly_Info(list(item) t endcap_type))
			lconc(poly_data[net_name] 
			    car(result)
			) 
			lconc(other_items 
			    cadr(result)
			) else 
			tconc(other_items item)
		    )
		) 
		((((item->objType) == "shape") || ((item->objType) == "polygon")) 
		    (net_name = ((item->net)->name)) 
		    if((shape_mode == "fill_shape") then 
			(result = TBX_CROSSCOPY_Get_Shape_Poly_Info(item void_mode)) 
			lconc(poly_data[net_name] 
			    car(result)
			) 
			lconc(void_data[net_name] 
			    cadr(result)
			)
			else 
			tconc(other_items item)
		    )
		) 
		(t 
		    tconc(other_items item)
		)
	    )
	) 
	printf("Processing nets first:...\n") 
	foreach(key poly_data 
	    (poly_list = cdar(poly_data[key])) 
	    (hole_list = cdar(hole_data[key])) 
	    (void_list = cdar(void_data[key]))
	    TBX_CROSSCOPY_Generate_Merged_Shapes(poly_list void_list hole_list destination_layer)
	)
	(other_items = cdar(other_items)) 
	TBX_UTIL_Check_Figures(other_items) 
	foreach(struct other_items 
	    cond((((struct->objType) == "path") 
		    TBX_CROSSCOPY_Copy_Path((struct->segments) destination_layer)
		) 
		((((struct->objType) == "line") || ((struct->objType) == "arc")) 
		    TBX_CROSSCOPY_Copy_Path(list(struct) destination_layer)
		) 
		(((struct->objType) == "text") 
		    TBX_CROSSCOPY_Copy_Text(struct destination_layer)
		) 
		(((struct->objType) == "figure") 
		    TBX_CROSSCOPY_Copy_Figure(struct destination_layer figure_boundary_mode)
		) 
		(t t)
	    )
	) t
    )
)
procedure(TBX_CROSSCOPY_Process_Data_No_Merge(selection_set cmd_param) 
    let((poly_data hole_data result probe_figure shape_mode
	    void_mode pad_mode line_to_shape endcap_type figure_boundary_mode
	    destination_layer
	) 
	(shape_mode = (cmd_param->shapeMode)) 
	(void_mode = (cmd_param->voidMode)) 
	(pad_mode = (cmd_param->padMode)) 
	(line_to_shape = (cmd_param->lineToShape))
	(endcap_type = (cmd_param->endcapType)) 
	(figure_boundary_mode = (cmd_param->figureBoundaryMode)) 
	(destination_layer = (cmd_param->destinationLayer)) 
	(probe_figure = (tbx_crosscopy_data->probeFigure)) 
	TBX_UTIL_Check_Figures(selection_set)
	foreach(struct selection_set 
	    cond(((((struct->objType) == "line") || ((struct->objType) == "arc")) 
		    if(line_to_shape then 
			(result = TBX_CROSSCOPY_Get_Line_Poly_Info(list(struct) nil endcap_type)) 
			foreach(poly 
			    car(result) 
			    (axlDBCreateShape poly t destination_layer)
			) 
			foreach(seg 
			    cadr(result) 
			    TBX_CROSSCOPY_Copy_Path(list(seg) destination_layer)
			)
			else 
			TBX_CROSSCOPY_Copy_Path(list(struct) destination_layer)
		    )
		) 
		(((struct->objType) == "path") 
		    if(line_to_shape then 
			(result = TBX_CROSSCOPY_Get_Line_Poly_Info((struct->segments) nil endcap_type)) 
			foreach(poly 
			    car(result) 
			    (axlDBCreateShape poly t destination_layer)
			) 
			foreach(seg 
			    cadr(result) 
			    TBX_CROSSCOPY_Copy_Path(list(seg) destination_layer)
			)
			else 
			TBX_CROSSCOPY_Copy_Path((struct->segments) destination_layer)
		    )
		) 
		((((struct->objType) == "pin") || ((struct->objType) == "via")) 
		    (poly_data = tconc(nil nil)) 
		    (hole_data = tconc(nil nil)) 
		    case(pad_mode 
			("pad_and_hole" 
			    lconc(poly_data 
				TBX_CROSSCOPY_Get_Padstack_Poly_Info(struct)
			    ) 
			    lconc(hole_data 
				TBX_CROSSCOPY_Get_Padstack_Hole_Info(struct)
			    )
			) 
			("pad_only" 
			    lconc(poly_data 
				TBX_CROSSCOPY_Get_Padstack_Poly_Info(struct)
			    )
			) 
			("hole_only" 
			    lconc(poly_data 
				TBX_CROSSCOPY_Get_Padstack_Hole_Info(struct)
			    )
			) 
			("testpoint_figure" 
			    lconc(poly_data 
				TBX_CROSSCOPY_Get_Testpoint_Figure_Info(struct probe_figure)
			    )
			)
		    ) 
		    (poly_data = cdar(poly_data))
		    (hole_data = cdar(hole_data)) 
		    TBX_CROSSCOPY_Generate_Merged_Shapes(poly_data nil hole_data destination_layer)
		) 
		((((struct->objType) == "shape") || ((struct->objType) == "polygon")) 
		    TBX_CROSSCOPY_Copy_Shape(struct destination_layer shape_mode void_mode)
		) 
		(((struct->objType) == "text") 
		    TBX_CROSSCOPY_Copy_Text(struct destination_layer)
		)
		(((struct->objType) == "figure") 
		    TBX_CROSSCOPY_Copy_Figure(struct destination_layer figure_boundary_mode)
		) 
		(t 
		    printf("-->Function Select_and_Execute: Unknown type %L\n" 
			(struct->objType)
		    )
		)
	    )
	) t
    )
)
procedure(TBX_CROSSCOPY_Read_Probe_Type_Configuration() 
    let((probe_figure line cfg_file port arr
	    p_type p_figure
	) 
	(probe_figure = makeTable("probe_figure_data" nil)) 
	(cfg_file = strcat(getWorkingDir() "/probe_types.csv")) 
	when(isFile(cfg_file) 
	    (port = infile(cfg_file)) 
	    while((line = _gets(port)) 
		(arr = (axlStringCSVParse line t)) 
		when((length(arr) == 4) 
		    (p_type = cadr(arr)) 
		    (p_figure = nth(3 arr)) 
		    (probe_figure[p_type] = p_figure)
		)
	    ) 
	    close(port)
	) probe_figure
    )
)
procedure(TBX_CUSTOMVAR_Build_Context_Popup(form_handle) 
    let((name_list) 
	(name_list = TBX_CUSTOMVAR_Get_Context_Names()) 
	(name_list = setof(x name_list 
		(x != "BASE")
	    )) 
	(name_list = sort(name_list 
		'axlStrcmpAlpNum
	    )) 
	(name_list = cons("BASE" name_list))
	(axlFormBuildPopup form_handle "current_context" name_list) t
    )
)
procedure(TBX_CUSTOMVAR_Build_Prop_String(ph_param prop_type) 
    let((mirror_type prop_str) 
	cond(((prop_type == "name") 
		(prop_str = strcat((ph_param->name) "|" 
			(ph_param->histLevel)
		    ))
	    ) 
	    ((prop_type == "attr") 
		if((ph_param->mirror) then 
		    (mirror_type = "YES") else 
		    (mirror_type = "NO")
		) 
		(prop_str = strcat((ph_param->type) "|" 
			(ph_param->layer) "|" 
			(ph_param->textBlock)
			"|" 
			sprintf(nil "%.2f" 
			    (ph_param->rotation)
			) "|" 
			(ph_param->justify) "|"
			mirror_type
		    ))
	    )
	) prop_str
    )
)
procedure(TBX_CUSTOMVAR_Calculate_Placeholder_Extents(ph_param) 
    let((display_value text_height text_width block_param char_cnt
	    origin xy1 xy2 xy3 xy4
	    pt_new pt_list poly_xy_list result
	) 
	(display_value = (ph_param->displayValue)) 
	unless(display_value 
	    (display_value = " ")
	) 
	(block_param = (axlGetParam 
		strcat("paramTextBlock:" 
		    (ph_param->textBlock)
		)
	    )) 
	(char_cnt = strlen(display_value))
	(text_width = ((char_cnt * (block_param->width)) + ((char_cnt - 1) * (block_param->charSpace)))) 
	(text_height = (block_param->height)) 
	(xy1 = (0.0:0.0)) 
	(xy2 = (text_width:0.0)) 
	(xy3 = (text_width:text_height))
	(xy4 = (0.0:text_height)) 
	case((ph_param->justify) 
	    ("LEFT" 
		(origin = (0.0:0.0))
	    ) 
	    ("CENTER" 
		(origin = ((text_width / 2.0):0.0))
	    ) 
	    ("RIGHT" 
		(origin = (text_width:0.0))
	    )
	) 
	foreach(pt 
	    list(xy1 xy2 xy3 xy4) 
	    (pt_new = pt) 
	    when((ph_param->mirror) 
		(pt_new = (axlGeoRotatePt 0.0 pt_new origin t))
	    ) 
	    (pt_new = (axlGeoRotatePt 
		    (ph_param->rotation) pt_new origin
		))
	    (pt_list = cons(pt_new pt_list))
	) 
	(pt_list = reverse(pt_list)) 
	(poly_xy_list = append1(pt_list 
		car(pt_list)
	    ))
	(result = list(origin poly_xy_list)) result
    )
)
procedure(TBX_CUSTOMVAR_Callback(form_handle) 
    let((cell new_context current_context var_name var_value
	    base_key context_list value text_color
	) 
	case((form_handle->curField) 
	    ("var_update" 
		case((form_handle->curValue) 
		    ("process_all" 
			(context_list = TBX_CUSTOMVAR_Get_Context_Names())
		    ) 
		    ("process_current" 
			(context_list = list((axlFormGetField form_handle "current_context")))
		    )
		) 
		TBX_CUSTOMVAR_Update_Start("variable" context_list) 
		(axlVisibleUpdate t)
	    ) 
	    ("push_to_history" 
		case((form_handle->curValue) 
		    ("process_all" 
			(context_list = TBX_CUSTOMVAR_Get_Context_Names())
		    ) 
		    ("process_current" 
			(context_list = list((axlFormGetField form_handle "current_context")))
		    )
		) 
		TBX_CUSTOMVAR_Update_Start("history" context_list)
	    ) 
	    ("grid" 
		caseq((form_handle->event) 
		    (rightpopup 
			case((form_handle->curValue) 
			    ("clear_current_context_variable" 
				(current_context = (axlFormGetField form_handle "current_context")) 
				if((current_context != "BASE") then 
				    (cell = (axlFormGridNewCell)) 
				    (cell->col = 2) 
				    (cell->row = (form_handle->row))
				    (var_name = ((axlFormGridGetCell form_handle "grid" cell)->value)) 
				    (base_key = strcat(var_name "|0")) 
				    (var_value = ((tbx_customvar_global->varInfo)["BASE"][base_key]->newValue)) 
				    unless(var_value 
					(var_value = "")
				    ) 
				    (cell = (axlFormGridNewCell))
				    (cell->col = 3) 
				    (cell->row = (form_handle->row)) 
				    (cell->value = var_value) 
				    (axlFormSetField form_handle "grid" cell) 
				    when((tbx_customvar_global->varInfo)[current_context][var_name] 
					((tbx_customvar_global->varInfo)[current_context][var_name]->newValue = var_value) 
					((tbx_customvar_global->varDef)[current_context][var_name] = var_value)
				    )
				    else 
				    printf("Info: Only applies for context other than BASE\n")
				)
			    ) 
			    ("clear_all_context" 
				(current_context = (axlFormGetField form_handle "current_context")) 
				if((current_context != "BASE") then 
				    for(r 1 
					((tbx_customvar_global->gridRows)->main) 
					(cell = (axlFormGridNewCell)) 
					(cell->col = 2)
					(cell->row = r) 
					(var_name = ((axlFormGridGetCell form_handle "grid" cell)->value)) 
					(base_key = strcat(var_name "|0")) 
					(var_value = ((tbx_customvar_global->varInfo)["BASE"][base_key]->newValue)) 
					unless(var_value 
					    (var_value = "")
					)
					(cell = (axlFormGridNewCell)) 
					(cell->col = 3) 
					(cell->row = r) 
					(cell->value = var_value) 
					(axlFormSetField form_handle "grid" cell)
					when((tbx_customvar_global->varInfo)[current_context][var_name] 
					    ((tbx_customvar_global->varInfo)[current_context][var_name]->newValue = var_value) 
					    ((tbx_customvar_global->varDef)[current_context][var_name] = var_value)
					)
				    ) else 
				    printf("Info: Only applies for context other than BASE\n")
				)
			    )
			) 
			(axlFormGridUpdate form_handle "grid")
		    ) 
		    (change 
			(current_context = (axlFormGetField form_handle "current_context")) 
			(cell = (axlFormGridNewCell)) 
			(cell->col = 2) 
			(cell->row = (form_handle->row))
			(var_name = ((axlFormGridGetCell form_handle "grid" cell)->value)) 
			(cell = (axlFormGridNewCell)) 
			(cell->col = 3) 
			(cell->row = (form_handle->row)) 
			(value = ((axlFormGridGetCell form_handle "grid" cell)->value))
			((tbx_customvar_global->varInfo)[current_context][var_name]->newValue = value) 
			((tbx_customvar_global->varDef)[current_context][var_name] = value) 
			if((current_context == "BASE") then t else 
			    if((value != ((tbx_customvar_global->varInfo)["BASE"][var_name]->newValue)) then 
				(text_color = 'blue) else 
				(text_color = nil)
			    )
			    (cell = (axlFormGridNewCell)) 
			    (cell->col = 3) 
			    (cell->row = (form_handle->row)) 
			    (cell->value = ((axlFormGridGetCell form_handle "grid" cell)->value)) 
			    (cell->textColor = text_color)
			    (axlFormSetField form_handle "grid" cell) 
			    (axlFormGridUpdate form_handle "grid")
			)
		    )
		)
	    ) 
	    ("current_context" 
		(tbx_customvar_global->varInfo = TBX_CUSTOMVAR_Synchronize_Context((form_handle->curValue))) 
		(axlFormSetField form_handle "match_name" "*") 
		(axlFormSetField form_handle "match_context" "*") 
		(axlFormSetField form_handle "match_value" "*")
		if((TBX_CUSTOMVAR_Get_Status()->hasContext) then 
		    TBX_CUSTOMVAR_Init_Grid(form_handle) else 
		    (axlUIConfirm "Note: No context placeholders defined in the design. For more details refer to section 2.3.1 from documentation.")
		    (axlFormSetField form_handle "current_context" "BASE") 
		    TBX_CUSTOMVAR_Init_Grid(form_handle)
		)
	    )
	    ("add_new_context" 
		(new_context = (axlEnterString ?prompts 
			list("Enter new context to be added:")
		    )) 
		when(new_context 
		    (new_context = upperCase(new_context)) 
		    (tbx_customvar_global->varInfo = TBX_CUSTOMVAR_Synchronize_Context(new_context)) 
		    (tbx_customvar_global->textLayer = TBX_CUSTOMVAR_Get_Context_Layers()) 
		    TBX_CUSTOMVAR_Build_Context_Popup(form_handle)
		)
	    ) 
	    ("limit_view" 
		(current_context = upperCase((axlFormGetField form_handle "current_context"))) 
		TBX_CUSTOMVAR_Limit_View(current_context)
	    ) 
	    ("specify_layer_map" 
		TBX_CUSTOMVAR_LAYERMAP_Start()
	    ) 
	    ("match_name" 
		TBX_CUSTOMVAR_Init_Grid(form_handle)
	    ) 
	    ("match_context" 
		TBX_CUSTOMVAR_Init_Grid(form_handle)
	    )
	    ("match_value" 
		TBX_CUSTOMVAR_Init_Grid(form_handle)
	    ) 
	    ("show_all" 
		TBX_CUSTOMVAR_Global_Display(t)
	    ) 
	    ("hide_all" 
		TBX_CUSTOMVAR_Global_Display(nil)
	    ) 
	    ("done" 
		TBX_CUSTOMVAR_Save_Variables() 
		TBX_CUSTOMVAR_Save_Layer_Map((tbx_customvar_global->layerMap) nil) 
		(axlFormClose form_handle) 
		(axlFinishEnterFun)
		(axlVisibleLayer 
		    ((tbx_customvar_global->sysDefaults)->layer) nil
		) 
		(axlVisibleUpdate t)
	    ) 
	    ("my_help" 
		(axlShell "tbx help customvar")
	    )
	    (t 
		println((form_handle->curField))
	    )
	)
    )
)
procedure(TBX_CUSTOMVAR_Check_Layers(context_list layerMap) 
    let((layer_name layer_list lyr_prm) 
	foreach(cxt context_list 
	    (layer_name = nil) 
	    if((cxt == "BASE") then 
		foreach(key layerMap 
		    when((key != "BASE") 
			foreach(entry 
			    layerMap[key] 
			    (layer_name = cadr(entry))
			)
		    )
		) else 
		foreach(entry 
		    layerMap["CONTEXT"] 
		    when((car(entry) == cxt) 
			(layer_name = cadr(entry))
		    )
		)
		unless(layer_name 
		    (layer_name = strcat((axlMapClassName "DRAWING FORMAT") "/CXT_" cxt))
		)
	    ) 
	    when(layer_name 
		(layer_list = cons(layer_name layer_list))
	    )
	) 
	foreach(lyr layer_list 
	    unless((axlLayerGet lyr) 
		(axlLayerCreateNonConductor lyr) 
		(lyr_prm = (axlLayerGet lyr)) 
		(lyr_prm->color = 1) 
		(axlLayerSet lyr_prm)
	    )
	) t
    )
)
procedure(TBX_CUSTOMVAR_Dump() 
    let((file port cxt_list name_list key_str) 
	(file = "./customvar_debug.txt") 
	(port = outfile(file "w")) 
	fprintf(port "==============\n") 
	fprintf(port "Layer Map\n")
	fprintf(port "==============\n") 
	foreach(key 
	    (tbx_customvar_global->layerMap) 
	    (key_str = sprintf(nil "layerMap[%L]" key)) 
	    fprintf(port "%-35s =  %L\n" key_str 
		(tbx_customvar_global->layerMap)[key]
	    )
	) 
	fprintf(port "\n") 
	fprintf(port "=====================================\n") 
	fprintf(port "Data from local cfg file %L\n" 
	    ((tbx_customvar_global->varConfig)->localFile)
	)
	fprintf(port "=====================================\n") 
	foreach(entry 
	    ((tbx_customvar_global->varConfig)->localData) 
	    fprintf(port "%L\n" entry)
	) 
	fprintf(port "\n") 
	fprintf(port "=====================================\n") 
	fprintf(port "Data from cpm file %L\n" 
	    ((tbx_customvar_global->varConfig)->cpmFile)
	)
	fprintf(port "=====================================\n") 
	foreach(entry 
	    ((tbx_customvar_global->varConfig)->cpmData) 
	    fprintf(port "%L\n" entry)
	) 
	fprintf(port "\n") 
	fprintf(port "==========================================\n") 
	fprintf(port "Variable definitions separated by context\n")
	fprintf(port "===========================================\n") 
	if((tbx_customvar_global->varDef) then 
	    (cxt_list = mapcar(lambda((x) 
			car(x)
		    ) 
		    tableToList((tbx_customvar_global->varDef))
		)) 
	    (cxt_list = sort(cxt_list nil)) 
	    foreach(cxt cxt_list 
		(name_list = mapcar(lambda((x) 
			    car(x)
			) 
			tableToList((tbx_customvar_global->varDef)[cxt])
		    )) 
		(name_list = sort(name_list nil)) 
		foreach(vn name_list 
		    (key_str = sprintf(nil "varDef[%L][%L]" cxt vn)) 
		    fprintf(port "%-35s = %L\n" key_str 
			(tbx_customvar_global->varDef)[cxt][vn]
		    )
		)
		fprintf(port "\n")
	    )
	    fprintf(port "\n") else 
	    fprintf(port "NA\n")
	) 
	fprintf(port "=====================================\n") 
	fprintf(port "Context layer definitions\n") 
	fprintf(port "=====================================\n")
	if((tbx_customvar_global->textLayer) then 
	    (cxt_list = mapcar(lambda((x) 
			car(x)
		    ) 
		    tableToList((tbx_customvar_global->textLayer))
		)) 
	    (cxt_list = sort(cxt_list nil)) 
	    foreach(cxt cxt_list 
		(key_str = sprintf(nil "cxtLayer[%L]" cxt)) 
		fprintf(port "%-35s = %L\n" key_str 
		    (tbx_customvar_global->textLayer)[cxt]
		)
	    )
	    else 
	    fprintf(port "NA\n")
	) 
	fprintf(port "\n") 
	fprintf(port "=====================================\n") 
	fprintf(port "Variable Info for placeholders\n") 
	fprintf(port "=====================================\n")
	if((tbx_customvar_global->varInfo) then 
	    (cxt_list = mapcar(lambda((x) 
			car(x)
		    ) 
		    tableToList((tbx_customvar_global->varInfo))
		)) 
	    (cxt_list = sort(cxt_list nil)) 
	    foreach(cxt cxt_list 
		(name_list = mapcar(lambda((x) 
			    car(x)
			) 
			tableToList((tbx_customvar_global->varInfo)[cxt])
		    )) 
		(name_list = sort(name_list nil)) 
		foreach(vn name_list 
		    (key_str = sprintf(nil "phInfo[%L][%L]" cxt vn)) 
		    fprintf(port "%-35s = %L\n" key_str 
			(tbx_customvar_global->varInfo)[cxt][vn]
		    )
		)
		fprintf(port "\n")
	    )
	    fprintf(port "\n") else 
	    fprintf(port "NA\n")
	) 
	fprintf(port "=====================================\n") 
	fprintf(port "History Info\n") 
	fprintf(port "=====================================\n") 
	if(((tbx_customvar_global->status)->hasHistory) then 
	    (cxt_list = mapcar(lambda((x) 
			car(x)
		    ) 
		    tableToList((tbx_customvar_global->histLabel))
		)) 
	    (cxt_list = sort(cxt_list nil)) 
	    foreach(cxt cxt_list 
		(name_list = mapcar(lambda((x) 
			    car(x)
			) 
			tableToList((tbx_customvar_global->histLabel)[cxt])
		    )) 
		(name_list = sort(name_list nil)) 
		foreach(vn name_list 
		    for(i 0 9 
			(key_str = sprintf(nil "histLabel[%L][%L][%d]" cxt vn i)) 
			fprintf(port "%-35s = %L\n" key_str 
			    (tbx_customvar_global->histLabel)[cxt][vn][i]
			)
		    ) 
		    fprintf(port "\n")
		)
	    )
	    fprintf(port "\n") else 
	    fprintf(port "NA\n")
	)
	close(port) 
	printf("Note: File %L has been written\n" file) t
    )
)
procedure(TBX_CUSTOMVAR_Filter_Items(form_handle) 
    let((name_pattern value_pattern current_context filter_list var_dpl) 
	(current_context = (axlFormGetField form_handle "current_context")) 
	(name_pattern = TBX_UTIL_Trim_String((axlFormGetField form_handle "match_name"))) 
	(value_pattern = TBX_UTIL_Trim_String((axlFormGetField form_handle "match_value"))) 
	(name_pattern = TBX_UTIL_Regex_From_Shell(name_pattern t))
	(value_pattern = TBX_UTIL_Regex_From_Shell(value_pattern t)) 
	foreach(vn 
	    (tbx_customvar_global->varInfo)[current_context] 
	    cond((rexMatchp("^AUTO_" 
			upperCase(vn)
		    ) t
		) 
		(t 
		    when((rexMatchp(name_pattern vn) && 
			    rexMatchp(value_pattern 
				((tbx_customvar_global->varInfo)[current_context][vn]->newValue)
			    )) 
			(var_dpl = copy((tbx_customvar_global->varInfo)[current_context][vn])) 
			(var_dpl->dispName = vn) 
			cond((((var_dpl->source) == "cpm") 
				(var_dpl->backColor = 'button) 
				(var_dpl->noEdit = t)
			    ) 
			    (t 
				(var_dpl->backColor = nil) 
				(var_dpl->noEdit = nil)
			    )
			) 
			(var_dpl->textColor = nil)
			when((current_context != "BASE") 
			    when(((var_dpl->newValue) != ((tbx_customvar_global->varInfo)["BASE"][vn]->newValue)) 
				(var_dpl->textColor = 'blue)
			    )
			) 
			(filter_list = cons(list(vn var_dpl) filter_list))
		    )
		)
	    )
	) filter_list
    )
)
procedure(TBX_CUSTOMVAR_Get_All_Layers() 
    let((all_cxt_layers all_base_layers ph_param result) 
	foreach(cxt 
	    (tbx_customvar_global->textLayer) 
	    (all_cxt_layers = cons((tbx_customvar_global->textLayer)[cxt] all_cxt_layers))
	) 
	foreach(ph 
	    TBX_CUSTOMVAR_Get_All_Placeholders() 
	    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(((ph->prop)->TBX_CUSTOMVAR_NAME) 
		    ((ph->prop)->TBX_CUSTOMVAR_ATTR)
		)) 
	    when((((ph_param->type) == "C") && (ph_param->layer)) 
		unless(exists(x all_base_layers 
			((ph_param->layer) == x)
		    ) 
		    (all_base_layers = cons((ph_param->layer) all_base_layers))
		)
	    )
	) 
	(result = list(all_base_layers all_cxt_layers)) result
    )
)
procedure(TBX_CUSTOMVAR_Get_All_Placeholders() 
    let((ph_list) 
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "boundary_shapes" "shapes") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	when((axlGetSelSet) 
	    (ph_list = setof(x 
		    (axlGetSelSet) 
		    ((x->layer) == ((tbx_customvar_global->sysDefaults)->layer))
		)) 
	    (ph_list = setof(x ph_list 
		    (((x->prop)->TBX_CUSTOMVAR_NAME) && ((x->prop)->TBX_CUSTOMVAR_ATTR))
		))
	)
	(axlClearSelSet) ph_list
    )
)
procedure(TBX_CUSTOMVAR_Get_Context_Layers() 
    let((layerName context_name) 
	(layerName = makeTable("layer_name_table" nil)) 
	foreach(cxt 
	    (tbx_customvar_global->varDef) 
	    when((cxt != "BASE") 
		(layerName[cxt] = strcat((axlMapClassName "DRAWING FORMAT") "/CXT_" cxt))
	    )
	) 
	foreach(lyr 
	    (axlSubclasses 
		(axlMapClassName "DRAWING FORMAT")
	    ) 
	    when(rexMatchp("^CXT_" 
		    upperCase(lyr)
		) 
		rexCompile("^CXT_") 
		(context_name = rexReplace(lyr "" 0)) 
		unless(layerName[context_name] 
		    (layerName[context_name] = strcat((axlMapClassName "DRAWING FORMAT") "/CXT_" context_name))
		)
	    )
	) layerName
    )
)
procedure(TBX_CUSTOMVAR_Get_Context_Names() 
    let((context_list) 
	foreach(key 
	    (tbx_customvar_global->varInfo) 
	    (context_list = cons(key context_list))
	) 
	(context_list = sort(context_list nil)) context_list
    )
)
procedure(TBX_CUSTOMVAR_Get_Obsolete_Texts(ph) 
    let((ph_param obsolete_text_list c_layers g_layers layer_name) 
	(ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(((ph->prop)->TBX_CUSTOMVAR_NAME) 
		((ph->prop)->TBX_CUSTOMVAR_ATTR)
	    )) 
	foreach(cxt 
	    (tbx_customvar_global->textLayer) 
	    (layer_name = (tbx_customvar_global->textLayer)[cxt]) 
	    when((layer_name != member(layer_name c_layers)) 
		(c_layers = cons(layer_name c_layers))
	    )
	) 
	unless(member((ph_param->layer) c_layers) 
	    (c_layers = cons((ph_param->layer) c_layers))
	) 
	foreach(entry 
	    (tbx_customvar_global->layerMap)[(ph_param->name)] 
	    (g_layers = cons(cadr(entry) g_layers))
	)
	case((ph_param->type) 
	    ("S" 
		(obsolete_text_list = setof(x 
			(axlDBGetAttachedText ph) 
			((x->layer) != (ph_param->layer))
		    ))
	    ) 
	    ("C" 
		(obsolete_text_list = setof(x 
			(axlDBGetAttachedText ph) 
			!member((x->layer) c_layers)
		    ))
	    ) 
	    ("G" 
		(obsolete_text_list = setof(x 
			(axlDBGetAttachedText ph) 
			!member((x->layer) g_layers)
		    ))
	    )
	) obsolete_text_list
    )
)
procedure(TBX_CUSTOMVAR_Get_Placeholder_Base_Values(ph ph_param) 
    let((base_data text_list base_info) 
	(text_list = setof(x 
		(axlDBGetAttachedText ph) 
		((x->layer) == (ph_param->layer))
	    )) 
	if(text_list then 
	    (base_data = list("BASE" 
		    (ph_param->layer) 
		    (car(text_list)->text)
		)) else 
	    (base_data = list("BASE" 
		    (ph_param->layer) "<NULL>"
		))
	) 
	(base_info = list(base_data)) base_info
    )
)
procedure(TBX_CUSTOMVAR_Get_Placeholder_Context_Values(ph ph_param) 
    let((text_layer text_value tmp_data context_info) 
	(tmp_data = makeTable("tmp_data_context_table" nil)) 
	(tmp_data["BASE"] = list((ph_param->layer) "<NULL>")) 
	foreach(cxt 
	    (tbx_customvar_global->textLayer) 
	    (tmp_data[cxt] = list((tbx_customvar_global->textLayer)[cxt] "<NULL>"))
	) 
	foreach(txt 
	    (axlDBGetAttachedText ph) 
	    (text_layer = upperCase((txt->layer))) 
	    (text_value = (txt->text)) 
	    if((text_layer == (ph_param->layer)) then 
		(tmp_data["BASE"] = list(text_layer text_value)) else 
		foreach(cxt tmp_data 
		    when((car(tmp_data[cxt]) == text_layer) 
			(tmp_data[cxt] = list(text_layer text_value))
		    )
		)
	    )
	)
	foreach(cxt tmp_data 
	    (context_info = cons(list(cxt 
			car(tmp_data[cxt]) 
			cadr(tmp_data[cxt])
		    ) context_info
		))
	) context_info
    )
)
procedure(TBX_CUSTOMVAR_Get_Placeholder_Group_Values(ph ph_param) 
    let((tmp_data group_info group_layer_map var_name sub_name
	    text_layer text_value
	) 
	(var_name = (ph_param->name)) 
	(group_layer_map = (tbx_customvar_global->layerMap)[var_name]) 
	(tmp_data = makeTable("tmp_data_group_table" nil)) 
	foreach(entry group_layer_map 
	    (sub_name = car(entry)) 
	    (text_layer = cadr(entry)) 
	    (tmp_data[sub_name] = list(text_layer "<NULL>"))
	)
	foreach(txt 
	    (axlDBGetAttachedText ph) 
	    (text_layer = upperCase((txt->layer))) 
	    (text_value = (txt->text)) 
	    foreach(sn tmp_data 
		when((car(tmp_data[sn]) == text_layer) 
		    (tmp_data[sn] = list(text_layer text_value))
		)
	    )
	) 
	foreach(sn tmp_data 
	    (group_info = cons(list(sn 
			car(tmp_data[sn]) 
			cadr(tmp_data[sn])
		    ) group_info
		))
	) 
	unless(group_info 
	    (group_info = list(list("*" "?" "<NULL>")))
	) group_info
    )
)
procedure((TBX_CUSTOMVAR_Get_Placeholder_Param arg1 \@optional arg2) 
    let((form_handle name_str attr_str arr ph_param
	    hist_level_str
	) 
	(ph_param = ncons(nil)) 
	if(((type(arg1) == 'string) && (type(arg2) == 'string)) then 
	    (name_str = arg1) 
	    (attr_str = arg2) 
	    (arr = parseString(upperCase(name_str) "|"))
	    when((length(arr) == 2) 
		(ph_param->name = car(arr)) 
		(ph_param->displayValue = strcat("<" 
			(ph_param->name) ">"
		    )) 
		(ph_param->histLevel = cadr(arr))
	    ) 
	    (arr = parseString(upperCase(attr_str) "|")) 
	    (ph_param->type = car(arr)) 
	    (ph_param->layer = cadr(arr)) 
	    (ph_param->textBlock = caddr(arr))
	    (ph_param->rotation = atof(nth(3 arr))) 
	    (ph_param->justify = nth(4 arr)) 
	    if((nth(5 arr) == "YES") then 
		(ph_param->mirror = t) else 
		(ph_param->mirror = nil)
	    ) else 
	    (form_handle = arg1)
	    (ph_param->name = (axlFormGetField form_handle "variable_name")) 
	    (ph_param->displayValue = (axlFormGetField form_handle "display_value")) 
	    (ph_param->layer = (axlDBControl 
		    'activeLayer
		)) 
	    (ph_param->textBlock = sprintf(nil "%d" 
		    (axlFormGetField form_handle "text_block")
		)) 
	    (ph_param->justify = (axlFormGetField form_handle "text_align"))
	    (ph_param->rotation = (axlFormGetField form_handle "text_rotation")) 
	    (hist_level_str = (axlFormGetField form_handle "hist_level")) 
	    case((axlFormGetField form_handle "placeholder_type") 
		("standard" 
		    (ph_param->type = "S") 
		    if((hist_level_str == "none") then 
			(ph_param->histLevel = "0") else 
			(ph_param->histLevel = hist_level_str)
		    )
		) 
		("context" 
		    (ph_param->type = "C") 
		    if((hist_level_str == "none") then 
			(ph_param->histLevel = "0") else 
			(ph_param->histLevel = hist_level_str)
		    )
		) 
		("group" 
		    (ph_param->type = "G") 
		    (ph_param->histLevel = "0")
		)
	    ) 
	    if(((axlFormGetField form_handle "text_mirror") == "YES") then 
		(ph_param->mirror = t) else 
		(ph_param->mirror = nil)
	    )
	) ph_param
    )
)
procedure(TBX_CUSTOMVAR_Get_Placeholder_Text_Info(ph ph_param) 
    let((data) 
	case((ph_param->type) 
	    ("S" 
		(data = TBX_CUSTOMVAR_Get_Placeholder_Base_Values(ph ph_param)) 
		(data = cons("S" data))
	    ) 
	    ("C" 
		(data = TBX_CUSTOMVAR_Get_Placeholder_Context_Values(ph ph_param)) 
		(data = cons("C" data))
	    ) 
	    ("G" 
		(data = TBX_CUSTOMVAR_Get_Placeholder_Group_Values(ph ph_param)) 
		(data = cons("G" data))
	    )
	) data
    )
)
procedure(TBX_CUSTOMVAR_Get_Status() 
    let((status unmapped_groups arr grp_name) 
	(status = ncons(nil)) 
	foreach(cxt 
	    (tbx_customvar_global->varInfo) 
	    foreach(vn 
		(tbx_customvar_global->varInfo)[cxt] 
		case(((tbx_customvar_global->varInfo)[cxt][vn]->type) 
		    ("S" 
			(status->hasStandard = t)
		    ) 
		    ("C" 
			(status->hasContext = t)
		    ) 
		    ("G" 
			(status->hasGroup = t) 
			(arr = parseString(vn "|")) 
			when(((length(arr) == 2) && (cadr(arr) == "*")) 
			    (grp_name = car(arr)) 
			    unless(exists(x unmapped_groups 
				    (x == grp_name)
				) 
				(unmapped_groups = cons(grp_name unmapped_groups))
			    )
			)
		    )
		)
	    )
	) 
	(status->unMappedGroups = unmapped_groups) 
	foreach(cxt 
	    (tbx_customvar_global->histLabel) 
	    foreach(vn 
		(tbx_customvar_global->histLabel)[cxt] 
		for(i 1 9 
		    when((tbx_customvar_global->histLabel)[cxt][vn][i] 
			(status->hasHistory = t)
		    )
		)
	    )
	)
	status
    )
)
procedure(TBX_CUSTOMVAR_Get_Variable_Definitions() 
    let((varDef var_name var_context var_value) 
	(varDef = makeTable("var_def_table_data" nil)) 
	foreach(src 
	    list(((tbx_customvar_global->varConfig)->localData) 
		((tbx_customvar_global->varConfig)->cpmData)
	    ) 
	    foreach(entry src 
		(var_name = car(entry)) 
		(var_context = cadr(entry)) 
		(var_value = caddr(entry))
		unless(varDef[var_context] 
		    (tbx_customvar_global->hashCnt = ((tbx_customvar_global->hashCnt) + 1)) 
		    (varDef[var_context] = makeTable(sprintf(nil "hash_%02d" 
				(tbx_customvar_global->hashCnt)
			    ) nil
			))
		) 
		(varDef[var_context][var_name] = var_value)
	    )
	) varDef
    )
)
procedure(TBX_CUSTOMVAR_Global_Display(mode) 
    let((result variassy_layers) 
	(result = TBX_CUSTOMVAR_Get_All_Layers()) 
	foreach(lyr 
	    nconc(car(result) 
		cadr(result)
	    ) 
	    (axlVisibleLayer lyr mode)
	) 
	foreach(grp 
	    (axlSelectByName "GROUP" "VAS_*" t) 
	    foreach(mem 
		(grp->groupMembers) 
		unless(exists(x variassy_layers 
			(x == (mem->layer))
		    ) 
		    (variassy_layers = cons((mem->layer) variassy_layers))
		)
	    )
	) 
	foreach(lyr variassy_layers 
	    (axlVisibleLayer lyr nil)
	)
	(axlClearSelSet) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_CUSTOMVAR_Init() 
    let((lyr_prm popup_map sys_defaults var_config FC_FEATURE
	    FC_VERSION SUB_VERSION VERSION_STR app_info max_block
	    block_id design_type
	) 
	(FC_FEATURE = "CUSTOMVAR") 
	(FC_VERSION = "17.1") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Custom Variables %s (C)2017" FC_VERSION))
	(app_info = list(nil 
		'name FC_FEATURE 
		'version FC_VERSION
		'release SUB_VERSION 
		'title VERSION_STR
	    )) 
	(sys_defaults = ncons(nil)) 
	(sys_defaults->layer = "MANUFACTURING/TBX_CUSTOMVAR_SYS") 
	(sys_defaults->phSize = (axlMKSConvert "0.5 MM" 
		car((axlDBGetDesignUnits))
	    )) 
	(design_type = upperCase((axlDesignType t)))
	when((((design_type == "MCM") || (design_type == "SIP")) && !axlGetVariable("TBX_PV_REGRESSION")) 
	    (sys_defaults->phSize = (axlMKSConvert "0.2 MM" 
		    car((axlDBGetDesignUnits))
		))
	) 
	unless((axlLayerGet 
		(sys_defaults->layer)
	    ) 
	    (axlLayerCreateNonConductor 
		(sys_defaults->layer)
	    ) 
	    (lyr_prm = (axlLayerGet 
		    (sys_defaults->layer)
		)) 
	    (lyr_prm->color = 17) 
	    (axlLayerSet lyr_prm)
	) 
	(axlColorPrioritySet 
	    'top 
	    ((axlLayerGet 
		    (sys_defaults->layer)
		)->color)
	) 
	(axlVisibleLayer 
	    (sys_defaults->layer) t
	) 
	(axlVisibleUpdate t)
	foreach(prp 
	    list("TBX_CUSTOMVAR_NAME" "TBX_CUSTOMVAR_ATTR") 
	    unless((axlDBGetPropDictEntry prp) 
		(axlDBCreatePropDictEntry prp "STRING" 
		    list("shapes")
		)
	    )
	) 
	(var_config = ncons(nil)) 
	(var_config->localFile = strcat(getWorkingDir() "/customvar.cfg")) 
	(block_id = 1) 
	while(((axlGetParam 
		    sprintf(nil "paramTextBlock:%d" block_id)
		)->height) 
	    (max_block = block_id) 
	    ++block_id
	)
	(sys_defaults->maxBlockInt = max_block) 
	(popup_map = makeTable("popup_table" nil)) 
	foreach(cls 
	    ((axlGetParam "paramLayerGroup")->groupMembers) 
	    case(upperCase((axlMapClassName cls t)) 
		("BOARD GEOMETRY" 
		    (popup_map[cls] = "BoardGeo")
		) 
		("DRAWING FORMAT" 
		    (popup_map[cls] = "DrngFmt")
		) 
		("ETCH" 
		    (popup_map[cls] = "Etch")
		) 
		("MANUFACTURING" 
		    (popup_map[cls] = "Mfg")
		)
		("PACKAGE GEOMETRY" 
		    (popup_map[cls] = "PkgGeo")
		) 
		(t t)
	    )
	) 
	unless(boundp('tbx_customvar_global) 
	    iliDefstruct('defstruct(tbx_customvar_global_struct formHandle runTime varInfo histLabel
			popupMap transMark hashCnt licCheck sysDefaults
			varConfig varDef layerMap curMap gridRows
			filterData templateInfo status appInfo cxtLayer
		    )
	    ) 
	    defvar(tbx_customvar_global nil)
	) 
	if(!tbx_customvar_global then 
	    (tbx_customvar_global = (make_tbx_customvar_global_struct ?hashCnt 0 ?formHandle 
		    ncons(nil)
		    ?varConfig var_config ?varDef nil ?varInfo
		    nil ?histLabel nil ?runTime 
		    ncons(nil)
		    ?sysDefaults sys_defaults ?gridRows 
		    ncons(nil) ?popupMap
		    popup_map ?transMark nil ?licCheck nil
		    ?layerMap nil ?curMap nil ?filterData
		    nil ?templateInfo nil ?status nil
		    ?appInfo app_info ?cxtLayer nil
		)) else 
	    (tbx_customvar_global->hashCnt = 0)
	    (tbx_customvar_global->formHandle = ncons(nil)) 
	    (tbx_customvar_global->varConfig = var_config) 
	    (tbx_customvar_global->varDef = var_config) 
	    (tbx_customvar_global->varInfo = nil) 
	    (tbx_customvar_global->histLabel = nil)
	    (tbx_customvar_global->runTime = ncons(nil)) 
	    (tbx_customvar_global->sysDefaults = sys_defaults) 
	    (tbx_customvar_global->gridRows = ncons(nil)) 
	    (tbx_customvar_global->popupMap = popup_map) 
	    (tbx_customvar_global->transMark = nil)
	    (tbx_customvar_global->licCheck = nil) 
	    (tbx_customvar_global->layerMap = nil) 
	    (tbx_customvar_global->curMap = nil) 
	    (tbx_customvar_global->filterData = nil) 
	    (tbx_customvar_global->templateInfo = nil)
	    (tbx_customvar_global->status = nil) 
	    (tbx_customvar_global->appInfo = app_info) 
	    (tbx_customvar_global->textLayer = nil)
	)
	t
    )
)
procedure(TBX_CUSTOMVAR_Init_Form(form_handle mode) 
    let((record msg) 
	cond(((mode == "place") 
		(record = "customvar|place") 
		(axlFormSetField form_handle "variable_name" "") 
		(axlFormSetField form_handle "display_value" "") 
		(axlDBControl 
		    'activeLayer 
		    TBX_SESSION_Get_Param(record "active_layer" "DRAWING FORMAT/TITLE_BLOCK")
		)
		(axlFormSetField form_handle "text_block" 
		    TBX_SESSION_Get_Param(record "text_block" 3)
		) 
		(axlFormSetField form_handle "text_rotation" 
		    TBX_SESSION_Get_Param(record "text_rotation" 0.0)
		) 
		(axlFormSetField form_handle "text_align" 
		    TBX_SESSION_Get_Param(record "text_align" "LEFT")
		) 
		(axlFormSetField form_handle "text_mirror" 
		    TBX_SESSION_Get_Param(record "text_mirror" "NO")
		) 
		(axlFormSetField form_handle "add_placeholder" 
		    TBX_SESSION_Get_Param(record "add_placeholder" t)
		)
		(axlFormSetField form_handle "modify_placeholder" 
		    TBX_SESSION_Get_Param(record "modify_placeholder" nil)
		) 
		(axlFormSetField form_handle "delete_placeholder" 
		    TBX_SESSION_Get_Param(record "delete_placeholder" nil)
		) 
		(axlFormSetField form_handle "placeholder_type" 
		    TBX_SESSION_Get_Param(record "placeholder_type" "standard")
		) 
		(axlFormSetField form_handle "hist_level" 
		    TBX_SESSION_Get_Param(record "hist_level" "none")
		) 
		case((axlFormGetField form_handle "placeholder_type") 
		    ("standard" 
			(axlFormSetFieldEditable form_handle "hist_level" t)
		    ) 
		    ("context" 
			(axlFormSetFieldEditable form_handle "hist_level" t)
		    ) 
		    ("group" 
			(axlFormSetFieldEditable form_handle "hist_level" nil)
		    )
		)
	    ) 
	    ((mode == "main") 
		(axlFormSetField form_handle "match_name" "*") 
		(axlFormSetField form_handle "match_context" "*") 
		(axlFormSetField form_handle "match_value" "*") 
		TBX_CUSTOMVAR_Build_Context_Popup(form_handle)
		(axlFormSetField form_handle "current_context" "BASE") 
		(axlFormSetField form_handle "process_current_only" t) 
		if(((tbx_customvar_global->status)->hasHistory) then 
		    (axlFormSetFieldEditable form_handle "push_to_history" t) else 
		    (axlFormSetFieldEditable form_handle "push_to_history" nil)
		) 
		if(((tbx_customvar_global->status)->hasGroup) then 
		    (axlFormSetFieldEditable form_handle "specify_layer_map" t) else 
		    (axlFormSetFieldEditable form_handle "specify_layer_map" nil)
		) 
		TBX_CUSTOMVAR_Init_Grid(form_handle)
		when(((tbx_customvar_global->status)->unMappedGroups) 
		    (msg = sprintf(nil "Layer mapping required for group placeholder(s) %s. Specify mapping first." 
			    buildString(((tbx_customvar_global->status)->unMappedGroups) " ")
			)) 
		    (axlUIConfirm msg)
		)
	    )
	) t
    )
)
procedure(TBX_CUSTOMVAR_Init_Grid(form_handle) 
    (axlFormGridReset form_handle "grid") 
    TBX_CUSTOMVAR_Init_Grid_Cols(form_handle) 
    TBX_CUSTOMVAR_Init_Grid_Rows(form_handle) 
    (axlFormGridUpdate form_handle "grid")
    (axlFormGridEvents form_handle "grid" 
	list('cellselect 
	    'change 
	    'rightpopup
	)
    )
)
procedure(TBX_CUSTOMVAR_Init_Grid_Cols(form_handle) 
    let((p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 4) 
	(p->fieldLength = 1)
	(p->headText = "Type") 
	(p->scriptLabel = "variable_type") 
	(axlFormGridInsertCol form_handle "grid" p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING)
	(p->colWidth = 16) 
	(p->fieldLength = 50) 
	(p->headText = "Name") 
	(p->scriptLabel = "variable_name") 
	(axlFormGridInsertCol form_handle "grid" p)
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 16) 
	(p->fieldLength = 50) 
	(p->headText = "Value")
	(p->scriptLabel = "variable_value") 
	(axlFormGridInsertCol form_handle "grid" p)
    )
)
procedure(TBX_CUSTOMVAR_Init_Grid_Rows(form_handle) 
    let((a) 
	(a = a) 
	(tbx_customvar_global->filterData = TBX_CUSTOMVAR_Filter_Items(form_handle)) 
	if(zerop(length((tbx_customvar_global->filterData))) then t 
	    printf("Info: No data to display.\n") 
	    ((tbx_customvar_global->gridRows)->main = 0)
	    else 
	    (axlFormGridInsertRows form_handle "grid" 0 
		length((tbx_customvar_global->filterData))
	    ) 
	    ((tbx_customvar_global->gridRows)->main = length((tbx_customvar_global->filterData))) 
	    (axlFormGridSetBatch form_handle "grid" 
		'TBX_CUSTOMVAR_Init_Grid_Rows_CB nil
	    )
	)
    )
)
procedure(TBX_CUSTOMVAR_Init_Grid_Rows_CB(pvt) 
    let((cell index display_name new_value var_type
	    text_color back_color no_edit dpl_data filter_data
	) 
	(pvt = pvt) 
	(filter_data = sortcar((tbx_customvar_global->filterData) 
		'axlStrcmpAlpNum
	    )) 
	(dpl_data = mapcar(lambda((x) 
		    cadr(x)
		) filter_data
	    )) 
	(index = 1)
	foreach(dpl dpl_data 
	    (var_type = (dpl->type)) 
	    (display_name = (dpl->dispName)) 
	    (new_value = (dpl->newValue))
	    (text_color = (dpl->textColor)) 
	    (back_color = (dpl->backColor)) 
	    (no_edit = (dpl->noEdit)) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 1)
	    (cell->row = index) 
	    (cell->value = strcat("  " var_type " ")) 
	    (cell->backColor = 'button) 
	    (cell->noEdit = t) 
	    (axlFormGridBatch cell)
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 2) 
	    (cell->row = index) 
	    (cell->value = display_name) 
	    (cell->backColor = 'button)
	    (cell->noEdit = t) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 3) 
	    (cell->row = index)
	    (cell->value = new_value) 
	    (cell->backColor = back_color) 
	    (cell->noEdit = no_edit) 
	    (cell->textColor = text_color) 
	    (axlFormGridBatch cell)
	    index++
	)
    )
)
procedure(TBX_CUSTOMVAR_LAYERMAP_Callback(form_handle) 
    let((cell new_class subclass_popup tmp_list config_file
	    current_group data result
	) 
	case((form_handle->curField) 
	    ("current_group" 
		(axlFormGridReset form_handle "grid") 
		TBX_CUSTOMVAR_LAYERMAP_Init_Grid_Cols(form_handle) 
		TBX_CUSTOMVAR_LAYERMAP_Init_Grid_Rows(form_handle) 
		(axlFormGridUpdate form_handle "grid")
		(axlFormGridEvents form_handle "grid" 
		    list('cellselect 
			'change 
			'rightpopup
		    )
		)
	    ) 
	    ("grid" 
		(current_group = (axlFormGetField form_handle "current_group")) 
		caseq((form_handle->event) 
		    (rightpopup 
			case((form_handle->curValue) 
			    ("add_row" 
				((tbx_customvar_global->gridRows)->layerMap = (((tbx_customvar_global->gridRows)->layerMap) + 1)) 
				(axlFormGridInsertRows form_handle "grid" 
				    ((tbx_customvar_global->gridRows)->layerMap) 1
				) 
				(subclass_popup = (tbx_customvar_global->popupMap)[(axlMapClassName "DRAWING FORMAT")]) 
				(cell = (axlFormGridNewCell))
				(cell->col = 2) 
				(cell->row = ((tbx_customvar_global->gridRows)->layerMap)) 
				(cell->value = (axlMapClassName "DRAWING FORMAT")) 
				(cell->popup = "layer_class") 
				(axlFormSetField form_handle "grid" cell)
				(cell = (axlFormGridNewCell)) 
				(cell->col = 3) 
				(cell->row = ((tbx_customvar_global->gridRows)->layerMap)) 
				(cell->value = "TITLE_BLOCK") 
				(cell->popup = subclass_popup)
				(axlFormSetField form_handle "grid" cell) 
				(data = TBX_CUSTOMVAR_LAYERMAP_Extract_Grid(form_handle 
					((tbx_customvar_global->gridRows)->layerMap)
				    )) 
				((tbx_customvar_global->layerMapTmp)[current_group] = data)
			    ) 
			    ("delete_row" 
				if((((tbx_customvar_global->gridRows)->layerMap) >= 2) then 
				    (axlFormGridDeleteRows form_handle "grid" 
					(form_handle->row) 1
				    ) 
				    ((tbx_customvar_global->gridRows)->layerMap = (((tbx_customvar_global->gridRows)->layerMap) - 1)) else
				    (tmp_list = list("" "" "")) 
				    for(i 1 3 
					(cell = (axlFormGridNewCell)) 
					(cell->col = i)
					(cell->row = 1) 
					(cell->value = nth((i - 1) tmp_list)) 
					(axlFormSetField form_handle "grid" cell)
				    )
				) 
				(axlFormGridUpdate form_handle "grid") 
				(data = TBX_CUSTOMVAR_LAYERMAP_Extract_Grid(form_handle 
					((tbx_customvar_global->gridRows)->layerMap)
				    )) 
				((tbx_customvar_global->layerMapTmp)[current_group] = data)
			    )
			) 
			(axlFormGridUpdate form_handle "grid")
		    ) 
		    (change 
			cond((((form_handle->col) == 2) 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 2) 
				(cell->row = (form_handle->row)) 
				(new_class = ((axlFormGridGetCell form_handle "grid" cell)->value))
				(subclass_popup = (tbx_customvar_global->popupMap)[new_class]) 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 3) 
				(cell->row = (form_handle->row)) 
				(cell->popup = subclass_popup)
				(cell->value = "") 
				(axlFormSetField form_handle "grid" cell) 
				(axlFormGridUpdate form_handle "grid")
			    )
			) 
			(axlFormGridUpdate form_handle "grid") 
			(data = TBX_CUSTOMVAR_LAYERMAP_Extract_Grid(form_handle 
				((tbx_customvar_global->gridRows)->layerMap)
			    )) 
			((tbx_customvar_global->layerMapTmp)[current_group] = data)
		    )
		)
	    ) 
	    ("export_settings" 
		(current_group = (axlFormGetField form_handle "current_group")) 
		(data = TBX_CUSTOMVAR_LAYERMAP_Extract_Grid(form_handle 
			((tbx_customvar_global->gridRows)->layerMap)
		    )) 
		((tbx_customvar_global->layerMapTmp)[current_group] = data) 
		(config_file = (axlDMFileBrowse "ALLEGRO_TEXT" t))
		when(config_file 
		    TBX_CUSTOMVAR_Save_Layer_Map((tbx_customvar_global->layerMapTmp) config_file)
		)
	    ) 
	    ("import_settings" 
		(config_file = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
		when(config_file 
		    (tbx_customvar_global->layerMap = TBX_CUSTOMVAR_Load_Layer_Map(config_file)) 
		    (tbx_customvar_global->textLayer = TBX_CUSTOMVAR_Get_Context_Layers()) 
		    (result = TBX_CUSTOMVAR_Synchronize_Variables()) 
		    (tbx_customvar_global->varInfo = car(result))
		    (tbx_customvar_global->histLabel = cadr(result)) 
		    (tbx_customvar_global->status = TBX_CUSTOMVAR_Get_Status()) 
		    TBX_CUSTOMVAR_LAYERMAP_Init_Form(form_handle)
		)
	    )
	    ("done" 
		(tbx_customvar_global->layerMap = (tbx_customvar_global->layerMapTmp)) 
		(axlFormClose form_handle) 
		(tbx_customvar_global->textLayer = TBX_CUSTOMVAR_Get_Context_Layers()) 
		(result = TBX_CUSTOMVAR_Synchronize_Variables())
		(tbx_customvar_global->varInfo = car(result)) 
		(tbx_customvar_global->histLabel = cadr(result)) 
		(tbx_customvar_global->status = TBX_CUSTOMVAR_Get_Status()) 
		TBX_CUSTOMVAR_Init_Grid(((tbx_customvar_global->formHandle)->main))
	    ) 
	    ("cancel" 
		(axlFormClose form_handle)
	    ) 
	    ("my_help" 
		(axlShell "tbx help customvar")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_CUSTOMVAR_LAYERMAP_Extract_Grid(form_handle row_cnt) 
    let((cell cxt_name cxt_class cxt_subclass data
	    layer
	) 
	for(i 1 row_cnt 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 1) 
	    (cxt_name = ((axlFormGridGetCell form_handle "grid" cell)->value)) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i) 
	    (cell->col = 2)
	    (cxt_class = ((axlFormGridGetCell form_handle "grid" cell)->value)) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i) 
	    (cell->col = 3) 
	    (cxt_subclass = ((axlFormGridGetCell form_handle "grid" cell)->value))
	    when((cxt_name && (cxt_name != "") && cxt_class && (cxt_class != "") && cxt_subclass && (cxt_subclass != "")) 
		(layer = strcat(cxt_class "/" cxt_subclass)) 
		(data = cons(list(cxt_name layer) data))
	    )
	) 
	(data = sortcar(data nil)) data
    )
)
procedure(TBX_CUSTOMVAR_LAYERMAP_Init_Form(form_handle) 
    let((group_names cls_list) 
	foreach(cls 
	    (tbx_customvar_global->popupMap) 
	    (cls_list = cons(cls cls_list))
	) 
	(cls_list = sort(cls_list nil)) 
	(axlFormBuildPopup form_handle "layer_class" cls_list) 
	foreach(cls cls_list 
	    (axlBuildSubclassPopup form_handle 
		(tbx_customvar_global->popupMap)[cls] cls
	    )
	)
	(tbx_customvar_global->layerMapTmp = makeTable("layer_map_data_tmp" nil)) 
	(group_names = mapcar(lambda((x) 
		    car(x)
		) 
		tableToList((tbx_customvar_global->layerMap))
	    )) 
	foreach(grp 
	    ((tbx_customvar_global->status)->unMappedGroups) 
	    (group_names = cons(grp group_names))
	) 
	(group_names = sort(group_names nil)) 
	(axlFormBuildPopup form_handle "current_group" group_names)
	(axlFormSetField form_handle "current_group" 
	    car(group_names)
	) 
	foreach(grp group_names 
	    ((tbx_customvar_global->layerMapTmp)[grp] = copy((tbx_customvar_global->layerMap)[grp]))
	) 
	(axlFormGridReset form_handle "grid") 
	TBX_CUSTOMVAR_LAYERMAP_Init_Grid_Cols(form_handle) 
	TBX_CUSTOMVAR_LAYERMAP_Init_Grid_Rows(form_handle)
	(axlFormGridUpdate form_handle "grid") 
	(axlFormGridEvents form_handle "grid" 
	    list('cellselect 
		'change 
		'rightpopup
	    )
	) t
    )
)
procedure(TBX_CUSTOMVAR_LAYERMAP_Init_Grid_Cols(form_handle) 
    let((p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 10) 
	(p->fieldLength = 50)
	(p->headText = "Suffix") 
	(p->scriptLabel = "group_suffix") 
	(axlFormGridInsertCol form_handle "grid" p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'ENUMSET)
	(p->colWidth = 22) 
	(p->align = 'left) 
	(p->popup = "layer_class") 
	(p->headText = "Class") 
	(p->scriptLabel = "class_name")
	(axlFormGridInsertCol form_handle "grid" p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'ENUMSET) 
	(p->colWidth = 22) 
	(p->align = 'left)
	(p->popup = (tbx_customvar_global->popupMap)[(axlMapClassName "DRAWING FORMAT")]) 
	(p->headText = "Subclass") 
	(p->scriptLabel = "subclass_name") 
	(axlFormGridInsertCol form_handle "grid" p)
    )
)
procedure(TBX_CUSTOMVAR_LAYERMAP_Init_Grid_Rows(form_handle) 
    let((current_group) 
	(current_group = (axlFormGetField form_handle "current_group")) 
	((tbx_customvar_global->layerMap)[current_group] = sortcar((tbx_customvar_global->layerMap)[current_group] 
		'axlStrcmpAlpNum
	    )) 
	if(zerop(length((tbx_customvar_global->layerMap)[current_group])) then 
	    (axlFormGridInsertRows form_handle "grid" 0 1) 
	    ((tbx_customvar_global->gridRows)->layerMap = 1) else
	    (axlFormGridInsertRows form_handle "grid" 0 
		length((tbx_customvar_global->layerMap)[current_group])
	    ) 
	    ((tbx_customvar_global->gridRows)->layerMap = length((tbx_customvar_global->layerMap)[current_group]))
	) 
	(tbx_customvar_global->curMap = (tbx_customvar_global->layerMap)[current_group])
	(axlFormGridSetBatch form_handle "grid" 
	    'TBX_CUSTOMVAR_LAYERMAP_Init_Grid_Rows_CB nil
	)
    )
)
procedure(TBX_CUSTOMVAR_LAYERMAP_Init_Grid_Rows_CB(pvt) 
    let((cell index arr name class_name
	    subclass_name
	) 
	(index = 1) 
	(pvt = pvt) 
	foreach(entry 
	    (tbx_customvar_global->curMap) 
	    (name = car(entry)) 
	    (arr = parseString(cadr(entry) "/")) 
	    (class_name = car(arr))
	    (subclass_name = cadr(arr)) 
	    (class_name = (axlMapClassName class_name)) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 1) 
	    (cell->row = index)
	    (cell->value = name) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 2) 
	    (cell->row = index)
	    (cell->value = class_name) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 3) 
	    (cell->row = index)
	    (cell->value = subclass_name) 
	    (cell->popup = (tbx_customvar_global->popupMap)[class_name]) 
	    (axlFormGridBatch cell) 
	    (axlFormGridBatch cell) 
	    index++
	)
    )
)
procedure(TBX_CUSTOMVAR_LAYERMAP_Start() 
    let((FORM_FILE fid) 
	(FORM_FILE = TBX_FORM_Get_Name((tbx_customvar_global->licCheck) "customvar_layer_map")) 
	(fid = (axlFormCreate 
		gensym("tbxcustomvarlayermap") FORM_FILE 
		'(e outer) 
		'TBX_CUSTOMVAR_LAYERMAP_Callback
		t nil
	    )) 
	((tbx_customvar_global->formHandle)->layerMap = fid) 
	TBX_FORM_Init_Header(fid "Licensed for " 
	    (tbx_customvar_global->licCheck) 
	    (axlFormGetField 
		((tbx_customvar_global->formHandle)->main) "lic_info"
	    )
	)
	(axlFormDisplay fid) 
	(axlUIWSetParent fid 
	    ((tbx_customvar_global->formHandle)->main)
	) 
	TBX_CUSTOMVAR_LAYERMAP_Init_Form(fid) 
	TBX_FORM_Delete((tbx_customvar_global->licCheck) FORM_FILE)
    )
)
procedure(TBX_CUSTOMVAR_Limit_View(current_context) 
    let((all_cxt_layers all_base_layers hide_layers show_layers result) 
	(result = TBX_CUSTOMVAR_Get_All_Layers()) 
	(all_base_layers = car(result)) 
	(all_cxt_layers = cadr(result)) 
	if((current_context == "BASE") then 
	    (show_layers = all_base_layers) 
	    (hide_layers = all_cxt_layers) else
	    (show_layers = list((tbx_customvar_global->textLayer)[current_context])) 
	    (hide_layers = nconc(all_cxt_layers all_base_layers)) 
	    (hide_layers = remove((tbx_customvar_global->textLayer)[current_context] hide_layers))
	)
	(hide_layers = setof(x hide_layers 
		(axlIsLayer x)
	    )) 
	foreach(lyr show_layers 
	    (axlVisibleLayer lyr t)
	) 
	foreach(lyr hide_layers 
	    (axlVisibleLayer lyr nil)
	) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_CUSTOMVAR_Load_Layer_Map(input_file) 
    let((att inport data layerMap group_name) 
	if(input_file then 
	    if(isFile(input_file) then 
		(inport = infile(input_file)) 
		(data = car(lineread(inport))) 
		close(inport)
		else 
		printf("Warning: Cannot access %\n" input_file)
	    ) else 
	    (att = (axlGetAttachment "tbx_customvar" 
		    'string
		))
	    when(att 
		(data = car(linereadstring((att->data))))
	    )
	) 
	(layerMap = makeTable("layer_map_table" nil)) 
	foreach(entry data 
	    (group_name = upperCase(car(entry))) 
	    (layerMap[group_name] = cdr(entry))
	) layerMap
    )
)
procedure(TBX_CUSTOMVAR_MIG_Create_Form(form_file) 
    let((port) 
	(port = outfile(form_file "w")) 
	fprintf(port "FILE_TYPE=FORM_DEFN VERSION=2\n") 
	fprintf(port "FORM\n") 
	fprintf(port "FIXED\n")
	fprintf(port "PORT 25 60\n") 
	fprintf(port "HEADER \"Customvar Migration\"\n") 
	fprintf(port "TILE\n") 
	fprintf(port "TEXT\n") 
	fprintf(port "FLOC 1 1\n")
	fprintf(port "INFO info_string 1\n") 
	fprintf(port "FSIZE 20 3\n") 
	fprintf(port "ENDFIELD\n") 
	fprintf(port "FIELD name_list\n") 
	fprintf(port "FLOC 1 5\n")
	fprintf(port "LIST \"\" 24 10\n") 
	fprintf(port "OPTIONS multiselect\n") 
	fprintf(port "ENDFIELD\n") 
	fprintf(port "FIELD done\n") 
	fprintf(port "FLOC 6 25 \n")
	fprintf(port "MENUBUTTON \"Ok\" 12 3\n") 
	fprintf(port "ENDFIELD\n") 
	fprintf(port "\n") 
	fprintf(port "ENDTILE\n") 
	fprintf(port "\n")
	fprintf(port "ENDFORM\n") 
	close(port)
    )
)
procedure(TBX_CUSTOMVAR_MIG_Dummy_Loop() 
    let((eventMask loop event) 
	(eventMask = list('PICK)) 
	(loop = t) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil t)) 
	    caseq((event->type) 
		(PICK t) 
		(DONE 
		    (axlFinishEnterFun) 
		    (loop = nil)
		) 
		(CANCEL 
		    (axlCancelEnterFun) 
		    (loop = nil)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_CUSTOMVAR_MIG_Init() 
    let((parseLine updateLocalConfigFile getVariableData checkPropertyDefinitions getOldPlaceholders
	    getNewPlaceholders getDefaultTextParam getTextParam cleanUp func
	    getPlaceholderNames
	) 
	(parseLine = lambda((str_l) 
		let((arr_l var_name_l var_value_l var_subname_l ret_list_l) 
		    rexCompile("'") 
		    (str_l = rexReplace(str_l "" 0)) 
		    rexCompile("\"") 
		    (str_l = rexReplace(str_l "" 0))
		    rexCompile("__") 
		    (str_l = rexReplace(str_l "|" 0)) 
		    (arr_l = parseString(str_l)) 
		    if((length(arr_l) >= 2) then 
			(var_name_l = car(arr_l)) 
			(var_value_l = buildString(cdr(arr_l) " ")) 
			(arr_l = parseString(var_name_l "|"))
			cond((onep(length(arr_l)) 
				(var_name_l = car(arr_l)) 
				(var_subname_l = "BASE")
			    ) 
			    ((length(arr_l) == 2) 
				(var_name_l = car(arr_l)) 
				(var_subname_l = cadr(arr_l))
			    ) 
			    ((length(arr_l) > 2) 
				(arr_l = reverse(arr_l)) 
				(var_subname_l = car(arr_l)) 
				(arr_l = cdr(arr_l)) 
				(arr_l = reverse(arr_l))
				(var_name_l = buildString(arr_l "|"))
			    )
			) 
			(ret_list_l = list(var_name_l var_subname_l var_value_l)) else 
			(ret_list_l = nil)
		    ) ret_list_l
		)
	    )) 
	(updateLocalConfigFile = lambda((context_list_l group_suffix_l) 
		let((old_config_l new_config_l inport_l line_l data_l
			local_info_l port_l key_list_l var_name_l var_subname_l
			var_value_l
		    ) 
		    (old_config_l = strcat(getWorkingDir() "/floware/customvar_data.txt")) 
		    (new_config_l = strcat(getWorkingDir() "/customvar.cfg")) 
		    (local_info_l = makeTable("local_info_l_table" nil)) 
		    (context_list_l = setof(x context_list_l 
			    ((upperCase(x) != "ALL") && (upperCase(x) != "BASE"))
			))
		    (context_list_l = cons("BASE" context_list_l)) 
		    if(isFile(old_config_l) then 
			when(isFile(old_config_l) 
			    (inport_l = infile(old_config_l)) 
			    while((line_l = _gets(inport_l)) 
				(data_l = funcall(((tbx_customvar_migrate->func)->parseLine) line_l)) 
				when(data_l 
				    (var_name_l = upperCase(car(data_l))) 
				    (var_subname_l = upperCase(cadr(data_l))) 
				    (var_value_l = caddr(data_l)) 
				    when((var_subname_l == "ALL") 
					(var_subname_l = "BASE")
				    )
				    unless(rexMatchp("^AUTO" var_name_l) 
					cond(((var_subname_l == "BASE") 
						(local_info_l["BASE"] = cons(list(var_name_l var_value_l) 
							local_info_l["BASE"]
						    ))
					    ) 
					    (exists(x context_list_l 
						    (x == var_subname_l)
						) 
						(local_info_l[var_subname_l] = cons(list(var_name_l var_value_l) 
							local_info_l[var_subname_l]
						    ))
					    ) 
					    (exists(x group_suffix_l 
						    (x == var_subname_l)
						) 
						(local_info_l["BASE"] = cons(list(strcat(var_name_l "|" var_subname_l) var_value_l) 
							local_info_l["BASE"]
						    ))
					    ) 
					    (t 
						(local_info_l["BASE"] = cons(list(var_name_l var_value_l) 
							local_info_l["BASE"]
						    ))
					    )
					)
				    )
				)
			    ) 
			    close(inport_l)
			) 
			foreach(key local_info_l 
			    (local_info_l[key] = sortcar(local_info_l[key] nil)) 
			    (key_list_l = cons(key key_list_l))
			) 
			(key_list_l = sort(key_list_l 
				'axlStrcmpAlpNum
			    ))
			when(member("BASE" key_list_l) 
			    (key_list_l = remove("BASE" key_list_l)) 
			    (key_list_l = cons("BASE" key_list_l))
			) 
			(port_l = outfile(new_config_l "w")) 
			foreach(key key_list_l 
			    fprintf(port_l "[Customvar %s]\n" key) 
			    foreach(entry 
				local_info_l[key] 
				fprintf(port_l "%-20s = %s\n" 
				    car(entry) 
				    cadr(entry)
				)
			    ) 
			    fprintf(port_l "\n")
			) 
			close(port_l) 
			printf("Note: File %L has been written\n" new_config_l)
			else 
			printf("Customvar migration: File %L does not exist\n" old_config_l)
		    )
		)
	    )) 
	(getVariableData = lambda(nil 
		let((att_l var_name_l var_subname_l var_value_l varinfo_l) 
		    (varinfo_l = makeTable("varinfo_l_table" nil)) 
		    (att_l = (axlGetAttachment "flw_customvar_vardata" 
			    'string
			)) 
		    when(att_l 
			foreach(entry 
			    car(linereadstring((att_l->data))) 
			    (var_name_l = upperCase(car(entry))) 
			    (var_subname_l = upperCase(cadr(entry))) 
			    (var_value_l = caddr(entry))
			    unless(rexMatchp("^AUTO" var_name_l) 
				(varinfo_l[strcat(var_name_l "_" var_subname_l)] = 
				    list(var_name_l var_subname_l var_value_l))
			    )
			)
		    ) varinfo_l
		)
	    )) 
	(checkPropertyDefinitions = lambda(nil 
		foreach(prp 
		    list("TBX_CUSTOMVAR_NAME" "TBX_CUSTOMVAR_ATTR") 
		    unless((axlDBGetPropDictEntry prp) 
			(axlDBCreatePropDictEntry prp "STRING" 
			    list("shapes")
			)
		    )
		)
	    ))
	(getOldPlaceholders = lambda(nil 
		let((orgvis sys_layer_old ph_l) 
		    (orgvis = (axlVisibleGet)) 
		    (sys_layer_old = strcat((axlMapClassName "MANUFACTURING") "/FLW_CUSTOMVAR_INFO")) 
		    (axlVisibleDesign nil) 
		    (axlVisibleLayer sys_layer_old t)
		    (axlVisibleUpdate nil) 
		    (axlSetFindFilter ?enabled 
			list("noall" "lines") ?onButtons 
			list("all")
		    ) 
		    (axlClearSelSet) 
		    (axlAddSelectAll) 
		    (ph_l = setof(x 
			    (axlGetSelSet) 
			    ((x->prop)->FLW_CUSTOMVAR_NAME)
			))
		    (axlVisibleSet orgvis) 
		    (axlClearSelSet) 
		    (axlVisibleUpdate t) ph_l
		)
	    )) 
	(getNewPlaceholders = lambda(nil 
		let((ph_list) 
		    (axlSetFindFilter ?enabled 
			list("noall" "invisible" "boundary_shapes" "shapes") ?onButtons 
			list("all")
		    ) 
		    (axlClearSelSet) 
		    (axlAddSelectAll) 
		    when((axlGetSelSet) 
			(ph_list = setof(x 
				(axlGetSelSet) 
				((x->layer) == strcat((axlMapClassName "MANUFACTURING") "/TBX_CUSTOMVAR_SYS"))
			    )) 
			(ph_list = setof(x ph_list 
				(((x->prop)->TBX_CUSTOMVAR_NAME) && ((x->prop)->TBX_CUSTOMVAR_ATTR))
			    ))
		    )
		    (axlClearSelSet) ph_list
		)
	    )) 
	(getDefaultTextParam = lambda(nil 
		let((dwg_title mfg_notes default_param txt_layer txt_block
			txt_rotation txt_just txt_mirror
		    ) 
		    (dwg_title = strcat((axlMapClassName "DRAWING FORMAT") "/TITLE_BLOCK")) 
		    (mfg_notes = strcat((axlMapClassName "MANUFACTURING") "/NOTES")) 
		    if((upperCase((axlDesignType nil)) == "LAYOUT") then 
			(txt_layer = dwg_title) else 
			case(upperCase((axlDesignType t)) 
			    ("FORMAT" 
				(txt_layer = dwg_title)
			    ) 
			    ("PACKAGE" 
				(txt_layer = mfg_notes)
			    ) 
			    ("MECHANICAL" 
				(txt_layer = mfg_notes)
			    ) 
			    (t 
				(txt_layer = mfg_notes)
			    )
			)
		    ) 
		    (txt_block = "3")
		    (txt_rotation = 0.0) 
		    (txt_just = "LEFT") 
		    (default_param = list(nil 
			    'layer txt_layer 
			    'textBlock txt_block
			    'rotation txt_rotation 
			    'justify txt_just 
			    'mirror
			    txt_mirror
			)) default_param
		)
	    )) 
	(getTextParam = lambda((file_name) 
		let((att txtParam txt_class txt_subclass txt_block
			txt_rotation txt_just txt_mirror v_name v_subname
			data port
		    ) 
		    (txtParam = makeTable("txt_param_table" nil)) 
		    if(file_name then 
			(port = infile(file_name)) 
			(data = car(lineread(port))) 
			close(port)
			else 
			(att = (axlGetAttachment "flw_customvar_textparam" 
				'string
			    )) 
			when(att 
			    (data = car(linereadstring((att->data))))
			)
		    ) 
		    when(data 
			foreach(entry data 
			    (v_name = upperCase(car(entry))) 
			    (v_subname = upperCase(cadr(entry))) 
			    (txt_class = caddr(entry))
			    (txt_subclass = nth(3 entry)) 
			    (txt_block = nth(4 entry)) 
			    (txt_rotation = atof(nth(5 entry))) 
			    (txt_just = upperCase(nth(6 entry))) 
			    (txt_mirror = nil)
			    (txtParam[strcat(v_name "_" v_subname)] = 
				list(nil 
				    'layer 
				    strcat(txt_class "/" txt_subclass) 
				    'textBlock txt_block
				    'rotation txt_rotation 
				    'justify txt_just 
				    'mirror
				    txt_mirror
				))
			)
		    ) txtParam
		)
	    )) 
	(cleanUp = lambda(nil 
		let((att layer_name_l) 
		    (layer_name_l = strcat((axlMapClassName "MANUFACTURING") "/FLW_CUSTOMVAR_INFO")) 
		    when((axlIsLayer layer_name_l) 
			(axlDeleteObject 
			    (axlLayerGet layer_name_l)
			)
		    ) 
		    (layer_name_l = strcat((axlMapClassName "MANUFACTURING") "/FLW_CUSTOMVAR")) 
		    when((axlIsLayer layer_name_l) 
			(axlDeleteObject 
			    (axlLayerGet layer_name_l)
			)
		    )
		    when((axlDBGetPropDictEntry "FLW_CUSTOMVAR_NAME") 
			(axlDBDeletePropDictEntry "FLW_CUSTOMVAR_NAME")
		    ) 
		    when((axlDBGetPropDictEntry "FLW_CUSTOMVAR_SUBNAME") 
			(axlDBDeletePropDictEntry "FLW_CUSTOMVAR_SUBNAME")
		    ) 
		    (att = (axlGetAttachment "flw_customvar_textparam" 
			    'string
			)) 
		    when(att 
			(axlDeleteAttachment "flw_customvar_textparam")
		    ) 
		    (att = (axlGetAttachment "flw_customvar_vardata" 
			    'string
			))
		    when(att 
			(axlDeleteAttachment "flw_customvar_vardata")
		    ) 
		    foreach(scls 
			(axlSubclasses 
			    (axlMapClassName "DRAWING FORMAT")
			) 
			when(rexMatchp("^CXT_" 
				upperCase(scls)
			    ) 
			    (axlVisibleLayer 
				strcat((axlMapClassName "DRAWING FORMAT") "/" scls) nil
			    )
			)
		    ) 
		    (axlVisibleUpdate t) t
		)
	    ))
	(getPlaceholderNames = lambda((ph_list) 
		let((name_list var_name) 
		    foreach(ph ph_list 
			(var_name = upperCase(((ph->prop)->FLW_CUSTOMVAR_NAME))) 
			unless(exists(x name_list 
				(x == var_name)
			    ) 
			    (name_list = cons(var_name name_list))
			)
		    ) 
		    (name_list = sort(name_list nil)) name_list
		)
	    )) 
	(func = ncons(nil)) 
	(func->parseLine = parseLine) 
	(func->updateLocalConfigFile = updateLocalConfigFile) 
	(func->getVariableData = getVariableData)
	(func->checkPropertyDefinitions = checkPropertyDefinitions) 
	(func->getOldPlaceholders = getOldPlaceholders) 
	(func->getNewPlaceholders = getNewPlaceholders) 
	(func->getPlaceholderNames = getPlaceholderNames) 
	(func->getDefaultTextParam = getDefaultTextParam)
	(func->getTextParam = getTextParam) 
	(func->cleanUp = cleanUp) 
	unless(boundp('tbx_customvar_migrate) 
	    iliDefstruct('defstruct(tbx_customvar_migrate_struct formHandle func selectMode phNameList
			textParam varInfo contextNames groupSuffixes
		    )
	    ) 
	    defvar(tbx_customvar_migrate nil)
	) 
	if(!tbx_customvar_migrate then 
	    (tbx_customvar_migrate = (make_tbx_customvar_migrate_struct ?formHandle nil ?func func
		    ?selectMode nil ?phNameList 
		    ncons(nil) ?textParam
		    nil ?varInfo nil ?contextNames nil
		    ?groupSuffixes nil
		)) else 
	    (tbx_customvar_migrate->formHandle = nil)
	    (tbx_customvar_migrate->func = func) 
	    (tbx_customvar_migrate->selectMode = nil) 
	    (tbx_customvar_migrate->phNameList = ncons(nil)) 
	    (tbx_customvar_migrate->textParam = nil) 
	    (tbx_customvar_migrate->varInfo = nil)
	    (tbx_customvar_migrate->contextNames = nil) 
	    (tbx_customvar_migrate->groupSuffixes = nil)
	)
    )
)
procedure(TBX_CUSTOMVAR_MIG_Start() 
    let((result ph_list_new ph_list_old ph_names msg
	    standard_list format_symbols ph_list_old_parent design_type attr_file
	    sys_layer_new ph_list_parent
	) 
	TBX_CUSTOMVAR_MIG_Init() 
	(ph_list_old = funcall(((tbx_customvar_migrate->func)->getOldPlaceholders))) 
	(ph_names = funcall(((tbx_customvar_migrate->func)->getPlaceholderNames) ph_list_old)) 
	(ph_list_new = funcall(((tbx_customvar_migrate->func)->getNewPlaceholders)))
	cond(((ph_list_old && (upperCase((axlDesignType nil)) == "SYMBOL")) 
		(design_type = "SYMBOL") 
		(msg = "") 
		(msg = strcat(msg "Placeholder were defined using an earlier version of Custom variables and will be updated for compatibility with current version. ")) 
		(msg = strcat(msg "Before continue you should export text attributes from a given layout database using command \"Save to File\" in Custom Variables - Setup. "))
		(msg = strcat(msg "This file is needed for proper migration of placeholders on symbol drawings.\n")) 
		(msg = strcat(msg "Do you want to continue?\n")) 
		if((axlUIYesNo msg "Custom Variables migration" 
			'no
		    ) then 
		    (attr_file = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
		    if(attr_file then 
			(tbx_customvar_migrate->textParam = funcall(((tbx_customvar_migrate->func)->getTextParam) attr_file)) 
			((tbx_customvar_migrate->textParam)["TBX_DEFAULT"] = funcall(((tbx_customvar_migrate->func)->getDefaultTextParam))) 
			(result = list(t nil))
			else 
			(result = list(t t))
		    ) else
		    (result = list(t t))
		)
	    ) 
	    ((ph_list_old && (upperCase((axlDesignType nil)) == "LAYOUT")) 
		(design_type = "LAYOUT") 
		(ph_list_parent = setof(x ph_list_old 
			(((x->parent)->type) == "FORMAT")
		    )) 
		foreach(ph ph_list_parent 
		    unless(exists(x format_symbols 
			    (((ph->parent)->name) == x)
			) 
			(format_symbols = cons(((ph->parent)->name) format_symbols))
		    )
		) 
		(format_symbols = sort(format_symbols nil))
		(tbx_customvar_migrate->textParam = funcall(((tbx_customvar_migrate->func)->getTextParam) nil)) 
		((tbx_customvar_migrate->textParam)["TBX_DEFAULT"] = funcall(((tbx_customvar_migrate->func)->getDefaultTextParam))) 
		cond(((!ph_list_new && (length(ph_list_old) > 0)) 
			(msg = "") 
			(msg = strcat(msg "Design was created using an earlier version of Custom variables and will be updated for compatibility with current version. ")) 
			(msg = strcat(msg "After migration text attributes are stored directly at the placeholder. ")) 
			(msg = strcat(msg "Variants are handled in a different way. Please refer to documentation. "))
			(msg = strcat(msg "It's recommended to verify setup after migration.\nDo you want to continue?\n")) 
			if((axlUIYesNo msg "Custom Variables migration" 
				'no
			    ) then 
			    (result = list(t nil)) else 
			    printf("Canceling migration...\n")
			    (result = list(t t))
			)
		    ) 
		    ((ph_list_new && (length(ph_list_old_parent) > 0)) 
			(msg = "") 
			(msg = sprintf(nil "Warning: Some placeholder were defined using an earlier version of Custom variables and still exist in symbol(s) %s. " 
				buildString(format_symbols " ")
			    )) 
			(msg = strcat(msg "You should open the symbol drawing and enter the command \"tbx customvar migrate\" in order to cleanup the symbol.")) 
			(axlUIConfirm msg)
			(result = list(t nil))
		    )
		)
	    )
	) 
	when((car(result) && !cadr(result)) 
	    (sys_layer_new = strcat((axlMapClassName "MANUFACTURING") "/TBX_CUSTOMVAR_SYS")) 
	    unless((axlLayerGet sys_layer_new) 
		(axlLayerCreateNonConductor sys_layer_new)
	    ) 
	    when((design_type == "LAYOUT") 
		(tbx_customvar_migrate->varInfo = funcall(((tbx_customvar_migrate->func)->getVariableData)))
	    ) 
	    funcall(((tbx_customvar_migrate->func)->checkPropertyDefinitions))
	    ((tbx_customvar_migrate->phNameList)->all = ph_names) 
	    (tbx_customvar_migrate->selectMode = "context") 
	    TBX_CUSTOMVAR_MIG_User_Select() 
	    TBX_CUSTOMVAR_MIG_Dummy_Loop() 
	    if((length(((tbx_customvar_migrate->phNameList)->context)) < length(((tbx_customvar_migrate->phNameList)->all))) then 
		(tbx_customvar_migrate->selectMode = "group") 
		TBX_CUSTOMVAR_MIG_User_Select() 
		TBX_CUSTOMVAR_MIG_Dummy_Loop()
		if((length(((tbx_customvar_migrate->phNameList)->group)) < length(((tbx_customvar_migrate->phNameList)->context))) then 
		    foreach(phn 
			((tbx_customvar_migrate->phNameList)->all) 
			when((!member(phn 
					((tbx_customvar_migrate->phNameList)->context)
				    ) && !member(phn 
					((tbx_customvar_migrate->phNameList)->group)
				    )) 
			    (standard_list = cons(phn standard_list))
			)
		    ) 
		    (standard_list = sort(standard_list nil)) 
		    ((tbx_customvar_migrate->phNameList)->standard = standard_list)
		    else 
		    ((tbx_customvar_migrate->phNameList)->standard = nil)
		) else 
		((tbx_customvar_migrate->phNameList)->group = nil) 
		((tbx_customvar_migrate->phNameList)->standard = nil)
	    )
	    TBX_CUTOMVAR_MIG_Process(design_type ph_list_old) 
	    when((design_type == "LAYOUT") 
		when(format_symbols 
		    (msg = "") 
		    (msg = sprintf(nil "Some placeholders were defined in symbol(s) %s. " 
			    buildString(format_symbols " ")
			)) 
		    (msg = strcat(msg "You should open the symbol drawing and enter the command \"tbx customvar migrate\" in order to cleanup the symbol.")) 
		    (axlUIConfirm msg)
		) 
		funcall(((tbx_customvar_migrate->func)->updateLocalConfigFile) 
		    (tbx_customvar_migrate->contextNames) 
		    (tbx_customvar_migrate->groupSuffixes)
		)
	    ) 
	    (axlVisibleLayer sys_layer_new t) 
	    (axlClearSelSet) 
	    (axlVisibleUpdate t)
	) result
    )
)
procedure(TBX_CUSTOMVAR_MIG_User_Select() 
    let((FORM_FILE fid name_list) 
	(FORM_FILE = (axlTempFile t)) 
	TBX_CUSTOMVAR_MIG_Create_Form(FORM_FILE) 
	(fid = (axlFormCreate 
		gensym("tbxcustomvarmigselect") FORM_FILE 
		'(e outer) 
		'TBX_CUSTOMVAR_MIG_User_Select_Callback
		t nil
	    )) 
	(axlFormListDeleteAll fid "name_list")
	case((tbx_customvar_migrate->selectMode) 
	    ("context" 
		(axlFormSetField fid "info_string" "Select placeholders from list to be treated as context:") 
		(axlFormSetField fid "name_list" 
		    ((tbx_customvar_migrate->phNameList)->all)
		)
	    ) 
	    ("group" 
		(axlFormSetField fid "info_string" "Select placeholders from list to be treated as groups:") 
		foreach(phn 
		    ((tbx_customvar_migrate->phNameList)->all) 
		    unless(member(phn 
			    ((tbx_customvar_migrate->phNameList)->context)
			) 
			(name_list = cons(phn name_list))
		    )
		) 
		(name_list = sort(name_list nil)) 
		(axlFormSetField fid "name_list" name_list)
	    )
	) 
	(axlFormDisplay fid)
    )
)
procedure(TBX_CUSTOMVAR_MIG_User_Select_Callback(form_handle) 
    let((cur_list) 
	case((form_handle->curField) 
	    ("done" 
		(cur_list = (axlFormListGetSelItems form_handle "name_list")) 
		case((tbx_customvar_migrate->selectMode) 
		    ("context" 
			((tbx_customvar_migrate->phNameList)->context = cur_list)
		    ) 
		    ("group" 
			((tbx_customvar_migrate->phNameList)->group = cur_list)
		    )
		) 
		(axlFormClose form_handle) 
		(axlFinishEnterFun)
	    )
	)
    )
)
procedure((TBX_CUSTOMVAR_Main \@optional arg) 
    let((fid FORM_FILE info_file port lic_check_result
	    ok_continue msg result ok_start_app
	) 
	(ok_start_app = t) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./customvar_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Custom variables information:\n") 
		fprintf(port "=============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version   : Prints the current version of the module\n") 
		fprintf(port "  place     : Main procedure for defining placeholders\n") 
		fprintf(port "  update    : Main procedure for updating variables in the design\n") 
		fprintf(port "\n")
		close(port) 
		(axlUIViewFileCreate info_file "Custom Variables: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" 
		    ((tbx_customvar_global->appInfo)->version) 
		    ((tbx_customvar_global->appInfo)->release)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "reset")) 
		when((axlUIYesNo "Delete configuration for Custom Variables from database?" nil 
			'no
		    ) 
		    (axlDeleteAttachment "tbx_customvar")
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "migrate")) 
		TBX_CUSTOMVAR_Init() 
		TBX_CUSTOMVAR_MIG_Start()
	    ) 
	    ((arg && (lowerCase(arg) == "dump")) 
		TBX_CUSTOMVAR_Dump() 
		(ok_start_app = nil)
	    )
	    (!arg 
		printf("Warning: Insufficient number of arguments.  Use command \"tbx customvar info\" for more information.\n") 
		(ok_start_app = nil)
	    )
	) 
	when(ok_start_app 
	    TBX_CUSTOMVAR_Init() 
	    (lic_check_result = TBX_LIC_Validate(((tbx_customvar_global->appInfo)->name) 
		    ((tbx_customvar_global->appInfo)->version) t
		)) 
	    when(lic_check_result 
		(ok_continue = t) 
		(result = TBX_CUSTOMVAR_MIG_Start()) 
		when((car(result) && cadr(result) && (upperCase((axlDesignType nil)) == "LAYOUT")) 
		    (msg = "") 
		    (msg = strcat(msg "Canceling migration. Do you want to continue with regular application?\n")) 
		    if((axlUIYesNo msg "Custom Variables" 
			    'no
			) then 
			(ok_continue = t) else 
			(ok_continue = nil)
		    )
		) 
		when(ok_continue 
		    (tbx_customvar_global->licCheck = lic_check_result) 
		    cond((((lowerCase(arg) == "place") || (lowerCase(arg) == "setup")) 
			    TBX_CUSTOMVAR_Synchronize_Attributes() 
			    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "customvar_place_mini")) 
			    (fid = (axlMiniStatusLoad 
				    gensym("tbxcustomvarplacemini") FORM_FILE 
				    'TBX_CUSTOMVAR_PLACE_Callback nil
				)) 
			    ((tbx_customvar_global->formHandle)->place = fid)
			    TBX_FORM_Init_Header(fid nil lic_check_result nil) 
			    TBX_CUSTOMVAR_Init_Form(fid "place") 
			    (axlFormSetFieldLimits fid "text_block" 1 
				((tbx_customvar_global->sysDefaults)->maxBlockInt)
			    ) 
			    (axlFormDisplay fid) 
			    (axlAutoOpenFindFilter)
			    TBX_CUSTOMVAR_PLACE_Event_Loop(fid) 
			    TBX_CUSTOMVAR_PLACE_Cache_Param(fid) 
			    TBX_FORM_Delete(lic_check_result FORM_FILE) 
			    (axlVisibleLayer 
				((tbx_customvar_global->sysDefaults)->layer) nil
			    ) 
			    (axlVisibleUpdate t)
			) 
			((lowerCase(arg) == "update") 
			    (tbx_customvar_global->layerMap = TBX_CUSTOMVAR_Load_Layer_Map(nil)) 
			    TBX_CUSTOMVAR_Synchronize_Attributes() 
			    ((tbx_customvar_global->varConfig)->localData = TBX_CUSTOMVAR_Read_Local_Data(((tbx_customvar_global->varConfig)->localFile))) 
			    when(axlGetVariable("TBX_CUSTOMVAR_SOURCE_CPM") 
				if(axlGetVariable("TBX_CUSTOMVAR_CPM_FILE") then 
				    printf("Info  Cpm file specified by environment variable TBX_CUSTOMVAR_CPM_FILE\n") 
				    ((tbx_customvar_global->varConfig)->cpmFile = axlGetVariable("TBX_CUSTOMVAR_CPM_FILE")) else
				    ((tbx_customvar_global->varConfig)->cpmFile = TBX_CPM_Determine_Project_File())
				) 
				when(((tbx_customvar_global->varConfig)->cpmFile) 
				    ((tbx_customvar_global->varConfig)->cpmData = TBX_CUSTOMVAR_Read_Cpm_Data(((tbx_customvar_global->varConfig)->cpmFile)))
				)
			    )
			    (tbx_customvar_global->varDef = TBX_CUSTOMVAR_Get_Variable_Definitions()) 
			    (tbx_customvar_global->textLayer = TBX_CUSTOMVAR_Get_Context_Layers()) 
			    (result = TBX_CUSTOMVAR_Synchronize_Variables()) 
			    (tbx_customvar_global->varInfo = car(result)) 
			    (tbx_customvar_global->histLabel = cadr(result))
			    (tbx_customvar_global->status = TBX_CUSTOMVAR_Get_Status()) 
			    if((length((tbx_customvar_global->varInfo)["BASE"]) > 0) then 
				(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "customvar_update_main")) 
				unless(boundp('tbxCustomvarUpdateMainHandle) 
				    defvar(tbxCustomvarUpdateMainHandle nil)
				) 
				(fid = (axlFormCreate 
					'tbxCustomvarUpdateMainHandle FORM_FILE 
					'(e outer) 
					'TBX_CUSTOMVAR_Callback
					t
				    ))
				when(fid 
				    ((tbx_customvar_global->formHandle)->main = fid) 
				    TBX_FORM_Init_Header(fid "Licensed for " lic_check_result 
					((tbx_customvar_global->appInfo)->title)
				    ) 
				    (axlFormDisplay fid) 
				    TBX_CUSTOMVAR_Init_Form(fid "main")
				    TBX_FORM_Delete(lic_check_result FORM_FILE)
				) else 
				(axlUIConfirm "Info: Design does contain any placeholders.")
			    )
			) 
			((lowerCase(arg) == "backsync") 
			    TBX_CUSTOMVAR_Synchronize_Attributes()
			)
		    )
		)
	    )
	)
    )
)
procedure(TBX_CUSTOMVAR_Make_Display_String(value) 
    rexCompile("^ *<* *") 
    (value = rexReplace(value "" 0)) 
    rexCompile(" *>* *$") 
    (value = rexReplace(value "" 0))
    (value = strcat("<" value ">")) value
)
procedure(TBX_CUSTOMVAR_PLACE_Build_Dynamics(ph_param) 
    let((result rpath text_boundary_poly_points origin) 
	(result = TBX_CUSTOMVAR_Calculate_Placeholder_Extents(ph_param)) 
	(origin = car(result)) 
	(text_boundary_poly_points = cadr(result)) 
	(rpath = (axlPathStart text_boundary_poly_points 0.0))
	(axlClearDynamics) 
	(axlAddSimpleMoveDynamics origin rpath "path") t
    )
)
procedure(TBX_CUSTOMVAR_PLACE_Build_Template_Dynamics(data) 
    let((offset name_str attr_str text_origin text_boundary_poly_points
	    result rpath ph_param
	) 
	(axlClearDynamics) 
	foreach(entry data 
	    (name_str = car(entry)) 
	    (offset = cadr(entry)) 
	    (attr_str = caddr(entry))
	    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(name_str attr_str)) 
	    (result = TBX_CUSTOMVAR_Calculate_Placeholder_Extents(ph_param)) 
	    when(result 
		(text_origin = car(result)) 
		(text_boundary_poly_points = cadr(result)) 
		(rpath = (axlPathStart text_boundary_poly_points 0.0)) 
		(rpath = (axlPathOffset rpath offset))
		(axlAddSimpleMoveDynamics text_origin rpath "path")
	    )
	) t
    )
)
procedure(TBX_CUSTOMVAR_PLACE_Cache_Param(form_handle) 
    let((rec session_param) 
	(rec = "customvar|place") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "variable_name") 
	    stringToSymbol("variable_name")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "display_value") 
	    stringToSymbol("display_value")
	) 
	putprop(session_param[rec] 
	    (axlDBControl 
		'activeLayer
	    ) 
	    stringToSymbol("active_layer")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "text_block") 
	    stringToSymbol("text_block")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "text_rotation") 
	    stringToSymbol("text_rotation")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "text_align") 
	    stringToSymbol("text_align")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "text_mirror") 
	    stringToSymbol("text_mirror")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "placeholder_type") 
	    stringToSymbol("placeholder_type")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "hist_level") 
	    stringToSymbol("hist_level")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "add_placeholder") 
	    stringToSymbol("add_placeholder")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "modify_placeholder") 
	    stringToSymbol("modify_placeholder")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "delete_placeholder") 
	    stringToSymbol("delete_placeholder")
	) t
    )
)
procedure(TBX_CUSTOMVAR_PLACE_Callback(form_handle) 
    let((cur_value ph_param) 
	case((form_handle->curField) 
	    ("variable_name" 
		(cur_value = (form_handle->curValue)) 
		when(rexMatchp("|" cur_value) 
		    printf("Warning: \"|\" character not supported in variable name. Replaced by \"_\"\n") 
		    rexCompile("|") 
		    (cur_value = rexReplace(cur_value "_" 0))
		) 
		(axlFormSetField form_handle "variable_name" 
		    upperCase(cur_value)
		) 
		(axlFormSetField form_handle "display_value" 
		    TBX_CUSTOMVAR_Make_Display_String(cur_value)
		)
		if((axlFormGetField form_handle "add_placeholder") then 
		    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(form_handle)) 
		    TBX_CUSTOMVAR_PLACE_Build_Dynamics(ph_param) else
		    (axlClearDynamics)
		)
	    ) 
	    ("display_value" 
		(axlFormSetField form_handle "display_value" 
		    TBX_CUSTOMVAR_Make_Display_String((form_handle->curValue))
		) 
		if((axlFormGetField form_handle "add_placeholder") then 
		    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(form_handle)) 
		    TBX_CUSTOMVAR_PLACE_Build_Dynamics(ph_param) else
		    (axlClearDynamics)
		)
	    ) 
	    ("text_block" 
		if((axlFormGetField form_handle "add_placeholder") then 
		    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(form_handle)) 
		    TBX_CUSTOMVAR_PLACE_Build_Dynamics(ph_param) else
		    (axlClearDynamics)
		)
	    ) 
	    ("text_rotation" 
		if((axlFormGetField form_handle "add_placeholder") then 
		    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(form_handle)) 
		    TBX_CUSTOMVAR_PLACE_Build_Dynamics(ph_param) else
		    (axlClearDynamics)
		)
	    )
	    ("text_align" 
		if((axlFormGetField form_handle "add_placeholder") then 
		    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(form_handle)) 
		    TBX_CUSTOMVAR_PLACE_Build_Dynamics(ph_param) else
		    (axlClearDynamics)
		)
	    ) 
	    ("text_mirror" 
		if((axlFormGetField form_handle "add_placeholder") then 
		    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(form_handle)) 
		    TBX_CUSTOMVAR_PLACE_Build_Dynamics(ph_param) else
		    (axlClearDynamics)
		)
	    ) 
	    ("placeholder_type" 
		case((form_handle->curValue) 
		    ("standard" 
			(axlFormSetFieldEditable form_handle "hist_level" t)
		    ) 
		    ("context" 
			(axlFormSetFieldEditable form_handle "hist_level" t)
		    ) 
		    ("group" 
			(axlFormSetFieldEditable form_handle "hist_level" nil) 
			(axlFormSetField form_handle "hist_level" "none")
		    )
		)
	    ) 
	    ("hist_level" t) 
	    ("add_placeholder" 
		(ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(form_handle)) 
		TBX_CUSTOMVAR_PLACE_Build_Dynamics(ph_param)
	    )
	    ("modify_placeholder" 
		(axlClearDynamics)
	    ) 
	    ("delete_placeholder" 
		(axlClearDynamics)
	    )
	)
    )
)
procedure(TBX_CUSTOMVAR_PLACE_Create_Placeholder(location ph_param) 
    let((name_str attr_str radius ph_shape rpath
	    result text_orient
	) 
	unless((axlIsVisibleLayer 
		((tbx_customvar_global->sysDefaults)->layer)
	    ) 
	    (axlVisibleLayer 
		((tbx_customvar_global->sysDefaults)->layer) t
	    ) 
	    (axlVisibleUpdate t)
	) 
	(name_str = TBX_CUSTOMVAR_Build_Prop_String(ph_param "name")) 
	(attr_str = TBX_CUSTOMVAR_Build_Prop_String(ph_param "attr")) 
	(radius = (((tbx_customvar_global->sysDefaults)->phSize) / 2.0))
	(rpath = (axlPathStartCircle 
		list(location radius) 0.0
	    )) 
	(result = (axlDBCreateShape rpath t 
		((tbx_customvar_global->sysDefaults)->layer)
	    )) 
	when(result 
	    (ph_shape = car(result)) 
	    if((axlIsLayer 
		    (ph_param->layer)
		) then 
		(text_orient = (make_axlTextOrientation ?textBlock 
			(ph_param->textBlock) ?rotation 
			(ph_param->rotation)
			?mirrored 
			(ph_param->mirror) ?justify 
			(ph_param->justify)
		    )) 
		(axlDBCreateText 
		    (ph_param->displayValue) location text_orient 
		    (ph_param->layer)
		    ph_shape
		) 
		unless((axlIsVisibleLayer 
			(ph_param->layer)
		    ) 
		    (axlVisibleLayer 
			(ph_param->layer) t
		    ) 
		    (axlVisibleUpdate t)
		)
		else 
		printf("Warning:  Layer %L specified by placeholder does not exist yet. Cannot create display string.\n" 
		    (ph_param->layer)
		)
	    ) 
	    (axlDBAddProp ph_shape 
		list(list("TBX_CUSTOMVAR_NAME" name_str) 
		    list("TBX_CUSTOMVAR_ATTR" attr_str) 
		    list("FIXED" t)
		)
	    )
	) ph_shape
    )
)
procedure(TBX_CUSTOMVAR_PLACE_Delete_Placeholder(xy) 
    let((ph_entity) 
	(ph_entity = car(TBX_CUSTOMVAR_Select_Placeholders("pick" xy))) 
	if(ph_entity then 
	    (axlDBIgnoreFixed t) 
	    (axlDeleteObject ph_entity) 
	    (axlDBIgnoreFixed nil)
	    (axlDBRefreshId nil) else 
	    printf("No element selected.\n")
	) 
	(axlClearSelSet) t
    )
)
procedure(TBX_CUSTOMVAR_PLACE_Event_Loop(form_handle) 
    let((eventMask loop event start_pick bBox
	    ph_list template_file ph_param
	) 
	(axlEventSetStartPopup 
	    'TBX_CUSTOMVAR_PLACE_Popup_Callback
	) 
	(eventMask = list('PICK 
		'STARTDRAG 
		'STOPDRAG
	    )) 
	(loop = t) 
	(tbx_customvar_global->transMark = (axlDBTransactionStart))
	while(loop 
	    (event = (axlEnterEvent eventMask nil t)) 
	    caseq((event->type) 
		(PICK 
		    cond(((((tbx_customvar_global->runTime)->templateMode) == "save_select") t) 
			((((tbx_customvar_global->runTime)->templateMode) == "save_pick_origin") 
			    when(ph_list 
				(template_file = (axlDMFileBrowse nil t ?optFilters "Template files(*.tpl)|*.tpl")) 
				when(template_file 
				    TBX_CUSTOMVAR_PLACE_Save_Template_File(ph_list 
					(event->xy) template_file
				    ) 
				    (axlDehighlightObject ph_list)
				)
			    ) 
			    ((tbx_customvar_global->runTime)->templateMode = nil)
			) 
			((((tbx_customvar_global->runTime)->templateMode) == "load_wait_select") t) 
			((((tbx_customvar_global->runTime)->templateMode) == "load_pick_origin") 
			    when(((tbx_customvar_global->runTime)->curTemplateData) 
				printf("Placing template at %L\n" 
				    (event->xy)
				) 
				(axlClearDynamics) 
				TBX_CUSTOMVAR_PLACE_Load_Template_Data(((tbx_customvar_global->runTime)->curTemplateData) 
				    (event->xy)
				) 
				((tbx_customvar_global->runTime)->templateMode = nil)
			    )
			) 
			((((tbx_customvar_global->runTime)->templateMode) == "cancel") 
			    ((tbx_customvar_global->runTime)->templateMode = nil)
			)
			((axlFormGetField form_handle "add_placeholder") 
			    if(((tbx_customvar_global->runTime)->paramProbe) then 
				TBX_CUSTOMVAR_PLACE_Probe_Param((event->xy) form_handle) 
				((tbx_customvar_global->runTime)->paramProbe = nil) 
				(ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(form_handle))
				TBX_CUSTOMVAR_PLACE_Build_Dynamics(ph_param) else 
				if(rexMatchp("^ *$" 
					(axlFormGetField form_handle "variable_name")
				    ) then 
				    printf("Warning: Please specify a valid variable name first\n") 
				    (axlClearDynamics) else
				    (axlDBTransactionMark 
					(tbx_customvar_global->transMark)
				    ) 
				    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(form_handle)) 
				    when(TBX_CUSTOMVAR_Valid_Placeholder_Layer((ph_param->layer)) 
					TBX_CUSTOMVAR_PLACE_Create_Placeholder((event->xySnap) ph_param)
				    ) 
				    TBX_CUSTOMVAR_PLACE_Build_Dynamics(ph_param)
				)
			    )
			) 
			((axlFormGetField form_handle "modify_placeholder") 
			    (axlClearDynamics) 
			    if(((tbx_customvar_global->runTime)->paramProbe) then 
				TBX_CUSTOMVAR_PLACE_Probe_Param((event->xy) form_handle) 
				((tbx_customvar_global->runTime)->paramProbe = nil) else
				(axlDBTransactionMark 
				    (tbx_customvar_global->transMark)
				) 
				TBX_CUSTOMVAR_PLACE_Modify_Placeholder((event->xy) form_handle)
			    )
			) 
			((axlFormGetField form_handle "delete_placeholder") 
			    (axlDBTransactionMark 
				(tbx_customvar_global->transMark)
			    ) 
			    TBX_CUSTOMVAR_PLACE_Delete_Placeholder((event->xy))
			)
		    ) 
		    (axlVisibleUpdate t)
		) 
		(STARTDRAG 
		    when((((tbx_customvar_global->runTime)->templateMode) == "save_select") 
			(axlAddSimpleRbandDynamics 
			    (event->xy) "box" ?origin 
			    (0.0:0.0)
			) 
			(start_pick = (event->xy))
		    )
		) 
		(STOPDRAG 
		    when((((tbx_customvar_global->runTime)->templateMode) == "save_select") 
			(bBox = list(start_pick 
				(event->xy)
			    )) 
			(ph_list = TBX_CUSTOMVAR_Select_Placeholders("box" bBox)) 
			if(ph_list then 
			    (axlHighlightObject ph_list) 
			    ((tbx_customvar_global->runTime)->templateMode = "save_pick_origin") 
			    printf("Pick template origin\n")
			    else 
			    printf("Nothing selected.\n") 
			    ((tbx_customvar_global->runTime)->templateMode = nil)
			) 
			(axlClearDynamics)
		    )
		) 
		(DONE 
		    (axlDBTransactionCommit 
			(tbx_customvar_global->transMark)
		    ) 
		    (axlClearDynamics) 
		    (loop = nil)
		)
		(CANCEL 
		    (axlDBTransactionOops 
			(tbx_customvar_global->transMark)
		    ) 
		    (axlDBTransactionCommit 
			(tbx_customvar_global->transMark)
		    ) 
		    (axlClearDynamics) 
		    (loop = nil)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_CUSTOMVAR_PLACE_Load_Template_Data(data location) 
    let((name_str offset attr_str ph_param xy) 
	foreach(entry data 
	    (name_str = car(entry)) 
	    (offset = cadr(entry)) 
	    (attr_str = caddr(entry))
	    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(name_str attr_str)) 
	    if((ph_param && TBX_CUSTOMVAR_Valid_Placeholder_Layer((ph_param->layer))) then 
		(xy = ((car(offset) + car(location)):(cadr(offset) + cadr(location)))) 
		TBX_CUSTOMVAR_PLACE_Create_Placeholder(xy ph_param) else
		printf("Warning: Invalid data specified %L. Skipping...\n" entry)
	    )
	) t
    )
)
procedure(TBX_CUSTOMVAR_PLACE_Modify_Placeholder(xy form_handle) 
    let((ph_entity ph_location ph_param) 
	(ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(form_handle)) 
	when(TBX_CUSTOMVAR_Valid_Placeholder_Layer((ph_param->layer)) 
	    (ph_entity = car(TBX_CUSTOMVAR_Select_Placeholders("pick" xy))) 
	    if(ph_entity then 
		(ph_location = (car((ph_entity->segments))->xy)) 
		(axlDBIgnoreFixed t) 
		(axlDeleteObject ph_entity)
		(axlDBIgnoreFixed nil) 
		TBX_CUSTOMVAR_PLACE_Create_Placeholder(ph_location ph_param) 
		(axlDBRefreshId nil) else 
		printf("No element selected.\n")
	    ) 
	    (axlClearSelSet)
	) t
    )
)
procedure(TBX_CUSTOMVAR_PLACE_Popup_Callback(event) 
    let((popup form_handle) 
	(event = event) 
	(form_handle = ((tbx_customvar_global->formHandle)->place)) 
	cond((((axlFormGetField form_handle "add_placeholder") || 
		    (axlFormGetField form_handle "modify_placeholder")) 
		(popup = (axlUIPopupDefine nil 
			list(list("Done" 
				'TBX_CUSTOMVAR_PLACE_RMB_Done
			    ) 
			    list("Probe" 
				'TBX_CUSTOMVAR_PLACE_RMB_Probe
			    ) 
			    list("Oops" 
				'TBX_CUSTOMVAR_PLACE_RMB_Oops
			    ) 
			    list("Cancel" 
				'TBX_CUSTOMVAR_PLACE_RMB_Cancel
			    ) 
			    list("Save Template" 
				'TBX_CUSTOMVAR_PLACE_RMB_Save_Template
			    )
			    list("Load Template" 
				'TBX_CUSTOMVAR_PLACE_RMB_Load_Template
			    )
			)
		    )) 
		(axlUIPopupSet popup)
	    ) 
	    ((axlFormGetField form_handle "delete_placeholder") 
		(popup = (axlUIPopupDefine nil 
			list(list("Done" 
				'TBX_CUSTOMVAR_PLACE_RMB_Done
			    ) 
			    list("Oops" 
				'TBX_CUSTOMVAR_PLACE_RMB_Oops
			    ) 
			    list("Cancel" 
				'TBX_CUSTOMVAR_PLACE_RMB_Cancel
			    ) 
			    list("Save Template" 
				'TBX_CUSTOMVAR_PLACE_RMB_Save_Template
			    ) 
			    list("Load Template" 
				'TBX_CUSTOMVAR_PLACE_RMB_Load_Template
			    )
			)
		    ))
	    ) 
	    (t t)
	) 
	when(popup 
	    (axlUIPopupSet popup)
	)
	t
    )
)
procedure(TBX_CUSTOMVAR_PLACE_Probe_Param(xy form_handle) 
    let((text_mirror_yes_no ph_entity ph_param type_str hist_level_str
	    text_dbid display_value
	) 
	(ph_entity = car(TBX_CUSTOMVAR_Select_Placeholders("pick" xy))) 
	when(ph_entity 
	    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(((ph_entity->prop)->TBX_CUSTOMVAR_NAME) 
		    ((ph_entity->prop)->TBX_CUSTOMVAR_ATTR)
		)) 
	    case((ph_param->type) 
		("S" 
		    (type_str = "standard")
		) 
		("C" 
		    (type_str = "context")
		) 
		("G" 
		    (type_str = "group") 
		    (ph_param->histLevel = "0")
		)
	    ) 
	    if((ph_param->mirror) then 
		(text_mirror_yes_no = "YES") else 
		(text_mirror_yes_no = "NO")
	    ) 
	    (hist_level_str = (ph_param->histLevel))
	    when(((ph_param->histLevel) == "0") 
		(hist_level_str = "none")
	    ) 
	    (text_dbid = car(setof(x 
			(axlDBGetAttachedText ph_entity) 
			((x->layer) == (ph_param->layer))
		    )
		)) 
	    (display_value = "") 
	    when((text_dbid && ((text_dbid->text) != "")) 
		(display_value = (text_dbid->text))
	    ) 
	    (axlFormSetField form_handle "variable_name" 
		(ph_param->name)
	    )
	    (axlFormSetField form_handle "display_value" display_value) 
	    (axlDBControl 
		'activeLayer 
		(ph_param->layer)
	    ) 
	    (axlFormSetField form_handle "text_block" 
		(ph_param->textBlock)
	    ) 
	    (axlFormSetField form_handle "text_rotation" 
		(ph_param->rotation)
	    ) 
	    (axlFormSetField form_handle "text_align" 
		(ph_param->justify)
	    )
	    (axlFormSetField form_handle "text_mirror" text_mirror_yes_no) 
	    (axlFormSetField form_handle "placeholder_type" type_str) 
	    (axlFormSetField form_handle "hist_level" hist_level_str) 
	    case((axlFormGetField form_handle "placeholder_type") 
		("standard" 
		    (axlFormSetFieldEditable form_handle "hist_level" t)
		) 
		("context" 
		    (axlFormSetFieldEditable form_handle "hist_level" t)
		) 
		("group" 
		    (axlFormSetFieldEditable form_handle "hist_level" nil)
		)
	    )
	) 
	(axlClearSelSet) t
    )
)
procedure(TBX_CUSTOMVAR_PLACE_RMB_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_CUSTOMVAR_PLACE_RMB_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_CUSTOMVAR_PLACE_RMB_Load_Template() 
    let((FORM_FILE fid file_list base_name template_list) 
	(file_list = TBX_UTIL_Search_Config("*.tpl" "customvar" t ?includeWorkDir t)) 
	if(file_list then 
	    printf("Loading a template.\n") 
	    ((tbx_customvar_global->runTime)->templateMode = "load_wait_select") 
	    (FORM_FILE = TBX_FORM_Get_Name((tbx_customvar_global->licCheck) "customvar_template_select"))
	    (fid = (axlFormCreate 
		    gensym("tbxcustomvartemplateselect") FORM_FILE 
		    '(e outer) 
		    'TBX_CUSTOMVAR_TEMPLATE_Callback
		    t nil
		)) 
	    ((tbx_customvar_global->formHandle)->templateSelect = fid) 
	    (tbx_customvar_global->templateInfo = makeTable("template_file_table" nil)) 
	    foreach(fn file_list 
		(base_name = cadr((axlDMFileParts fn))) 
		((tbx_customvar_global->templateInfo)[base_name] = fn)
	    ) 
	    (template_list = mapcar(lambda((x) 
			car(x)
		    ) 
		    tableToList((tbx_customvar_global->templateInfo))
		))
	    (template_list = sort(template_list nil)) 
	    (axlFormListDeleteAll fid "template_list") 
	    (axlFormSetField fid "template_list" template_list) 
	    (axlFormDisplay fid) 
	    TBX_FORM_Delete((tbx_customvar_global->licCheck) FORM_FILE)
	    else 
	    ((tbx_customvar_global->runTime)->templateMode = "cancel") 
	    printf("Warning: No template files found.\n")
	) t
    )
)
procedure(TBX_CUSTOMVAR_PLACE_RMB_Oops() 
    (axlDBTransactionOops 
	(tbx_customvar_global->transMark)
    ) 
    (tbx_customvar_global->runTime = ncons(nil))
)
procedure(TBX_CUSTOMVAR_PLACE_RMB_Probe() 
    printf("Pick a a placeholder to extract parameters from\n") 
    (axlClearDynamics) 
    ((tbx_customvar_global->runTime)->paramProbe = t)
)
procedure(TBX_CUSTOMVAR_PLACE_RMB_Save_Template() 
    (axlClearDynamics) 
    ((tbx_customvar_global->runTime)->templateMode = "save_select") 
    printf("Select placeholders. Pick two points to define the selection window.\n")
)
procedure(TBX_CUSTOMVAR_PLACE_Save_Template_File(ph_list origin file) 
    let((port data x_loc y_loc name_prop
	    attr_prop loc_str name_str attr_str ph_location
	) 
	foreach(ph ph_list 
	    (ph_location = (car((ph->segments))->xy)) 
	    (x_loc = (car(ph_location) - car(origin))) 
	    (y_loc = (cadr(ph_location) - cadr(origin)))
	    (name_prop = ((ph->prop)->TBX_CUSTOMVAR_NAME)) 
	    (attr_prop = ((ph->prop)->TBX_CUSTOMVAR_ATTR)) 
	    (loc_str = sprintf(nil "%L" 
		    (x_loc:y_loc)
		)) 
	    (name_str = sprintf(nil "%L" name_prop)) 
	    (attr_str = sprintf(nil "%L" attr_prop))
	    (data = cons(list(name_str loc_str attr_str) data))
	) 
	(data = sortcar(data nil)) 
	(port = outfile(file "w")) 
	fprintf(port "(\n")
	foreach(entry data 
	    (name_str = car(entry)) 
	    (loc_str = cadr(entry)) 
	    (attr_str = caddr(entry))
	    fprintf(port "   ( %-20s  %-20s  %s)\n" name_str loc_str attr_str)
	) 
	fprintf(port ")\n") 
	close(port) 
	printf("Note: File %L has been written\n" file) t
    )
)
procedure(TBX_CUSTOMVAR_Read_Cpm_Data(cpm_file) 
    let((data var_list var_name var_context var_value) 
	cond(((cpm_file && isFile(cpm_file)) 
		printf("Info: Reading custom variables from %L\n" cpm_file) 
		(data = TBX_CPM_Read_Project_File(cpm_file t)) 
		foreach(entry data 
		    (var_name = upperCase(car(entry))) 
		    (var_context = upperCase(cadr(entry))) 
		    (var_value = caddr(entry))
		    (var_list = cons(list(var_name var_context var_value) var_list))
		) 
		(var_list = reverse(var_list))
	    ) 
	    ((cpm_file && !isFile(cpm_file)) 
		printf("Info: File %L does not exist\n" cpm_file)
	    ) 
	    (t 
		printf("Warning: Cannot open file %L\n" cpm_file)
	    )
	) var_list
    )
)
procedure(TBX_CUSTOMVAR_Read_Local_Data(cfg_file) 
    let((arr inport var_name var_context var_value
	    var_list line
	) 
	cond(((cfg_file && isFile(cfg_file)) 
		(inport = infile(cfg_file)) 
		while((line = _gets(inport)) 
		    (line = substring(line 1 
			    (strlen(line) - 1)
			)) 
		    rexCompile("^ *\\[ *customvar \\(.*\\) *\\] *$") 
		    cond((rexExecute(lowerCase(line)) 
			    (var_context = upperCase(rexSubstitute("\\1")))
			) 
			(var_context 
			    rexCompile("'") 
			    (line = rexReplace(line "" 0)) 
			    rexCompile("\"") 
			    (line = rexReplace(line "" 0))
			    (arr = parseString(line "=")) 
			    when((length(arr) >= 1) 
				(var_name = upperCase(car(arr))) 
				if(cadr(arr) then 
				    (var_value = buildString(cdr(arr) "=")) else 
				    (var_value = "")
				) 
				(var_value = buildString(cdr(arr) "=")) 
				(var_name = TBX_UTIL_Trim_String(var_name))
				(var_value = TBX_UTIL_Trim_String(var_value)) 
				(var_list = cons(list(var_name var_context var_value) var_list))
			    )
			)
		    )
		) 
		close(inport) 
		(var_list = sortcar(var_list nil))
	    ) 
	    ((cfg_file && !isFile(cfg_file)) 
		printf("Info: File %L does not exist yet\n" cfg_file)
	    ) 
	    (t 
		printf("Warning: Cannot open file %L\n" cfg_file)
	    )
	) var_list
    )
)
procedure(TBX_CUSTOMVAR_Refresh_Auto_Variables() 
    let((month_nr tmp_list mm dd yy
	    full_version int_version build_date auto_user auto_date
	    auto_design_name auto_design_path auto_tool_version auto_tool_version_isr auto_tool_version_detail
	    format_str arr format_arr day_int day_str
	    month_int month_str year_str date_list format_separator
	    tmp_format
	) 
	if(axlGetVariable("username") then 
	    (auto_user = upperCase(axlGetVariable("username"))) else 
	    printf("Warning: Cannot determine user name\n")
	    (auto_user = "NA")
	) 
	(month_nr = makeTable("month_nr_table" nil)) 
	(month_nr["JAN"] = 1) 
	(month_nr["FEB"] = 2)
	(month_nr["MAR"] = 3) 
	(month_nr["APR"] = 4) 
	(month_nr["MAY"] = 5) 
	(month_nr["JUN"] = 6) 
	(month_nr["JUL"] = 7)
	(month_nr["AUG"] = 8) 
	(month_nr["SEP"] = 9) 
	(month_nr["OCT"] = 10) 
	(month_nr["NOV"] = 11) 
	(month_nr["DEC"] = 12)
	(tmp_list = parseString(upperCase(getCurrentTime()))) 
	(month_int = month_nr[car(tmp_list)]) 
	(day_int = atoi(cadr(tmp_list))) 
	(year_str = nth(3 tmp_list)) 
	(mm = sprintf(nil "%02d" 
		month_nr[car(tmp_list)]
	    ))
	(dd = sprintf(nil "%02d" 
		atoi(cadr(tmp_list))
	    )) 
	(yy = substring(nth(3 tmp_list) 3)) 
	(auto_date = strcat(dd "." mm "." yy)) 
	(auto_design_name = (axlCurrentDesign)) 
	(auto_design_path = getWorkingDir())
	(auto_tool_version = (axlVersion 
		'pVersion
	    )) 
	(auto_tool_version_isr = (axlVersion 
		'fullVersion
	    )) 
	(full_version = (axlVersion 
		'fullVersion
	    )) 
	(int_version = (axlVersion 
		'internalVersion
	    )) 
	(build_date = (axlVersion 
		'buildDate
	    ))
	(auto_tool_version_detail = strcat(full_version " (" int_version ") [" build_date
		"]"
	    )) 
	foreach(cxt 
	    (tbx_customvar_global->varInfo) 
	    foreach(vn 
		(tbx_customvar_global->varInfo)[cxt] 
		when(rexMatchp("^AUTO_" 
			upperCase(vn)
		    ) 
		    cond(((vn == "AUTO_USER") 
			    ((tbx_customvar_global->varInfo)[cxt][vn]->newValue = auto_user)
			) 
			(rexMatchp("^AUTO_DATE" vn) 
			    (date_list = nil) 
			    (arr = parseString(vn "_")) 
			    if((length(arr) == 3) then 
				(format_str = upperCase(caddr(arr))) 
				cond((rexMatchp("/" format_str) 
					(format_separator = "/")
				    ) 
				    (rexMatchp("[.]" format_str) 
					(format_separator = ".")
				    ) 
				    (rexMatchp("-" format_str) 
					(format_separator = "-")
				    )
				) 
				(format_arr = parseString(format_str format_separator))
				foreach(elem format_arr 
				    cond((rexMatchp("^D*$" elem) 
					    (tmp_format = strcat("%0" 
						    sprintf(nil "%d" 
							strlen(elem)
						    ) "d"
						)) 
					    (day_str = sprintf(nil tmp_format day_int)) 
					    (date_list = cons(day_str date_list))
					) 
					(rexMatchp("^M*$" elem) 
					    (tmp_format = strcat("%0" 
						    sprintf(nil "%d" 
							strlen(elem)
						    ) "d"
						)) 
					    (month_str = sprintf(nil tmp_format month_int)) 
					    (date_list = cons(month_str date_list))
					) 
					(rexMatchp("^Y*$" elem) 
					    (date_list = cons(substring(year_str 
							(5 - strlen(elem))
						    ) date_list
						))
					)
				    )
				) 
				(date_list = reverse(date_list)) 
				((tbx_customvar_global->varInfo)[cxt][vn]->newValue = buildString(date_list format_separator)) else 
				(mm = sprintf(nil "%02d" month_int))
				(dd = sprintf(nil "%02d" day_int)) 
				(yy = substring(year_str 3)) 
				(auto_date = strcat(dd "." mm "." yy)) 
				((tbx_customvar_global->varInfo)[cxt][vn]->newValue = auto_date)
			    )
			) 
			((vn == "AUTO_TIME") 
			    ((tbx_customvar_global->varInfo)[cxt][vn]->newValue = getCurrentTime())
			) 
			((vn == "AUTO_DESIGN_NAME") 
			    ((tbx_customvar_global->varInfo)[cxt][vn]->newValue = auto_design_name)
			) 
			((vn == "AUTO_DESIGN_PATH") 
			    ((tbx_customvar_global->varInfo)[cxt][vn]->newValue = auto_design_path)
			)
			((vn == "AUTO_TOOL_VERSION") 
			    ((tbx_customvar_global->varInfo)[cxt][vn]->newValue = auto_tool_version)
			) 
			((vn == "AUTO_TOOL_VERSION_ISR") 
			    ((tbx_customvar_global->varInfo)[cxt][vn]->newValue = auto_tool_version_isr)
			) 
			((vn == "AUTO_TOOL_VERSION_DETAIL") 
			    ((tbx_customvar_global->varInfo)[cxt][vn]->newValue = auto_tool_version_detail)
			) 
			((vn == "AUTO_VARIANT") 
			    ((tbx_customvar_global->varInfo)[cxt][vn]->newValue = upperCase(cxt))
			)
		    )
		)
	    )
	) 
	(tbx_customvar_global->varInfo)
    )
)
procedure(TBX_CUSTOMVAR_Save_Layer_Map(layerMap output_file) 
    let((port data data_str key_list) 
	(key_list = mapcar(lambda((x) 
		    car(x)
		) 
		tableToList(layerMap)
	    )) 
	(key_list = sort(key_list nil)) 
	(key_list = reverse(key_list)) 
	foreach(key key_list 
	    when(layerMap[key] 
		(data = cons(cons(key 
			    layerMap[key]
			) data
		    ))
	    )
	)
	if((length(data) > 0) then 
	    if(output_file then 
		(port = outfile(output_file "w")) 
		pprint(data port) 
		close(port)
		printf("Note: File %L has been written\n" output_file) else 
		(axlDeleteAttachment "tbx_customvar") 
		(data_str = sprintf(nil "%L" data)) 
		(axlCreateAttachment "tbx_customvar" nil 1 
		    'string
		    data_str
		)
	    ) else t
	) t
    )
)
procedure(TBX_CUSTOMVAR_Save_Variables() 
    let((port fileData key_list value) 
	foreach(cxt 
	    (tbx_customvar_global->varInfo) 
	    foreach(vn 
		(tbx_customvar_global->varInfo)[cxt] 
		((tbx_customvar_global->varDef)[cxt][vn] = ((tbx_customvar_global->varInfo)[cxt][vn]->newValue))
	    )
	) 
	when((length((tbx_customvar_global->varDef)) > 0) 
	    foreach(cxt 
		(tbx_customvar_global->varDef) 
		foreach(vn 
		    (tbx_customvar_global->varDef)[cxt] 
		    (value = (tbx_customvar_global->varDef)[cxt][vn]) 
		    when((!value || (value == "") || (value == "<NULL>")) 
			((tbx_customvar_global->varDef)[cxt][vn] = "''")
		    )
		)
	    ) 
	    (fileData = makeTable("file_data_table" nil)) 
	    foreach(cxt 
		(tbx_customvar_global->varDef) 
		foreach(vn 
		    (tbx_customvar_global->varDef)[cxt] 
		    cond(((upperCase(cxt) == "BASE") 
			    (fileData[cxt] = cons(list(vn 
					(tbx_customvar_global->varDef)[cxt][vn]
				    ) 
				    fileData[cxt]
				))
			) 
			(((upperCase(cxt) != "BASE") && ((tbx_customvar_global->varDef)[cxt][vn] != (tbx_customvar_global->varDef)["BASE"][vn])) 
			    (fileData[cxt] = cons(list(vn 
					(tbx_customvar_global->varDef)[cxt][vn]
				    ) 
				    fileData[cxt]
				))
			) 
			(t t)
		    )
		)
	    ) 
	    foreach(key fileData 
		(fileData[key] = sortcar(fileData[key] nil))
	    )
	    foreach(key fileData 
		(key_list = cons(key key_list))
	    ) 
	    (key_list = sort(key_list nil)) 
	    (key_list = setof(x key_list 
		    (upperCase(x) != "BASE")
		)) 
	    (key_list = cons("BASE" key_list)) 
	    (port = outfile(((tbx_customvar_global->varConfig)->localFile) "w"))
	    foreach(key key_list 
		fprintf(port "[Customvar %s]\n" key) 
		foreach(entry 
		    fileData[key] 
		    fprintf(port "%s=%s\n" 
			car(entry) 
			cadr(entry)
		    )
		) 
		fprintf(port "\n")
	    ) 
	    close(port) 
	    printf("Note: File %L has been written\n" 
		((tbx_customvar_global->varConfig)->localFile)
	    )
	) t
    )
)
procedure(TBX_CUSTOMVAR_Select_Placeholders(mode arg) 
    let((ph_entity ph_list) 
	(axlSetFindFilter ?enabled 
	    list("noall" "shapes" "text") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	if((mode == "pick") then 
	    (axlSingleSelectPoint arg) else 
	    (axlSingleSelectBox arg)
	) 
	foreach(elem 
	    (axlGetSelSet) 
	    case((elem->objType) 
		("text" 
		    when(((((elem->parent)->objType) == "shape") && (((elem->parent)->prop)->TBX_CUSTOMVAR_NAME) && (((elem->parent)->prop)->TBX_CUSTOMVAR_ATTR)) 
			(ph_entity = (elem->parent)) 
			(ph_list = cons(ph_entity ph_list))
		    )
		) 
		("shape" 
		    when((((elem->prop)->TBX_CUSTOMVAR_NAME) && ((elem->prop)->TBX_CUSTOMVAR_ATTR)) 
			(ph_entity = elem) 
			(ph_list = cons(ph_entity ph_list))
		    )
		)
	    )
	)
	(axlClearSelSet) ph_list
    )
)
procedure(TBX_CUSTOMVAR_Synchronize_Attributes() 
    let((attr_str ph_param ph_list text_dbid arr
	    txt_list
	) 
	(ph_list = TBX_CUSTOMVAR_Get_All_Placeholders()) 
	foreach(ph ph_list 
	    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(((ph->prop)->TBX_CUSTOMVAR_NAME) 
		    ((ph->prop)->TBX_CUSTOMVAR_ATTR)
		)) 
	    when(((ph_param->name) && (ph_param->layer) && ((ph_param->type) != "G")) 
		foreach(txt 
		    (axlDBGetAttachedText ph) 
		    (arr = parseString((txt->layer) "/")) 
		    if((((axlMapClassName 
				    car(arr) t
				) == "DRAWING FORMAT") && rexMatchp("^CXT_" 
				cadr(arr)
			    )) then t else 
			(txt_list = cons(txt txt_list))
		    )
		) 
		(text_dbid = car(txt_list)) 
		when(text_dbid 
		    (ph_param->textBlock = (text_dbid->textBlock)) 
		    (ph_param->rotation = (text_dbid->rotation)) 
		    (ph_param->justify = (text_dbid->justify)) 
		    (ph_param->layer = (text_dbid->layer))
		    if((text_dbid->isMirrored) then 
			(ph_param->mirror = t) else 
			(ph_param->mirror = nil)
		    ) 
		    (attr_str = TBX_CUSTOMVAR_Build_Prop_String(ph_param "attr")) 
		    (axlDBAddProp ph 
			list(list("TBX_CUSTOMVAR_ATTR" 
				upperCase(attr_str)
			    )
			)
		    )
		)
	    )
	) 
	(axlClearSelSet) t
    )
)
procedure(TBX_CUSTOMVAR_Synchronize_Context(current_context) 
    let((a) 
	(a = a) 
	when(((current_context != "BASE") && !(tbx_customvar_global->varInfo)[current_context]) 
	    (tbx_customvar_global->hashCnt = ((tbx_customvar_global->hashCnt) + 1)) 
	    unless((tbx_customvar_global->varInfo)[current_context] 
		((tbx_customvar_global->varInfo)[current_context] = makeTable(sprintf(nil "hash_%02d" 
			    (tbx_customvar_global->hashCnt)
			) nil
		    ))
	    ) 
	    (tbx_customvar_global->hashCnt = ((tbx_customvar_global->hashCnt) + 1)) 
	    unless((tbx_customvar_global->varDef)[current_context] 
		((tbx_customvar_global->varDef)[current_context] = makeTable(sprintf(nil "hash_%02d" 
			    (tbx_customvar_global->hashCnt)
			) nil
		    ))
	    )
	    foreach(vn 
		(tbx_customvar_global->varInfo)["BASE"] 
		if(((((tbx_customvar_global->varInfo)["BASE"][vn]->type) == "S") || (((tbx_customvar_global->varInfo)["BASE"][vn]->type) == "G")) then t else 
		    ((tbx_customvar_global->varInfo)[current_context][vn] = copy((tbx_customvar_global->varInfo)["BASE"][vn]))
		    ((tbx_customvar_global->varDef)[current_context][vn] = ((tbx_customvar_global->varInfo)[current_context][vn]->newValue))
		)
	    )
	) 
	(tbx_customvar_global->varInfo)
    )
)
procedure(TBX_CUSTOMVAR_Synchronize_Variables() 
    let((var_name var_context varInfo histLabel cur_data
	    ph_param ph_list text_value var_value user_data
	    source_type arr sub_name context_list hist_id
	    result
	) 
	(ph_list = TBX_CUSTOMVAR_Get_All_Placeholders()) 
	(axlClearSelSet) 
	(varInfo = makeTable("var_info_table" nil)) 
	(histLabel = makeTable("hist_label_table" nil))
	(tbx_customvar_global->hashCnt = ((tbx_customvar_global->hashCnt) + 1)) 
	(varInfo["BASE"] = makeTable(sprintf(nil "hash_%02d" 
		    (tbx_customvar_global->hashCnt)
		) nil
	    )) 
	(tbx_customvar_global->hashCnt = ((tbx_customvar_global->hashCnt) + 1)) 
	(histLabel["BASE"] = makeTable(sprintf(nil "hash_%02d" 
		    (tbx_customvar_global->hashCnt)
		) nil
	    )) 
	foreach(ph ph_list 
	    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(((ph->prop)->TBX_CUSTOMVAR_NAME) 
		    ((ph->prop)->TBX_CUSTOMVAR_ATTR)
		)) 
	    (cur_data = TBX_CUSTOMVAR_Get_Placeholder_Text_Info(ph ph_param)) 
	    (hist_id = atoi((ph_param->histLevel)))
	    cond((((car(cur_data) == "S") || (car(cur_data) == "C")) 
		    (var_name = (ph_param->name)) 
		    foreach(entry 
			cdr(cur_data) 
			(var_context = car(entry)) 
			(text_value = caddr(entry)) 
			unless(varInfo[var_context] 
			    (tbx_customvar_global->hashCnt = ((tbx_customvar_global->hashCnt) + 1)) 
			    (varInfo[var_context] = makeTable(sprintf(nil "hash_%02d" 
					(tbx_customvar_global->hashCnt)
				    ) nil
				))
			)
			(varInfo[var_context][var_name] = list(nil 
				'type 
				car(cur_data) 
				'newValue text_value
				'source "design"
			    )) 
			unless(histLabel[var_context] 
			    (tbx_customvar_global->hashCnt = ((tbx_customvar_global->hashCnt) + 1)) 
			    (histLabel[var_context] = makeTable(sprintf(nil "hash_%02d" 
					(tbx_customvar_global->hashCnt)
				    ) nil
				))
			) 
			unless(histLabel[var_context][var_name] 
			    (histLabel[var_context][var_name] = makeVector(10 nil))
			) 
			(histLabel[var_context][var_name][hist_id] = text_value)
		    )
		) 
		((car(cur_data) == "G") 
		    unless(varInfo["BASE"] 
			(tbx_customvar_global->hashCnt = ((tbx_customvar_global->hashCnt) + 1)) 
			(varInfo["BASE"] = makeTable(sprintf(nil "hash_%02d" 
				    (tbx_customvar_global->hashCnt)
				) nil
			    ))
		    ) 
		    foreach(entry 
			cdr(cur_data) 
			(sub_name = car(entry)) 
			(text_value = caddr(entry)) 
			(var_name = strcat((ph_param->name) "|" sub_name))
			(varInfo["BASE"][var_name] = list(nil 
				'type "G" 
				'newValue text_value
				'source "design"
			    ))
		    )
		)
	    )
	)
	foreach(cfg 
	    list(list(((tbx_customvar_global->varConfig)->localData) "local") 
		list(((tbx_customvar_global->varConfig)->cpmData) "cpm")
	    ) 
	    (user_data = car(cfg)) 
	    (source_type = cadr(cfg)) 
	    foreach(entry user_data 
		(var_name = car(entry)) 
		(var_context = cadr(entry)) 
		(var_value = caddr(entry))
		(arr = parseString(var_name "|")) 
		if(((var_context == "BASE") && (length(arr) == 2)) then 
		    when(varInfo["BASE"][var_name] 
			(varInfo["BASE"][var_name]->newValue = var_value) 
			(varInfo["BASE"][var_name]->source = source_type)
		    ) else 
		    when(varInfo["BASE"][var_name] 
			when((var_context != "BASE") 
			    unless(varInfo[var_context] 
				(tbx_customvar_global->hashCnt = ((tbx_customvar_global->hashCnt) + 1)) 
				(varInfo[var_context] = makeTable(sprintf(nil "hash_%02d" 
					    (tbx_customvar_global->hashCnt)
					) nil
				    ))
			    ) 
			    unless(varInfo[var_context][var_name] 
				(varInfo[var_context][var_name] = copy(varInfo["BASE"][var_name]))
			    )
			) 
			(varInfo[var_context][var_name]->source = source_type) 
			(varInfo[var_context][var_name]->newValue = var_value)
		    )
		)
	    )
	) 
	foreach(vn 
	    varInfo["BASE"] 
	    when(((varInfo["BASE"][vn]->newValue) == "<NULL>") 
		(varInfo["BASE"][vn]->newValue = "")
	    )
	) 
	foreach(cxt varInfo 
	    if(!(tbx_customvar_global->varDef)[cxt] then 
		(tbx_customvar_global->hashCnt = ((tbx_customvar_global->hashCnt) + 1)) 
		((tbx_customvar_global->varDef)[cxt] = makeTable(sprintf(nil "hash_%02d" 
			    (tbx_customvar_global->hashCnt)
			) nil
		    )) else
		foreach(vn 
		    (tbx_customvar_global->varDef)[cxt] 
		    when(varInfo[cxt][vn] 
			(varInfo[cxt][vn]->newValue = (tbx_customvar_global->varDef)[cxt][vn])
		    )
		)
	    )
	) 
	(context_list = mapcar(lambda((x) 
		    car(x)
		) 
		tableToList(varInfo)
	    )) 
	(context_list = setof(x context_list 
		(x != "BASE")
	    ))
	foreach(cxt context_list 
	    foreach(vn 
		varInfo[cxt] 
		when((((varInfo[cxt][vn]->newValue) == "<NULL>") && (varInfo["BASE"][vn]->newValue)) 
		    (varInfo[cxt][vn]->newValue = (varInfo["BASE"][vn]->newValue))
		) 
		when((((varInfo[cxt][vn]->newValue) != "<NULL>") && !(tbx_customvar_global->varDef)[cxt][vn] && (tbx_customvar_global->varDef)["BASE"][vn]) 
		    (varInfo[cxt][vn]->newValue = (tbx_customvar_global->varDef)["BASE"][vn])
		)
	    )
	) 
	(result = list(varInfo histLabel)) result
    )
)
procedure(TBX_CUSTOMVAR_TEMPLATE_Callback(form_handle) 
    let((cur_name template_file port data) 
	case((form_handle->curField) 
	    ("done" 
		(cur_name = (axlFormGetField form_handle "template_list")) 
		(axlFormClose form_handle) 
		(template_file = (tbx_customvar_global->templateInfo)[cur_name]) 
		if((template_file && isFile(template_file)) then 
		    (port = infile(template_file)) 
		    (data = car(lineread(port))) 
		    close(port)
		    if(data then 
			((tbx_customvar_global->runTime)->templateMode = "load_pick_origin") 
			((tbx_customvar_global->runTime)->curTemplateData = data) 
			TBX_CUSTOMVAR_PLACE_Build_Template_Dynamics(((tbx_customvar_global->runTime)->curTemplateData))
			else 
			printf("Warning: Invalid data in file %L.\n" template_file) 
			((tbx_customvar_global->runTime)->templateMode = nil) 
			((tbx_customvar_global->runTime)->curTemplateData = nil)
		    ) else 
		    printf("Warning: File %L does not exist.\n" template_file) 
		    ((tbx_customvar_global->runTime)->templateMode = nil) 
		    ((tbx_customvar_global->runTime)->curTemplateData = nil)
		)
	    ) 
	    ("cancel" 
		(axlFormClose form_handle)
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_CUSTOMVAR_Update_Batch(context_list update_regular update_history) 
    let((lic_check_result result) 
	TBX_CUSTOMVAR_Init() 
	(lic_check_result = TBX_LIC_Validate(((tbx_customvar_global->appInfo)->name) 
		((tbx_customvar_global->appInfo)->version) t
	    )) 
	when(lic_check_result 
	    (tbx_customvar_global->layerMap = TBX_CUSTOMVAR_Load_Layer_Map(nil)) 
	    TBX_CUSTOMVAR_Synchronize_Attributes() 
	    unless(((tbx_customvar_global->varConfig)->localFile) 
		printf("Info: File %L does not exist yet\n" 
		    ((tbx_customvar_global->varConfig)->localFile)
		)
	    ) 
	    (tbx_customvar_global->layerMap = TBX_CUSTOMVAR_Load_Layer_Map(nil))
	    ((tbx_customvar_global->varConfig)->localData = TBX_CUSTOMVAR_Read_Local_Data(((tbx_customvar_global->varConfig)->localFile))) 
	    when(axlGetVariable("TBX_CUSTOMVAR_SOURCE_CPM") 
		if(axlGetVariable("TBX_CUSTOMVAR_CPM_FILE") then 
		    printf("Info  Cpm file specified by environment variable TBX_CUSTOMVAR_CPM_FILE\n") 
		    ((tbx_customvar_global->varConfig)->cpmFile = axlGetVariable("TBX_CUSTOMVAR_CPM_FILE")) else
		    ((tbx_customvar_global->varConfig)->cpmFile = TBX_CPM_Determine_Project_File())
		) 
		when(((tbx_customvar_global->varConfig)->cpmFile) 
		    ((tbx_customvar_global->varConfig)->cpmData = TBX_CUSTOMVAR_Read_Cpm_Data(((tbx_customvar_global->varConfig)->cpmFile)))
		)
	    ) 
	    (tbx_customvar_global->varDef = TBX_CUSTOMVAR_Get_Variable_Definitions()) 
	    (tbx_customvar_global->textLayer = TBX_CUSTOMVAR_Get_Context_Layers()) 
	    (result = TBX_CUSTOMVAR_Synchronize_Variables())
	    (tbx_customvar_global->varInfo = car(result)) 
	    (tbx_customvar_global->histLabel = cadr(result)) 
	    (tbx_customvar_global->status = TBX_CUSTOMVAR_Get_Status()) 
	    when(update_history 
		TBX_CUSTOMVAR_Update_Start("history" context_list t)
	    ) 
	    when(update_regular 
		TBX_CUSTOMVAR_Update_Start("variable" context_list t)
	    )
	)
    )
)
procedure(TBX_CUSTOMVAR_Update_History(context_list) 
    let((ph_param new_value text_dbid_list cur_text_dbid ph_list
	    text_orient text_layer ph_location hist_id var_name
	    ok_found prev_id
	) 
	(axlVisibleLayer 
	    ((tbx_customvar_global->sysDefaults)->layer) t
	) 
	(ph_list = TBX_CUSTOMVAR_Get_All_Placeholders()) 
	(axlClearSelSet) 
	foreach(ph ph_list 
	    (ph_location = (car((ph->segments))->xy)) 
	    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(((ph->prop)->TBX_CUSTOMVAR_NAME) 
		    ((ph->prop)->TBX_CUSTOMVAR_ATTR)
		)) 
	    (hist_id = atoi((ph_param->histLevel)))
	    (var_name = (ph_param->name)) 
	    when(((hist_id > 0) && ((ph_param->type) != "G")) 
		foreach(cxt context_list 
		    (text_layer = nil) 
		    case((ph_param->type) 
			("S" 
			    (text_layer = (ph_param->layer))
			) 
			("C" 
			    if((cxt == "BASE") then 
				(text_layer = (ph_param->layer)) else 
				(text_layer = (tbx_customvar_global->textLayer)[cxt])
			    )
			)
		    ) 
		    (prev_id = (hist_id - 1))
		    (new_value = "") 
		    (ok_found = nil) 
		    while((prev_id >= 0) 
			unless(ok_found 
			    when((tbx_customvar_global->histLabel)[cxt][var_name][prev_id] 
				(ok_found = t) 
				(new_value = (tbx_customvar_global->histLabel)[cxt][var_name][prev_id])
			    )
			) 
			--prev_id
		    ) 
		    when((text_layer && (axlIsLayer text_layer)) 
			(new_value = (axlStringRemoveSpaces new_value)) 
			rexCompile("^<[Nn][Uu][Ll][Ll]>$") 
			(new_value = rexReplace(new_value "" 0)) 
			(text_dbid_list = setof(x 
				(axlDBGetAttachedText ph) 
				((x->layer) == text_layer)
			    ))
			when((length(text_dbid_list) > 1) 
			    printf("Warning: History Update, more than text attached to placeholder at % on layer  %L. Considering first element only.\n" ph_location text_layer) 
			    (axlDeleteObject 
				cdr(text_dbid_list)
			    ) 
			    (axlDBRefreshId nil)
			) 
			(cur_text_dbid = car(text_dbid_list)) 
			if(cur_text_dbid then 
			    if((new_value != "") then 
				(axlDBChangeText cur_text_dbid new_value) else 
				(axlDeleteObject cur_text_dbid)
			    ) else 
			    when((new_value != "") 
				(text_orient = (make_axlTextOrientation ?textBlock 
					(ph_param->textBlock) ?rotation 
					(ph_param->rotation)
					?mirrored 
					(ph_param->mirror) ?justify 
					(ph_param->justify)
				    )) 
				(axlDBCreateText new_value ph_location text_orient text_layer
				    ph
				)
			    )
			)
		    )
		)
	    )
	)
	(axlDBRefreshId nil) t
    )
)
procedure((TBX_CUSTOMVAR_Update_Start mode context_list \@optional batch_mode) 
    let((ok_proceed no_update_yet msg session_param rec
	    result already_processed
	) 
	(session_param = eval('tbx_session_param)) 
	(rec = "customvar|update") 
	unless(session_param[rec] 
	    (session_param[rec] = ncons(nil)) 
	    (session_param[rec]->historyDone = ncons(nil))
	) 
	TBX_CUSTOMVAR_Check_Layers(context_list 
	    (tbx_customvar_global->layerMap)
	)
	when(((mode == "history") && ((tbx_customvar_global->status)->hasHistory)) 
	    foreach(cxt context_list 
		(ok_proceed = t) 
		cond(((get((session_param[rec]->historyDone) 
				stringToSymbol(cxt)
			    ) && !batch_mode) 
			(already_processed = cons(cxt already_processed))
		    ) 
		    ((get((session_param[rec]->historyDone) 
				stringToSymbol(cxt)
			    ) && batch_mode) 
			printf("Info: History update was already made for context %L. Skipping...\n" cxt) 
			(ok_proceed = nil)
		    ) 
		    (t 
			(ok_proceed = t)
		    )
		)
	    ) 
	    when(already_processed 
		(msg = sprintf(nil "History update was already made for context(s): %L\nDo you really want to process history stack again?" 
			buildString(already_processed ", ")
		    )) 
		(ok_proceed = (axlUIYesNo msg nil 
			'no
		    ))
	    ) 
	    when(ok_proceed 
		TBX_CUSTOMVAR_Update_History(context_list) 
		foreach(cxt context_list 
		    putprop((session_param[rec]->historyDone) t 
			stringToSymbol(cxt)
		    )
		)
	    )
	) 
	when((mode == "variable") 
	    (ok_proceed = t) 
	    when(((tbx_customvar_global->status)->hasHistory) 
		(no_update_yet = setof(x context_list 
			!get((session_param[rec]->historyDone) 
				stringToSymbol(x)
			    )
		    )) 
		when(((length(no_update_yet) > 0) && !batch_mode) 
		    (no_update_yet = buildString(no_update_yet ", ")) 
		    (msg = sprintf(nil "History update not made yet for context(s): %s\nDo you still want to continue?" no_update_yet)) 
		    (ok_proceed = (axlUIYesNo msg nil 
			    'no
			))
		)
	    ) 
	    when(ok_proceed 
		TBX_CUSTOMVAR_Update_Variables(context_list)
	    )
	) 
	(result = TBX_CUSTOMVAR_Synchronize_Variables()) 
	(tbx_customvar_global->varInfo = car(result)) 
	(tbx_customvar_global->histLabel = cadr(result))
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_CUSTOMVAR_Update_Variables(context_list) 
    let((ph_list ph_param text_layer text_orient obsolete_text_list
	    tmp_config new_value cur_text_dbid text_dbid_list ph_location
	    var_name
	) 
	(tbx_customvar_global->varInfo = TBX_CUSTOMVAR_Refresh_Auto_Variables()) 
	(ph_list = TBX_CUSTOMVAR_Get_All_Placeholders()) 
	(axlClearSelSet) 
	foreach(ph ph_list 
	    (ph_location = (car((ph->segments))->xy)) 
	    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(((ph->prop)->TBX_CUSTOMVAR_NAME) 
		    ((ph->prop)->TBX_CUSTOMVAR_ATTR)
		)) 
	    when(((ph_param->histLevel) == "0") 
		(obsolete_text_list = nil) 
		(obsolete_text_list = TBX_CUSTOMVAR_Get_Obsolete_Texts(ph)) 
		when(obsolete_text_list 
		    (axlDeleteObject obsolete_text_list) 
		    (axlDBRefreshId ph)
		) 
		foreach(cxt context_list 
		    (tmp_config = nil) 
		    cond(((cxt == "BASE") 
			    case((ph_param->type) 
				("S" 
				    (var_name = (ph_param->name)) 
				    (tmp_config = list(list(var_name 
						(ph_param->layer)
					    )
					))
				) 
				("C" 
				    (var_name = (ph_param->name)) 
				    (tmp_config = list(list(var_name 
						(ph_param->layer)
					    )
					))
				) 
				("G" 
				    foreach(entry 
					(tbx_customvar_global->layerMap)[(ph_param->name)] 
					(var_name = strcat((ph_param->name) "|" 
						car(entry)
					    )) 
					(tmp_config = cons(list(var_name 
						    cadr(entry)
						) tmp_config
					    ))
				    )
				)
			    )
			) 
			(((ph_param->type) == "C") 
			    (var_name = (ph_param->name)) 
			    (text_layer = (tbx_customvar_global->textLayer)[cxt]) 
			    when(text_layer 
				(tmp_config = list(list(var_name text_layer)))
			    )
			) 
			(t t)
		    ) 
		    foreach(entry tmp_config 
			(var_name = car(entry)) 
			(text_layer = cadr(entry)) 
			(new_value = "")
			when(((tbx_customvar_global->varInfo)[cxt][var_name]->newValue) 
			    (new_value = ((tbx_customvar_global->varInfo)[cxt][var_name]->newValue)) 
			    (new_value = (axlStringRemoveSpaces new_value)) 
			    rexCompile("^<[Nn][Uu][Ll][Ll]>$") 
			    (new_value = rexReplace(new_value "" 0))
			) 
			(text_dbid_list = setof(x 
				(axlDBGetAttachedText ph) 
				((x->layer) == text_layer)
			    )) 
			when((length(text_dbid_list) > 1) 
			    printf("Warning: More than text attached to placeholder at % on layer  %L. Considering first element only.\n" ph_location text_layer) 
			    (axlDeleteObject 
				cdr(text_dbid_list)
			    ) 
			    (axlDBRefreshId nil)
			) 
			(cur_text_dbid = car(text_dbid_list)) 
			if(cur_text_dbid then 
			    if((new_value != "") then 
				(axlDBChangeText cur_text_dbid new_value) else 
				(axlDeleteObject cur_text_dbid)
			    ) else 
			    when(((new_value != "") && (axlIsLayer text_layer)) 
				(text_orient = (make_axlTextOrientation ?textBlock 
					(ph_param->textBlock) ?rotation 
					(ph_param->rotation)
					?mirrored 
					(ph_param->mirror) ?justify 
					(ph_param->justify)
				    )) 
				(axlDBCreateText new_value ph_location text_orient text_layer
				    ph
				)
			    )
			)
		    )
		)
	    )
	)
	(axlDBRefreshId nil) t
    )
)
procedure(TBX_CUSTOMVAR_Valid_Placeholder_Layer(layer_name) 
    let((ok_layer arr) 
	(ok_layer = t) 
	(arr = parseString(upperCase(layer_name) "/")) 
	cond(((upperCase(layer_name) == upperCase(((tbx_customvar_global->sysDefaults)->layer))) 
		(ok_layer = nil)
	    ) 
	    ((((axlMapClassName 
			    car(arr) t
			) == "DRAWING FORMAT") && rexMatchp("^CXT_" 
			cadr(arr)
		    )) 
		(ok_layer = nil)
	    )
	) 
	unless(ok_layer 
	    (axlUIConfirm 
		sprintf(nil "%s is a reserved layer and should not be used for placeholder definitions" layer_name) 
		'warn
	    )
	)
	ok_layer
    )
)
procedure(TBX_CUTOMVAR_MIG_Process(design_type ph_list) 
    let((tmpMap var_name var_suffix var_subname cur_text_info
	    cur_param ph_param ph_location subname_arr var_name_key
	    ph_entity layer_name display_value txt2change text_orient
	    arr msg cur_layer cur_value cxt_layer
	    layerMap lyr_prm
	) 
	(tmpMap = makeTable("layer_map_data" nil)) 
	foreach(ph ph_list 
	    (var_name = nil) 
	    (var_subname = nil) 
	    when(((ph->prop)->FLW_CUSTOMVAR_NAME) 
		(var_name = upperCase(((ph->prop)->FLW_CUSTOMVAR_NAME)))
	    )
	    when(((ph->prop)->FLW_CUSTOMVAR_SUBNAME) 
		(var_subname = upperCase(((ph->prop)->FLW_CUSTOMVAR_SUBNAME))) 
		when((var_subname == "ALL") 
		    (var_subname = "BASE")
		)
	    ) 
	    unless(var_subname 
		(var_subname = "BASE")
	    ) 
	    (cur_text_info = nil) 
	    (cur_param = nil) 
	    (ph_param = ncons(nil))
	    (ph_location = (car((ph->segments))->xy)) 
	    (ph_param->name = var_name) 
	    (ph_param->histLevel = "0") 
	    (subname_arr = parseString(var_subname "|")) 
	    if(((ph_param->type) == "G") then 
		(subname_arr = remove("BASE" subname_arr)) 
		(subname_arr = remove("ALL" subname_arr)) else
		when(member("ALL" subname_arr) 
		    (subname_arr = remove("BASE" subname_arr)) 
		    (subname_arr = remove("ALL" subname_arr)) 
		    (subname_arr = cons("BASE" subname_arr))
		)
	    )
	    cond((member(var_name 
			((tbx_customvar_migrate->phNameList)->group)
		    ) 
		    (ph_param->type = "G") 
		    foreach(sn subname_arr 
			unless(member(sn 
				(tbx_customvar_migrate->groupSuffixes)
			    ) 
			    (tbx_customvar_migrate->groupSuffixes = cons(sn 
				    (tbx_customvar_migrate->groupSuffixes)
				))
			)
		    )
		) 
		(member(var_name 
			((tbx_customvar_migrate->phNameList)->context)
		    ) 
		    (ph_param->type = "C") 
		    foreach(sn subname_arr 
			unless(member(sn 
				(tbx_customvar_migrate->contextNames)
			    ) 
			    (tbx_customvar_migrate->contextNames = cons(sn 
				    (tbx_customvar_migrate->contextNames)
				))
			)
		    )
		) 
		(t 
		    (ph_param->type = "S")
		)
	    ) 
	    (var_name_key = strcat((ph_param->name) "_" 
		    car(subname_arr)
		)) 
	    if((tbx_customvar_migrate->textParam)[var_name_key] then 
		(cur_param = copy((tbx_customvar_migrate->textParam)[var_name_key])) else 
		(cur_param = copy((tbx_customvar_migrate->textParam)["TBX_DEFAULT"]))
	    ) 
	    (ph_param->layer = (cur_param->layer)) 
	    (ph_param->textBlock = (cur_param->textBlock))
	    (ph_param->rotation = (cur_param->rotation)) 
	    (ph_param->justify = (cur_param->justify)) 
	    (ph_param->mirror = (cur_param->mirror)) 
	    when(((ph_param->type) == "G") 
		(tmpMap[strcat((ph_param->name) "|" 
			car(subname_arr)
		    )] = (cur_param->layer))
	    ) 
	    (ph_param->displayValue = (ph_param->name))
	    if((design_type == "SYMBOL") then 
		(cur_value = strcat("<" 
			(ph_param->name) ">"
		    )) 
		(cur_layer = (ph_param->layer)) 
		(cur_text_info = cons(list(cur_layer cur_value) cur_text_info))
		else 
		foreach(sn 
		    parseString(var_subname "|") 
		    (var_name_key = strcat((ph_param->name) "_" sn)) 
		    if((tbx_customvar_migrate->varInfo)[var_name_key] then 
			(cur_value = caddr((tbx_customvar_migrate->varInfo)[var_name_key])) else 
			(cur_value = "")
		    ) 
		    if((((ph_param->type) == "C") && (sn != "BASE") && (sn != "ALL")) then 
			(cxt_layer = strcat((axlMapClassName "DRAWING FORMAT") "/CXT_" sn)) 
			unless((axlIsLayer cxt_layer) 
			    printf("Info: Creating layer %L  for context %L\n" cxt_layer sn) 
			    (axlLayerCreateNonConductor cxt_layer) 
			    (lyr_prm = (axlLayerGet cxt_layer)) 
			    (lyr_prm->color = 33)
			    (axlLayerSet lyr_prm)
			) 
			(cur_layer = cxt_layer)
			else 
			(cur_layer = (ph_param->layer))
		    )
		    (cur_text_info = cons(list(cur_layer cur_value) cur_text_info))
		)
	    ) 
	    (axlDeleteObject ph) 
	    (ph_entity = TBX_CUSTOMVAR_PLACE_Create_Placeholder(ph_location ph_param)) 
	    when(ph_entity 
		foreach(entry cur_text_info 
		    (layer_name = car(entry)) 
		    (display_value = cadr(entry)) 
		    (display_value = (axlStringRemoveSpaces display_value))
		    rexCompile("^<[Nn][Uu][Ll][Ll]>$") 
		    (display_value = rexReplace(display_value "" 0)) 
		    (txt2change = car(setof(x 
				(axlDBGetAttachedText ph_entity) 
				((x->layer) == layer_name)
			    )
			)) 
		    cond(((txt2change && (display_value != "")) 
			    (axlDBChangeText txt2change display_value)
			) 
			((txt2change && (display_value == "")) 
			    (axlDeleteObject txt2change)
			) 
			((display_value != "") 
			    (text_orient = (make_axlTextOrientation ?textBlock 
				    (ph_param->textBlock) ?rotation 
				    (ph_param->rotation)
				    ?mirrored 
				    (ph_param->mirror) ?justify 
				    (ph_param->justify)
				)) 
			    (axlDBCreateText display_value ph_location text_orient layer_name
				ph_entity
			    )
			)
		    )
		)
	    )
	) 
	(msg = "") 
	(msg = strcat(msg "Please check your placeholders in terms of attributes such as display layer, block number, justification etc. "))
	(msg = strcat(msg "Variables and their values are now stored in file ./customvar.cfg in the local working directory.")) 
	(axlUIConfirm msg) 
	when((design_type == "LAYOUT") 
	    (layerMap = makeTable("layer_map_table" nil)) 
	    foreach(key tmpMap 
		(arr = parseString(key)) 
		(var_name = car(arr)) 
		(var_suffix = cadr(arr))
		(layer_name = tmpMap[key]) 
		(layerMap[var_name] = cons(list(var_suffix layer_name) 
			layerMap[var_name]
		    ))
	    ) 
	    TBX_CUSTOMVAR_Save_Layer_Map(layerMap nil)
	) t
    )
)
procedure(TBX_DBCORE_Change_Rpath_Units(rpath from_units to_units) 
    let((seg_list rpath_new pt pt_x pt_y
	    width arc_center arc_center_x arc_center_y clockwise
	) 
	(seg_list = (axlPathGetPathSegs rpath)) 
	(pt = (axlPathSegGetEndPoint 
		car(seg_list)
	    )) 
	(pt_x = (axlMKSConvert 
		car(pt) from_units to_units
	    )) 
	(pt_y = (axlMKSConvert 
		cadr(pt) from_units to_units
	    ))
	(rpath_new = (axlPathStart 
		list((pt_x:pt_y)) 0.0
	    )) 
	foreach(rp 
	    cdr(seg_list) 
	    (width = (axlPathSegGetWidth rp)) 
	    (pt = (axlPathSegGetEndPoint rp)) 
	    (pt_x = (axlMKSConvert 
		    car(pt) from_units to_units
		))
	    (pt_y = (axlMKSConvert 
		    cadr(pt) from_units to_units
		)) 
	    (arc_center = (axlPathSegGetArcCenter rp)) 
	    if(arc_center then 
		(arc_center_x = (axlMKSConvert 
			car(arc_center) from_units to_units
		    )) 
		(arc_center_y = (axlMKSConvert 
			cadr(arc_center) from_units to_units
		    )) 
		(clockwise = (axlPathSegGetArcClockwise rp))
		(rpath_new = (axlPathArcCenter rpath_new width 
			(pt_x:pt_y) clockwise
			(arc_center_x:arc_center_y)
		    )) else 
		(rpath_new = (axlPathLine rpath_new width 
			(pt_x:pt_y)
		    ))
	    )
	) rpath_new
    )
)
procedure(TBX_DBCORE_Copy_Rpath(rp new_width split) 
    let((seg_list pt_start pt_end pt_center clockwise
	    rpath_c path_list
	) 
	unless(new_width 
	    (new_width = 0.0)
	) 
	(seg_list = (axlPathGetPathSegs rp)) 
	(pt_start = (axlPathSegGetEndPoint 
		car(seg_list)
	    )) 
	(rpath_c = (axlPathStart 
		list(pt_start) 0.0
	    ))
	foreach(seg 
	    cdr(seg_list) 
	    (pt_center = (axlPathSegGetArcCenter seg)) 
	    (pt_end = (axlPathSegGetEndPoint seg)) 
	    if(pt_center then 
		(clockwise = (axlPathSegGetArcClockwise seg)) 
		(rpath_c = (axlPathArcCenter rpath_c new_width pt_end clockwise
			pt_center
		    )) else
		(rpath_c = (axlPathLine rpath_c new_width pt_end))
	    )
	    when(split 
		(path_list = cons(rpath_c path_list)) 
		(rpath_c = (axlPathStart 
			list(pt_end) 0.0
		    ))
	    )
	) 
	if(split then 
	    (path_list = reverse(path_list)) else 
	    (path_list = list(rpath_c))
	) path_list
    )
)
procedure((TBX_DBCORE_Is_Poly_Clockwise arg \@optional debug_layer) 
    let((rpath first_seg last_seg rseg_list pt_list
	    pt_arr pt_list_tmp start_xy end_xy arc_center
	    arc_cw arc_is_circle arc_points vec_a vec_b
	    size_a size_b cur_result signed_area cw_orientation
	    markPoints
	) 
	(markPoints = lambda((pts lyr) 
		let((txt_orient id) 
		    (txt_orient = (make_axlTextOrientation ?textBlock "1" ?rotation 0.0
			    ?mirrored nil ?justify "left"
			)) 
		    (id = 0) 
		    (pts = reverse(cdr(reverse(pts)))) 
		    foreach(pt pts 
			(axlDBCreateText 
			    sprintf(nil "%d" 
				++id
			    ) pt txt_orient lyr
			    nil
			)
		    )
		    t
		)
	    )) 
	cond(((((arg->objType) == "shape") || ((arg->objType) == "polygon")) 
		(rpath = (axlDB2Path arg))
	    ) 
	    ((axlIsPolyType arg) 
		(rpath = TBX_DBCORE_Rpath_From_Poly(arg ?compactArc t))
	    ) 
	    ((arg->_pathList) 
		(first_seg = car((axlPathGetPathSegs arg))) 
		(last_seg = (axlPathGetLastPathSeg arg)) 
		if(((axlGeo2Str 
			    (axlPathSegGetEndPoint first_seg)
			) == (axlGeo2Str 
			    (axlPathSegGetEndPoint last_seg)
			)) then 
		    (rpath = arg) else 
		    printf("Warning: Argument %L does not represent a closed polygon.\n" arg)
		)
	    )
	) 
	when(rpath 
	    (rseg_list = (axlPathGetPathSegs rpath)) 
	    (pt_list = tconc(nil nil)) 
	    foreach(rs rseg_list 
		(end_xy = (axlPathSegGetEndPoint rs)) 
		(arc_center = (axlPathSegGetArcCenter rs)) 
		(arc_cw = (axlPathSegGetArcClockwise rs))
		if(arc_center then 
		    (arc_is_circle = nil) 
		    when(((axlGeo2Str end_xy) == 
			    (axlGeo2Str start_xy)) 
			(arc_is_circle = t)
		    ) 
		    (arc_points = TBX_GEOM_Vectorize_Arc(start_xy end_xy arc_center arc_cw arc_is_circle
			    8
			))
		    lconc(pt_list 
			cdr(arc_points)
		    ) else 
		    tconc(pt_list end_xy)
		) 
		(start_xy = end_xy)
	    ) 
	    (pt_list = cdar(pt_list))
	    when((debug_layer && (axlIsLayer debug_layer)) 
		(axlDBCreatePath rpath debug_layer) 
		funcall(markPoints pt_list debug_layer)
	    ) 
	    (pt_list_tmp = copy(pt_list)) 
	    (pt_list_tmp = cons(cadr(reverse(pt_list)) pt_list_tmp)) 
	    (pt_arr = listToVector(pt_list_tmp)) 
	    (signed_area = 0)
	    for(i 1 
		(length(pt_arr) - 2) 
		(vec_a = TBX_MATH_Get_Vector(pt_arr[i] 
			pt_arr[(i + 1)]
		    )) 
		(vec_b = TBX_MATH_Get_Vector(pt_arr[i] 
			pt_arr[(i - 1)]
		    ))
		(size_a = TBX_MATH_Get_Vector_Size(vec_a)) 
		(size_b = TBX_MATH_Get_Vector_Size(vec_b)) 
		when(((size_a * size_b) != 0.0) 
		    (cur_result = (((car(vec_a) * cadr(vec_b)) - (cadr(vec_a) * car(vec_b))) / (size_a * size_b))) 
		    (signed_area = (signed_area + cur_result))
		)
	    )
	) 
	cond(((signed_area > 0) 
		(cw_orientation = nil)
	    ) 
	    ((signed_area < 0) 
		(cw_orientation = t)
	    )
	)
	cw_orientation
    )
)
procedure(TBX_DBCORE_Poly_From_Box(box) 
    let((rpath xy_ll xy_ur poly) 
	(xy_ll = car(box)) 
	(xy_ur = cadr(box)) 
	(rpath = (axlPathStart 
		list(xy_ll 
		    (car(xy_ur):cadr(xy_ll)) xy_ur 
		    (car(xy_ll):cadr(xy_ur)) xy_ll
		) 0.0
	    )) 
	(poly = car((axlPolyFromDB rpath)))
	poly
    )
)
procedure(TBX_DBCORE_Poly_From_Drill(pad_inst) 
    let((pad_def circle_path hole_data dx dy
	    x_pad y_pad x y newpt
	    row_cnt col_cnt spacing_x spacing_y stagger
	    stagger_offset diam xll yll tmp_list
	    c12 c34 p1 p2 p3
	    p4 slot_height slot_width h w
	    center_list point_list slot_path cw
	) 
	(pad_def = (pad_inst->definition)) 
	(hole_data = list()) 
	(center_list = list()) 
	(point_list = list())
	(tmp_list = list()) 
	when(((pad_def->drillDiameter) > 0.0) 
	    cond((((lowerCase((pad_def->holeType)) == "circle_drill") && !(pad_def->multiDrillData)) 
		    (x_pad = car((pad_inst->xy))) 
		    (y_pad = cadr((pad_inst->xy))) 
		    (dx = car((pad_def->drillOffset))) 
		    (dy = cadr((pad_def->drillOffset)))
		    (newpt = list((x_pad + dx) 
			    (y_pad + dy)
			)) 
		    when((pad_inst->isMirrored) 
			(newpt = (axlGeoRotatePt 0.0 newpt 
				(x_pad:y_pad) t
			    ))
		    ) 
		    when(((pad_inst->rotation) != 0.0) 
			(newpt = (axlGeoRotatePt 
				(pad_inst->rotation) newpt 
				(x_pad:y_pad)
			    ))
		    ) 
		    (circle_path = (axlPathStartCircle 
			    list(newpt 
				((pad_def->drillDiameter) / 2.0)
			    ) 0
			)) 
		    (hole_data = cons(car((axlPolyFromDB circle_path)) hole_data))
		) 
		(((lowerCase((pad_def->holeType)) == "circle_drill") && (pad_def->multiDrillData)) 
		    (x_pad = car((pad_inst->xy))) 
		    (y_pad = cadr((pad_inst->xy))) 
		    (dx = car((pad_def->drillOffset))) 
		    (dy = cadr((pad_def->drillOffset)))
		    (diam = ((pad_def->drillDiameter) / 1.0)) 
		    (row_cnt = car((pad_def->multiDrillData))) 
		    (col_cnt = cadr((pad_def->multiDrillData))) 
		    (spacing_x = caddr((pad_def->multiDrillData))) 
		    (spacing_y = cadddr((pad_def->multiDrillData)))
		    (stagger = nth(4 
			    (pad_def->multiDrillData)
			)) 
		    (xll = ((((col_cnt - 1) / 2.0) * (spacing_x + diam) * -1) + x_pad + dx)) 
		    (yll = ((((row_cnt - 1) / 2.0) * (spacing_y + diam) * -1) + y_pad + dy)) 
		    if(stagger then 
			(stagger_offset = ((spacing_x / 2.0) + (diam / 2.0))) else 
			(stagger_offset = 0.0)
		    ) 
		    for(r 1 row_cnt 
			for(c 1 col_cnt 
			    if(zerop(mod(r 2)) then 
				(x = (xll + ((c - 1) * (spacing_x + diam)) + stagger_offset)) else 
				(x = (xll + ((c - 1) * (spacing_x + diam))))
			    ) 
			    (y = (yll + ((r - 1) * (spacing_y + diam))))
			    (tmp_list = cons((x:y) tmp_list))
			)
		    )
		    foreach(xy tmp_list 
			(newpt = xy) 
			when((pad_inst->isMirrored) 
			    (newpt = (axlGeoRotatePt 0.0 newpt 
				    (x_pad:y_pad) t
				))
			) 
			when(((pad_inst->rotation) != 0.0) 
			    (newpt = (axlGeoRotatePt 
				    (pad_inst->rotation) newpt 
				    (x_pad:y_pad)
				))
			)
			(center_list = cons(newpt center_list))
		    ) 
		    (center_list = reverse(center_list)) 
		    foreach(xy center_list 
			(hole_data = cons(car((axlPolyFromDB 
					(axlPathStartCircle 
					    list(xy 
						(diam / 2.0)
					    ) 0
					)
				    )
				) hole_data
			    ))
		    )
		) 
		(((lowerCase((pad_def->holeType)) == "oval_slot") || (lowerCase((pad_def->holeType)) == "rectangle_slot")) 
		    (x_pad = car((pad_inst->xy))) 
		    (y_pad = cadr((pad_inst->xy))) 
		    (dx = car((pad_def->drillOffset))) 
		    (dy = cadr((pad_def->drillOffset)))
		    (slot_width = (pad_def->drillFigureWidth)) 
		    (slot_height = (pad_def->drillFigureHeight)) 
		    (x = (x_pad + dx)) 
		    (y = (y_pad + dy)) 
		    if((slot_width != slot_height) then 
			(w = (slot_width / 2.0)) 
			(h = (slot_height / 2.0)) 
			if((slot_width > slot_height) then 
			    when((lowerCase((pad_def->holeType)) == "oval_slot") 
				(w = ((slot_width - slot_height) / 2.0))
			    ) 
			    (c12 = list(((- w) + x) 
				    (0.0 + y)
				)) 
			    (c34 = list((w + x) 
				    (0.0 + y)
				))
			    (p1 = list(((- w) + x) 
				    (h + y)
				)) 
			    (p2 = list(((- w) + x) 
				    ((- h) + y)
				)) 
			    (p3 = list((w + x) 
				    ((- h) + y)
				)) 
			    (p4 = list((w + x) 
				    (h + y)
				)) else
			    when((lowerCase((pad_def->holeType)) == "oval_slot") 
				(h = ((slot_height - slot_width) / 2.0))
			    ) 
			    (c12 = list((0.0 + x) 
				    ((- h) + y)
				)) 
			    (c34 = list((0.0 + x) 
				    (h + y)
				)) 
			    (p1 = list(((- w) + x) 
				    ((- h) + y)
				)) 
			    (p2 = list((w + x) 
				    ((- h) + y)
				))
			    (p3 = list((w + x) 
				    (h + y)
				)) 
			    (p4 = list(((- w) + x) 
				    (h + y)
				))
			)
			(point_list = list()) 
			foreach(xy 
			    list(c12 c34 p1 p2 p3
				p4
			    ) 
			    (newpt = xy) 
			    if((pad_inst->isMirrored) then 
				(cw = t) 
				(newpt = (axlGeoRotatePt 0.0 newpt 
					(x_pad:y_pad) t
				    )) else
				(cw = nil)
			    ) 
			    when(((pad_inst->rotation) != 0.0) 
				(newpt = (axlGeoRotatePt 
					(pad_inst->rotation) newpt 
					(x_pad:y_pad)
				    ))
			    )
			    (point_list = cons(newpt point_list))
			) 
			(point_list = reverse(point_list)) 
			(c12 = car(point_list)) 
			(c34 = cadr(point_list))
			(p1 = caddr(point_list)) 
			(p2 = nth(3 point_list)) 
			(p3 = nth(4 point_list)) 
			(p4 = nth(5 point_list)) 
			if((lowerCase((pad_def->holeType)) == "oval_slot") then 
			    (slot_path = (axlPathStart 
				    list(p1) 0.0
				)) 
			    (slot_path = (axlPathArcCenter slot_path 0.0 p2 cw
				    c12
				)) 
			    (slot_path = (axlPathLine slot_path 0.0 p3))
			    (slot_path = (axlPathArcCenter slot_path 0.0 p4 cw
				    c34
				)) 
			    (slot_path = (axlPathLine slot_path 0.0 p1)) else 
			    (slot_path = (axlPathStart 
				    list(p1 p2 p3 p4 p1) 0.0
				))
			)
			(hole_data = cons(car((axlPolyFromDB slot_path)) hole_data)) else 
			(newpt = (x:y)) 
			when((pad_inst->isMirrored) 
			    (newpt = (axlGeoRotatePt 0.0 newpt 
				    (x_pad:y_pad) t
				))
			) 
			when(((pad_inst->rotation) != 0.0) 
			    (newpt = (axlGeoRotatePt 
				    (pad_inst->rotation) newpt 
				    (x_pad:y_pad)
				))
			)
			(circle_path = (axlPathStartCircle 
				list(newpt 
				    ((pad_def->drillDiameter) / 2.0)
				) 0
			    )) 
			(hole_data = cons(car((axlPolyFromDB circle_path)) hole_data))
		    )
		) 
		(t 
		    printf("Do nothing with unknown hole type\n")
		)
	    )
	) hole_data
    )
)
procedure(TBX_DBCORE_Poly_From_Figure(fg) 
    let((x_offset y_offset pt1 pt2 pt3
	    pt4 pt5 pt6 pt7 pt8
	    pt9 rpath PI angle_rad half_width
	    half_height fg_x fg_y radius corners
	    trim_size figure_poly ret_data pt_left pt_bot
	    pt_right pt_top pt_ll pt_lr pt_ur
	    pt_ul pt_ll_a pt_ll_b pt_lr_a pt_lr_b
	    pt_ur_a pt_ur_b pt_ul_a pt_ul_b outer_poly
	    hole_poly
	) 
	(PI = (defMathConstants('mymathconst)->PI)) 
	cond(((((fg->figureName) == "RECTANGLE") || ((fg->figureName) == "SQUARE") || ((fg->figureName) == "NULL")) 
		(fg_x = car((fg->xy))) 
		(fg_y = cadr((fg->xy))) 
		(half_width = ((fg->width) / 2.0)) 
		(half_height = ((fg->height) / 2.0))
		(pt1 = ((fg_x + half_width):(fg_y - half_height))) 
		(pt2 = ((fg_x + half_width):(fg_y + half_height))) 
		(pt3 = ((fg_x - half_width):(fg_y + half_height))) 
		(pt4 = ((fg_x - half_width):(fg_y - half_height))) 
		(rpath = (axlPathStart 
			list(pt1 pt2 pt3 pt4 pt1) 0.0
		    ))
	    ) 
	    (((fg->figureName) == "CIRCLE") 
		(radius = (max((fg->height) 
			    (fg->width)
			) / 2.0)) 
		(rpath = (axlPathStartCircle 
			list((fg->xy) radius) 0.0
		    ))
	    ) 
	    ((((fg->figureName) == "OBLONG_X") || ((fg->figureName) == "OBLONG_Y")) 
		(fg_x = car((fg->xy))) 
		(fg_y = cadr((fg->xy))) 
		if(((fg->width) > (fg->height)) then 
		    (x_offset = (((fg->width) - (fg->height)) / 2.0)) 
		    (y_offset = ((fg->height) / 2.0)) 
		    (pt1 = ((fg_x - x_offset):(fg_y - y_offset)))
		    (pt2 = ((fg_x + x_offset):(fg_y - y_offset))) 
		    (pt3 = ((fg_x + x_offset):(fg_y + y_offset))) 
		    (pt4 = ((fg_x - x_offset):(fg_y + y_offset))) 
		    (rpath = (axlPathStart 
			    list(pt1 pt2) 0.0
			)) 
		    (rpath = (axlPathArcAngle rpath 0.0 pt3 nil
			    180.0
			))
		    (rpath = (axlPathLine rpath 0.0 pt4)) 
		    (rpath = (axlPathArcAngle rpath 0.0 pt1 nil
			    180.0
			)) else 
		    (x_offset = ((fg->width) / 2.0)) 
		    (y_offset = (((fg->height) - (fg->width)) / 2.0))
		    (pt1 = ((fg_x - x_offset):(fg_y - y_offset))) 
		    (pt2 = ((fg_x + x_offset):(fg_y - y_offset))) 
		    (pt3 = ((fg_x + x_offset):(fg_y + y_offset))) 
		    (pt4 = ((fg_x - x_offset):(fg_y + y_offset))) 
		    (rpath = (axlPathStart 
			    list(pt1) 0.0
			))
		    (rpath = (axlPathArcAngle rpath 0.0 pt2 nil
			    180.0
			)) 
		    (rpath = (axlPathLine rpath 0.0 pt3)) 
		    (rpath = (axlPathArcAngle rpath 0.0 pt4 nil
			    180.0
			)) 
		    (rpath = (axlPathLine rpath 0.0 pt1))
		)
	    ) 
	    ((((fg->figureName) == "TRIANGLE") || ((fg->figureName) == "TRIANGLE_1")) 
		(fg_x = car((fg->xy))) 
		(fg_y = cadr((fg->xy))) 
		(half_width = ((fg->width) / 2.0)) 
		(half_height = ((fg->height) / 2.0))
		(pt1 = ((fg_x - half_width):(fg_y - ((fg->height) / 4.0)))) 
		(pt2 = ((fg_x + half_width):(fg_y - ((fg->height) / 4.0)))) 
		(pt3 = (fg_x:(fg_y + half_height))) 
		(rpath = (axlPathStart 
			list(pt1 pt2 pt3 pt1) 0.0
		    ))
	    ) 
	    (((fg->figureName) == "DIAMOND") 
		(fg_x = car((fg->xy))) 
		(fg_y = cadr((fg->xy))) 
		(half_width = ((fg->width) / 2.0)) 
		(half_height = ((fg->height) / 2.0))
		(pt1 = ((fg_x - half_width):fg_y)) 
		(pt2 = (fg_x:(fg_y - half_height))) 
		(pt3 = ((fg_x + half_width):fg_y)) 
		(pt4 = (fg_x:(fg_y + half_height))) 
		(rpath = (axlPathStart 
			list(pt1 pt2 pt3 pt4 pt1) 0.0
		    ))
	    )
	    (((fg->figureName) == "OCTAGON") 
		(fg_x = car((fg->xy))) 
		(fg_y = cadr((fg->xy))) 
		(half_width = ((fg->width) / 2.0)) 
		(half_height = ((fg->height) / 2.0))
		(angle_rad = ((2 * PI * 22.5) / 360.0)) 
		(y_offset = ((tan(angle_rad) * (fg->height)) / 2.0)) 
		(x_offset = ((tan(angle_rad) * (fg->width)) / 2.0)) 
		(pt1 = ((fg_x + half_width):fg_y)) 
		(pt2 = ((fg_x + half_width):(fg_y + y_offset)))
		(pt3 = ((fg_x + x_offset):(fg_y + half_height))) 
		(pt4 = ((fg_x - x_offset):(fg_y + half_height))) 
		(pt5 = ((fg_x - half_width):(fg_y + y_offset))) 
		(pt6 = ((fg_x - half_width):(fg_y - y_offset))) 
		(pt7 = ((fg_x - x_offset):(fg_y - half_height)))
		(pt8 = ((fg_x + x_offset):(fg_y - half_height))) 
		(pt9 = ((fg_x + half_width):(fg_y - y_offset))) 
		(rpath = (axlPathStart 
			list(pt1 pt2 pt3 pt4 pt5
			    pt6 pt7 pt8 pt9 pt1
			) 0.0
		    ))
	    ) 
	    (((fg->figureName) == "HEXAGON_Y") 
		(fg_x = car((fg->xy))) 
		(fg_y = cadr((fg->xy))) 
		(half_height = ((fg->height) / 2.0)) 
		(half_width = ((fg->width) / 2.0))
		(angle_rad = ((2 * PI * 30.0) / 360.0)) 
		(x_offset = (cos(angle_rad) * half_width)) 
		(y_offset = ((fg->height) / 4.0)) 
		(pt1 = ((fg_x + x_offset):fg_y)) 
		(pt2 = ((fg_x + x_offset):(fg_y + y_offset)))
		(pt3 = (fg_x:(fg_y + half_height))) 
		(pt4 = ((fg_x - x_offset):(fg_y + y_offset))) 
		(pt5 = ((fg_x - x_offset):(fg_y - y_offset))) 
		(pt6 = (fg_x:(fg_y - half_height))) 
		(pt7 = ((fg_x + x_offset):(fg_y - y_offset)))
		(rpath = (axlPathStart 
			list(pt1 pt2 pt3 pt4 pt5
			    pt6 pt7 pt1
			) 0.0
		    ))
	    ) 
	    (((fg->figureName) == "HEXAGON_X") 
		(fg_x = car((fg->xy))) 
		(fg_y = cadr((fg->xy))) 
		(half_width = ((fg->width) / 2.0)) 
		(half_height = ((fg->height) / 2.0))
		(angle_rad = ((2 * PI * 30.0) / 360.0)) 
		(y_offset = (cos(angle_rad) * half_height)) 
		(x_offset = ((fg->width) / 4.0)) 
		(pt1 = ((fg_x + half_width):fg_y)) 
		(pt2 = ((fg_x + x_offset):(fg_y + y_offset)))
		(pt3 = ((fg_x - x_offset):(fg_y + y_offset))) 
		(pt4 = ((fg_x - half_width):fg_y)) 
		(pt5 = ((fg_x - x_offset):(fg_y - y_offset))) 
		(pt6 = ((fg_x + x_offset):(fg_y - y_offset))) 
		(rpath = (axlPathStart 
			list(pt1 pt2 pt3 pt4 pt5
			    pt6 pt1
			) 0.0
		    ))
	    ) 
	    (((fg->figureName) == "ROUNDED_RECTANGLE") 
		(fg_x = car((fg->xy))) 
		(fg_y = cadr((fg->xy))) 
		(half_width = ((fg->width) / 2.0)) 
		(half_height = ((fg->height) / 2.0))
		(y_offset = (half_height - (fg->radius))) 
		(x_offset = (half_width - (fg->radius))) 
		(corners = parseString((fg->corners) "-")) 
		(pt_left = ((fg_x - half_width):fg_y)) 
		(pt_bot = (fg_x:(fg_y - half_height)))
		(pt_right = ((fg_x + half_width):fg_y)) 
		(pt_top = (fg_x:(fg_y + half_height))) 
		(pt_ll = ((fg_x - half_width):(fg_y - half_height))) 
		(pt_lr = ((fg_x + half_width):(fg_y - half_height))) 
		(pt_ur = ((fg_x + half_width):(fg_y + half_height)))
		(pt_ul = ((fg_x - half_width):(fg_y + half_height))) 
		(pt_ll_a = ((fg_x - half_width):(fg_y - y_offset))) 
		(pt_ll_b = ((fg_x - x_offset):(fg_y - half_height))) 
		(pt_lr_a = ((fg_x - x_offset):(fg_y - half_height))) 
		(pt_lr_b = ((fg_x + half_width):(fg_y - y_offset)))
		(pt_ur_a = ((fg_x + half_width):(fg_y + y_offset))) 
		(pt_ur_b = ((fg_x + x_offset):(fg_y + half_height))) 
		(pt_ul_a = ((fg_x - x_offset):(fg_y + half_height))) 
		(pt_ul_b = ((fg_x - half_width):(fg_y + y_offset))) 
		(rpath = (axlPathStart 
			list(pt_left) 0.0
		    ))
		if(member("LL" corners) then 
		    when((y_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_ll_a))
		    ) 
		    (rpath = (axlPathArcAngle rpath 0.0 pt_ll_b nil
			    90.0
			)) 
		    when((x_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_bot))
		    )
		    else 
		    (rpath = (axlPathLine rpath 0.0 pt_ll)) 
		    (rpath = (axlPathLine rpath 0.0 pt_bot))
		) 
		if(member("LR" corners) then 
		    when((x_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_lr_a))
		    ) 
		    (rpath = (axlPathArcAngle rpath 0.0 pt_lr_b nil
			    90.0
			)) 
		    when((y_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_right))
		    )
		    else 
		    (rpath = (axlPathLine rpath 0.0 pt_lr)) 
		    (rpath = (axlPathLine rpath 0.0 pt_right))
		) 
		if(member("UR" corners) then 
		    when((y_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_ur_a))
		    ) 
		    (rpath = (axlPathArcAngle rpath 0.0 pt_ur_b nil
			    90.0
			)) 
		    when((x_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_top))
		    )
		    else 
		    (rpath = (axlPathLine rpath 0.0 pt_ur)) 
		    (rpath = (axlPathLine rpath 0.0 pt_top))
		) 
		if(member("UL" corners) then 
		    when((x_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_ul_a))
		    ) 
		    (rpath = (axlPathArcAngle rpath 0.0 pt_ul_b nil
			    90.0
			)) 
		    when((y_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_left))
		    )
		    else 
		    (rpath = (axlPathLine rpath 0.0 pt_ul)) 
		    (rpath = (axlPathLine rpath 0.0 pt_left))
		)
	    ) 
	    (((fg->figureName) == "CHAMFERED_RECTANGLE") 
		(fg_x = car((fg->xy))) 
		(fg_y = cadr((fg->xy))) 
		(half_width = ((fg->width) / 2.0)) 
		(half_height = ((fg->height) / 2.0))
		(trim_size = (fg->radius)) 
		(y_offset = (half_height - trim_size)) 
		(x_offset = (half_width - trim_size)) 
		(corners = parseString((fg->corners) "-")) 
		(corners = parseString((fg->corners) "-"))
		(pt_left = ((fg_x - half_width):fg_y)) 
		(pt_bot = (fg_x:(fg_y - half_height))) 
		(pt_right = ((fg_x + half_width):fg_y)) 
		(pt_top = (fg_x:(fg_y + half_height))) 
		(pt_ll = ((fg_x - half_width):(fg_y - half_height)))
		(pt_lr = ((fg_x + half_width):(fg_y - half_height))) 
		(pt_ur = ((fg_x + half_width):(fg_y + half_height))) 
		(pt_ul = ((fg_x - half_width):(fg_y + half_height))) 
		(pt_ll_a = ((fg_x - half_width):(fg_y - y_offset))) 
		(pt_ll_b = ((fg_x - x_offset):(fg_y - half_height)))
		(pt_lr_a = ((fg_x - x_offset):(fg_y - half_height))) 
		(pt_lr_b = ((fg_x + half_width):(fg_y - y_offset))) 
		(pt_ur_a = ((fg_x + half_width):(fg_y + y_offset))) 
		(pt_ur_b = ((fg_x + x_offset):(fg_y + half_height))) 
		(pt_ul_a = ((fg_x - x_offset):(fg_y + half_height)))
		(pt_ul_b = ((fg_x - half_width):(fg_y + y_offset))) 
		(rpath = (axlPathStart 
			list(pt_left) 0.0
		    )) 
		if(member("LL" corners) then 
		    when((y_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_ll_a))
		    ) 
		    (rpath = (axlPathLine rpath 0.0 pt_ll_b)) 
		    when((x_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_bot))
		    )
		    else 
		    (rpath = (axlPathLine rpath 0.0 pt_ll)) 
		    (rpath = (axlPathLine rpath 0.0 pt_bot))
		) 
		if(member("LR" corners) then 
		    when((x_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_lr_a))
		    ) 
		    (rpath = (axlPathLine rpath 0.0 pt_lr_b)) 
		    when((y_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_right))
		    )
		    else 
		    (rpath = (axlPathLine rpath 0.0 pt_lr)) 
		    (rpath = (axlPathLine rpath 0.0 pt_right))
		) 
		if(member("UR" corners) then 
		    when((y_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_ur_a))
		    ) 
		    (rpath = (axlPathLine rpath 0.0 pt_ur_b)) 
		    when((x_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_top))
		    )
		    else 
		    (rpath = (axlPathLine rpath 0.0 pt_ur)) 
		    (rpath = (axlPathLine rpath 0.0 pt_top))
		)
		if(member("UL" corners) then 
		    when((x_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_ul_a))
		    ) 
		    (rpath = (axlPathLine rpath 0.0 pt_ul_b)) 
		    when((y_offset > 0.0) 
			(rpath = (axlPathLine rpath 0.0 pt_left))
		    )
		    else 
		    (rpath = (axlPathLine rpath 0.0 pt_ul)) 
		    (rpath = (axlPathLine rpath 0.0 pt_left))
		)
	    )
	    (((fg->figureName) == "DONUT") 
		(radius = (max((fg->height) 
			    (fg->width)
			) / 2.0)) 
		(rpath = (axlPathStartCircle 
			list((fg->xy) radius) 0.0
		    )) 
		(outer_poly = car((axlPolyFromDB rpath))) 
		(radius = ((fg->inside) / 2.0))
		(rpath = (axlPathStartCircle 
			list((fg->xy) radius) 0.0
		    )) 
		(hole_poly = car((axlPolyFromDB rpath))) 
		(figure_poly = car((axlPolyOperation outer_poly hole_poly 
			    'ANDNOT
			)
		    ))
	    ) 
	    (t 
		(rpath = nil) 
		printf("Warning: Poly from Figure, unsupported type: %L\n" 
		    (fg->figureName)
		)
	    )
	) 
	when((!figure_poly && rpath) 
	    when(((fg->rotation) != 0.0) 
		(rpath = TBX_DBCORE_Rotate_Rpath(rpath 
			(fg->rotation) 
			(fg->xy)
		    ))
	    ) 
	    (figure_poly = car((axlPolyFromDB rpath)))
	) 
	when(figure_poly 
	    (ret_data = list(figure_poly))
	)
	ret_data
    )
)
procedure(TBX_DBCORE_Poly_From_Line(segment_list merge_data endcap_type) 
    let((seg_poly_list poly_info zero_width_objects) 
	(seg_poly_list = list()) 
	(zero_width_objects = list()) 
	foreach(seg segment_list 
	    if(((seg->width) == 0.0) then 
		(zero_width_objects = cons(seg zero_width_objects)) else 
		foreach(p 
		    (axlPolyFromDB seg ?endCapType endcap_type) 
		    (seg_poly_list = cons(p seg_poly_list))
		)
	    )
	) 
	if(merge_data then 
	    if(onep(length(seg_poly_list)) then 
		(poly_info = seg_poly_list) else 
		(poly_info = (axlPolyOperation 
			cdr(seg_poly_list) 
			list(car(seg_poly_list)) 
			'OR
		    ))
	    ) else 
	    (poly_info = seg_poly_list)
	)
	poly_info
    )
)
procedure(TBX_DBCORE_Poly_From_Padstack(pad_inst) 
    let((class_name lay_id full_name poly_list pad_poly_data
	    final_poly_list
	) 
	(poly_list = list()) 
	case(upperCase((pad_inst->objType)) 
	    ("PIN" 
		(class_name = "PIN")
	    ) 
	    ("VIA" 
		(class_name = "VIA CLASS")
	    ) 
	    (t 
		printf("Warning: Invalid type: %s\n" 
		    (pad_inst->objType)
		)
	    )
	) 
	foreach(layer 
	    ((axlGetParam 
		    strcat("paramLayerGroup:" class_name)
		)->groupMembers) 
	    (full_name = strcat(class_name "/" layer)) 
	    (lay_id = (axlLayerGet full_name)) 
	    (pad_poly_data = (axlPolyFromDB pad_inst ?layer full_name ?padType
		    'REGULAR
		))
	    when((pad_poly_data && (lay_id->visible)) 
		(poly_list = cons(car(pad_poly_data) poly_list))
	    )
	) 
	(final_poly_list = (axlPolyOperation 
		cdr(poly_list) 
		list(car(poly_list)) 
		'OR
	    ))
	final_poly_list
    )
)
procedure((TBX_DBCORE_Poly_From_Shape shape_dbid include_voids \@optional embedded_voids) 
    let((poly_list void_list result poly_list_new) 
	(poly_list = tconc(nil nil)) 
	(void_list = tconc(nil nil)) 
	if(embedded_voids then 
	    if(include_voids then 
		if((shape_dbid->shapeAuto) then 
		    foreach(vd 
			(shape_dbid->voids) 
			lconc(void_list 
			    (axlPolyFromDB 
				(axlDB2Path vd)
			    )
			)
		    ) 
		    foreach(ashape 
			(shape_dbid->shapeAuto) 
			lconc(poly_list 
			    (axlPolyFromDB ashape)
			)
		    ) 
		    (poly_list = cdar(poly_list))
		    (void_list = cdar(void_list)) 
		    if(void_list then 
			(poly_list_new = (axlPolyOperation poly_list void_list 
				'ANDNOT
			    )) else 
			(poly_list_new = poly_list)
		    ) else 
		    (poly_list_new = (axlPolyFromDB shape_dbid ?holes t))
		) else 
		(poly_list_new = (axlPolyFromDB shape_dbid ?holes nil))
	    ) 
	    (result = poly_list_new) else
	    if(include_voids then 
		if((shape_dbid->shapeAuto) then 
		    foreach(ashape 
			(shape_dbid->shapeAuto) 
			lconc(poly_list 
			    (axlPolyFromDB ashape)
			)
		    ) else 
		    lconc(poly_list 
			(axlPolyFromDB 
			    (axlDB2Path shape_dbid)
			)
		    )
		) 
		foreach(vd 
		    (shape_dbid->voids) 
		    lconc(void_list 
			(axlPolyFromDB 
			    (axlDB2Path vd)
			)
		    )
		) else
		lconc(poly_list 
		    (axlPolyFromDB 
			(axlDB2Path shape_dbid)
		    )
		)
	    ) 
	    (poly_list = cdar(poly_list)) 
	    (void_list = cdar(void_list)) 
	    (result = list(poly_list void_list))
	) result
    )
)
procedure(TBX_DBCORE_Poly_From_Text(txt_dbid tmp_layer) 
    let((seg_poly_list poly_info line_path text_param result) 
	(text_param = (axlGetParam 
		sprintf(nil "paramTextBlock:%s" 
		    (txt_dbid->textBlock)
		)
	    )) 
	if(((text_param->photoWidth) > 0.0) then 
	    foreach(char_entry 
		(axlText2Lines txt_dbid) 
		foreach(rpath char_entry 
		    (result = (axlDBCreatePath rpath tmp_layer)) 
		    (line_path = caar(result)) 
		    foreach(seg 
			(line_path->segments) 
			(seg_poly_list = cons(car((axlPolyFromDB seg ?endCapType 
					'ROUND
				    )
				) seg_poly_list
			    ))
		    )
		    (axlDeleteObject line_path)
		)
	    ) 
	    if(onep(length(seg_poly_list)) then 
		(poly_info = seg_poly_list) else 
		(poly_info = (axlPolyOperation 
			cdr(seg_poly_list) 
			list(car(seg_poly_list)) 
			'OR
		    ))
	    ) 
	    (axlVisibleUpdate nil)
	    else 
	    printf("Warning: Text photo width is 0.0\n")
	) poly_info
    )
)
procedure((TBX_DBCORE_Rotate_Rpath rpath angle origin \@optional
	mirror
    ) 
    let((rpath_m seg_list pt_start_m pt_end_m pt_center_m
	    width clockwise_m
	) 
	(seg_list = (axlPathGetPathSegs rpath)) 
	(pt_start_m = (axlPathSegGetEndPoint 
		car(seg_list)
	    )) 
	when(mirror 
	    (pt_start_m = (axlGeoRotatePt 0.0 pt_start_m origin t))
	) 
	when((angle != 0.0) 
	    (pt_start_m = (axlGeoRotatePt angle pt_start_m origin nil))
	)
	(rpath_m = (axlPathStart 
		list(pt_start_m) 0.0
	    )) 
	foreach(seg 
	    cdr(seg_list) 
	    (pt_center_m = (axlPathSegGetArcCenter seg)) 
	    (pt_end_m = (axlPathSegGetEndPoint seg)) 
	    (width = (axlPathSegGetWidth seg))
	    when(mirror 
		(pt_end_m = (axlGeoRotatePt 0.0 pt_end_m origin t))
	    ) 
	    when((angle != 0.0) 
		(pt_end_m = (axlGeoRotatePt angle pt_end_m origin nil))
	    ) 
	    if(pt_center_m then 
		if(mirror then 
		    (clockwise_m = !(axlPathSegGetArcClockwise seg)) else 
		    (clockwise_m = (axlPathSegGetArcClockwise seg))
		) 
		when(mirror 
		    (pt_center_m = (axlGeoRotatePt 0.0 pt_center_m origin t))
		) 
		when((angle != 0.0) 
		    (pt_center_m = (axlGeoRotatePt angle pt_center_m origin nil))
		)
		(rpath_m = (axlPathArcCenter rpath_m width pt_end_m clockwise_m
			pt_center_m
		    )) else 
		(rpath_m = (axlPathLine rpath_m width pt_end_m))
	    )
	) rpath_m
    )
)
procedure((TBX_DBCORE_Rpath_From_Poly poly_dbid \@key width compactArc) 
    let((rpath cur_xy cur_radius last_xy delta_x
	    delta_y clockwise vertex_list seg_list pt_stack
	    path_start_xy path_end_xy cur_center cur_end cur_width
	    cur_clockwise arc_start arc_end arc_center arc_clockwise
	    arc_width rpath_c
	) 
	unless(width 
	    (width = 0.0)
	) 
	(vertex_list = (poly_dbid->vertices)) 
	(vertex_list = nconc(vertex_list 
		list(car(vertex_list))
	    )) 
	foreach(entry vertex_list 
	    if(!last_xy then 
		(last_xy = car(entry)) 
		(rpath = (axlPathStart 
			list(last_xy) 0.0
		    )) else
		(cur_xy = car(entry)) 
		(cur_radius = cadr(entry)) 
		if((cur_radius == 0.0) then 
		    (rpath = (axlPathLine rpath width cur_xy)) else 
		    (delta_x = (car(cur_xy) - car(last_xy)))
		    (delta_y = (cadr(cur_xy) - cadr(last_xy))) 
		    cond(((((delta_x < 0.0) && (delta_y > 0.0)) || ((delta_x > 0.0) && (delta_y > 0.0))) 
			    if((cur_radius > 0.0) then 
				(clockwise = t) else 
				(clockwise = nil)
			    ) 
			    (rpath = (axlPathArcRadius rpath width cur_xy clockwise
				    nil 
				    abs(cur_radius)
				))
			) 
			((((delta_x > 0.0) && (delta_y < 0.0)) || ((delta_x < 0.0) && (delta_y < 0.0))) 
			    if((cur_radius > 0.0) then 
				(clockwise = nil) else 
				(clockwise = t)
			    ) 
			    (rpath = (axlPathArcRadius rpath width cur_xy clockwise
				    nil 
				    abs(cur_radius)
				))
			) 
			(t t)
		    )
		) 
		(last_xy = cur_xy)
	    )
	)
	when(compactArc 
	    (seg_list = (axlPathGetPathSegs rpath)) 
	    (path_start_xy = (axlPathSegGetEndPoint 
		    car(seg_list)
		)) 
	    (path_end_xy = (axlPathSegGetEndPoint 
		    (lastelem seg_list)
		)) 
	    (rpath_c = (axlPathStart 
		    list(path_start_xy) 0.0
		))
	    (pt_stack = cons(path_start_xy pt_stack)) 
	    (seg_list = cdr(seg_list)) 
	    while(seg_list 
		(cur_center = (axlPathSegGetArcCenter 
			car(seg_list)
		    )) 
		(cur_end = (axlPathSegGetEndPoint 
			car(seg_list)
		    )) 
		(cur_width = (axlPathSegGetWidth 
			car(seg_list)
		    )) 
		(cur_clockwise = (axlPathSegGetArcClockwise 
			car(seg_list)
		    ))
		cond(((cur_center && !arc_start) 
			(arc_start = car(pt_stack)) 
			(arc_clockwise = cur_clockwise) 
			(arc_center = cur_center) 
			(arc_width = cur_width)
			(arc_end = cur_end)
		    ) 
		    ((cur_center && arc_start && (cur_clockwise == arc_clockwise) && (axlGeoEqual cur_width arc_width) && 
			    (axlGeoPointsEqual cur_center arc_center)) 
			(arc_end = cur_end)
		    ) 
		    (t 
			when((arc_start && arc_end) 
			    (rpath_c = (axlPathArcCenter rpath_c arc_width arc_end arc_clockwise
				    arc_center
				))
			) 
			if(cur_center then 
			    (arc_start = car(pt_stack)) 
			    (arc_clockwise = cur_clockwise) 
			    (arc_center = cur_center)
			    (arc_width = cur_width) 
			    (arc_end = cur_end) else 
			    (rpath_c = (axlPathLine rpath_c cur_width cur_end)) 
			    (arc_start = nil)
			    (arc_clockwise = nil) 
			    (arc_center = nil) 
			    (arc_width = nil) 
			    (arc_end = nil)
			)
		    )
		) 
		(pt_stack = cons(cur_end pt_stack)) 
		(seg_list = cdr(seg_list)) 
		when(((axlGeoPointsEqual cur_end path_end_xy) && arc_start && arc_end) 
		    (rpath_c = (axlPathArcCenter rpath_c arc_width arc_end arc_clockwise
			    arc_center
			))
		)
	    ) 
	    (rpath = rpath_c)
	) rpath
    )
)
procedure((TBX_DBDISPLAY_Canvas_Grid mode \@optional lo_arg) 
    let((ret grid_param global_grid grd_param) 
	caseq(mode 
	    (getGrid 
		(grid_param = list()) 
		foreach(lyr 
		    (axlSubclassRoute) 
		    (grid_param = cons((axlDBGridGet lyr) grid_param))
		) 
		(grid_param = cons((axlDBGridGet "non-etch") grid_param)) 
		(ret = grid_param)
	    ) 
	    (setGrid 
		cond((((type(lo_arg) == 'fixnum) || (type(lo_arg) == 'flonum)) 
			(global_grid = (lo_arg * 1.0)) 
			printf("Note: Changing grid to %L\n" global_grid) 
			(grd_param = (axlDBGridGet "non-etch")) 
			(grd_param->name = 'all)
			(grd_param->xGrids = global_grid) 
			(grd_param->yGrids = global_grid) 
			(grd_param->xOrigin = 0.0) 
			(grd_param->yOrigin = 0.0) 
			(axlDBGridSet grd_param)
		    ) 
		    ((type(lo_arg) == 'list) 
			foreach(def lo_arg 
			    (grd_param = (axlDBGridGet "non-etch")) 
			    when(((def->name) != "non-etch") 
				(grd_param->name = (def->name))
			    ) 
			    (grd_param->xGrids = (def->xGrids))
			    (grd_param->yGrids = (def->yGrids)) 
			    (grd_param->xOrigin = (def->xOrigin)) 
			    (grd_param->yOrigin = (def->yOrigin)) 
			    (grd_param->xMajor = (def->xMajor)) 
			    (grd_param->yMajor = (def->yMajor))
			    (axlDBGridSet grd_param)
			)
		    )
		) 
		(axlDBRefreshId nil) 
		(axlVisibleUpdate t) 
		(ret = t)
	    )
	) ret
    )
)
procedure(TBX_DBDISPLAY_Dehighlight_By_Type(type_list) 
    let((obj_list ff_en_orig ff_on_orig) 
	(ff_en_orig = cons("noall" 
		(axlGetFindFilter nil)
	    )) 
	(ff_on_orig = (axlGetFindFilter t)) 
	foreach(tpe type_list 
	    (axlClearSelSet) 
	    case(tpe 
		("groups" 
		    (obj_list = (axlSelectByName "GROUP" "*" t)) 
		    (axlClearObjectCustomColor obj_list)
		) 
		("functions" 
		    (obj_list = (axlSelectByName "FUNCTION" "*" t)) 
		    (axlClearObjectCustomColor obj_list)
		) 
		("symbols" 
		    (obj_list = (axlSelectByName "SYMTYPE" "*" t)) 
		    (axlClearObjectCustomColor obj_list)
		) 
		("nets" 
		    (axlSetFindFilter ?enabled 
			list("noall" "invisible" "nets") ?onButtons 
			list("all")
		    ) 
		    (axlAddSelectAll) 
		    (axlClearObjectCustomColor 
			(axlGetSelSet)
		    )
		)
		("pins" 
		    (axlSetFindFilter ?enabled 
			list("noall" "pins" "invisible") ?onButtons 
			list("all")
		    ) 
		    (axlAddSelectAll) 
		    (axlClearObjectCustomColor 
			(axlGetSelSet)
		    )
		) 
		("vias" 
		    (axlSetFindFilter ?enabled 
			list("noall" "vias" "invisible") ?onButtons 
			list("all")
		    ) 
		    (axlAddSelectAll) 
		    (axlClearObjectCustomColor 
			(axlGetSelSet)
		    )
		) 
		("drcs" 
		    (axlSetFindFilter ?enabled 
			list("noall" "drcs" "invisible") ?onButtons 
			list("all")
		    ) 
		    (axlAddSelectAll) 
		    (axlClearObjectCustomColor 
			(axlGetSelSet)
		    )
		)
	    )
	) 
	(axlClearSelSet)
	(axlSetFindFilter ?enabled ff_en_orig ?onButtons ff_on_orig) t
    )
)
procedure(TBX_DBDISPLAY_Get_Color_References() 
    let((color_ref cid class_list subclass_list layer_name) 
	(color_ref = makeVector(((axlColorGet 
			'count
		    ) + 1) nil
	    )) 
	foreach(arg 
	    list('highlightColor 
		'tempColor 
		'gridColor 
		'ratsnestColor 
		'waiveDRCColor
	    ) 
	    (cid = (axlDBControl arg)) 
	    when((cid && (type(cid) == 'fixnum)) 
		(color_ref[cid] = cons(symbolToString(arg) 
			color_ref[cid]
		    ))
	    )
	) 
	(class_list = ((axlGetParam "paramLayerGroup")->groupMembers)) 
	foreach(cls class_list 
	    (subclass_list = (axlSubclasses cls)) 
	    foreach(scls subclass_list 
		(layer_name = strcat(cls "/" scls)) 
		(cid = ((axlLayerGet layer_name)->color)) 
		when((cid && (type(cid) == 'fixnum)) 
		    (color_ref[cid] = cons(layer_name 
			    color_ref[cid]
			))
		)
	    )
	)
	color_ref
    )
)
procedure(TBX_DBDISPLAY_Set_Design_Colors(profile_name) 
    let((class_name subclass_name class_list cfg config_file
	    col_id col_list prm cnt COLID
	    arg type ok2color etch_layers top_etch_layer
	    bottom_etch_layer layer_name col_rgb outer_etch_layers
	) 
	(config_file = car(TBX_UTIL_Search_Config(lowerCase(strcat(profile_name ".prm")) "dbdisplay" nil))) 
	if(config_file then 
	    printf("Reading color settings from %s ...\n" config_file) 
	    (cfg = TBX_UTIL_File_Lineread(config_file)) else
	    printf("Warning: Cannot find file %s in configuration directory\n" 
		strcat(profile_name ".prm")
	    )
	) 
	when(cfg 
	    (COLID = makeTable("colortable" nil)) 
	    (class_list = list("BOARD GEOMETRY" "PACKAGE GEOMETRY" "CAVITY" "PLAN" "PIN"
		    "VIA CLASS" "DRC ERROR CLASS" "ETCH" "ANTI ETCH" "BOUNDARY"
		    "COMPONENT VALUE" "DEVICE TYPE" "REF DES" "TOLERANCE" "USER PART NUMBER"
		    "MANUFACTURING" "DRAWING FORMAT" "CONSTRAINT REGION" "ROUTE KEEPOUT" "VIA KEEPOUT"
		    "PACKAGE KEEPOUT" "PACKAGE KEEPIN" "ROUTE KEEPIN" "ANALYSIS" "RIGID FLEX"
		    "SURFACE FINISHES"
		)) 
	    (class_list = mapcar(lambda((x) 
			(axlMapClassName x)
		    ) class_list
		)) 
	    (axlColorLoad nil)
	    (axlVisibleUpdate t) 
	    foreach(entry cfg 
		(type = car(entry)) 
		(arg = cadr(entry)) 
		(col_list = caddr(entry))
		(col_id = car(col_list)) 
		cond(((type == "ALL") 
			foreach(cls class_list 
			    foreach(lyr 
				(axlSubclasses cls) 
				(prm = (axlLayerGet 
					strcat(cls "/" lyr)
				    )) 
				when(prm 
				    (prm->color = col_id) 
				    (axlLayerSet prm)
				)
			    )
			)
		    ) 
		    ((type == "BACKGROUND") 
			(col_rgb = col_list) 
			(axlColorSet 
			    'background col_rgb
			)
		    ) 
		    ((type == "CLASS") 
			(class_name = (axlMapClassName arg)) 
			foreach(lyr 
			    (axlSubclasses class_name) 
			    (prm = (axlLayerGet 
				    strcat(class_name "/" lyr)
				)) 
			    when(prm 
				(prm->color = col_id) 
				(axlLayerSet prm)
			    )
			)
		    ) 
		    ((type == "SUBCLASS") 
			(subclass_name = arg) 
			foreach(cls class_list 
			    foreach(lyr 
				(axlSubclasses cls) 
				when((upperCase(lyr) == upperCase(subclass_name)) 
				    (prm = (axlLayerGet 
					    strcat(cls "/" lyr)
					)) 
				    when(prm 
					(prm->color = col_id) 
					(axlLayerSet prm)
				    )
				)
			    )
			)
		    ) 
		    ((type == "CROSS_SECTION") 
			(cnt = 0) 
			(etch_layers = setof(x 
				(axlSubclassRoute) 
				((axlLayerGet 
					strcat((axlMapClassName "ETCH") "/" x)
				    )->isEtch)
			    )) 
			(top_etch_layer = car(etch_layers)) 
			(bottom_etch_layer = car(reverse(etch_layers)))
			(outer_etch_layers = list(top_etch_layer bottom_etch_layer)) 
			foreach(lyr 
			    (axlSubclassRoute) 
			    (prm = (axlLayerGet 
				    strcat((axlMapClassName "ETCH") "/" lyr)
				)) 
			    (ok2color = nil) 
			    cond((((prm->isEtch) && member(upperCase(lyr) outer_etch_layers)) 
				    when((arg == "OUTER") 
					(ok2color = t)
				    )
				) 
				(((prm->isEtch) && !member(upperCase(lyr) outer_etch_layers)) 
				    cond(((arg == "INNER") 
					    (ok2color = t)
					) 
					(((arg == "INNER_SIGNAL") && (lowerCase((prm->type)) == "conductor")) 
					    (ok2color = t)
					) 
					(((arg == "INNER_PLANE") && (lowerCase((prm->type)) == "plane")) 
					    (ok2color = t)
					)
				    )
				) 
				(((arg == "DIESTACK") && (lowerCase((prm->type)) == "diestack")) 
				    (ok2color = t)
				)
			    )
			    when(ok2color 
				(COLID[lyr] = nth(mod(cnt 
					    length(col_list)
					) col_list
				    )) 
				++cnt
			    )
			) 
			foreach(cls class_list 
			    foreach(lyr 
				(axlSubclasses cls) 
				(prm = (axlLayerGet 
					strcat(cls "/" lyr)
				    )) 
				when((prm && COLID[lyr]) 
				    (prm->color = COLID[lyr]) 
				    (axlLayerSet prm)
				)
			    )
			)
		    )
		    ((type == "LAYER") 
			(layer_name = arg) 
			(prm = (axlLayerGet layer_name)) 
			when(prm 
			    (prm->color = col_id) 
			    (axlLayerSet prm)
			)
		    ) 
		    ((type == "MISC") 
			case(arg 
			    ("RATS_TB" 
				(axlDBDisplayControl 
				    'ratsnestColor col_id
				)
			    ) 
			    ("RATS_TT" 
				(axlDBDisplayControl 
				    'ratsnestTTColor col_id
				)
			    ) 
			    ("RATS_BB" 
				(axlDBDisplayControl 
				    'ratsnestBBColor col_id
				)
			    ) 
			    ("GRID" 
				(axlDBDisplayControl 
				    'gridBBColor col_id
				)
			    )
			    ("PERM_HIGHLIGHT" 
				(axlDBDisplayControl 
				    'highlightColor col_id
				)
			    ) 
			    ("TEMP_HIGHLIGHT" 
				(axlDBDisplayControl 
				    'tempColor col_id
				)
			    ) 
			    ("WAIVE_DRC" 
				(axlDBDisplayControl 
				    'waiveDRCColor col_id
				)
			    ) 
			    ("HOLE" 
				(axlDBDisplayControl 
				    'holeColor col_id
				)
			    ) 
			    ("VIA_LABEL" 
				(axlDBDisplayControl 
				    'viaLabelColor col_id
				)
			    )
			    ("STACKED_VIA_LABEL" 
				(axlDBDisplayControl 
				    'stackedViaLabelColor col_id
				)
			    )
			)
		    ) 
		    (t)
		)
	    ) 
	    (axlVisibleUpdate t)
	)
    )
)
procedure(TBX_DBDISPLAY_Set_Design_Visibility(arg) 
    let((layer_list class_list prm etch_layers okVisible) 
	when((arg == "default") 
	    (layer_list = list("BOARD GEOMETRY/OUTLINE" "BOARD GEOMETRY/DESIGN_OUTLINE" "BOARD GEOMETRY/CUTOUT" "PACKAGE GEOMETRY/ASSEMBLY_TOP" "PACKAGE GEOMETRY/ASSEMBLY_BOTTOM"
		    "REF DES/ASSEMBLY_TOP" "REF DES/ASSEMBLY_BOTTOM" "ROUTE KEEPOUT/ALL" "VIA KEEPOUT/ALL" "PACKAGE KEEPOUT/TOP"
		    "PACKAGE KEEPOUT/BOTTOM" "PACKAGE KEEPOUT/ALL" "ROUTE KEEPIN/ALL" "PACKAGE KEEPIN/ALL" "DRC ERROR CLASS/ALL"
		    "DRC ERROR CLASS/WIRE" "DRC ERROR CLASS/PACKAGE_TOP" "DRC ERROR CLASS/PACKAGE_BOTTOM"
		)) 
	    (class_list = list("PIN" "VIA CLASS" "DRC ERROR CLASS" "PLAN" "ETCH"
		    "ANTI ETCH" "BOUNDARY" "ROUTE KEEPOUT" "VIA KEEPOUT" "CONSTRAINT REGION"
		))
	) 
	when((layer_list && class_list) 
	    (class_list = mapcar(lambda((x) 
			(axlMapClassName x)
		    ) class_list
		)) 
	    if(((axlVersion 
			'isAPD
		    ) || (axlVersion 
			'isSIP
		    )) then 
		(layer_list = mapcar(lambda((x) 
			    TBX_UTIL_Map_Layer_Name(x 
				'forceMCM
			    )
			) layer_list
		    )) else 
		(layer_list = mapcar(lambda((x) 
			    TBX_UTIL_Map_Layer_Name(x 
				'forcePCB
			    )
			) layer_list
		    ))
	    ) 
	    (axlVisibleDesign nil) 
	    if((axlIsLayer "CONDUCTOR/WIRE") 
		(axlVisibleLayer "CONDUCTOR/WIRE" t)
	    )
	    foreach(lyr layer_list 
		(axlVisibleLayer lyr t)
	    ) 
	    (etch_layers = setof(x 
		    (axlSubclassRoute) 
		    ((axlLayerGet 
			    strcat((axlMapClassName "ETCH") "/" x)
			)->isEtch)
		)) 
	    (okVisible = makeTable("ok_visible_table" nil)) 
	    foreach(lyr etch_layers 
		(prm = (axlLayerGet 
			strcat((axlMapClassName "ETCH") "/" lyr)
		    )) 
		when(((prm->isEtch) && ((prm->type) != "PLANE")) 
		    (okVisible[lyr] = t)
		)
	    ) 
	    foreach(cls class_list 
		foreach(lyr 
		    (axlSubclasses cls) 
		    (prm = (axlLayerGet 
			    strcat(cls "/" lyr)
			)) 
		    when(((prm->isEtch) && okVisible[lyr]) 
			(prm->visible = t) 
			(axlLayerSet prm)
		    )
		)
	    )
	    (axlVisibleUpdate t) 
	    printf("Note: Setting %s visibility\n" arg)
	)
    )
)
procedure((TBX_DBDISPLAY_Set_Layer_Color layer_name color_arg_main \@optional color_arg_alt) 
    let((cur_arg color_id all_colors param color_ref
	    cnt
	) 
	(cur_arg = color_arg_main) 
	when((((axlColorGet 
			'background
		    ) != list(0 0 0)) && color_arg_alt) 
	    (cur_arg = color_arg_alt)
	) 
	cond(((type(cur_arg) == 'list) 
		(all_colors = (axlColorGet 
			'all
		    )) 
		for(i 0 
		    (length(all_colors) - 1) 
		    when((nth(i all_colors) == cur_arg) 
			(color_id = (i + 1))
		    )
		) 
		unless(color_id 
		    (color_ref = TBX_DBDISPLAY_Get_Color_References()) 
		    (cnt = (axlColorGet 
			    'count
			)) 
		    while(((cnt > 0) && !color_id) 
			unless(color_ref[cnt] 
			    (color_id = cnt)
			) 
			--cnt
		    )
		)
	    ) 
	    ((type(cur_arg) == 'fixnum) 
		(color_id = cur_arg)
	    ) 
	    ((type(cur_arg) == 'string) 
		(color_id = ((axlLayerGet cur_arg)->color))
	    )
	) 
	when(color_id 
	    (param = (axlLayerGet layer_name)) 
	    (param->color = color_id) 
	    (axlLayerSet param)
	)
	t
    )
)
procedure(TBX_DERIVECONN_Assign_Via_Nets() 
    let((report_file inport line arr via_data
	    offset sel_set sel_box via_name via_type
	    start_layer end_layer x_pt y_pt net_name
	    via_list design_nets
	) 
	(design_nets = mapcar(lambda((n) 
		    (n->name)
		) 
		((axlDBGetDesign)->nets)
	    )) 
	(offset = (axlMKSConvert "0.1 MM" 
		car((axlDBGetDesignUnits))
	    )) 
	(report_file = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
	when(report_file 
	    (inport = infile(report_file)) 
	    while((line = _gets(inport)) 
		(arr = parseString(line)) 
		when((length(arr) == 7) 
		    (via_data = cons(arr via_data))
		)
	    ) 
	    close(inport)
	)
	(via_data = sortcar(via_data nil)) 
	(axlDBControl 
	    'drcEnable nil
	) 
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "vias") ?onButtons 
	    list("all")
	) 
	foreach(entry via_data 
	    (via_name = car(entry)) 
	    (via_type = cadr(entry)) 
	    (start_layer = caddr(entry))
	    (end_layer = nth(3 entry)) 
	    (x_pt = atof(nth(4 entry))) 
	    (y_pt = atof(nth(5 entry))) 
	    (net_name = nth(6 entry)) 
	    when((net_name != "<DUMMY>") 
		(sel_box = list(((x_pt - offset):(y_pt - offset)) 
			((x_pt + offset):(y_pt + offset))
		    )) 
		(axlClearSelSet) 
		(axlSingleSelectBox sel_box) 
		(sel_set = (axlGetSelSet))
		(axlClearSelSet) 
		when(sel_set 
		    cond(((via_type == "THT") 
			    (via_list = setof(v sel_set 
				    ((v->name) == via_name)
				))
			) 
			(t 
			    (via_list = setof(v sel_set 
				    (((v->name) == via_name) && (car((v->startEnd)) == start_layer) && (cadr((v->startEnd)) == end_layer))
				))
			)
		    ) 
		    foreach(v via_list 
			when((((v->net)->name) != net_name) 
			    if(member(net_name design_nets) then 
				printf("Info: Changing net on via %s at %L to %s\n" via_name 
				    (x_pt:y_pt) net_name
				) 
				(axlChangeNet v net_name) else
				printf("Warning: Via %s at %L, net %L does not exist any longer\n" via_name 
				    (x_pt:y_pt) net_name
				)
			    )
			)
		    )
		)
	    )
	) 
	(axlDBControl 
	    'drcEnable t
	)
	(axlUIConfirm "You may need to update shapes and DRC status") 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_DERIVECONN_Build_Layer_Popup(form_handle) 
    let((layer_list) 
	(layer_list = (axlSubclassRoute)) 
	(layer_list = cons("Plane" layer_list)) 
	(layer_list = cons("Signal" layer_list)) 
	(layer_list = cons("Inner" layer_list))
	(layer_list = cons("Outer" layer_list)) 
	(layer_list = cons("All" layer_list)) 
	(axlFormBuildPopup form_handle "layer" layer_list)
    )
)
procedure(TBX_DERIVECONN_Cache_Param(form_handle) 
    let((rec session_param) 
	(rec = "deriveconn") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "layer") 
	    stringToSymbol("layer")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "check_item") 
	    stringToSymbol("check_item")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "fix_connectivity") 
	    stringToSymbol("fix_connectivity")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "mark_only") 
	    stringToSymbol("mark_only")
	)
    )
)
procedure(TBX_DERIVECONN_Callback(form_handle) 
    let((layer_list) 
	case((form_handle->curField) 
	    ("layer" 
		(layer_list = TBX_UTIL_Resolve_Etch_Layers((form_handle->curValue))) 
		TBX_DERIVECONN_Set_Visibility(layer_list)
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_DERIVECONN_Change_Line2Cline(cur_box lyr) 
    let((line_set layer_name) 
	(layer_name = strcat((axlMapClassName "ETCH") "/" lyr)) 
	(axlVisibleDesign nil) 
	(axlVisibleLayer layer_name t) 
	(axlVisibleUpdate t)
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    list("noall" "lines") ?onButtons 
	    list("all")
	) 
	(axlSingleSelectBox cur_box) 
	(line_set = (axlGetSelSet)) 
	(axlClearSelSet)
	when(line_set 
	    (axlChangeLine2Cline line_set)
	) 
	(axlDBRefreshId nil) t
    )
)
procedure(TBX_DERIVECONN_Clear_Layer(box layer) 
    let((marker_data) 
	(box = box) 
	(axlSetFindFilter ?enabled 
	    list("noall" "linesegs" "shapes") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll)
	(marker_data = setof(x 
		(axlGetSelSet) 
		((x->layer) == layer)
	    )) 
	when(marker_data 
	    (axlDeleteObject marker_data)
	) 
	(axlClearSelSet)
    )
)
procedure(TBX_DERIVECONN_Cline2Cline(window_box lyr mark_only) 
    let((cline_set seg_set loc_list width xy
	    xy_str etch_layer pin_layer via_layer rpath
	    pt_close dist_data search_box cap_poly prim_seg
	    sec_seg prim_candidates sec_candidates prim_poly sec_poly
	    and_poly last_percent cur_percent info_1 info_2
	    dangling_ends cur_cnt skip pad_poly pad_source
	    result window_poly
	) 
	(result = (axlDBCreateRectangle window_box nil 
		((tbx_deriveconn_global->marker)->layer)
	    )) 
	when(car(result) 
	    (window_poly = car((axlPolyFromDB 
			car(result)
		    )
		))
	) 
	TBX_DERIVECONN_Clear_Layer(window_box 
	    ((tbx_deriveconn_global->marker)->layer)
	) 
	TBX_DERIVECONN_Set_Visibility(list(lyr))
	(etch_layer = strcat("ETCH/" lyr)) 
	(pin_layer = strcat("PIN/" lyr)) 
	(via_layer = strcat("VIA CLASS/" lyr)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "clines") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet)
	(axlSingleSelectBox window_box) 
	(cline_set = (axlGetSelSet)) 
	(axlClearSelSet) 
	(info_1 = sprintf(nil "")) 
	(axlMeterCreate "Derive Cline2Cline" info_1 t nil)
	foreach(cl cline_set 
	    (loc_list = nconc(loc_list 
		    TBX_DERIVECONN_Get_Unconnected_Ends(cl)
		))
	) 
	(dangling_ends = length(loc_list)) 
	(cur_cnt = 0) 
	foreach(entry loc_list 
	    ++cur_cnt 
	    (xy = car(entry)) 
	    (width = cadr(entry))
	    (search_box = caddr(entry)) 
	    (cap_poly = nth(3 entry)) 
	    (xy_str = (axlGeo2Str xy)) 
	    (skip = nil) 
	    when((axlGeoPointInShape xy window_poly) 
		(axlClearSelSet) 
		(axlSetFindFilter ?enabled 
		    list("noall" "pins" "vias") ?onButtons 
		    list("all")
		) 
		(axlSingleSelectBox search_box) 
		when((axlGetSelSet) 
		    foreach(pv 
			(axlGetSelSet) 
			if(((pv->objType) == "via") then 
			    (pad_source = via_layer) else 
			    (pad_source = pin_layer)
			) 
			(pad_poly = car((axlPolyFromDB pv ?layer pad_source ?padType
				    'REGULAR
				)
			    )) 
			(result = (axlPolyOperation pad_poly cap_poly 
				'AND
			    ))
			when(car(result) 
			    (skip = t)
			)
		    )
		)
		(axlClearSelSet) 
		unless(skip 
		    (axlClearSelSet) 
		    (axlSetFindFilter ?enabled 
			list("noall" "clinesegs") ?onButtons 
			list("all")
		    ) 
		    (axlSingleSelectBox search_box) 
		    (seg_set = (axlGetSelSet))
		    (axlClearSelSet) 
		    when((length(seg_set) >= 2) 
			(prim_candidates = setof(sg seg_set 
				((sg->objType) && (((axlGeo2Str 
						car((sg->startEnd))
					    ) == xy_str) || ((axlGeo2Str 
						cadr((sg->startEnd))
					    ) == xy_str)))
			    )) 
			when(onep(length(prim_candidates)) 
			    (sec_candidates = setof(sg seg_set 
				    ((sg->objType) && (((axlGeo2Str 
						    car((sg->startEnd))
						) != xy_str) && ((axlGeo2Str 
						    cadr((sg->startEnd))
						) != xy_str)))
				)) 
			    (dist_data = nil) 
			    foreach(sg sec_candidates 
				(dist_data = cons(list((axlDistance 
						car((sg->startEnd)) xy
					    ) sg
					) dist_data
				    )) 
				(dist_data = cons(list((axlDistance 
						cadr((sg->startEnd)) xy
					    ) sg
					) dist_data
				    ))
			    ) 
			    (dist_data = sortcar(dist_data 
				    'lessp
				))
			    (prim_seg = car(prim_candidates)) 
			    (sec_seg = cadar(dist_data)) 
			    when((prim_seg && sec_seg && (prim_seg->startEnd) && (sec_seg->startEnd)) 
				(dist_data = nil) 
				(pt_close = nil) 
				when((axlGeoPointInShape 
					car((sec_seg->startEnd)) cap_poly
				    ) 
				    (dist_data = cons(list((axlDistance 
						    car((sec_seg->startEnd)) xy
						) 
						car((sec_seg->startEnd))
					    ) dist_data
					))
				) 
				when((axlGeoPointInShape 
					cadr((sec_seg->startEnd)) cap_poly
				    ) 
				    (dist_data = cons(list((axlDistance 
						    cadr((sec_seg->startEnd)) xy
						) 
						cadr((sec_seg->startEnd))
					    ) dist_data
					))
				)
				(dist_data = sortcar(dist_data 
					'lessp
				    )) 
				(pt_close = cadar(dist_data)) 
				cond(((pt_close && ((axlGeo2Str pt_close) != xy_str)) 
					if(mark_only then 
					    (axlDBCreateCircle 
						list(xy 
						    ((tbx_deriveconn_global->marker)->radius)
						) 
						((tbx_deriveconn_global->marker)->lineWidth) 
						((tbx_deriveconn_global->marker)->layer)
					    ) else 
					    (rpath = (axlPathStart 
						    list(xy pt_close) width
						))
					    (axlDBCreatePath rpath etch_layer)
					)
				    ) 
				    (t 
					(prim_poly = car((axlPolyFromDB prim_seg ?endCapType 
						    'ROUND
						)
					    )) 
					(sec_poly = car((axlPolyFromDB sec_seg ?endCapType 
						    'ROUND
						)
					    )) 
					(and_poly = car((axlPolyOperation prim_poly sec_poly 
						    'AND
						)
					    )) 
					when(and_poly 
					    if(mark_only then 
						(axlDBCreateCircle 
						    list(xy 
							((tbx_deriveconn_global->marker)->radius)
						    ) 
						    ((tbx_deriveconn_global->marker)->lineWidth) 
						    ((tbx_deriveconn_global->marker)->layer)
						) else 
						TBX_DERIVECONN_Create_T_Junction(sec_seg xy 
						    (prim_seg->width) and_poly etch_layer
						)
					    )
					)
				    )
				)
			    )
			)
		    )
		) 
		(cur_percent = ((100 * cur_cnt) / dangling_ends)) 
		when((cur_percent != last_percent) 
		    (info_1 = sprintf(nil "Checking %s..." lyr)) 
		    (info_2 = sprintf(nil "Completed: %d%% (%d of %d dangling ends)" cur_percent cur_cnt dangling_ends)) 
		    (axlMeterUpdate cur_percent info_1 info_2) 
		    (last_percent = cur_percent)
		)
	    )
	) 
	(axlMeterDestroy)
    )
)
procedure(TBX_DERIVECONN_Cline2Pad(box lyr mark_only) 
    let((etch_layer pin_layer via_layer seg_poly width
	    pv_set pad_source pad_poly pad_box rpath
	    cline_set cl_xy cline_done and_poly conn_status
	    cur_cnt last_percent cur_percent info_1 info_2
	    pin_via_cnt
	) 
	TBX_DERIVECONN_Clear_Layer(box 
	    ((tbx_deriveconn_global->marker)->layer)
	) 
	TBX_DERIVECONN_Set_Visibility(list(lyr)) 
	(etch_layer = strcat("ETCH/" lyr)) 
	(pin_layer = strcat("PIN/" lyr))
	(via_layer = strcat("VIA CLASS/" lyr)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "pins" "vias") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlSingleSelectBox box) 
	(pv_set = (axlGetSelSet))
	(axlClearSelSet) 
	(pin_via_cnt = length(pv_set)) 
	(info_1 = sprintf(nil "")) 
	(axlMeterCreate "Derive Cline2Pad" info_1 t nil) 
	(cur_cnt = 0)
	(last_percent = 0) 
	foreach(pv pv_set 
	    ++cur_cnt 
	    if(((pv->objType) == "via") then 
		(pad_source = via_layer) else 
		(pad_source = pin_layer)
	    ) 
	    (pad_poly = car((axlPolyFromDB pv ?layer pad_source ?padType
			'REGULAR
		    )
		))
	    (pad_box = (pad_poly->bBox)) 
	    when(pad_box 
		(axlClearSelSet) 
		(axlSetFindFilter ?enabled 
		    list("noall" "clines") ?onButtons 
		    list("all")
		) 
		(axlSingleSelectBox pad_box) 
		(cline_set = (axlGetSelSet))
		(axlClearSelSet) 
		foreach(cl cline_set 
		    when((cl->segments) 
			(conn_status = TBX_DERIVECONN_Get_Cline_Pad_Connect_Status(cl 
				(pv->xy) 
				(pv->objType) pad_poly
			    )) 
			cond((eq(car(conn_status) 
				    'viaArray
				) t
			    ) 
			    (eq(car(conn_status) 
				    'connected
				) t
			    ) 
			    (eq(car(conn_status) 
				    'vertexInside
				) 
				when(mark_only 
				    (axlDBCreateCircle 
					list((pv->xy) 
					    ((tbx_deriveconn_global->marker)->radius)
					) 
					((tbx_deriveconn_global->marker)->lineWidth) 
					((tbx_deriveconn_global->marker)->layer)
				    )
				) 
				(cl_xy = cadr(conn_status)) 
				(width = caddr(conn_status)) 
				(rpath = (axlPathStart 
					list(cl_xy 
					    (pv->xy)
					) width
				    ))
				when((rpath && !mark_only) 
				    (axlDBCreatePath rpath etch_layer) 
				    (axlDBRefreshId nil)
				)
			    ) 
			    (t 
				(cline_done = nil) 
				foreach(seg 
				    (cl->segments) 
				    (seg_poly = car((axlPolyFromDB seg ?endCapType 
						'ROUND
					    )
					)) 
				    (width = (seg->width)) 
				    unless(cline_done 
					(and_poly = car((axlPolyOperation pad_poly seg_poly 
						    'AND
						)
					    )) 
					when(and_poly 
					    if(mark_only then 
						(axlDBCreateCircle 
						    list((pv->xy) 
							((tbx_deriveconn_global->marker)->radius)
						    ) 
						    ((tbx_deriveconn_global->marker)->lineWidth) 
						    ((tbx_deriveconn_global->marker)->layer)
						) else 
						TBX_DERIVECONN_Create_T_Junction(seg 
						    (pv->xy) 
						    (seg->width) and_poly etch_layer
						)
					    ) 
					    (cline_done = t)
					)
				    )
				)
			    )
			)
		    )
		)
	    ) 
	    (cur_percent = ((100 * cur_cnt) / pin_via_cnt)) 
	    when((cur_percent != last_percent) 
		(info_1 = sprintf(nil "Checking %s..." lyr)) 
		(info_2 = sprintf(nil "Completed: %d%% (%d of %d)" cur_percent cur_cnt pin_via_cnt)) 
		(axlMeterUpdate cur_percent info_1 info_2) 
		(last_percent = cur_percent)
	    )
	) 
	(axlMeterDestroy) t
    )
)
procedure(TBX_DERIVECONN_Create_T_Junction(seg dest_xy T_width and_poly etch_layer) 
    let((poly_center dir_vec pt_norm result seg_start
	    seg_end seg_width seg_center seg_cw dist_data
	    default_size isec rpath
	) 
	(poly_center = TBX_UTIL_Get_Box_Center((and_poly->bBox))) 
	cond((((seg->objType) == "line") 
		(dir_vec = TBX_MATH_Get_Vector(car((seg->startEnd)) 
			cadr((seg->startEnd))
		    )) 
		(dir_vec = (TBX_MATH_Transform_Vector dir_vec ?angle 90.0 ?size
			default_size
		    )) 
		(pt_norm = TBX_MATH_Add_Vector(poly_center 
			list(dir_vec)
		    )) 
		(result = TBX_MATH_Calculate_Intersection(list(poly_center pt_norm) 
			list(car((seg->startEnd)) 
			    cadr((seg->startEnd))
			)
		    ))
		(isec = car(result)) 
		when((isec && ((axlDistance poly_center isec) <= 
			    (seg->width))) 
		    (seg_start = car((seg->startEnd))) 
		    (seg_end = cadr((seg->startEnd))) 
		    (seg_width = (seg->width)) 
		    (axlDeleteObject seg)
		    (rpath = (axlPathStart 
			    list(seg_start isec) seg_width
			)) 
		    (axlDBCreatePath rpath etch_layer) 
		    when(((axlGeo2Str isec) != 
			    (axlGeo2Str dest_xy)) 
			(rpath = (axlPathStart 
				list(isec dest_xy) T_width
			    )) 
			(axlDBCreatePath rpath etch_layer)
		    ) 
		    (rpath = (axlPathStart 
			    list(isec seg_end) seg_width
			)) 
		    (axlDBCreatePath rpath etch_layer)
		)
	    ) 
	    (((seg->objType) == "arc") 
		(result = TBX_MATH_Calculate_Intersection(list(poly_center 
			    (seg->xy)
			) 
			list(car((seg->startEnd)) 
			    cadr((seg->startEnd)) 
			    (seg->xy)
			)
		    )) 
		foreach(xy result 
		    (dist_data = cons(list((axlDistance xy poly_center) xy) dist_data))
		) 
		(dist_data = sortcar(dist_data 
			'lessp
		    )) 
		(isec = cadar(dist_data))
		when((isec && ((axlDistance poly_center isec) <= 
			    (seg->width))) 
		    (seg_start = car((seg->startEnd))) 
		    (seg_end = cadr((seg->startEnd))) 
		    (seg_width = (seg->width)) 
		    (seg_center = (seg->xy))
		    (seg_cw = (seg->isClockwise)) 
		    (axlDeleteObject seg) 
		    (rpath = (axlPathStart 
			    list(seg_start) 0.0
			)) 
		    (rpath = (axlPathArcCenter rpath seg_width isec seg_cw
			    seg_center
			)) 
		    when(((axlGeo2Str isec) != 
			    (axlGeo2Str dest_xy)) 
			(rpath = (axlPathLine rpath T_width dest_xy)) 
			(axlDBCreatePath rpath etch_layer) 
			(rpath = (axlPathStart 
				list(isec) 0.0
			    ))
		    )
		    (rpath = (axlPathArcCenter rpath seg_width seg_end seg_cw
			    seg_center
			)) 
		    (axlDBCreatePath rpath etch_layer)
		)
	    )
	)
    )
)
procedure(TBX_DERIVECONN_Dump_Via_Nets() 
    let((via_data via_set via_type net_name output_file
	    port
	) 
	(output_file = (axlDMFileBrowse "ALLEGRO_TEXT" t)) 
	when(output_file 
	    (axlClearSelSet) 
	    (axlSetFindFilter ?enabled 
		list("noall" "invisible" "vias") ?onButtons 
		list("all")
	    ) 
	    (axlAddSelectAll) 
	    (via_set = (axlGetSelSet))
	    (axlClearSelSet) 
	    foreach(via via_set 
		cond(((via->isThrough) 
			(via_type = "THT")
		    ) 
		    ((car((via->startEnd)) != cadr((via->startEnd))) 
			(via_type = "BBV")
		    ) 
		    (t 
			(via_type = "THT")
		    )
		) 
		(net_name = ((via->net)->name)) 
		when((!net_name || (net_name == "")) 
		    (net_name = "<DUMMY>")
		)
		(via_data = cons(list((via->name) via_type 
			    car((via->startEnd)) 
			    cadr((via->startEnd)) 
			    (via->xy)
			    net_name
			) via_data
		    ))
	    ) 
	    (via_data = sortcar(via_data nil)) 
	    (port = outfile(output_file "w")) 
	    foreach(entry via_data 
		fprintf(port "%s  %s  %s  %s  %s  %s\n" 
		    car(entry) 
		    cadr(entry) 
		    caddr(entry)
		    nth(3 entry) 
		    (axlGeo2Str 
			nth(4 entry)
		    ) 
		    nth(5 entry)
		)
	    )
	    close(port) 
	    printf("Note: Data has been written to %L\n" output_file)
	) t
    )
)
procedure(TBX_DERIVECONN_Event_Loop(form_handle) 
    let((event loop event_mask start_pick bBox
	    layer cline2cline cline2pad shape2pad mark_only
	) 
	(axlEventSetStartPopup 
	    'TBX_DERIVECONN_Popup_Callback
	) 
	(loop = t) 
	(event_mask = list('STARTDRAG 
		'STOPDRAG
	    )) 
	while(loop 
	    (event = (axlEnterEvent event_mask nil nil)) 
	    caseq((event->type) 
		(STARTDRAG 
		    (axlAddSimpleRbandDynamics 
			(event->xy) "box" ?origin 
			(0.0:0.0)
		    ) 
		    (start_pick = (event->xy))
		) 
		(STOPDRAG 
		    (bBox = list(start_pick 
			    (event->xy)
			)) 
		    (layer = (axlFormGetField form_handle "layer")) 
		    (cline2cline = nil) 
		    (cline2pad = nil)
		    (shape2pad = nil) 
		    case((axlFormGetField form_handle "check_item") 
			("cline2cline" 
			    (cline2cline = t)
			) 
			("cline2pad" 
			    (cline2pad = t)
			) 
			("cline2all" 
			    (cline2cline = t) 
			    (cline2pad = t)
			) 
			("shape2pad" 
			    (shape2pad = t)
			)
		    ) 
		    (mark_only = nil) 
		    when((axlFormGetField form_handle "mark_only") 
			(mark_only = t)
		    ) 
		    (TBX_DERIVECONN_Run layer ?checkClineCline cline2cline ?checkClinePad
			cline2pad ?checkShapePad shape2pad ?boxWindow bBox
			?markOnly mark_only
		    )
		    (axlClearDynamics) 
		    (start_pick = nil)
		) 
		(DONE 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    (loop = nil)
		) 
		(CANCEL 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    (loop = nil)
		)
	    )
	)
	(axlEventSetStartPopup)
    )
)
procedure(TBX_DERIVECONN_Get_Cline_Pad_Connect_Status(cline pad_xy obj_type pad_poly) 
    let((pad_xy_str direct_connect indirect_connect vertex_inside tmp_list
	    loc_list xy width filter_list seg_list
	    result cline_start_xy_str cline_end_xy_str sel_set sel_box
	    scl_start_xy_str scl_end_xy_str conn_status via_array
	) 
	(pad_xy_str = (axlGeo2Str pad_xy)) 
	when((obj_type == "via") 
	    (axlSetFindFilter ?enabled 
		list("noall" "clinesegs") ?onButtons 
		list("all")
	    ) 
	    (axlClearSelSet) 
	    (axlSingleSelectBox 
		(pad_poly->bBox)
	    ) 
	    (width = 0.0)
	    foreach(seg 
		(axlGetSelSet) 
		when(((seg->width) > width) 
		    (width = (seg->width))
		)
	    ) 
	    (axlClearSelSet) 
	    (width = (width / 2.0)) 
	    when((width > 0.0) 
		(sel_box = list(((car(pad_xy) - width):(cadr(pad_xy) - width)) 
			((car(pad_xy) + width):(cadr(pad_xy) + width))
		    )) 
		(axlSetFindFilter ?enabled 
		    list("noall" "vias") ?onButtons 
		    list("all")
		) 
		(axlClearSelSet) 
		(axlSingleSelectBox sel_box)
		when((length((axlGetSelSet)) > 1) 
		    (via_array = t)
		) 
		(axlClearSelSet)
	    )
	) 
	unless(via_array 
	    (pad_xy_str = (axlGeo2Str pad_xy)) 
	    (loc_list = TBX_DERIVECONN_Get_Point_Details(cline 
		    'all nil
		)) 
	    (cline_start_xy_str = (axlGeo2Str 
		    caar(loc_list)
		)) 
	    (cline_end_xy_str = (axlGeo2Str 
		    car((lastelem loc_list))
		))
	    foreach(entry loc_list 
		(xy = car(entry)) 
		(width = cadr(entry)) 
		cond((((axlGeo2Str xy) == pad_xy_str) 
			(direct_connect = t)
		    ) 
		    ((!direct_connect && (axlGeoPointInShape xy pad_poly)) 
			(tmp_list = cons(list((axlDistance xy pad_xy) xy width) tmp_list)) 
			(vertex_inside = t)
		    )
		)
	    ) 
	    unless(direct_connect 
		(axlSetFindFilter ?enabled 
		    list("noall" "clines") ?onButtons 
		    list("all")
		) 
		(axlClearSelSet) 
		(axlSingleSelectBox 
		    (pad_poly->bBox)
		) 
		(sel_set = (axlGetSelSet))
		(axlClearSelSet) 
		when(sel_set 
		    (filter_list = setof(c sel_set 
			    (c != cline)
			)) 
		    foreach(c filter_list 
			(seg_list = (c->segments)) 
			(scl_start_xy_str = (axlGeo2Str 
				car((car(seg_list)->startEnd))
			    )) 
			(scl_end_xy_str = (axlGeo2Str 
				cadr(((lastelem seg_list)->startEnd))
			    ))
			when(((scl_start_xy_str == pad_xy_str) && ((scl_end_xy_str == cline_start_xy_str) || (scl_end_xy_str == cline_end_xy_str))) 
			    (indirect_connect = t)
			) 
			when(((scl_end_xy_str == pad_xy_str) && ((scl_start_xy_str == cline_start_xy_str) || (scl_start_xy_str == cline_end_xy_str))) 
			    (indirect_connect = t)
			)
		    )
		)
	    )
	) 
	cond((via_array 
		(conn_status = list('viaArray nil nil))
	    ) 
	    ((direct_connect || indirect_connect) 
		(conn_status = list('connected nil nil))
	    ) 
	    (vertex_inside 
		(tmp_list = sortcar(tmp_list 
			'lessp
		    )) 
		(result = car(tmp_list)) 
		(conn_status = list('vertexInside 
			cadr(result) 
			caddr(result)
		    ))
	    )
	)
	conn_status
    )
)
procedure(TBX_DERIVECONN_Get_Point_Details(cl mode include_poly_details) 
    let((seg_list xy width whalf pt1
	    pt2 pt3 pt4 rp poly
	    data cfg
	) 
	(seg_list = (cl->segments)) 
	(cfg = tconc(nil nil)) 
	cond(((mode == 'clineEndsOnly) 
		tconc(cfg 
		    list(car((car(seg_list)->startEnd)) 
			(car(seg_list)->width)
		    )
		) 
		tconc(cfg 
		    list(cadr(((lastelem seg_list)->startEnd)) 
			((lastelem seg_list)->width)
		    )
		)
	    ) 
	    ((mode == 'all) 
		foreach(seg seg_list 
		    tconc(cfg 
			list(car((seg->startEnd)) 
			    (seg->width)
			)
		    )
		) 
		tconc(cfg 
		    list(cadr(((lastelem seg_list)->startEnd)) 
			((lastelem seg_list)->width)
		    )
		)
	    )
	) 
	(cfg = cdar(cfg))
	if(include_poly_details then 
	    foreach(entry cfg 
		(xy = car(entry)) 
		(width = cadr(entry)) 
		(whalf = (width / 2.0))
		(pt1 = ((car(xy) - whalf):(cadr(xy) - whalf))) 
		(pt2 = ((car(xy) + whalf):(cadr(xy) - whalf))) 
		(pt3 = ((car(xy) + whalf):(cadr(xy) + whalf))) 
		(pt4 = ((car(xy) - whalf):(cadr(xy) + whalf))) 
		(rp = (axlPathStart 
			list(pt1 pt2 pt3 pt4 pt1) 0.0
		    ))
		(poly = car((axlPolyFromDB rp))) 
		(data = cons(list(xy width 
			    list(pt1 pt3) poly
			) data
		    ))
	    ) 
	    (data = reverse(data)) else
	    (data = cfg)
	) data
    )
)
procedure(TBX_DERIVECONN_Get_Tile_Info(box tile_size) 
    let((x_ll y_ll x_ur y_ur box_width
	    box_height cur_x cur_y tile_size_x tile_size_y
	    cur_width cur_height vertices rpath tile_box
	    tile_poly tile_info
	) 
	(x_ll = car((lowerLeft box))) 
	(y_ll = cadr((lowerLeft box))) 
	(x_ur = car((upperRight box))) 
	(y_ur = cadr((upperRight box)))
	(box_width = (x_ur - x_ll)) 
	(box_height = (y_ur - y_ll)) 
	(tile_size_x = tile_size) 
	(tile_size_y = tile_size) 
	if(((box_width > tile_size) || (box_height > tile_size)) then 
	    (cur_x = x_ll) 
	    (cur_y = y_ll) 
	    while((cur_y < y_ur) 
		(cur_x = x_ll) 
		while((cur_x < x_ur) 
		    if(((cur_x + tile_size_x) < x_ur) then 
			(cur_width = tile_size_x) else 
			(cur_width = (x_ur - cur_x))
		    ) 
		    if(((cur_y + tile_size_y) < y_ur) then 
			(cur_height = tile_size_y) else 
			(cur_height = (y_ur - cur_y))
		    ) 
		    (tile_box = list((cur_x:cur_y) 
			    ((cur_x + cur_width):(cur_y + cur_height))
			)) 
		    (vertices = list((cur_x:cur_y) 
			    ((cur_x + cur_width):cur_y) 
			    ((cur_x + cur_width):(cur_y + cur_height)) 
			    (cur_x:(cur_y + cur_height)) 
			    (cur_x:cur_y)
			))
		    (rpath = (axlPathStart vertices 0.0)) 
		    (tile_poly = car((axlPolyFromDB rpath))) 
		    (tile_info = cons(list(tile_box tile_poly) tile_info)) 
		    (cur_x = (cur_x + tile_size_x))
		) 
		(cur_y = (cur_y + tile_size_y))
	    )
	    (tile_info = reverse(tile_info)) else 
	    (tile_box = box) 
	    (vertices = list((x_ll:y_ll) 
		    (x_ur:y_ll) 
		    (x_ur:y_ur) 
		    (x_ll:y_ur) 
		    (x_ll:y_ll)
		)) 
	    (rpath = (axlPathStart vertices 0.0))
	    (tile_poly = car((axlPolyFromDB rpath))) 
	    (tile_info = list(list(tile_box tile_poly)))
	)
	tile_info
    )
)
procedure(TBX_DERIVECONN_Get_Unconnected_Ends(cl) 
    let((endpoint_details touching_cl tcl_details loc_list xy
	    xy_str box is_connected
	) 
	(endpoint_details = TBX_DERIVECONN_Get_Point_Details(cl 
		'clineEndsOnly t
	    )) 
	foreach(entry endpoint_details 
	    (is_connected = nil) 
	    (xy = car(entry)) 
	    (box = caddr(entry))
	    (xy_str = (axlGeo2Str xy)) 
	    (axlClearSelSet) 
	    (axlSetFindFilter ?enabled 
		list("noall" "clines") ?onButtons 
		list("all")
	    ) 
	    (axlSingleSelectBox box) 
	    (touching_cl = setof(x 
		    (axlGetSelSet) 
		    (x != cl)
		))
	    foreach(tcl touching_cl 
		(tcl_details = TBX_DERIVECONN_Get_Point_Details(tcl 
			'clineEndsOnly nil
		    )) 
		foreach(tcl_entry tcl_details 
		    when(((axlGeo2Str 
				car(tcl_entry)
			    ) == xy_str) 
			(is_connected = t)
		    )
		)
	    ) 
	    unless(is_connected 
		(loc_list = cons(entry loc_list))
	    )
	) 
	(axlClearSelSet) loc_list
    )
)
procedure(TBX_DERIVECONN_Init() 
    let((radius line_width design_units marker_data layer) 
	(design_units = car((axlDBGetDesignUnits))) 
	(layer = "MANUFACTURING/TBX_DERIVECONN") 
	unless((axlIsLayer layer) 
	    (axlLayerCreateNonConductor layer)
	) 
	(radius = (axlMKSConvert "0.2 MM" design_units))
	(line_width = (axlMKSConvert "0.05 MM" design_units)) 
	(marker_data = list(nil 
		'radius radius 
		'lineWidth line_width
		'layer layer
	    )) 
	unless(boundp('tbx_deriveconn_global) 
	    iliDefstruct('defstruct(tbx_deriveconn_global_struct formId marker viewLog designExtents)) 
	    defvar(tbx_deriveconn_global nil)
	) 
	if(!tbx_deriveconn_global then 
	    (tbx_deriveconn_global = (make_tbx_deriveconn_global_struct ?formId nil ?designExtents nil
		    ?marker marker_data ?viewLog nil
		)) else 
	    (tbx_deriveconn_global->designExtents = nil)
	    (tbx_deriveconn_global->marker = marker_data) 
	    (tbx_deriveconn_global->viewLog = nil) 
	    (tbx_deriveconn_global->formId = nil)
	)
    )
)
procedure((TBX_DERIVECONN_Main \@optional arg) 
    let((info_file VERSION_STR port fid FORM_FILE
	    lic_check_result FC_FEATURE FC_VERSION SUB_VERSION record
	    layer_list
	) 
	(FC_FEATURE = "DERIVECONN") 
	(FC_VERSION = "17.1") 
	(SUB_VERSION = "03") 
	(VERSION_STR = sprintf(nil "Derive Connectivity %s (C)2017" FC_VERSION))
	(VERSION_STR = VERSION_STR) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./deriveconn_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Derive connectivity information:\n") 
		fprintf(port "===============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Derive Connectivity: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    TBX_DERIVECONN_Init() 
		    if((axlOKToProceed t) then 
			(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "deriveconn_mini")) 
			(fid = (axlMiniStatusLoad 
				gensym() FORM_FILE 
				'TBX_DERIVECONN_Callback nil
			    )) 
			(tbx_deriveconn_global->formId = fid)
			TBX_FORM_Init_Header(fid nil lic_check_result nil) 
			TBX_DERIVECONN_Build_Layer_Popup(fid) 
			(record = "deriveconn") 
			(axlFormSetField fid "layer" 
			    TBX_SESSION_Get_Param(record "layer" 
				(axlConductorTopLayer)
			    )
			) 
			(axlFormSetField fid "check_item" 
			    TBX_SESSION_Get_Param(record "check_item" "cline2all")
			)
			(axlFormSetField fid "fix_connectivity" 
			    TBX_SESSION_Get_Param(record "fix_connectivity" t)
			) 
			(axlFormSetField fid "mark_only" 
			    TBX_SESSION_Get_Param(record "mark_only" nil)
			) 
			(layer_list = TBX_UTIL_Resolve_Etch_Layers((axlFormGetField fid "layer"))) 
			TBX_DERIVECONN_Set_Visibility(layer_list) 
			(axlFormDisplay fid)
			(axlAutoOpenFindFilter) 
			TBX_DERIVECONN_Event_Loop(fid) 
			TBX_DERIVECONN_Cache_Param(fid) 
			TBX_FORM_Delete(lic_check_result FORM_FILE) else
			printf("Warning: Finish active command first\n")
		    ) 
		    printf("For additional help enter: 'tbx help deriveconn' in console window\n")
		)
	    )
	)
    )
)
procedure(TBX_DERIVECONN_Popup_Callback(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_DERIVECONN_RMB_Done
		    ) 
		    list("Cancel" 
			'TBX_DERIVECONN_RMB_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_DERIVECONN_Process_Clines() 
    (TBX_DERIVECONN_Run "All" ?checkClineCline t ?checkClinePad
	t ?checkShapePad nil
    )
)
procedure(TBX_DERIVECONN_Process_Shapes() 
    (TBX_DERIVECONN_Run "All" ?checkClineCline nil ?checkClinePad
	nil ?checkShapePad t
    )
)
procedure(TBX_DERIVECONN_RMB_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_DERIVECONN_RMB_Done() 
    (axlFinishEnterFun)
)
procedure((TBX_DERIVECONN_Run layer \@key checkClineCline checkClinePad
	checkShapePad boxWindow markOnly
    ) 
    let((design_box orgvis cur_box layer_list) 
	(orgvis = (axlVisibleGet)) 
	TBX_DERIVECONN_Init() 
	(axlDBControl 
	    'drcEnable nil
	) 
	(axlDBControl 
	    'dynamicFillMode nil
	)
	when(checkShapePad 
	    (axlDBControl 
		'dynamicFillMode 
		'wysiwyg
	    )
	) 
	(design_box = TBX_DERVIECONN_Get_Design_Extents()) 
	if(boxWindow then 
	    (cur_box = boxWindow) else 
	    (cur_box = design_box)
	) 
	(layer_list = TBX_UTIL_Resolve_Etch_Layers(layer)) 
	if(layer_list then 
	    foreach(lyr layer_list 
		when((checkClinePad || checkClineCline) 
		    TBX_DERIVECONN_Change_Line2Cline(cur_box lyr)
		) 
		when(checkClinePad 
		    TBX_DERIVECONN_Cline2Pad(cur_box lyr markOnly)
		) 
		unless(markOnly 
		    TBX_DERIVECONN_Update_Connectivity(cur_box lyr)
		)
		when(checkClineCline 
		    TBX_DERIVECONN_Cline2Cline(cur_box lyr markOnly)
		) 
		when(checkShapePad 
		    TBX_DERIVECONN_Shape2Pad(cur_box lyr markOnly)
		)
	    ) 
	    (axlVisibleSet orgvis) 
	    (axlDBControl 
		'drcEnable t
	    )
	    (axlDBControl 
		'dynamicFillMode 
		'wysiwyg
	    ) 
	    (axlVisibleUpdate t) else 
	    (axlUIConfirm "Warning: Invalid layer argument %L" layer)
	)
	t
    )
)
procedure(TBX_DERIVECONN_Set_Visibility(layer_list) 
    let((etch_layer pin_layer via_layer) 
	(axlVisibleDesign nil) 
	foreach(lyr layer_list 
	    (etch_layer = strcat("ETCH/" lyr)) 
	    (pin_layer = strcat("PIN/" lyr)) 
	    (via_layer = strcat("VIA CLASS/" lyr))
	    (axlVisibleLayer etch_layer t) 
	    (axlVisibleLayer pin_layer t) 
	    (axlVisibleLayer via_layer t)
	) 
	(axlVisibleLayer 
	    ((tbx_deriveconn_global->marker)->layer) t
	) 
	(axlDBControl 
	    'activeLayer 
	    ((tbx_deriveconn_global->marker)->layer)
	)
	(axlVisibleUpdate t)
    )
)
procedure(TBX_DERIVECONN_Shape2Pad(window_box lyr mark_only) 
    let((etch_layer pin_layer via_layer pv_set pad_source
	    pad_poly cur_cnt cur_percent cur_polys info_1
	    info_2 result tile_info tile_size tile_box
	    tile_poly tile_cnt sel_box shape_poly_data window_poly
	    pad_process_done
	) 
	(result = (axlDBCreateRectangle window_box nil 
		((tbx_deriveconn_global->marker)->layer)
	    )) 
	when(car(result) 
	    (window_poly = car((axlPolyFromDB 
			car(result)
		    )
		))
	) 
	(window_box = (window_poly->bBox)) 
	TBX_DERIVECONN_Clear_Layer(window_box 
	    ((tbx_deriveconn_global->marker)->layer)
	)
	(tile_size = (axlMKSConvert "2000.0 MILS" 
		car((axlDBGetDesignUnits))
	    )) 
	TBX_DERIVECONN_Set_Visibility(list(lyr)) 
	(etch_layer = strcat("ETCH/" lyr)) 
	(pin_layer = strcat("PIN/" lyr)) 
	(via_layer = strcat("VIA CLASS/" lyr))
	(tile_info = TBX_DERIVECONN_Get_Tile_Info(window_box tile_size)) 
	(tile_cnt = length(tile_info)) 
	(info_1 = sprintf(nil "Checking %s..." lyr)) 
	(info_2 = sprintf(nil "Tile: %d of %d" 1 tile_cnt)) 
	(axlMeterCreate "Derive Shape2Pad" info_1 t nil
	    info_2
	)
	(cur_cnt = 0) 
	(axlClearSelSet) 
	foreach(entry tile_info 
	    (tile_box = car(entry)) 
	    (tile_poly = cadr(entry)) 
	    (shape_poly_data = nil)
	    ++cur_cnt 
	    (axlSetFindFilter ?enabled 
		list("noall" "pins" "vias") ?onButtons 
		list("all")
	    ) 
	    (axlClearSelSet) 
	    (axlSingleSelectBox tile_box) 
	    when((axlGetSelSet) 
		(pv_set = (axlGetSelSet)) 
		(axlClearSelSet) 
		(pv_set = setof(pv pv_set 
			(axlGeoPointInShape 
			    (pv->xy) tile_poly
			)
		    )) 
		(sel_box = (axlDBGetExtents pv_set t))
		(axlSetFindFilter ?enabled 
		    list("noall" "noboundary_shapes" "shapes") ?onButtons 
		    list("all")
		) 
		(axlClearSelSet) 
		(axlSingleSelectBox sel_box) 
		foreach(shp 
		    (axlGetSelSet) 
		    (shape_poly_data = nconc(shape_poly_data 
			    (axlPolyFromDB shp)
			))
		) 
		(axlClearSelSet)
		(cur_polys = (axlPolyOperation shape_poly_data tile_poly 
			'AND
		    )) 
		foreach(pv pv_set 
		    (pad_process_done = nil) 
		    if(((pv->objType) == "via") then 
			(pad_source = via_layer) else 
			(pad_source = pin_layer)
		    ) 
		    (pad_poly = car((axlPolyFromDB pv ?layer pad_source ?padType
				'REGULAR
			    )
			))
		    when(pad_poly 
			foreach(spl cur_polys 
			    (result = car((axlPolyOperation spl pad_poly 
					'AND
				    )
				)) 
			    when((result && !(axlGeoPointInShape 
					    (pv->xy) spl t
					) && !pad_process_done) 
				(pad_process_done = t) 
				if(mark_only then 
				    (axlDBCreateCircle 
					list((pv->xy) 
					    ((tbx_deriveconn_global->marker)->radius)
					) 
					((tbx_deriveconn_global->marker)->lineWidth) 
					((tbx_deriveconn_global->marker)->layer)
				    ) else 
				    (axlDBCreateShape pad_poly t etch_layer 
					((pv->net)->name)
				    )
				)
			    )
			)
		    )
		)
	    )
	    (shape_poly_data = nil) 
	    (cur_polys = nil) 
	    (axlDBRefreshId nil) 
	    (cur_percent = ((100 * cur_cnt) / tile_cnt)) 
	    (info_1 = sprintf(nil "Checking %s..." lyr))
	    (info_2 = sprintf(nil "Tile:  %d of %d" cur_cnt tile_cnt)) 
	    (axlMeterUpdate cur_percent info_1 info_2)
	) 
	(axlMeterDestroy) t
    )
)
procedure(TBX_DERIVECONN_Update_Connectivity(window_box layer) 
    let((cline_data etch_layer) 
	(etch_layer = strcat((axlMapClassName "ETCH") "/" layer)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "clines") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlSingleSelectBox window_box)
	(cline_data = setof(c 
		(axlGetSelSet) 
		((c->layer) == etch_layer)
	    )) 
	(cline_data = setof(c cline_data 
		!(c->net)
	    )) 
	(axlClearSelSet) 
	when(cline_data 
	    (axlTransformObject cline_data ?move 
		(0.0:0.0)
	    )
	) 
	(axlDBRefreshId nil)
	t
    )
)
procedure(TBX_DERIVECONN_Viewlog() 
    let((out_f log_file) 
	(log_file = strcat(getWorkingDir() "/deriveconn.log")) 
	(out_f = outfile(log_file "w")) 
	foreach(item 
	    cdar((tbx_deriveconn_global->viewLog)) 
	    fprintf(out_f "%s\n" item)
	) 
	close(out_f)
	if(!isFile(log_file) then 
	    (axlUIConfirm "Unable to open file, Check Permissions!") else 
	    (axlUIViewFileCreate log_file " Derive Connectivity - Log" nil)
	)
    )
)
procedure(TBX_DERVIECONN_Get_Design_Extents() 
    let((orgvis layer_list extents) 
	(orgvis = (axlVisibleGet)) 
	(axlVisibleDesign nil) 
	(layer_list = list(strcat((axlMapClassName "BOARD GEOMETRY") "/DESIGN_OUTLINE") 
		strcat((axlMapClassName "BOARD GEOMETRY") "/OUTLINE") 
		strcat((axlMapClassName "ROUTE KEEPIN") "/ALL") 
		strcat((axlMapClassName "PACKAGE KEEPIN") "/ALL")
	    )) 
	foreach(lyr layer_list 
	    when((axlIsLayer lyr) 
		(axlVisibleLayer lyr t)
	    )
	)
	(axlSetFindFilter ?enabled 
	    list("noall" "lines" "shapes") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	when((axlGetSelSet) 
	    (extents = (axlDBGetExtents 
		    (axlGetSelSet) nil
		))
	) 
	(axlClearSelSet)
	(axlVisibleSet orgvis) 
	(axlVisibleUpdate nil) 
	unless(extents 
	    (extents = ((axlGetParam "paramDesign")->bBox))
	) extents
    )
)
procedure(TBX_DESCOMPARE_Cache_Param(form_handle) 
    let((rec session_param master_units) 
	(rec = "descompare") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	(master_units = (axlFormGetField form_handle "master_units"))
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "first_dsn") 
	    stringToSymbol("first_dsn")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "second_dsn") 
	    stringToSymbol("second_dsn")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "standard_compare") 
	    stringToSymbol("standard_compare")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "layer_compare") 
	    stringToSymbol("layer_compare")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "use_previous_session") 
	    stringToSymbol("use_previous_session")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "create_new_database") 
	    stringToSymbol("create_new_database")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "diff_dsn") 
	    stringToSymbol("diff_dsn")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "use_default_artwork") 
	    stringToSymbol("use_default_artwork")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "undef_photo_width") 
	    stringToSymbol("undef_photo_width")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "undef_line_width") 
	    stringToSymbol("undef_line_width")
	)
	putprop(session_param[rec] master_units 
	    stringToSymbol("master_units")
	) 
	putprop(session_param[rec] master_units 
	    'units
	) t
    )
)
procedure(TBX_DESCOMPARE_Copy_Designs() 
    let((arr_v1 arr_v2 okay_v1 okay_v2 v1_design
	    v2_design v1_path v2_path result
	) 
	(arr_v1 = (axlDMFileParts 
		((tbx_descompare_data->dbInfo)["v1"]->designPath)
	    )) 
	(arr_v2 = (axlDMFileParts 
		((tbx_descompare_data->dbInfo)["v2"]->designPath)
	    )) 
	(v1_design = strcat("v1." 
		nth(3 arr_v1)
	    )) 
	(v2_design = strcat("v2." 
		nth(3 arr_v2)
	    ))
	(v1_path = strcat(((tbx_descompare_data->session)->runDirAbs) "/" v1_design)) 
	(v2_path = strcat(((tbx_descompare_data->session)->runDirAbs) "/" v2_design)) 
	(okay_v1 = (axlOSFileCopy 
		((tbx_descompare_data->dbInfo)["v1"]->designPath) v1_path nil
	    )) 
	(okay_v2 = (axlOSFileCopy 
		((tbx_descompare_data->dbInfo)["v2"]->designPath) v2_path nil
	    )) 
	unless(okay_v1 
	    printf("Error: Could not copy database to %L\n" v1_path)
	)
	unless(okay_v2 
	    printf("Error: Could not copy database to %L\n" v2_path)
	) 
	if((okay_v1 && okay_v2) then 
	    (result = list(v1_design v2_design)) else 
	    (result = nil)
	) result
    )
)
procedure(TBX_DESCOMPARE_Dump() 
    let((port dump_file) 
	if(boundp('tbx_descompare_data) then 
	    (dump_file = strcat(getWorkingDir() "/tbx_descompare_dump.txt")) 
	    (port = outfile(dump_file "w")) 
	    fprintf(port "\n")
	    fprintf(port "=================\n") 
	    fprintf(port "dbInfo[\"v1\"]\n") 
	    fprintf(port "=================\n") 
	    fprintf(port "   ->designPath:   %L\n" 
		((tbx_descompare_data->dbInfo)["v1"]->designPath)
	    ) 
	    fprintf(port "   ->filmLayers:   \n   ")
	    pprint(((tbx_descompare_data->dbInfo)["v1"]->filmLayers) port) 
	    fprintf(port "\n") 
	    fprintf(port "   ->ipcLayerInfo: (tableToList)\n   ") 
	    when(((tbx_descompare_data->dbInfo)["v1"]->ipcLayerInfo) 
		pprint(tableToList(((tbx_descompare_data->dbInfo)["v1"]->ipcLayerInfo)) port)
	    ) 
	    fprintf(port "   ->extents:   %L\n" 
		((tbx_descompare_data->dbInfo)["v1"]->extents)
	    )
	    fprintf(port "   ->units:     %L\n" 
		((tbx_descompare_data->dbInfo)["v1"]->units)
	    ) 
	    fprintf(port "   ->accuracy:  %L\n" 
		((tbx_descompare_data->dbInfo)["v1"]->accuracy)
	    ) 
	    fprintf(port "\n") 
	    fprintf(port "\n") 
	    fprintf(port "=================\n")
	    fprintf(port "dbInfo[\"v2\"]\n") 
	    fprintf(port "=================\n") 
	    fprintf(port "   ->designPath:   %L\n" 
		((tbx_descompare_data->dbInfo)["v2"]->designPath)
	    ) 
	    fprintf(port "   ->filmLayers:   \n   ") 
	    pprint(((tbx_descompare_data->dbInfo)["v2"]->filmLayers) port)
	    fprintf(port "\n") 
	    fprintf(port "   ->ipcLayerInfo: (tableToList)\n   ") 
	    when(((tbx_descompare_data->dbInfo)["v2"]->ipcLayerInfo) 
		pprint(tableToList(((tbx_descompare_data->dbInfo)["v2"]->ipcLayerInfo)) port)
	    ) 
	    fprintf(port "   ->extents:   %L\n" 
		((tbx_descompare_data->dbInfo)["v2"]->extents)
	    ) 
	    fprintf(port "   ->units:     %L\n" 
		((tbx_descompare_data->dbInfo)["v2"]->units)
	    )
	    fprintf(port "   ->accuracy:  %L\n" 
		((tbx_descompare_data->dbInfo)["v2"]->accuracy)
	    ) 
	    fprintf(port "\n") 
	    fprintf(port "\n") 
	    fprintf(port "=================\n") 
	    fprintf(port "Session data\n")
	    fprintf(port "=================\n") 
	    pprint((tbx_descompare_data->session) port) 
	    fprintf(port "\n") 
	    fprintf(port "\n") 
	    fprintf(port "=======================\n")
	    fprintf(port "Layer set (tableToList)\n") 
	    fprintf(port "=======================\n") 
	    pprint(tableToList((tbx_descompare_data->layerSet)) port) 
	    fprintf(port "\n") 
	    fprintf(port "\n")
	    close(port) 
	    printf("Note: File %L has been written\n" dump_file) else 
	    printf("Record data does not exist yet\n")
	) t
    )
)
procedure(TBX_DESCOMPARE_GEN_Compare_Launch() 
    let((raw_file_v1 raw_file_v2 cur_dir report_data port
	    raw_data_v1 raw_data_v2 continue master_units html_report
	    raw_report
	) 
	(master_units = ((tbx_descompare_data->session)->masterUnits)) 
	(raw_file_v1 = strcat(((tbx_descompare_data->session)->runDirAbs) "/descompare_v1_raw.txt")) 
	(raw_file_v2 = strcat(((tbx_descompare_data->session)->runDirAbs) "/descompare_v2_raw.txt")) 
	TBX_UTIL_No_Confirm((tbx_descompare_data->env) "set")
	(continue = TBX_DESCOMPARE_Save_Design_Prompt()) 
	when(continue 
	    ((tbx_descompare_data->session)->tmpDesigns = TBX_DESCOMPARE_Copy_Designs())
	) 
	when(((tbx_descompare_data->session)->tmpDesigns) 
	    (cur_dir = getWorkingDir()) 
	    changeWorkingDir(((tbx_descompare_data->session)->runDirAbs)) 
	    (axlOpenDesign ?design 
		car(((tbx_descompare_data->session)->tmpDesigns)) ?mode "wf"
	    ) 
	    (axlShell "show element; done")
	    (raw_data_v1 = TBX_DESCOMPARE_GEN_Extract_Data(master_units)) 
	    (axlSaveDesign ?noConfirm t ?design 
		car(((tbx_descompare_data->session)->tmpDesigns))
	    ) 
	    (axlOpenDesign ?design 
		cadr(((tbx_descompare_data->session)->tmpDesigns)) ?mode "wf"
	    ) 
	    (axlShell "show element; done") 
	    (raw_data_v2 = TBX_DESCOMPARE_GEN_Extract_Data(master_units))
	    (axlSaveDesign ?noConfirm t ?design 
		cadr(((tbx_descompare_data->session)->tmpDesigns))
	    ) 
	    changeWorkingDir(cur_dir) 
	    (axlOpenDesign ?design 
		((tbx_descompare_data->session)->masterDesign) ?mode "wf"
	    ) 
	    (axlShell "show element; done") 
	    when(axlGetVariable("FLW_DEBUG") 
		foreach(entry 
		    list(list(raw_data_v1 raw_file_v1) 
			list(raw_data_v2 raw_file_v2)
		    ) 
		    (port = outfile(cadr(entry) "w")) 
		    pprint(car(entry) port) 
		    close(port)
		    printf("Note: File %L has been written\n" 
			cadr(entry)
		    )
		)
	    )
	    (report_data = tconc(nil nil)) 
	    tconc(report_data 
		list(list(nil 
			'name "general" 
			'title "General"
		    ) 
		    list(list(nil 
			    'name "general_info" 
			    'title "Database Info"
			    'help "General information"
			) 
			list("Date" 
			    getCurrentTime()
			) 
			list("Design V1" 
			    ((tbx_descompare_data->dbInfo)["v1"]->designPath)
			) 
			list("Design V2" 
			    ((tbx_descompare_data->dbInfo)["v2"]->designPath)
			) 
			list("Report Units" 
			    ((tbx_descompare_data->session)->masterUnits)
			)
		    )
		)
	    ) 
	    ((tbx_descompare_data->session)->meterStepCnt = 22) 
	    ((tbx_descompare_data->session)->meterCurStep = 1) 
	    (axlMeterCreate "Design Compare" "" "" nil)
	    tconc(report_data 
		TBX_DESCOMPARE_GEN_Process_Stackup(raw_data_v1 raw_data_v2)
	    ) 
	    tconc(report_data 
		TBX_DESCOMPARE_GEN_Process_Nets(raw_data_v1 raw_data_v2)
	    ) 
	    tconc(report_data 
		TBX_DESCOMPARE_GEN_Process_Parts(raw_data_v1 raw_data_v2)
	    ) 
	    tconc(report_data 
		TBX_DESCOMPARE_GEN_Process_Mechanical(raw_data_v1 raw_data_v2)
	    ) 
	    when(report_data 
		(report_data = cdar(report_data)) 
		when(axlGetVariable("FLW_DEBUG") 
		    (raw_report = strcat(((tbx_descompare_data->session)->runDirAbs) "/descompare_report_data.txt")) 
		    (port = outfile(raw_report "w")) 
		    pprint(report_data port) 
		    close(port)
		    printf("Writing report master data to file: %L\n" raw_report)
		) 
		TBX_DESCOMPARE_GEN_Update_Meter("Write HTML report") 
		(html_report = strcat(getWorkingDir() "/design_compare.html"))
		TBX_DESCOMPARE_GEN_Write_HTML_Report(report_data html_report) 
		when((isFile(html_report) && isReadable(html_report) && !axlGetVariable("TBX_PV_REGRESSION")) 
		    (axlShell 
			sprintf(nil "http %L" html_report)
		    )
		)
	    )
	    (axlMeterDestroy)
	) 
	TBX_UTIL_No_Confirm((tbx_descompare_data->env) "reset") t
    )
)
procedure(TBX_DESCOMPARE_GEN_Compare_Stackup_Attributes(v1_attr v2_attr prefix disp_name) 
    let((result) 
	(result = tconc(nil nil)) 
	when((car(v1_attr) != car(v2_attr)) 
	    tconc(result 
		list(sprintf(nil "%s  %s name" prefix disp_name) 
		    car(v1_attr) 
		    car(v2_attr)
		)
	    )
	) 
	when((cadr(v1_attr) != cadr(v2_attr)) 
	    tconc(result 
		list(sprintf(nil "%s  %s type" prefix disp_name) 
		    cadr(v1_attr) 
		    cadr(v2_attr)
		)
	    )
	) 
	when((caddr(v1_attr) != caddr(v2_attr)) 
	    tconc(result 
		list(sprintf(nil "%s  %s material" prefix disp_name) 
		    caddr(v1_attr) 
		    caddr(v2_attr)
		)
	    )
	)
	when((nth(3 v1_attr) != 
		nth(3 v2_attr)) 
	    tconc(result 
		list(sprintf(nil "%s  %s thickness" prefix disp_name) 
		    nth(3 v1_attr) 
		    nth(3 v2_attr)
		)
	    )
	) 
	when((nth(4 v1_attr) != 
		nth(4 v2_attr)) 
	    tconc(result 
		list(sprintf(nil "%s  %s dielectric constant" prefix disp_name) 
		    nth(4 v1_attr) 
		    nth(4 v2_attr)
		)
	    )
	) 
	when((nth(5 v1_attr) != 
		nth(5 v2_attr)) 
	    tconc(result 
		list(sprintf(nil "%s  %s artwork" prefix disp_name) 
		    nth(5 v1_attr) 
		    nth(5 v2_attr)
		)
	    )
	) 
	when((nth(6 v1_attr) != 
		nth(6 v2_attr)) 
	    tconc(result 
		list(sprintf(nil "%s  %s shield" prefix disp_name) 
		    nth(6 v1_attr) 
		    nth(6 v2_attr)
		)
	    )
	) 
	(result = cdar(result))
    )
)
procedure(TBX_DESCOMPARE_GEN_Extract_Data(master_units) 
    let((lay_id lay_id_str lay_name lay_type lay_mat
	    lay_thick lay_epsr lay_neg lay_shield stackup_section
	    pinInfo tpInfo viaCnt netInfo net_name
	    pin_des net_names net_section probe_info tp_x
	    tp_y tp_xy_str tp_side tp_probe cur_value
	    dummy_clines nc_etch_length all_pins_vias design_units class_dbid
	    dummy_net data probeNumbers compInfo comp_section
	    cur_info is_mirror refdes refdes_names sym_x
	    sym_y xy_str mech_symbols mech_section mechInfoList
	    comp_value comp_part_number func_path func_section func_info
	    prop_info attribute_info
	) 
	(axlDBRefreshId nil) 
	(design_units = car((axlDBGetDesignUnits))) 
	(pinInfo = makeTable("pin_list_data" nil)) 
	(viaCnt = makeTable("via_cnt_info" 0))
	(netInfo = makeTable("netInfo_data" nil)) 
	(lay_id = 0) 
	foreach(entry 
	    (axlGetXSection) 
	    (lay_name = car(entry)) 
	    (lay_type = cadr(entry)) 
	    (lay_mat = caddr(entry))
	    (lay_thick = nth(3 entry)) 
	    (lay_epsr = nth(6 entry)) 
	    (lay_neg = nth(7 entry)) 
	    (lay_shield = nth(8 entry)) 
	    (lay_id_str = sprintf(nil "%03d" lay_id))
	    (lay_thick = (axlGeo2Str 
		    (axlMKSConvert lay_thick master_units)
		)) 
	    if(((lay_type == "PLANE") || (lay_type == "CONDUCTOR")) then 
		if(lay_neg then 
		    (lay_neg = "NEGATIVE") else 
		    (lay_neg = "POSITIVE")
		) 
		if(lay_shield then 
		    (lay_shield = "YES") else 
		    (lay_shield = "NO")
		) else
		(lay_neg = "") 
		(lay_shield = "")
	    ) 
	    (stackup_section = cons(list(lay_id_str lay_name lay_type lay_mat lay_thick
			lay_epsr lay_neg lay_shield
		    ) stackup_section
		)) 
	    ++lay_id
	) 
	(stackup_section = reverse(stackup_section)) 
	(stackup_section = cons('stackup stackup_section))
	(pinInfo = makeTable("pin_list_data" nil)) 
	foreach(pin 
	    (axlSelectByName "PIN" "*.*" t) 
	    (net_name = ((pin->net)->name)) 
	    (pin_des = strcat(((pin->component)->name) "." 
		    (pin->number)
		)) 
	    (pinInfo[net_name] = cons(pin_des 
		    pinInfo[net_name]
		))
	) 
	foreach(n pinInfo 
	    (pinInfo[n] = sort(pinInfo[n] nil))
	) 
	(tpInfo = makeTable("testpoint_details_info" nil)) 
	(probeNumbers = makeTable("testpoint_probe_numbers" nil))
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "pins" "vias") ?onButtons 
	    list("all")
	) 
	(axlAddSelectAll) 
	(all_pins_vias = (axlGetSelSet)) 
	(axlClearSelSet)
	foreach(pv 
	    setof(x all_pins_vias 
		((x->objType) == "via")
	    ) 
	    (net_name = ((pv->net)->name)) 
	    unless(net_name 
		(net_name = "")
	    ) 
	    (viaCnt[net_name] = (viaCnt[net_name] + 1))
	) 
	foreach(pv 
	    setof(x all_pins_vias 
		(x->testPoint)
	    ) 
	    (net_name = ((pv->net)->name)) 
	    unless(net_name 
		(net_name = "")
	    ) 
	    (tp_x = (axlMKSConvert 
		    car((pv->xy)) design_units master_units
		))
	    (tp_y = (axlMKSConvert 
		    cadr((pv->xy)) design_units master_units
		)) 
	    (tp_xy_str = (axlGeo2Str 
		    (tp_x:tp_y)
		)) 
	    (tp_side = cadr(parseString((pv->testPoint) "/"))) 
	    (probe_info = setof(x 
		    (axlDBGetAttachedText pv) 
		    (((x->layer) == "MANUFACTURING/PROBE_TOP") || ((x->layer) == "MANUFACTURING/PROBE_BOTTOM"))
		)) 
	    if(probe_info then 
		(tp_probe = (car(probe_info)->text)) else 
		(tp_probe = "")
	    )
	    (tpInfo[net_name] = cons(list(tp_xy_str tp_probe tp_side) 
		    tpInfo[net_name]
		)) 
	    when((tp_probe != "") 
		(probeNumbers[net_name] = cons(tp_probe 
			probeNumbers[net_name]
		    ))
	    )
	) 
	foreach(n probeNumbers 
	    (probeNumbers[n] = sort(probeNumbers[n] nil))
	) 
	foreach(n 
	    ((axlDBGetDesign)->nets) 
	    (net_name = (n->name)) 
	    (netInfo[net_name] = tconc(nil nil)) 
	    when(pinInfo[net_name] 
		(cur_value = pinInfo[net_name]) 
		tconc(netInfo[net_name] 
		    cons('pins cur_value)
		)
	    )
	    when(tpInfo[net_name] 
		(cur_value = tpInfo[net_name]) 
		tconc(netInfo[net_name] 
		    cons('testpoints cur_value)
		)
	    ) 
	    when(probeNumbers[net_name] 
		(cur_value = probeNumbers[net_name]) 
		tconc(netInfo[net_name] 
		    cons('probeNumbers cur_value)
		)
	    ) 
	    (attribute_info = nil) 
	    when((axlNetClassGet n 
		    'spacing t
		) 
		(class_dbid = (axlNetClassGet n 
			'spacing t
		    )) 
		(cur_value = (class_dbid->name)) 
		(attribute_info = cons(list('spacingClass cur_value) attribute_info))
	    ) 
	    when((axlNetClassGet n 
		    'physical t
		) 
		(class_dbid = (axlNetClassGet n 
			'physical t
		    )) 
		(cur_value = (class_dbid->name)) 
		(attribute_info = cons(list('physicalClass cur_value) attribute_info))
	    )
	    when((axlNetClassGet n 
		    'electrical t
		) 
		(class_dbid = (axlNetClassGet n 
			'electrical t
		    )) 
		(cur_value = (class_dbid->name)) 
		(attribute_info = cons(list('electricalClass cur_value) attribute_info))
	    ) 
	    when(((n->prop)->NO_TEST) 
		(cur_value = "YES") 
		(attribute_info = cons(list('NO_TEST cur_value) attribute_info))
	    ) 
	    when(((n->prop)->TESTPOINT_QUANTITY) 
		(cur_value = ((n->prop)->TESTPOINT_QUANTITY)) 
		(attribute_info = cons(list('TESTPOINT_QUANTITY cur_value) attribute_info))
	    ) 
	    when(((n->prop)->VOLTAGE) 
		(cur_value = ((n->prop)->VOLTAGE)) 
		(attribute_info = cons(list('VOLTAGE cur_value) attribute_info))
	    ) 
	    (attribute_info = reverse(attribute_info))
	    when(attribute_info 
		tconc(netInfo[net_name] 
		    cons('attribute attribute_info)
		)
	    ) 
	    tconc(netInfo[net_name] 
		list('viaCnt 
		    sprintf(nil "%d" 
			viaCnt[net_name]
		    )
		)
	    ) 
	    (cur_value = "0.0") 
	    when((axlDBGetLength n) 
		(cur_value = (axlGeo2Str 
			(axlDBGetLength n)
		    ))
	    ) 
	    tconc(netInfo[net_name] 
		list('etchLength cur_value)
	    )
	    (netInfo[net_name] = cdar(netInfo[net_name]))
	) 
	(dummy_net = "")
	(netInfo[dummy_net] = tconc(nil nil)) 
	when(pinInfo[dummy_net] 
	    (cur_value = pinInfo[dummy_net]) 
	    tconc(netInfo[dummy_net] 
		cons('pins cur_value)
	    )
	) 
	when(tpInfo[dummy_net] 
	    (cur_value = tpInfo[dummy_net]) 
	    tconc(netInfo[dummy_net] 
		cons('testpoints cur_value)
	    )
	) 
	when(probeNumbers[dummy_net] 
	    (cur_value = probeNumbers[dummy_net]) 
	    tconc(netInfo[dummy_net] 
		cons('probeNumbers cur_value)
	    )
	) 
	when(viaCnt[dummy_net] 
	    (cur_value = sprintf(nil "%d" 
		    viaCnt[dummy_net]
		)) 
	    tconc(netInfo[dummy_net] 
		list('viaCnt cur_value)
	    )
	)
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "clines") ?onButtons 
	    list("all")
	) 
	(axlAddSelectAll) 
	(dummy_clines = setof(x 
		(axlGetSelSet) 
		!(x->net)
	    )) 
	(axlClearSelSet)
	(nc_etch_length = 0.0) 
	foreach(p dummy_clines 
	    (nc_etch_length = (nc_etch_length + (axlDBGetLength p)))
	) 
	(nc_etch_length = (axlMKSConvert nc_etch_length design_units master_units)) 
	tconc(netInfo[dummy_net] 
	    list('etchLength 
		(axlGeo2Str nc_etch_length)
	    )
	) 
	(netInfo[dummy_net] = cdar(netInfo[dummy_net]))
	(net_names = TBX_UTIL_Get_Hash_Keys(pinInfo t)) 
	(net_section = tconc(nil nil)) 
	tconc(net_section 
	    'nets
	) 
	foreach(n net_names 
	    tconc(net_section 
		cons(n 
		    netInfo[n]
		)
	    )
	) 
	(net_section = cdar(net_section))
	(compInfo = makeTable("component_info_data" nil)) 
	foreach(cmp 
	    ((axlDBGetDesign)->components) 
	    (comp_value = nil) 
	    (comp_part_number = nil) 
	    (refdes = (cmp->name))
	    (compInfo[refdes] = tconc(nil nil)) 
	    tconc(compInfo[refdes] 
		list('footprint 
		    (cmp->package)
		)
	    ) 
	    if((cmp->symbol) then 
		(sym_x = (axlMKSConvert 
			car(((cmp->symbol)->xy)) design_units master_units
		    )) 
		(sym_y = (axlMKSConvert 
			cadr(((cmp->symbol)->xy)) design_units master_units
		    )) 
		tconc(compInfo[refdes] 
		    list('xy 
			(axlGeo2Str 
			    (sym_x:sym_y)
			)
		    )
		)
		if(((cmp->symbol)->isMirrored) then 
		    tconc(compInfo[refdes] 
			list('isMirrored "YES")
		    ) else 
		    tconc(compInfo[refdes] 
			list('isMirrored "NO")
		    )
		) 
		tconc(compInfo[refdes] 
		    list('rotation 
			(axlGeo2Str 
			    ((cmp->symbol)->rotation)
			)
		    )
		) else 
		tconc(compInfo[refdes] 
		    list('xy "Unplaced")
		) 
		tconc(compInfo[refdes] 
		    list('isMirrored "Unplaced")
		)
		tconc(compInfo[refdes] 
		    list('rotation "Unplaced")
		)
	    ) 
	    tconc(compInfo[refdes] 
		list('deviceType 
		    (cmp->deviceType)
		)
	    ) 
	    tconc(compInfo[refdes] 
		list('class 
		    (cmp->class)
		)
	    )
	    (prop_info = nil) 
	    (comp_value = nil) 
	    when((((cmp->compdef)->prop)->VALUE) 
		(comp_value = (((cmp->compdef)->prop)->VALUE))
	    ) 
	    when(((cmp->prop)->VALUE) 
		(comp_value = ((cmp->prop)->VALUE))
	    ) 
	    when(comp_value 
		(prop_info = cons(list('VALUE comp_value) prop_info))
	    )
	    (comp_part_number = nil) 
	    when((((cmp->compdef)->prop)->PART_NUMBER) 
		(comp_part_number = (((cmp->compdef)->prop)->PART_NUMBER))
	    ) 
	    when(((cmp->prop)->PART_NUMBER) 
		(comp_part_number = ((cmp->prop)->PART_NUMBER))
	    ) 
	    when(comp_part_number 
		(prop_info = cons(list('PART_NUMBER comp_part_number) prop_info))
	    ) 
	    (prop_info = reverse(prop_info))
	    when(prop_info 
		tconc(compInfo[refdes] 
		    cons('attribute prop_info)
		)
	    ) 
	    (func_info = nil) 
	    foreach(f 
		(cmp->functions) 
		(func_section = nil) 
		(func_path = nil) 
		when(((f->prop)->SECTION) 
		    (func_section = ((f->prop)->SECTION))
		)
		unless(func_section 
		    (func_section = "")
		) 
		when(((f->prop)->LOGICAL_PATH) 
		    (func_path = ((f->prop)->LOGICAL_PATH))
		) 
		when(func_path 
		    (func_info = cons(list(func_section func_path) func_info))
		)
	    ) 
	    when(func_info 
		(func_info = sortcar(func_info nil))
	    ) 
	    tconc(compInfo[refdes] 
		cons('logicalPath func_info)
	    )
	    (compInfo[refdes] = cdar(compInfo[refdes]))
	) 
	(refdes_names = TBX_UTIL_Get_Hash_Keys(compInfo t)) 
	(comp_section = tconc(nil nil)) 
	tconc(comp_section 
	    'components
	)
	foreach(r refdes_names 
	    tconc(comp_section 
		cons(r 
		    compInfo[r]
		)
	    )
	) 
	(comp_section = cdar(comp_section)) 
	(mech_symbols = setof(x 
		((axlDBGetDesign)->symbols) 
		(upperCase((x->type)) == "MECHANICAL")
	    )) 
	foreach(sym mech_symbols 
	    (sym_x = (axlMKSConvert 
		    car((sym->xy)) design_units master_units
		)) 
	    (sym_y = (axlMKSConvert 
		    cadr((sym->xy)) design_units master_units
		)) 
	    (xy_str = (axlGeo2Str 
		    (sym_x:sym_y)
		))
	    if((sym->isMirrored) then 
		(is_mirror = "YES") else 
		(is_mirror = "NO")
	    ) 
	    (cur_info = list((sym->name) 
		    list('xy xy_str) 
		    list('rotation 
			(axlGeo2Str 
			    (sym->rotation)
			)
		    ) 
		    list('isMirrored is_mirror)
		)) 
	    (mechInfoList = cons(cur_info mechInfoList))
	) 
	(mechInfoList = sortcar(mechInfoList nil))
	(mech_section = cons('mechanical mechInfoList)) 
	(data = list(stackup_section net_section comp_section mech_section)) data
    )
)
procedure(TBX_DESCOMPARE_GEN_Get_Net_Display_String(net) 
    let((disp_name) 
	when(net 
	    (disp_name = net) 
	    when((disp_name == "") 
		(disp_name = "Unconnected (NC)")
	    )
	) disp_name
    )
)
procedure(TBX_DESCOMPARE_GEN_Get_Part_Description_Display_String(comp_info) 
    let((dev_type part_number value footprint part_display_str) 
	if(comp_info then 
	    (dev_type = "-") 
	    (part_number = "-") 
	    (value = "-")
	    (footprint = "-") 
	    when((comp_info->deviceType) 
		(dev_type = (comp_info->deviceType))
	    ) 
	    when(((comp_info->attribute)->VALUE) 
		(value = ((comp_info->attribute)->VALUE))
	    ) 
	    when(((comp_info->attribute)->PART_NUMBER) 
		(part_number = ((comp_info->attribute)->PART_NUMBER))
	    ) 
	    when((comp_info->footprint) 
		(footprint = (comp_info->footprint))
	    )
	    (part_display_str = buildString(list(dev_type part_number value footprint) "\n\n")) else 
	    (part_display_str = "-")
	) part_display_str
    )
)
procedure(TBX_DESCOMPARE_GEN_Get_Part_Location_Display_String(comp_info) 
    let((xy side rotation loc_display_str) 
	if(comp_info then 
	    (xy = "-") 
	    (side = "-") 
	    (rotation = "-")
	    if(((comp_info->xy) != "Unplaced") then 
		(xy = (comp_info->xy)) 
		if(((comp_info->isMirrored) == "YES") then 
		    (side = "BOTTOM") else 
		    (side = "TOP")
		) 
		(rotation = (comp_info->rotation))
		(loc_display_str = sprintf(nil "(%s)\n\n%s\n\n%s" xy side rotation)) else 
		(loc_display_str = "Unplaced")
	    ) else 
	    (loc_display_str = "-")
	) loc_display_str
    )
)
procedure(TBX_DESCOMPARE_GEN_Process_Mechanical(v1_data v2_data) 
    let((v1_mech_data v2_mech_data cur_data tag_name cur_name
	    cur_attr tmp_data summary mech_all mech_top
	    mech_bottom report_data mechInfo combined_mech combined_loc
	    mloc_v1 mloc_v2 loc_str v1_value v2_value
	    diff_note
	) 
	foreach(sec v1_data 
	    when((car(sec) == 'mechanical) 
		(v1_mech_data = cdr(sec))
	    )
	) 
	foreach(sec v2_data 
	    when((car(sec) == 'mechanical) 
		(v2_mech_data = cdr(sec))
	    )
	) 
	TBX_DESCOMPARE_GEN_Update_Meter("Parse mechanical symbols") 
	(mechInfo = makeTable("mech_info_data" nil))
	(mechInfo["v1"] = makeTable("mech_info_v1_data" nil)) 
	(mechInfo["v2"] = makeTable("mech_info_v2_data" nil)) 
	foreach(entry 
	    list(list(v1_mech_data "v1") 
		list(v2_mech_data "v2")
	    ) 
	    (cur_data = car(entry)) 
	    (tag_name = cadr(entry)) 
	    foreach(msec cur_data 
		(cur_name = car(msec)) 
		(cur_attr = ncons(nil)) 
		foreach(asec 
		    cdr(msec) 
		    putprop(cur_attr 
			cadr(asec) 
			car(asec)
		    )
		)
		(mechInfo[tag_name][cur_name] = cons(cur_attr 
			mechInfo[tag_name][cur_name]
		    )) 
		unless(exists(x combined_mech 
			(x == cur_name)
		    ) 
		    (combined_mech = cons(cur_name combined_mech))
		)
	    )
	) 
	(combined_mech = sort(combined_mech nil)) 
	(summary = makeTable("summary_table_data" nil))
	TBX_DESCOMPARE_GEN_Update_Meter("Mechanical summary") 
	foreach(tag 
	    list("v1" "v2") 
	    (mech_all = list()) 
	    (mech_top = list()) 
	    (mech_bottom = list())
	    foreach(m 
		mechInfo[tag] 
		foreach(dpl 
		    mechInfo[tag][m] 
		    (mech_all = cons(m mech_all)) 
		    if(((dpl->isMirrored) == "YES") then 
			(mech_bottom = cons(m mech_bottom)) else 
			(mech_top = cons(m mech_top))
		    )
		)
	    ) 
	    (mech_all = sort(mech_all nil)) 
	    (mech_top = sort(mech_top nil)) 
	    (mech_bottom = sort(mech_bottom nil)) 
	    (summary[tag] = ncons(nil))
	    (summary[tag]->mechAll = mech_all) 
	    (summary[tag]->mechTop = mech_top) 
	    (summary[tag]->mechBottom = mech_bottom)
	) 
	(report_data = tconc(nil nil)) 
	(tmp_data = list(list(nil 
		    'name "mechanical_summary" 
		    'title "Summary"
		    'tableHeader 
		    list("  " "Design V1" "Design V2")
		) 
		list("Mechanical" 
		    sprintf(nil "%d" 
			length((summary["v1"]->mechAll))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->mechAll))
		    )
		) 
		list("TOP side" 
		    sprintf(nil "%d" 
			length((summary["v1"]->mechTop))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->mechTop))
		    )
		) 
		list("BOTTOM side" 
		    sprintf(nil "%d" 
			length((summary["v1"]->mechBottom))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->mechBottom))
		    )
		)
	    )) 
	tconc(report_data tmp_data)
	TBX_DESCOMPARE_GEN_Update_Meter("Mechanical symbols compare") 
	(tmp_data = nil) 
	foreach(m combined_mech 
	    cond(((mechInfo["v1"][m] && !mechInfo["v2"][m]) 
		    foreach(atr 
			mechInfo["v1"][m] 
			(v1_value = strcat((atr->xy) "\n" 
				(atr->rotation) "\n" 
				(atr->isMirrored)
			    )) 
			(v2_value = "-") 
			(diff_note = sprintf(nil "Mechnical Symbol deleted (V1 only)"))
			(tmp_data = cons(list(m v1_value v2_value diff_note) tmp_data))
		    )
		) 
		((!mechInfo["v1"][m] && mechInfo["v2"][m]) 
		    foreach(atr 
			mechInfo["v2"][m] 
			(v1_value = "-") 
			(v2_value = strcat((atr->xy) "\n" 
				(atr->rotation) "\n" 
				(atr->isMirrored)
			    )) 
			(diff_note = sprintf(nil "Mechanical Symbol added (V2 only)"))
			(tmp_data = cons(list(m v1_value v2_value diff_note) tmp_data))
		    )
		) 
		((mechInfo["v1"][m] && mechInfo["v2"][m]) 
		    (combined_loc = nil) 
		    (mloc_v1 = makeTable("mech_phys_table_data_v1" nil)) 
		    (mloc_v2 = makeTable("mech_phys_table_data_v2" nil)) 
		    foreach(atr 
			mechInfo["v1"][m] 
			(loc_str = strcat((atr->xy) "!" 
				(atr->rotation) "!" 
				(atr->isMirrored)
			    )) 
			(mloc_v1[loc_str] = atr) 
			unless(exists(x combined_loc 
				(x == loc_str)
			    ) 
			    (combined_loc = cons(loc_str combined_loc))
			)
		    )
		    foreach(atr 
			mechInfo["v2"][m] 
			(loc_str = strcat((atr->xy) "!" 
				(atr->rotation) "!" 
				(atr->isMirrored)
			    )) 
			(mloc_v2[loc_str] = atr) 
			unless(exists(x combined_loc 
				(x == loc_str)
			    ) 
			    (combined_loc = cons(loc_str combined_loc))
			)
		    ) 
		    (combined_loc = sort(combined_loc nil)) 
		    foreach(key combined_loc 
			(diff_note = nil) 
			cond(((mloc_v1[key] && !mloc_v2[key]) 
				(v1_value = sprintf(nil "%s\n%s\n%s" 
					(mloc_v1[key]->xy) 
					(mloc_v1[key]->rotation) 
					(mloc_v1[key]->isMirrored)
				    )) 
				(v2_value = "-") 
				(diff_note = "Placement changed")
			    ) 
			    ((!mloc_v1[key] && mloc_v2[key]) 
				(v1_value = "-") 
				(v2_value = sprintf(nil "%s\n%s\n%s" 
					(mloc_v2[key]->xy) 
					(mloc_v2[key]->rotation) 
					(mloc_v2[key]->isMirrored)
				    )) 
				(diff_note = "Placement changed")
			    ) 
			    (t t)
			) 
			when(diff_note 
			    (tmp_data = cons(list(m v1_value v2_value diff_note) tmp_data))
			)
		    )
		)
	    )
	) 
	when(tmp_data 
	    (tmp_data = reverse(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "mechanical_compare" 
			'title "Mechanical Symbol Changes"
			'tableHeader 
			list("Symbol" "Design V1\n(xy side angle)" "Design V2\n(xy side angle)" "Note")
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	) 
	(report_data = cdar(report_data))
	(report_data = cons(list(nil 
		    'name "mech_symbols" 
		    'title "Mechanical"
		) report_data
	    )) report_data
    )
)
procedure(TBX_DESCOMPARE_GEN_Process_Nets(v1_net_data v2_net_data) 
    let((pinCon report_data cur_net net_names summary
	    one_pin_nets combined_nets tested_nets untested_nets tmp_data
	    net_display_name pin_display_name combined_pindes combined_xy prop_name
	    prop_display_name physProbe v1_details v2_details diff_details
	    no_physical_class_nets no_spacing_class_nets no_electrical_class_nets prop_no_test_nets diff_note
	    v1_data v2_data v1_value v2_value cur_data
	    tag_name netInfo arr xy_loc_str
	) 
	foreach(sec v1_net_data 
	    when((car(sec) == 'nets) 
		(v1_data = cdr(sec))
	    )
	) 
	foreach(sec v2_net_data 
	    when((car(sec) == 'nets) 
		(v2_data = cdr(sec))
	    )
	) 
	(netInfo = makeTable("net_info_data" nil)) 
	(netInfo["v1"] = makeTable("net_info_v1_data" nil))
	(netInfo["v2"] = makeTable("net_info_v2_data" nil)) 
	TBX_DESCOMPARE_GEN_Update_Meter("Parse nets") 
	foreach(entry 
	    list(list(v1_data "v1") 
		list(v2_data "v2")
	    ) 
	    (cur_data = car(entry)) 
	    (tag_name = cadr(entry)) 
	    foreach(nsec cur_data 
		(cur_net = car(nsec)) 
		(netInfo[tag_name][cur_net] = ncons(nil)) 
		foreach(asec 
		    cdr(nsec) 
		    caseq(car(asec) 
			(attribute 
			    (netInfo[tag_name][cur_net]->attribute = ncons(nil)) 
			    foreach(pentry 
				cdr(asec) 
				putprop((netInfo[tag_name][cur_net]->attribute) 
				    cadr(pentry) 
				    car(pentry)
				)
			    )
			) 
			(etchLength 
			    putprop(netInfo[tag_name][cur_net] 
				cadr(asec) 
				'etchLength
			    )
			) 
			(viaCnt 
			    putprop(netInfo[tag_name][cur_net] 
				cadr(asec) 
				'viaCnt
			    )
			) 
			(t 
			    putprop(netInfo[tag_name][cur_net] 
				cdr(asec) 
				car(asec)
			    )
			)
		    )
		)
	    )
	) 
	(pinCon = makeTable("pin_info_data" nil)) 
	(pinCon["v1"] = makeTable("pin_con_v1_data" nil))
	(pinCon["v2"] = makeTable("pin_con_v2_data" nil)) 
	foreach(tag 
	    list("v1" "v2") 
	    foreach(n 
		netInfo[tag] 
		foreach(pd 
		    (netInfo[tag][n]->pins) 
		    (pinCon[tag][pd] = n) 
		    unless(exists(x combined_pindes 
			    (x == pd)
			) 
			(combined_pindes = cons(pd combined_pindes))
		    )
		)
	    )
	) 
	(combined_pindes = sort(combined_pindes nil)) 
	(summary = makeTable("summary_table_data" nil)) 
	TBX_DESCOMPARE_GEN_Update_Meter("Net summary")
	foreach(tag 
	    list("v1" "v2") 
	    (one_pin_nets = list()) 
	    (net_names = list()) 
	    (untested_nets = list())
	    (tested_nets = list()) 
	    (prop_no_test_nets = list()) 
	    (no_spacing_class_nets = list()) 
	    (no_physical_class_nets = list()) 
	    (no_electrical_class_nets = list())
	    foreach(n 
		netInfo[tag] 
		when(onep(length((netInfo[tag][n]->pins))) 
		    (one_pin_nets = cons(n one_pin_nets))
		) 
		(net_names = cons(n net_names))
	    ) 
	    (net_names = sort(net_names nil)) 
	    foreach(n 
		netInfo[tag] 
		if((netInfo[tag][n]->testpoints) then 
		    (untested_nets = cons(n untested_nets)) else 
		    (tested_nets = cons(n tested_nets))
		) 
		when(((netInfo[tag][n]->attribute)->NO_TEST) 
		    (prop_no_test_nets = cons(n prop_no_test_nets))
		) 
		unless(((netInfo[tag][n]->attribute)->spacingClass) 
		    (no_spacing_class_nets = cons(n no_spacing_class_nets))
		)
		unless(((netInfo[tag][n]->attribute)->physicalClass) 
		    (no_physical_class_nets = cons(n no_physical_class_nets))
		) 
		unless(((netInfo[tag][n]->attribute)->electricalClass) 
		    (no_electrical_class_nets = cons(n no_electrical_class_nets))
		)
	    ) 
	    (summary[tag] = ncons(nil)) 
	    (summary[tag]->all = net_names)
	    (summary[tag]->onePin = one_pin_nets) 
	    (summary[tag]->tested = tested_nets) 
	    (summary[tag]->untested = untested_nets) 
	    (summary[tag]->propNoTest = prop_no_test_nets) 
	    (summary[tag]->noSpacingClass = no_spacing_class_nets)
	    (summary[tag]->noPhysicalClass = no_physical_class_nets) 
	    (summary[tag]->noElectricalClass = no_electrical_class_nets)
	) 
	(report_data = tconc(nil nil)) 
	(tmp_data = list(list(nil 
		    'name "nets_summary" 
		    'title "Summary"
		    'tableHeader 
		    list("Net" "Design V1" "Design V2")
		) 
		list("Nets" 
		    sprintf(nil "%d" 
			length((summary["v1"]->all))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->all))
		    )
		) 
		list("Single node nets" 
		    sprintf(nil "%d" 
			length((summary["v1"]->onePin))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->onePin))
		    )
		) 
		list("Tested nets" 
		    sprintf(nil "%d" 
			length((summary["v1"]->tested))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->tested))
		    )
		) 
		list("Untested nets" 
		    sprintf(nil "%d" 
			length((summary["v1"]->untested))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->untested))
		    )
		)
		list("Nets with NO_TEST" 
		    sprintf(nil "%d" 
			length((summary["v1"]->propNoTest))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->propNoTest))
		    )
		) 
		list("Nets without Spacing Class" 
		    sprintf(nil "%d" 
			length((summary["v1"]->noSpacingClass))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->noSpacingClass))
		    )
		) 
		list("Nets without Physical Class" 
		    sprintf(nil "%d" 
			length((summary["v1"]->noPhysicalClass))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->noPhysicalClass))
		    )
		) 
		list("Nets without Electrical Class" 
		    sprintf(nil "%d" 
			length((summary["v1"]->noElectricalClass))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->noElectricalClass))
		    )
		)
	    )) 
	tconc(report_data tmp_data) 
	(combined_nets = copy((summary["v1"]->all)))
	foreach(n 
	    (summary["v2"]->all) 
	    unless(exists(x combined_nets 
		    (x == n)
		) 
		(combined_nets = cons(n combined_nets))
	    )
	) 
	(combined_nets = sort(combined_nets nil)) 
	TBX_DESCOMPARE_GEN_Update_Meter("Compare net names") 
	(tmp_data = nil) 
	foreach(n combined_nets 
	    when((!exists(x 
			    (summary["v1"]->all) 
			    (x == n)
			) && exists(x 
			(summary["v2"]->all) 
			(x == n)
		    )) 
		(tmp_data = cons(list(n "-" "X" "Added (V2 net only)") tmp_data))
	    ) 
	    when((exists(x 
			(summary["v1"]->all) 
			(x == n)
		    ) && !exists(x 
			    (summary["v2"]->all) 
			    (x == n)
			)) 
		(tmp_data = cons(list(n "X" "-" "Deleted (V1 net only)") tmp_data))
	    )
	)
	when(tmp_data 
	    (tmp_data = reverse(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "nets_name_compare" 
			'title "Net Name Changes"
			'tableHeader 
			list("Net" "Design V1" "Design V2" "Note")
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	) 
	TBX_DESCOMPARE_GEN_Update_Meter("Number of connections") 
	(tmp_data = nil) 
	foreach(n combined_nets 
	    (net_display_name = TBX_DESCOMPARE_GEN_Get_Net_Display_String(n)) 
	    (v1_value = nil) 
	    (v2_value = nil)
	    (diff_note = nil) 
	    cond(((netInfo["v1"][n] && !netInfo["v2"][n]) 
		    (v1_value = sprintf(nil "%d" 
			    length((netInfo["v1"][n]->pins))
			)) 
		    (v2_value = "-") 
		    (diff_note = sprintf(nil "%d (V1 net only)" 
			    length((netInfo["v1"][n]->pins))
			))
		) 
		((!netInfo["v1"][n] && netInfo["v2"][n]) 
		    (v1_value = "-") 
		    (v2_value = sprintf(nil "%d" 
			    length((netInfo["v2"][n]->pins))
			)) 
		    (diff_note = sprintf(nil "%d (V2 net only)" 
			    length((netInfo["v2"][n]->pins))
			))
		) 
		((netInfo["v1"][n] && netInfo["v2"][n] && (length((netInfo["v1"][n]->pins)) != length((netInfo["v2"][n]->pins)))) 
		    (v1_value = sprintf(nil "%d" 
			    length((netInfo["v1"][n]->pins))
			)) 
		    (v2_value = sprintf(nil "%d" 
			    length((netInfo["v2"][n]->pins))
			)) 
		    (diff_note = sprintf(nil "%d" 
			    abs((length((netInfo["v1"][n]->pins)) - length((netInfo["v2"][n]->pins))))
			))
		)
	    ) 
	    when((v1_value && v2_value) 
		(tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
	    )
	) 
	when(tmp_data 
	    (tmp_data = reverse(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "number_of_connections" 
			'title "Number of Connnections"
			'tableHeader 
			list("Net" "Design V1" "Design V2" "Difference")
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	)
	TBX_DESCOMPARE_GEN_Update_Meter("Net connection details") 
	(tmp_data = nil) 
	foreach(n combined_nets 
	    (net_display_name = TBX_DESCOMPARE_GEN_Get_Net_Display_String(n)) 
	    (v1_value = nil) 
	    (v2_value = nil)
	    (diff_note = nil) 
	    cond(((!netInfo["v1"][n] && netInfo["v2"][n]) 
		    (v1_value = "-") 
		    foreach(pd 
			(netInfo["v2"][n]->pins) 
			(v2_value = pd) 
			(diff_note = "Pin assigned (V2 net only)") 
			(tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
		    )
		) 
		((netInfo["v1"][n] && !netInfo["v2"][n]) 
		    (v2_value = "-") 
		    foreach(pd 
			(netInfo["v1"][n]->pins) 
			(v1_value = pd) 
			(diff_note = "Pin deassigned (V1 net only)") 
			(tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
		    )
		) 
		((netInfo["v1"][n] && netInfo["v2"][n]) 
		    foreach(pd 
			(netInfo["v1"][n]->pins) 
			(v1_value = pd) 
			unless(exists(x 
				(netInfo["v2"][n]->pins) 
				(x == pd)
			    ) 
			    (v2_value = "-") 
			    (diff_note = "Pin deassigned") 
			    (tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
			)
		    ) 
		    foreach(pd 
			(netInfo["v2"][n]->pins) 
			(v2_value = pd) 
			unless(exists(x 
				(netInfo["v1"][n]->pins) 
				(x == pd)
			    ) 
			    (v1_value = "-") 
			    (diff_note = "Pin assigned") 
			    (tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
			)
		    )
		)
	    )
	) 
	when(tmp_data 
	    (tmp_data = reverse(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "conn_details" 
			'title "Connection Details - Net based"
			'tableHeader 
			list("Net" "Design V1" "Design V2" "Note")
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	) 
	TBX_DESCOMPARE_GEN_Update_Meter("Pin connection details")
	(tmp_data = nil) 
	foreach(pd combined_pindes 
	    (pin_display_name = pd) 
	    (v1_value = nil) 
	    (v2_value = nil)
	    (diff_note = nil) 
	    cond(((!pinCon["v1"][pd] && pinCon["v2"][pd]) 
		    (v1_value = "-") 
		    (v2_value = TBX_DESCOMPARE_GEN_Get_Net_Display_String(pinCon["v2"][pd])) 
		    (diff_note = "Added (V2 pin only)") 
		    (tmp_data = cons(list(pin_display_name v1_value v2_value diff_note) tmp_data))
		) 
		((pinCon["v1"][pd] && !pinCon["v2"][pd]) 
		    (v1_value = TBX_DESCOMPARE_GEN_Get_Net_Display_String(pinCon["v1"][pd])) 
		    (v2_value = "-") 
		    (diff_note = "Deleted (V1 pin only)") 
		    (tmp_data = cons(list(pin_display_name v1_value v2_value diff_note) tmp_data))
		) 
		((pinCon["v1"][pd] && pinCon["v2"][pd]) 
		    (v1_value = TBX_DESCOMPARE_GEN_Get_Net_Display_String(pinCon["v1"][pd])) 
		    (v2_value = TBX_DESCOMPARE_GEN_Get_Net_Display_String(pinCon["v2"][pd])) 
		    when((v1_value != v2_value) 
			(diff_note = "Net change") 
			(tmp_data = cons(list(pin_display_name v1_value v2_value diff_note) tmp_data))
		    )
		)
	    )
	) 
	when(tmp_data 
	    (tmp_data = reverse(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "conn_details" 
			'title "Connection Details - Pin based"
			'tableHeader 
			list("Net" "Design V1" "Design V2" "Note")
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	) 
	TBX_DESCOMPARE_GEN_Update_Meter("Testpoint status") 
	(tmp_data = nil)
	foreach(n combined_nets 
	    (net_display_name = TBX_DESCOMPARE_GEN_Get_Net_Display_String(n)) 
	    cond(((!netInfo["v1"][n] && netInfo["v2"][n]) 
		    (v1_value = "-") 
		    (v2_value = "Untested") 
		    (diff_note = "V2 net only") 
		    when((length((netInfo["v2"][n]->testpoints)) > 0) 
			(v2_value = "Tested")
		    )
		    (tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
		) 
		((netInfo["v1"][n] && !netInfo["v2"][n]) 
		    (v1_value = "Untested") 
		    (v2_value = "-") 
		    (diff_note = "V1 net only") 
		    when((length((netInfo["v1"][n]->testpoints)) > 0) 
			(v1_value = "Tested")
		    )
		    (tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
		) 
		((netInfo["v1"][n] && netInfo["v2"][n]) 
		    (v1_value = "Untested") 
		    when((length((netInfo["v1"][n]->testpoints)) > 0) 
			(v1_value = "Tested")
		    ) 
		    (v2_value = "Untested") 
		    when((length((netInfo["v2"][n]->testpoints)) > 0) 
			(v2_value = "Tested")
		    )
		    when((v1_value != v2_value) 
			(tmp_data = cons(list(net_display_name v1_value v2_value) tmp_data))
		    )
		)
	    )
	) 
	when(tmp_data 
	    (tmp_data = reverse(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "net_status" 
			'title "Test Status"
			'tableHeader 
			list("Net" "Design V1" "Design V2" "Note")
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	) 
	TBX_DESCOMPARE_GEN_Update_Meter("Testpoint designators") 
	(tmp_data = nil) 
	foreach(n combined_nets 
	    (net_display_name = TBX_DESCOMPARE_GEN_Get_Net_Display_String(n)) 
	    (v1_value = nil) 
	    (v2_value = nil)
	    (diff_note = nil) 
	    cond(((!netInfo["v1"][n] && netInfo["v2"][n]) 
		    (v1_value = "-") 
		    foreach(prb 
			(netInfo["v2"][n]->probeNumbers) 
			(v2_value = prb) 
			(diff_note = "Probe added (V2 net only)") 
			(tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
		    )
		) 
		((netInfo["v1"][n] && !netInfo["v2"][n]) 
		    (v2_value = "-") 
		    foreach(prb 
			(netInfo["v1"][n]->probeNumbers) 
			(v1_value = prb) 
			(diff_note = "Probe deleted (V1 net only)") 
			(tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
		    )
		) 
		((netInfo["v1"][n] && netInfo["v2"][n]) 
		    foreach(prb 
			(netInfo["v2"][n]->probeNumbers) 
			(v2_value = prb) 
			unless(exists(x 
				(netInfo["v1"][n]->probeNumbers) 
				(x == prb)
			    ) 
			    (v1_value = "-") 
			    (diff_note = "Probe added") 
			    (tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
			)
		    ) 
		    foreach(prb 
			(netInfo["v1"][n]->probeNumbers) 
			(v1_value = prb) 
			unless(exists(x 
				(netInfo["v2"][n]->probeNumbers) 
				(x == prb)
			    ) 
			    (v2_value = "-") 
			    (diff_note = "Probe deleted") 
			    (tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
			)
		    )
		)
	    )
	)
	when(tmp_data 
	    (tmp_data = reverse(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "testpoint_designators" 
			'title "Testpoint Designators"
			'tableHeader 
			list("Net" "Design V1" "Design V2" "Note")
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	) 
	TBX_DESCOMPARE_GEN_Update_Meter("Property compare") 
	(tmp_data = nil) 
	foreach(n combined_nets 
	    (net_display_name = TBX_DESCOMPARE_GEN_Get_Net_Display_String(n)) 
	    foreach(entry 
		list(list('PROBE_NUMBER "Probe Number") 
		    list('NO_TEST "NO_TEST") 
		    list('TESTPOINT_QUANTITY "Testpoint quantity") 
		    list('VOLTAGE "Voltage") 
		    list('spacingClass "Spacing Class")
		    list('physicalClass "Physical Class") 
		    list('electricalClass "Electrical Class")
		) 
		(prop_name = car(entry)) 
		(prop_display_name = cadr(entry)) 
		if((netInfo["v1"][n] && get((netInfo["v1"][n]->attribute) prop_name)) then 
		    (v1_value = get((netInfo["v1"][n]->attribute) prop_name)) else 
		    (v1_value = "-")
		)
		if((netInfo["v2"][n] && get((netInfo["v2"][n]->attribute) prop_name)) then 
		    (v2_value = get((netInfo["v2"][n]->attribute) prop_name)) else 
		    (v2_value = "-")
		) 
		cond(((!netInfo["v1"] && netInfo["v2"][n]) 
			(diff_note = "V2 net only")
		    ) 
		    ((netInfo["v1"] && !netInfo["v2"][n]) 
			(diff_note = "V1 net only")
		    ) 
		    (t 
			(diff_note = "")
		    )
		) 
		when((v1_value != v2_value) 
		    (tmp_data = cons(list(net_display_name prop_display_name v1_value v2_value diff_note) tmp_data))
		)
	    )
	) 
	when(tmp_data 
	    (tmp_data = reverse(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "prop_compare" 
			'title "Attribute Changes"
			'tableHeader 
			list("Net" "Property/Attribute" "Design V1" "Design V2" "Note")
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	)
	TBX_DESCOMPARE_GEN_Update_Meter("Via count") 
	(tmp_data = nil) 
	foreach(n combined_nets 
	    (net_display_name = TBX_DESCOMPARE_GEN_Get_Net_Display_String(n)) 
	    cond(((!netInfo["v1"][n] && netInfo["v2"][n]) 
		    (v1_value = "-") 
		    (v2_value = (netInfo["v2"][n]->viaCnt)) 
		    (diff_note = "V2 net only") 
		    (tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
		) 
		((netInfo["v1"][n] && !netInfo["v2"][n]) 
		    (v1_value = (netInfo["v1"][n]->viaCnt)) 
		    (v2_value = "-") 
		    (diff_note = "V1 net only") 
		    (tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
		) 
		((netInfo["v1"][n] && netInfo["v2"][n] && ((netInfo["v1"][n]->viaCnt) != (netInfo["v2"][n]->viaCnt))) 
		    (v1_value = (netInfo["v1"][n]->viaCnt)) 
		    (v2_value = (netInfo["v2"][n]->viaCnt)) 
		    (diff_note = sprintf(nil "%d" 
			    abs((atoi(v1_value) - atoi(v2_value)))
			)) 
		    (tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
		)
	    )
	) 
	when(tmp_data 
	    (tmp_data = reverse(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "num_vias" 
			'title "Via Count"
			'tableHeader 
			list("Net" "Design V1" "Design V2" "Difference")
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	) 
	TBX_DESCOMPARE_GEN_Update_Meter("Etch length")
	(tmp_data = nil) 
	foreach(n combined_nets 
	    (net_display_name = TBX_DESCOMPARE_GEN_Get_Net_Display_String(n)) 
	    cond(((!netInfo["v1"][n] && netInfo["v2"][n]) 
		    (v1_value = "-") 
		    (v2_value = (netInfo["v2"][n]->etchLength)) 
		    (diff_note = "V2 net only") 
		    (tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
		) 
		((netInfo["v1"][n] && !netInfo["v2"][n]) 
		    (v1_value = (netInfo["v1"][n]->etchLength)) 
		    (v2_value = "-") 
		    (diff_note = "V1 net only") 
		    (tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
		) 
		((netInfo["v1"][n] && netInfo["v2"][n] && ((netInfo["v1"][n]->etchLength) != (netInfo["v2"][n]->etchLength))) 
		    (v1_value = (netInfo["v1"][n]->etchLength)) 
		    (v2_value = (netInfo["v2"][n]->etchLength)) 
		    (diff_note = (axlGeo2Str 
			    abs((atof(v1_value) - atof(v2_value)))
			)) 
		    (tmp_data = cons(list(net_display_name v1_value v2_value diff_note) tmp_data))
		)
	    )
	) 
	when(tmp_data 
	    (tmp_data = reverse(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "etch_length" 
			'title "Etch Length"
			'tableHeader 
			list("Net" "Design V1" "Design V2" "Difference")
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	) 
	TBX_DESCOMPARE_GEN_Update_Meter("Testpoints physical") 
	(physProbe = makeTable("phys_probe_data" nil))
	(physProbe["v1"] = makeTable("phys_probe_v1_data" nil)) 
	(physProbe["v2"] = makeTable("phys_probe_v2_data" nil)) 
	foreach(n combined_nets 
	    (net_display_name = TBX_DESCOMPARE_GEN_Get_Net_Display_String(n)) 
	    when(netInfo["v1"][n] 
		foreach(entry 
		    (netInfo["v1"][n]->testpoints) 
		    (physProbe["v1"][car(entry)] = list(cadr(entry) 
			    caddr(entry) net_display_name
			)) 
		    unless(exists(x combined_xy 
			    (x == car(entry))
			) 
			(combined_xy = cons(car(entry) combined_xy))
		    )
		)
	    ) 
	    when(netInfo["v2"][n] 
		foreach(entry 
		    (netInfo["v2"][n]->testpoints) 
		    (physProbe["v2"][car(entry)] = list(cadr(entry) 
			    caddr(entry) net_display_name
			)) 
		    unless(exists(x combined_xy 
			    (x == car(entry))
			) 
			(combined_xy = cons(car(entry) combined_xy))
		    )
		)
	    )
	) 
	(tmp_data = nil) 
	foreach(xy combined_xy 
	    (arr = parseString(xy)) 
	    (xy_loc_str = strcat("x=" 
		    car(arr) " y=" 
		    cadr(arr)
		)) 
	    cond(((!physProbe["v1"][xy] && physProbe["v2"][xy]) 
		    (v1_value = "-") 
		    (v2_value = buildString(physProbe["v2"][xy] ", ")) 
		    (diff_note = "Testpoint added") 
		    (tmp_data = cons(list(xy_loc_str v1_value v2_value diff_note) tmp_data))
		) 
		((physProbe["v1"][xy] && !physProbe["v2"][xy]) 
		    (v1_value = buildString(physProbe["v1"][xy] ", ")) 
		    (v2_value = "-") 
		    (diff_note = "Testpoint deleted") 
		    (tmp_data = cons(list(xy_loc_str v1_value v2_value diff_note) tmp_data))
		) 
		((physProbe["v1"][xy] && physProbe["v2"][xy] && (buildString(physProbe["v1"][xy] ", ") != 
			    buildString(physProbe["v2"][xy] ", "))) 
		    (v1_value = buildString(physProbe["v1"][xy] ", ")) 
		    (v2_value = buildString(physProbe["v2"][xy] ", ")) 
		    (v1_details = physProbe["v1"][xy]) 
		    (v2_details = physProbe["v2"][xy])
		    (diff_details = nil) 
		    when((car(v1_details) != car(v2_details)) 
			(diff_details = cons("Designator" diff_details))
		    ) 
		    when((cadr(v1_details) != cadr(v2_details)) 
			(diff_details = cons("Side" diff_details))
		    ) 
		    when((caddr(v1_details) != caddr(v2_details)) 
			(diff_details = cons("Net" diff_details))
		    ) 
		    (diff_details = reverse(diff_details))
		    (diff_note = strcat("Change: " 
			    buildString(diff_details ", ")
			)) 
		    (tmp_data = cons(list(xy_loc_str v1_value v2_value diff_note) tmp_data))
		)
	    )
	)
	when(tmp_data 
	    (tmp_data = reverse(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "testpoint_details" 
			'title "Testpoint Details"
			'tableHeader 
			list("Location" "Design V1 \n(Designator, Side, Net)" "Design V2 \n(Designator, Side, Net)" "Note")
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	) 
	(report_data = cdar(report_data)) 
	(report_data = cons(list(nil 
		    'name "nets" 
		    'title "Netlist"
		) report_data
	    )) report_data
    )
)
procedure(TBX_DESCOMPARE_GEN_Process_Parts(v1_data v2_data) 
    let((v1_comp_data v2_comp_data compInfo pathInfo cur_data
	    tag_name cur_refdes tmp_data summary comp_all
	    comp_top comp_bottom comp_unplaced report_data combined_refdes
	    comp_value comp_partno new_refdes refdes_list v1_value
	    v2_value diff_note lg_path
	) 
	foreach(sec v1_data 
	    when((car(sec) == 'components) 
		(v1_comp_data = cdr(sec))
	    )
	) 
	foreach(sec v2_data 
	    when((car(sec) == 'components) 
		(v2_comp_data = cdr(sec))
	    )
	) 
	(compInfo = makeTable("comp_info_data" nil)) 
	(compInfo["v1"] = makeTable("comp_info_v1_data" nil))
	(compInfo["v2"] = makeTable("comp_info_v2_data" nil)) 
	TBX_DESCOMPARE_GEN_Update_Meter("Parse component data") 
	foreach(entry 
	    list(list(v1_comp_data "v1") 
		list(v2_comp_data "v2")
	    ) 
	    (cur_data = car(entry)) 
	    (tag_name = cadr(entry)) 
	    foreach(csec cur_data 
		(cur_refdes = car(csec)) 
		(compInfo[tag_name][cur_refdes] = ncons(nil)) 
		foreach(asec 
		    cdr(csec) 
		    caseq(car(asec) 
			(attribute 
			    (compInfo[tag_name][cur_refdes]->attribute = ncons(nil)) 
			    foreach(pentry 
				cdr(asec) 
				putprop((compInfo[tag_name][cur_refdes]->attribute) 
				    cadr(pentry) 
				    car(pentry)
				)
			    )
			) 
			(logicalPath 
			    putprop(compInfo[tag_name][cur_refdes] 
				cdr(asec) 
				car(asec)
			    )
			) 
			(t 
			    putprop(compInfo[tag_name][cur_refdes] 
				cadr(asec) 
				car(asec)
			    )
			)
		    )
		)
	    )
	) 
	(pathInfo = makeTable("path_info_data" nil)) 
	(pathInfo["v1"] = makeTable("path_info_v1_data" nil))
	(pathInfo["v2"] = makeTable("path_info_v2_data" nil)) 
	foreach(tag 
	    list("v1" "v2") 
	    foreach(r 
		compInfo[tag] 
		foreach(lpe 
		    (compInfo[tag][r]->logicalPath) 
		    (pathInfo[tag][cadr(lpe)] = r)
		)
	    )
	) 
	(summary = makeTable("summary_table_data" nil)) 
	TBX_DESCOMPARE_GEN_Update_Meter("Component summary") 
	foreach(tag 
	    list("v1" "v2") 
	    (comp_all = list()) 
	    (comp_top = list()) 
	    (comp_bottom = list())
	    (comp_unplaced = list()) 
	    foreach(r 
		compInfo[tag] 
		unless(exists(x combined_refdes 
			(x == r)
		    ) 
		    (combined_refdes = cons(r combined_refdes))
		) 
		(comp_all = cons(r comp_all)) 
		if(((compInfo[tag][r]->xy) != "Unplaced") then 
		    if(((compInfo[tag][r]->isMirrored) == "YES") then 
			(comp_bottom = cons(r comp_bottom)) else 
			(comp_top = cons(r comp_top))
		    ) else 
		    (comp_unplaced = cons(r comp_unplaced))
		)
	    ) 
	    (comp_all = sort(comp_all nil)) 
	    (comp_top = sort(comp_top nil)) 
	    (comp_bottom = sort(comp_bottom nil))
	    (comp_unplaced = sort(comp_unplaced nil)) 
	    (summary[tag] = ncons(nil)) 
	    (summary[tag]->compAll = comp_all) 
	    (summary[tag]->compTop = comp_top) 
	    (summary[tag]->compBottom = comp_bottom)
	    (summary[tag]->compUnplaced = comp_unplaced)
	)
	(combined_refdes = sort(combined_refdes nil)) 
	(report_data = tconc(nil nil)) 
	(tmp_data = list(list(nil 
		    'name "parts_summary" 
		    'title "Summary"
		    'tableHeader 
		    list("  " "Design V1" "Design V2")
		) 
		list("Components" 
		    sprintf(nil "%d" 
			length((summary["v1"]->compAll))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->compAll))
		    )
		) 
		list("TOP side" 
		    sprintf(nil "%d" 
			length((summary["v1"]->compTop))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->compTop))
		    )
		) 
		list("BOTTOM side" 
		    sprintf(nil "%d" 
			length((summary["v1"]->compBottom))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->compBottom))
		    )
		) 
		list("Unplaced" 
		    sprintf(nil "%d" 
			length((summary["v1"]->compUnplaced))
		    ) 
		    sprintf(nil "%d" 
			length((summary["v2"]->compUnplaced))
		    )
		)
	    )) 
	tconc(report_data tmp_data) 
	when((length((summary["v1"]->compUnplaced)) > 0) 
	    (tmp_data = tconc(nil nil)) 
	    tconc(tmp_data 
		list(nil 
		    'name "unplaced_v1" 
		    'title "Unplaced components V1"
		    'tableHeader 
		    list("Refdes" "Device Type" "Part Number" "Value" "Status")
		)
	    ) 
	    foreach(cmp 
		(summary["v1"]->compUnplaced) 
		(comp_value = "-") 
		(comp_partno = "-") 
		when(((compInfo["v1"][cmp]->attribute)->VALUE) 
		    (comp_value = ((compInfo["v1"][cmp]->attribute)->VALUE))
		)
		when(((compInfo["v1"][cmp]->attribute)->PART_NUMBER) 
		    (comp_partno = ((compInfo["v1"][cmp]->attribute)->PART_NUMBER))
		) 
		tconc(tmp_data 
		    list(cmp 
			(compInfo["v1"][cmp]->deviceType) comp_partno comp_value "Unplaced"
		    )
		)
	    ) 
	    (tmp_data = cdar(tmp_data))
	    tconc(report_data tmp_data)
	)
	when((length((summary["v2"]->compUnplaced)) > 0) 
	    (tmp_data = tconc(nil nil)) 
	    tconc(tmp_data 
		list(nil 
		    'name "unplaced_v2" 
		    'title "Unplaced components V2"
		    'tableHeader 
		    list("Refdes" "Device Type" "Part Number" "Value" "Status")
		)
	    ) 
	    foreach(cmp 
		(summary["v2"]->compUnplaced) 
		(comp_value = "-") 
		(comp_partno = "-") 
		when(((compInfo["v2"][cmp]->attribute)->VALUE) 
		    (comp_value = ((compInfo["v2"][cmp]->attribute)->VALUE))
		)
		when(((compInfo["v2"][cmp]->attribute)->PART_NUMBER) 
		    (comp_partno = ((compInfo["v2"][cmp]->attribute)->PART_NUMBER))
		) 
		tconc(tmp_data 
		    list(cmp 
			(compInfo["v2"][cmp]->deviceType) comp_partno comp_value "Unplaced"
		    )
		)
	    ) 
	    (tmp_data = cdar(tmp_data))
	    tconc(report_data tmp_data)
	) 
	TBX_DESCOMPARE_GEN_Update_Meter("BOM compare") 
	(tmp_data = nil) 
	foreach(r combined_refdes 
	    (v1_value = TBX_DESCOMPARE_GEN_Get_Part_Description_Display_String(compInfo["v1"][r])) 
	    (v2_value = TBX_DESCOMPARE_GEN_Get_Part_Description_Display_String(compInfo["v2"][r])) 
	    (diff_note = nil)
	    cond(((compInfo["v1"][r] && !compInfo["v2"][r]) 
		    (diff_note = sprintf(nil "Part deleted (V1 only)"))
		) 
		((!compInfo["v1"][r] && compInfo["v2"][r]) 
		    (diff_note = sprintf(nil "Part added (V2 only)"))
		) 
		((compInfo["v1"][r] && compInfo["v2"][r] && (v1_value != v2_value)) 
		    (diff_note = sprintf(nil "%s" "Device Type change (ECO)"))
		)
	    ) 
	    when((diff_note && (v1_value != v2_value)) 
		(tmp_data = cons(list(r v1_value v2_value diff_note) tmp_data))
	    )
	) 
	when(tmp_data 
	    (tmp_data = reverse(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "bom_compare" 
			'title "BOM Changes"
			'tableHeader 
			list("Refdes" "Design V1\n(DevType PartNum Value Package)" "Design V2\n(DevType PartNum Value Package)\n" "Note")
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	)
	TBX_DESCOMPARE_GEN_Update_Meter("Placement compare") 
	(tmp_data = nil) 
	foreach(r combined_refdes 
	    (v1_value = TBX_DESCOMPARE_GEN_Get_Part_Location_Display_String(compInfo["v1"][r])) 
	    (v2_value = TBX_DESCOMPARE_GEN_Get_Part_Location_Display_String(compInfo["v2"][r])) 
	    (diff_note = nil)
	    cond(((compInfo["v1"][r] && !compInfo["v2"][r]) 
		    (diff_note = sprintf(nil "Part deleted (V1 only)"))
		) 
		((!compInfo["v1"][r] && compInfo["v2"][r]) 
		    (diff_note = sprintf(nil "Part added (V2 only)"))
		) 
		((compInfo["v1"][r] && compInfo["v2"][r] && (v1_value != v2_value)) 
		    (diff_note = sprintf(nil "%s" "Placement change"))
		)
	    ) 
	    when((diff_note && (v1_value != v2_value)) 
		(tmp_data = cons(list(r v1_value v2_value diff_note) tmp_data))
	    )
	) 
	when(tmp_data 
	    (tmp_data = reverse(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "placement_compare" 
			'title "Placement Changes"
			'tableHeader 
			list("Refdes" "Design V1\n(xy side angle)" "Design V2\n(xy side angle)" "Note")
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	) 
	TBX_DESCOMPARE_GEN_Update_Meter("Component rename")
	(tmp_data = nil) 
	foreach(r 
	    TBX_UTIL_Get_Hash_Keys(compInfo["v1"] t) 
	    (refdes_list = nil) 
	    foreach(lpe 
		(compInfo["v1"][r]->logicalPath) 
		(lg_path = cadr(lpe)) 
		when(pathInfo["v2"][lg_path] 
		    (new_refdes = pathInfo["v2"][lg_path]) 
		    unless(exists(x refdes_list 
			    (x == new_refdes)
			) 
			(refdes_list = cons(new_refdes refdes_list))
		    )
		)
	    ) 
	    cond((zerop(length(refdes_list)) t) 
		(onep(length(refdes_list)) 
		    when((car(refdes_list) != r) 
			(v1_value = r) 
			(v2_value = car(refdes_list)) 
			(diff_note = "Component renamed") 
			(tmp_data = cons(list(v1_value v2_value diff_note) tmp_data))
		    )
		) 
		(t 
		    (refdes_list = setof(x refdes_list 
			    (x != r)
			))
		)
	    )
	) 
	when(tmp_data 
	    (tmp_data = reverse(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "component_rename" 
			'title "Component Rename"
			'tableHeader 
			list("Design V1" "Design V2" "Note")
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	) 
	(report_data = cdar(report_data)) 
	(report_data = cons(list(nil 
		    'name "components" 
		    'title "Components"
		) report_data
	    ))
	report_data
    )
)
procedure(TBX_DESCOMPARE_GEN_Process_Stackup(v1_data v2_data) 
    let((cur_data layer_cnt_all layer_cnt_copper layer_cnt_signal layer_cnt_plane
	    layer_cnt_diel layer_cnt_mask lid summaryData name
	    type material thickness eps_r artwork
	    shield tag_name layer_cnt_diestk cond_layer_order tmp_data
	    report_data v1_attributes v2_attributes total_thickness max_id
	    prefix disp_name layOrder diestk_layer_order generic_name
	    result v1_stackup v2_stackup cond_items diestack_items
	    nonetch_items attr_list rec_dpl cur_stackup cur_layer_attr
	    v1_cur_layer v2_cur_layer v1_dpl v2_dpl last_index_v1
	    last_index_v2
	) 
	foreach(sec v1_data 
	    when((car(sec) == 'stackup) 
		(v1_stackup = cdr(sec))
	    )
	) 
	foreach(sec v2_data 
	    when((car(sec) == 'stackup) 
		(v2_stackup = cdr(sec))
	    )
	) 
	(summaryData = makeTable("summary_data" nil)) 
	(layOrder = makeTable("lay_order_data" nil))
	(cond_items = makeTable("cond_items_data" nil)) 
	(diestack_items = makeTable("diestack_items_data" nil)) 
	(nonetch_items = makeTable("nonetch_items_data" nil)) 
	TBX_DESCOMPARE_GEN_Update_Meter("Process stackup") 
	foreach(entry 
	    list(list(v1_stackup "v1") 
		list(v2_stackup "v2")
	    ) 
	    (cur_data = car(entry)) 
	    (tag_name = cadr(entry)) 
	    (summaryData[tag_name] = ncons(nil))
	    (layer_cnt_all = 0) 
	    (layer_cnt_copper = 0) 
	    (layer_cnt_signal = 0) 
	    (layer_cnt_plane = 0) 
	    (layer_cnt_diel = 0)
	    (layer_cnt_diestk = 0) 
	    (layer_cnt_mask = 0) 
	    (cond_layer_order = nil) 
	    (diestk_layer_order = nil) 
	    (total_thickness = 0.0)
	    (cur_stackup = nil) 
	    foreach(rec cur_data 
		++layer_cnt_all 
		(lid = atoi(car(rec))) 
		(name = cadr(rec))
		(type = caddr(rec)) 
		(material = nth(3 rec)) 
		(thickness = nth(4 rec)) 
		(eps_r = nth(5 rec)) 
		(artwork = nth(6 rec))
		(shield = nth(7 rec)) 
		(total_thickness = (total_thickness + atof(thickness))) 
		(attr_list = list(name type material thickness eps_r
			artwork shield
		    )) 
		(cur_layer_attr = attr_list) 
		cond(((type == "SURFACE") 
			(cur_layer_attr = cons(lid 
				cons("" cur_layer_attr)
			    )) 
			if(car(nonetch_items[tag_name]) then 
			    (rec_dpl = car(nonetch_items[tag_name])) 
			    (rec_dpl->sysName = strcat((rec_dpl->sysName) " <-> " "SURFACE")) 
			    (nonetch_items[tag_name] = cons(rec_dpl 
				    cdr(nonetch_items[tag_name])
				))
			    else 
			    (rec_dpl = ncons(nil)) 
			    (rec_dpl->sysName = "SURFACE") 
			    (nonetch_items[tag_name] = cons(rec_dpl 
				    nonetch_items[tag_name]
				))
			)
		    ) 
		    ((type == "DIELECTRIC") 
			++layer_cnt_diel 
			(cur_layer_attr = cons(lid 
				cons("" cur_layer_attr)
			    )) 
			(rec_dpl = car(nonetch_items[tag_name])) 
			(rec_dpl->data = cons(attr_list 
				(rec_dpl->data)
			    ))
			(nonetch_items[tag_name] = cons(rec_dpl 
				cdr(nonetch_items[tag_name])
			    ))
		    ) 
		    ((type == "DIESTACK") 
			++layer_cnt_diestk 
			(generic_name = sprintf(nil "DS%02d" layer_cnt_diestk)) 
			(cur_layer_attr = cons(lid 
				cons(generic_name cur_layer_attr)
			    )) 
			(rec_dpl = car(nonetch_items[tag_name]))
			(rec_dpl->sysName = strcat((rec_dpl->sysName) " <-> " generic_name)) 
			(nonetch_items[tag_name] = cons(rec_dpl 
				cdr(nonetch_items[tag_name])
			    )) 
			(rec_dpl = ncons(nil)) 
			(rec_dpl->sysName = generic_name) 
			(nonetch_items[tag_name] = cons(rec_dpl 
				nonetch_items[tag_name]
			    ))
			(diestack_items[tag_name] = cons(cur_layer_attr 
				diestack_items[tag_name]
			    )) 
			(diestk_layer_order = cons(name diestk_layer_order))
		    ) 
		    (((type == "CONDUCTOR") || (type == "PLANE")) 
			++layer_cnt_copper 
			if((type == "CONDUCTOR") then 
			    ++layer_cnt_signal else 
			    ++layer_cnt_plane
			) 
			(generic_name = sprintf(nil "L%02d" layer_cnt_copper)) 
			(cur_layer_attr = cons(lid 
				cons(generic_name cur_layer_attr)
			    ))
			(rec_dpl = car(nonetch_items[tag_name])) 
			(rec_dpl->sysName = strcat((rec_dpl->sysName) " <-> " generic_name)) 
			(nonetch_items[tag_name] = cons(rec_dpl 
				cdr(nonetch_items[tag_name])
			    )) 
			(rec_dpl = ncons(nil)) 
			(rec_dpl->sysName = generic_name)
			(nonetch_items[tag_name] = cons(rec_dpl 
				nonetch_items[tag_name]
			    )) 
			(cond_items[tag_name] = cons(cur_layer_attr 
				cond_items[tag_name]
			    )) 
			(cond_layer_order = cons(name cond_layer_order))
		    ) 
		    ((type == "MASK") 
			++layer_cnt_mask 
			(cur_layer_attr = cons(lid 
				cons("" cur_layer_attr)
			    )) 
			(rec_dpl = car(nonetch_items[tag_name])) 
			(rec_dpl->data = cons(attr_list 
				(rec_dpl->data)
			    ))
			(nonetch_items[tag_name] = cons(rec_dpl 
				cdr(nonetch_items[tag_name])
			    ))
		    )
		)
		(cur_stackup = cons(cur_layer_attr cur_stackup))
	    ) 
	    (cur_stackup = reverse(cur_stackup)) 
	    (nonetch_items[tag_name] = reverse(nonetch_items[tag_name])) 
	    (cond_items[tag_name] = reverse(cond_items[tag_name]))
	    (diestack_items[tag_name] = reverse(diestack_items[tag_name])) 
	    (layOrder[tag_name] = cur_stackup) 
	    (cond_layer_order = reverse(cond_layer_order)) 
	    (diestk_layer_order = reverse(diestk_layer_order)) 
	    (summaryData[tag_name]->condLayerOrder = cond_layer_order)
	    (summaryData[tag_name]->diestkLayerOrder = diestk_layer_order) 
	    (summaryData[tag_name]->totalThickness = (axlGeo2Str total_thickness)) 
	    (summaryData[tag_name]->layerCntAll = sprintf(nil "%d" layer_cnt_all)) 
	    (summaryData[tag_name]->layerCntCopper = sprintf(nil "%d" layer_cnt_copper)) 
	    (summaryData[tag_name]->layerCntSignal = sprintf(nil "%d" layer_cnt_signal))
	    (summaryData[tag_name]->layerCntPlane = sprintf(nil "%d" layer_cnt_plane)) 
	    (summaryData[tag_name]->layerCntDiel = sprintf(nil "%d" layer_cnt_diel)) 
	    (summaryData[tag_name]->layerCntMask = sprintf(nil "%d" layer_cnt_mask)) 
	    (summaryData[tag_name]->layerCntDiestk = sprintf(nil "%d" layer_cnt_diestk))
	)
	(report_data = tconc(nil nil)) 
	(tmp_data = tconc(nil nil)) 
	foreach(rec 
	    layOrder["v1"] 
	    tconc(tmp_data 
		cdr(rec)
	    )
	) 
	when(cdar(tmp_data) 
	    (tmp_data = cdar(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "stackup_details" 
			'title "Design V1"
			'help "Reports stackup details for board V1"
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	) 
	(tmp_data = tconc(nil nil))
	foreach(rec 
	    layOrder["v2"] 
	    tconc(tmp_data 
		cdr(rec)
	    )
	) 
	when(cdar(tmp_data) 
	    (tmp_data = cdar(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "stackup_details" 
			'title "Design V2"
			'help "Reports stackup details for board V2"
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	) 
	(tmp_data = list(list(nil 
		    'name "stackup_summary" 
		    'title "Summary"
		    'help "Reports summary data"
		) 
		list("Number of Etch layers" 
		    (summaryData["v1"]->layerCntCopper) 
		    (summaryData["v2"]->layerCntCopper)
		) 
		list("Number of Signal layers" 
		    (summaryData["v1"]->layerCntSignal) 
		    (summaryData["v2"]->layerCntSignal)
		) 
		list("Number of Plane layers" 
		    (summaryData["v1"]->layerCntPlane) 
		    (summaryData["v2"]->layerCntPlane)
		) 
		list("Number of Dielectrics" 
		    (summaryData["v1"]->layerCntDiel) 
		    (summaryData["v2"]->layerCntDiel)
		)
		list("Number of Mask layers" 
		    (summaryData["v1"]->layerCntMask) 
		    (summaryData["v2"]->layerCntMask)
		) 
		list("Number of Diestack layers" 
		    (summaryData["v1"]->layerCntDiestk) 
		    (summaryData["v2"]->layerCntDiestk)
		) 
		list("Total thickness" 
		    (summaryData["v1"]->totalThickness) 
		    (summaryData["v2"]->totalThickness)
		) 
		list("Etch layer names" 
		    buildString((summaryData["v1"]->condLayerOrder) "\n") 
		    buildString((summaryData["v2"]->condLayerOrder) "\n")
		)
	    )) 
	when(((axlVersion 
		    'isSIP
		) || (axlVersion 
		    'isAPD
		)) 
	    (tmp_data = append1(tmp_data 
		    list("Diestack layer names" 
			buildString((summaryData["v1"]->diestkLayerOrder) "\n") 
			buildString((summaryData["v2"]->diestkLayerOrder) "\n")
		    )
		))
	) 
	tconc(report_data tmp_data)
	(tmp_data = tconc(nil nil)) 
	(last_index_v1 = (length(cond_items["v1"]) - 1)) 
	(last_index_v2 = (length(cond_items["v2"]) - 1)) 
	(max_id = max(last_index_v1 last_index_v2)) 
	for(i 0 max_id 
	    (v1_cur_layer = nth(i 
		    cond_items["v1"]
		)) 
	    (v2_cur_layer = nth(i 
		    cond_items["v2"]
		))
	    (v1_attributes = cddr(v1_cur_layer)) 
	    (v2_attributes = cddr(v2_cur_layer)) 
	    (prefix = "Conductor") 
	    cond(((v1_attributes && v2_attributes) 
		    (disp_name = cadr(v1_cur_layer)) 
		    (result = TBX_DESCOMPARE_GEN_Compare_Stackup_Attributes(v1_attributes v2_attributes prefix disp_name)) 
		    lconc(tmp_data result)
		) 
		((!v1_attributes && v2_attributes) 
		    (disp_name = cadr(v2_cur_layer)) 
		    (name = car(v2_attributes)) 
		    (type = cadr(v2_attributes)) 
		    (material = caddr(v2_attributes))
		    (thickness = nth(3 v2_attributes)) 
		    tconc(tmp_data 
			list(sprintf(nil "Added layer %s  %s" prefix disp_name) "" 
			    buildString(list(name type material thickness) ", ")
			)
		    )
		) 
		((v1_attributes && !v2_attributes) 
		    (disp_name = cadr(v1_cur_layer)) 
		    (name = car(v1_attributes)) 
		    (type = cadr(v1_attributes)) 
		    (material = caddr(v1_attributes))
		    (thickness = nth(3 v1_attributes)) 
		    tconc(tmp_data 
			list(sprintf(nil "Removed layer %s  %s" prefix disp_name) "" 
			    buildString(list(name type material thickness) ", ")
			)
		    )
		)
	    )
	)
	(last_index_v1 = (length(diestack_items["v1"]) - 1)) 
	(last_index_v2 = (length(diestack_items["v2"]) - 1)) 
	(max_id = max(last_index_v1 last_index_v2)) 
	for(i 0 max_id 
	    (v1_cur_layer = nth(i 
		    diestack_items["v1"]
		)) 
	    (v2_cur_layer = nth(i 
		    diestack_items["v2"]
		))
	    (v1_attributes = cddr(v1_cur_layer)) 
	    (v2_attributes = cddr(v2_cur_layer)) 
	    (prefix = "Diestack") 
	    cond(((v1_attributes && v2_attributes) 
		    (disp_name = cadr(v1_cur_layer)) 
		    (result = TBX_DESCOMPARE_GEN_Compare_Stackup_Attributes(v1_attributes v2_attributes prefix disp_name)) 
		    lconc(tmp_data result)
		) 
		((!v1_attributes && v2_attributes) 
		    (disp_name = cadr(v2_cur_layer)) 
		    (name = car(v2_attributes)) 
		    (type = cadr(v2_attributes)) 
		    (material = caddr(v2_attributes))
		    (thickness = nth(3 v2_attributes)) 
		    tconc(tmp_data 
			list(sprintf(nil "Added layer %s  %s" prefix disp_name) "" 
			    buildString(list(name type material thickness) ", ")
			)
		    )
		) 
		((v1_attributes && !v2_attributes) 
		    (disp_name = cadr(v1_cur_layer)) 
		    (name = car(v1_attributes)) 
		    (type = cadr(v1_attributes)) 
		    (material = caddr(v1_attributes))
		    (thickness = nth(3 v1_attributes)) 
		    tconc(tmp_data 
			list(sprintf(nil "Removed layer %s  %s" prefix disp_name) "" 
			    buildString(list(name type material thickness) ", ")
			)
		    )
		)
	    )
	) 
	(last_index_v1 = (length(nonetch_items["v1"]) - 1))
	(last_index_v2 = (length(nonetch_items["v2"]) - 1)) 
	(max_id = max(last_index_v1 last_index_v2)) 
	for(i 0 max_id 
	    (v1_dpl = nth(i 
		    nonetch_items["v1"]
		)) 
	    (v2_dpl = nth(i 
		    nonetch_items["v2"]
		))
	    (prefix = "NonEtch") 
	    cond(((!(v1_dpl->data) && !(v2_dpl->data)) t) 
		(((v1_dpl->sysName) && (v2_dpl->sysName) && ((v1_dpl->sysName) != (v2_dpl->sysName))) 
		    cond((((v1_dpl->data) && !(v2_dpl->data)) 
			    tconc(tmp_data 
				list(sprintf(nil "%s layer quantity below %s" prefix 
					car(parseString((v1_dpl->sysName) "<"))
				    ) 
				    sprintf(nil "%d" 
					length((v1_dpl->data))
				    ) 
				    sprintf(nil "%d" 
					length((v2_dpl->data))
				    )
				)
			    )
			) 
			((!(v1_dpl->data) && (v2_dpl->data)) 
			    tconc(tmp_data 
				list(sprintf(nil "%s layer quantity below %s" prefix 
					car(parseString((v1_dpl->sysName) "<"))
				    ) 
				    sprintf(nil "%d" 
					length((v1_dpl->data))
				    ) 
				    sprintf(nil "%d" 
					length((v2_dpl->data))
				    )
				)
			    )
			) 
			(((v1_dpl->data) && (v2_dpl->data) && (length((v1_dpl->data)) != length((v2_dpl->data)))) 
			    tconc(tmp_data 
				list(sprintf(nil "%s layer quantity below %s" prefix 
					car(parseString((v1_dpl->sysName) "<"))
				    ) 
				    sprintf(nil "%d" 
					length((v1_dpl->data))
				    ) 
				    sprintf(nil "%d" 
					length((v2_dpl->data))
				    )
				)
			    )
			)
		    )
		) 
		((!v1_dpl && (v2_dpl->data)) 
		    tconc(tmp_data 
			list(sprintf(nil "%s layer quantity between %s" prefix 
				(v2_dpl->sysName)
			    ) 
			    sprintf(nil "%d" 
				length((v1_dpl->data))
			    ) 
			    sprintf(nil "%d" 
				length((v2_dpl->data))
			    )
			)
		    )
		) 
		(((v1_dpl->data) && !v2_dpl) 
		    tconc(tmp_data 
			list(sprintf(nil "%s layer quantity between %s" prefix 
				(v1_dpl->sysName)
			    ) 
			    sprintf(nil "%d" 
				length((v1_dpl->data))
			    ) 
			    sprintf(nil "%d" 
				length((v2_dpl->data))
			    )
			)
		    )
		) 
		(((length((v1_dpl->data)) != length((v2_dpl->data))) && ((v1_dpl->sysName) == (v2_dpl->sysName))) 
		    cond(((v1_dpl->sysName) 
			    (disp_name = (v1_dpl->sysName))
			) 
			((v2_dpl->sysName) 
			    (disp_name = (v2_dpl->sysName))
			) 
			(t 
			    (disp_name = "NA")
			)
		    ) 
		    tconc(tmp_data 
			list(sprintf(nil "%s  layer quantity between %s" prefix disp_name) 
			    sprintf(nil "%d" 
				length((v1_dpl->data))
			    ) 
			    sprintf(nil "%d" 
				length((v2_dpl->data))
			    )
			)
		    )
		)
		(t 
		    (disp_name = (v1_dpl->sysName)) 
		    for(r 0 
			(length((v1_dpl->data)) - 1) 
			(v1_attributes = nth(r 
				(v1_dpl->data)
			    )) 
			(v2_attributes = nth(r 
				(v2_dpl->data)
			    ))
			(result = TBX_DESCOMPARE_GEN_Compare_Stackup_Attributes(v1_attributes v2_attributes prefix disp_name)) 
			lconc(tmp_data result)
		    )
		)
	    )
	) 
	when(cdar(tmp_data) 
	    (tmp_data = cdar(tmp_data)) 
	    (tmp_data = cons(list(nil 
			'name "stackup_attributes" 
			'title "Layer Attribute Changes"
			'help "Compares important attributes like thickness, material, type etc."
		    ) tmp_data
		)) 
	    tconc(report_data tmp_data)
	) 
	(report_data = cdar(report_data))
	(report_data = cons(list(nil 
		    'name "stackup" 
		    'title "Stackup"
		) report_data
	    )) report_data
    )
)
procedure(TBX_DESCOMPARE_GEN_Update_Meter(info_str) 
    let((a) 
	(a = a) 
	(axlMeterUpdate 
	    ((100 * mod(((tbx_descompare_data->session)->meterCurStep) 
			((tbx_descompare_data->session)->meterStepCnt)
		    )) / ((tbx_descompare_data->session)->meterStepCnt)) info_str 
	    sprintf(nil "Step %d of %d" 
		((tbx_descompare_data->session)->meterCurStep) 
		((tbx_descompare_data->session)->meterStepCnt)
	    )
	) 
	((tbx_descompare_data->session)->meterCurStep = (((tbx_descompare_data->session)->meterCurStep) + 1)) t
    )
)
procedure(TBX_DESCOMPARE_GEN_Write_HTML_Report(data html_file) 
    let((port inport line css_class html_data
	    js_source sec_info block_info ind_format_1 stringToHTML
	    printTable printHeader ind_format_2 report_mode
	) 
	(stringToHTML = lambda((str_l) 
		let((html_str_l) 
		    (html_str_l = str_l) 
		    rexCompile("<") 
		    (html_str_l = rexReplace(html_str_l "\\&lt;" 0)) 
		    rexCompile(">")
		    (html_str_l = rexReplace(html_str_l "\\&gt;" 0)) 
		    rexCompile("\n") 
		    (html_str_l = rexReplace(html_str_l "<br>" 0)) html_str_l
		)
	    )) 
	(printHeader = lambda((port_l block_l) 
		let((block_info_l help_str) 
		    (block_info_l = car(block_l)) 
		    (help_str = (block_info_l->help)) 
		    unless(help_str 
			(help_str = "")
		    ) 
		    (block_info_l = car(block_l))
		    fprintf(port_l "  <header>\n") 
		    fprintf(port_l "     <h3>\n") 
		    fprintf(port_l "        <span class=\"collapse-open-icon\"></span>\n") 
		    fprintf(port_l "        %s\n" 
			funcall(stringToHTML 
			    (block_info_l->title)
			)
		    ) 
		    fprintf(port_l "     </h3>\n")
		    fprintf(port_l "  </header>\n")
		)
	    )) 
	(printTable = lambda((port_l block_l indent_l) 
		let((block_info_l) 
		    (block_info_l = car(block_l)) 
		    (ind_format_1 = strcat("%-" 
			    sprintf(nil "%d" indent_l) "s"
			)) 
		    (ind_format_2 = strcat("%-" 
			    sprintf(nil "%d" 
				(indent_l + 2)
			    ) "s"
			)) 
		    fprintf(port_l ind_format_1 " ")
		    fprintf(port_l "<table>") 
		    if((block_info_l->tableHeader) then 
			fprintf(port_l ind_format_2 " ") 
			fprintf(port_l "<tr>") 
			foreach(nm 
			    (block_info_l->tableHeader) 
			    fprintf(port_l "<th>%s</th>" 
				funcall(stringToHTML nm)
			    )
			)
			fprintf(port_l "</tr>\n") 
			foreach(entry 
			    cdr(block_l) 
			    fprintf(port_l ind_format_2 " ") 
			    fprintf(port_l "<tr>") 
			    foreach(val entry 
				fprintf(port_l "<td>%s</td>" 
				    funcall(stringToHTML val)
				)
			    )
			    fprintf(port_l "</tr>\n")
			) else 
			fprintf(port_l ind_format_2 " ") 
			fprintf(port_l "<tr><th>Description</th><th>Design V1</th><th>Design V2</th></tr>\n")
			foreach(entry 
			    cdr(block_l) 
			    (html_data = mapcar(lambda((x) 
					funcall(stringToHTML x)
				    ) entry
				)) 
			    fprintf(port_l ind_format_2 " ") 
			    fprintf(port_l "<tr><td>%s</td><td>%s</td><td>%s</td></tr>\n" 
				car(html_data) 
				cadr(html_data) 
				caddr(html_data)
			    )
			)
		    ) 
		    fprintf(port_l "</table>\n")
		)
	    )) 
	(port = outfile(html_file "w"))
	fprintf(port "<!DOCTYPE html>\n<!--This is a report generated by Productivity Toolbox Design Compare-->\n<html>\n") 
	fprintf(port "<head>\n<title>PCB Editor Design Compare Report</title>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=yes\">\n<meta name=\"author\" content=\"FlowCAD\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n<style>\nbody {background-color: #FFFFFF;display: block;font-family:Calibri,Candara,Segoe,Segoe UI,Optima,Arial,sans-serif;\n  font-size: 0.95em;margin: 0.2em 0.2em 0.2em;\n  position: absolute;text-align: left: 800px;\n  font-family:Calibri,Candara,Segoe,Segoe UI,Optima,Arial,sans-serif;font-size: 1em;line-height: 1.4em;\n  width:800px;\n}\narticle {display: inline;float: left;margin-left: 10px;margin-right: 5px;\n  margin-top: 0.5em;overflow: visible;text-align: left;width: 800px;padding-left:0px;\n}\nh1 { color: #3366CC;font-size: 1.7em;margin-bottom: 0.5em;margin-top: 0.4em;}\nh2 {color:  #CC0000;font-size: 1.5em;margin-bottom: 0.35em;margin-top: 0.4em;}\nh3 { color: #666666;font-size: 1.2em;margin-bottom: 0.35em;margin-left:10px;}\nh2:hover{background-color:#e0e0e0;}\nh3:hover{background-color:#e0e0e0;}\ntable, th, td {\n  font-family:Calibri,Candara,Segoe,Segoe UI,Optima,Arial,sans-serif; font-size: 0.95em;\n  border: 1px solid black;\n  border-collapse: collapse;\n  line-height: 1em;\n  background-color: #f4f4f4;\n  margin-left:15px;\n  }\nth, td {\n  padding: 3px 5px 2px 5px;\n  text-align: left;\n  word-wrap: break-word;\n  max-width: 35em;\n}\nsvg{margin-right:5px;\n}\n.surface  {background-color:#F4F4F4;}\n.mask     {background-color:#E184F0;}\n.dielec   {background-color:#93B63A;}\n.diestk   {background-color:#7CDAF9;}\n.conduc   {background-color:#E87C1E;}\n.plane    {background-color:#CC0000;color:#ffffff;}\n.topline {text-align:right}\n.collapse-open-icon {\n    float:left;\n    margin: -3px 2px 0 0;\n}\n</style>\n</head>\n") 
	fprintf(port "<body>\n") 
	fprintf(port "<div id=\"collapse-icon-template\" style=\"display:none\">\n  <svg width=\"12\" height=\"12\">\n  <title>Click to collapse</title>\n  <polygon points=\"1,1 12,1 6,12\" style=\"fill:#666666;stroke:;stroke-width:0\" />\n  </svg>\n</div>\n\n<div id=\"open-icon-template\" style=\"display:none\">\n  <svg width=\"12\" height=\"12\">\n  <title>Click to open</title>\n  <polygon points=\"1,1 12,6 1,12\" style=\"fill:#666666;stroke:;stroke-width:0\" />\n  </svg>\n</div>\n\n<nav>\n  <div id='collapse-all'>\n    <svg width=\"12\" height=\"12\">\n    <title>Click to collapse</title>\n    <polygon points=\"1,1 12,1 6,12\" style=\"fill:#666666;stroke:;stroke-width:0\" />\n    </svg> collapse details\n  </div>\n\n  <div id='open-all'>\n    <svg width=\"12\" height=\"12\">\n    <title>Click to open</title>\n    <polygon points=\"1,1 12,6 1,12\" style=\"fill:#666666;stroke:;stroke-width:0\" />\n    </svg> open details\n  </div>\n</nav>\n") 
	(report_mode = "cadence")
	if((report_mode == "cadence") then 
	    fprintf(port "<header><!-- Cadence logo and headline-->\n") 
	    fprintf(port "<p class=\"topline\"><svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n") 
	    fprintf(port "   viewBox=\"0 0 218.5 51.5\" style=\"enable-background:new 0 0 218.5 51.5;\" xml:space=\"preserve\" preserveAspectRatio=\"xMidYMid\" width=\"166\" height=\"40\" viewBox=\"0 0 166 40\">\n")
	    fprintf(port "<style type=\"text/css\">\n") 
	    fprintf(port "  .st0{fill:#DD052B;}\n") 
	    fprintf(port "</style>\n") 
	    fprintf(port "<g>\n") 
	    fprintf(port "  <g>\n")
	    fprintf(port "    <polyline class=\"st0\" points=\"55.7,8.5 55.7,4.3 40.3,4.3 40.3,8.5 55.7,8.5     \"/>\n") 
	    fprintf(port "    <path d=\"M27.5,41.4c-0.8,0.4-2.3,0.9-4.2,0.9c-6.3,0-10.5-4.7-10.5-13.4c0-7.9,4.4-13.9,11.4-13.9c1.6,0,2.6,0.4,3.3,0.8v4.6\n") 
	    fprintf(port "      c-0.6-0.2-1.9-0.6-3.2-0.6c-3.8,0-5.7,4.1-5.7,9c0,5.4,2.2,8.7,5.7,8.7c1.1,0,2.3-0.2,3.2-0.6V41.4\"/>\n") 
	    fprintf(port "    <path d=\"M50,37.6l0-9.3c-2.3,0-6.4,0.7-6.4,5.3c0,3,1.6,4.1,2.9,4.1L50,37.6L50,37.6z M55.7,35.5c0,2.1,0.1,4.7,0.4,6.4\n") 
	    fprintf(port "      c0,0-9,0-11.4,0c-3.8,0-6.7-3.1-6.7-7.8c0-6.8,5.7-9.7,11.7-9.7v-0.5c0-2.8-1.1-4.7-4-4.7c-1.9,0-4.1,0.6-5.5,1.5v-4\n")
	    fprintf(port "      c1.3-0.8,3.5-1.9,6.8-1.9c6.8,0,8.6,4.4,8.6,10.1V35.5\"/>\n") 
	    fprintf(port "    <path d=\"M81.2,37.6h-3.4c-2.4,0-3.8-3.7-3.8-9c0-4.7,1.1-8.9,4-8.9c1.7,0,2.9,1.9,3.2,4c0.1,0.5,0.1,1.1,0.1,1.6V37.6L81.2,37.6z\n") 
	    fprintf(port "       M87,35.5L87,7h-5.8v10.6h-0.1c-0.8-1.8-2.4-2.9-4.6-2.9c-4.3,0-8.3,4.5-8.3,13.8c0,8,2.9,13.4,8,13.4l11.2,0\n") 
	    fprintf(port "      C87.1,40.2,87,37.5,87,35.5\"/>\n") 
	    fprintf(port "    <path d=\"M112.3,26.1c0-4.2-1.4-6.8-3.4-6.8c-2.5,0-3.7,3.7-3.8,6.8H112.3L112.3,26.1z M105.1,30.2c0.1,5.9,2.8,7.5,5.9,7.5\n")
	    fprintf(port "      c1.9,0,4-0.4,5.2-0.9v4.2c-1.7,0.8-3.8,1.2-6.2,1.2c-6.8,0-10.5-5-10.5-13.1c0-8.8,4.2-14.1,9.9-14.1c5.6,0,8.4,5,8.4,12.1\n") 
	    fprintf(port "      c0,1.5-0.1,2.4-0.2,3.1L105.1,30.2\"/>\n") 
	    fprintf(port "    <path d=\"M136.1,19.9v22h-5.8v-19c0-3-0.2-5.3-0.2-7.7h11.4c4.4,0,7,3.2,7,9.4v17.3h-5.8V25.1c0-2.6-0.6-5.2-3.1-5.2L136.1,19.9\"/>\n") 
	    fprintf(port "    <path d=\"M175.6,41.4c-0.8,0.4-2.3,0.9-4.2,0.9c-6.3,0-10.5-4.7-10.5-13.4c0-7.9,4.4-13.9,11.4-13.9c1.6,0,2.6,0.4,3.3,0.8v4.6\n") 
	    fprintf(port "      c-0.6-0.2-1.9-0.6-3.2-0.6c-3.8,0-5.7,4.1-5.7,9c0,5.4,2.2,8.7,5.7,8.7c1.1,0,2.3-0.2,3.2-0.6V41.4\"/>\n")
	    fprintf(port "    <path d=\"M191.5,26.1c0.1-3.1,1.3-6.8,3.8-6.8c2.1,0,3.5,2.5,3.4,6.8H191.5L191.5,26.1z M204.1,27.1c0-7.1-2.8-12.1-8.4-12.1\n") 
	    fprintf(port "      c-5.7,0-9.9,5.3-9.9,14.1c0,8.2,3.7,13.1,10.5,13.1c2.4,0,4.6-0.5,6.2-1.2v-4.2c-1.2,0.5-3.2,0.9-5.2,0.9c-3.1,0-5.8-1.6-5.9-7.5\n") 
	    fprintf(port "      l12.4,0C204,29.4,204.1,28.6,204.1,27.1\"/>\n") 
	    fprintf(port "  </g>\n") 
	    fprintf(port "</g>\n")
	    fprintf(port "<g>\n") 
	    fprintf(port "  <path d=\"M206.9,8.3c0-2.1,1.7-3.7,3.7-3.7c2.1,0,3.7,1.7,3.7,3.7c0,2-1.7,3.7-3.7,3.7C208.5,12,206.9,10.3,206.9,8.3z M213.4,8.3\n") 
	    fprintf(port "    c0-1.7-1.3-3-2.8-3c-1.6,0-2.8,1.3-2.8,3c0,1.7,1.3,3,2.8,3C212.1,11.3,213.4,10,213.4,8.3z M209.1,6.1h1.6c1,0,1.6,0.3,1.6,1.2\n") 
	    fprintf(port "    c0,0.7-0.4,1.1-1.1,1.1l1.1,1.8h-0.8l-1.1-1.8h-0.5v1.8h-0.8V6.1z M209.9,7.9h0.7c0.5,0,0.9-0.1,0.9-0.6c0-0.5-0.5-0.6-0.9-0.6\n") 
	    fprintf(port "    h-0.7V7.9z\"/>\n")
	    fprintf(port "</g>\n") 
	    fprintf(port "</svg>\n") 
	    fprintf(port "</p>\n") 
	    fprintf(port "<hr>\n") 
	    fprintf(port "<h1>PCB Editor Design Compare Report</h1>\n")
	    fprintf(port "</header>\n") else 
	    fprintf(port "<header><!-- Cadence logo and headline-->\n<p class=\"topline\"><svg preserveAspectRatio=\"xMidYMid\" width=\"83\" height=\"20\" viewBox=\"0 0 83 20\">\n  <image xlink:href=\"data:img/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFMAAAAUCAMAAADGMfHmAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAaVBMVEUAAAD///9AQED87+/539+AgIC/v7/pj4/SICDMAADPEBDicHDsn5/vr6/mgIDcUFD1z8/WMDCvr6/f39/Pz8/v7+/pz8/ZQEBgYGAgICCfn5/cj4/yv78QEBCPj49QUFBwcHDfYGAwMDDVsfIlAAAAAWJLR0QAiAUdSAAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAVFJREFUOMvd1Y1ugyAQAODjROrhX60yhBVt9/4PuTvt1izZXLesSbOLESHmk+MgAtwj1F8H/lMz0z8283WJDV+fvb0riGwpTxVRzU1DHLbd/94siYqOSFBu2jeT1WzTzJd2MQ95blRvBuUM94x5ItrxXIm00iJpMb1Se7t85mtzNIYVNh3KjMcBgooAvQN4JivvHDOZcdsJtJh8777NHcXMIcUJICboR24izCuwhKW6ki+sQzXRphkQ8SQmyjKcYBxhCgnmGeLV5AodGapuNN/XEyFKHw8QYE4pgWOJ09bFWfu1NP5iltcEts0R0LkAk0oAE2c/q8zSOcs8Wa5Q2TS8C7SYWW2puc0cEvDkglPsDVyluKQsUZVrTQo6X/ZSt7WXIsZ1GAc1zCGMjjcRzqpHdFLy1tq2Vq2vllX1beUldh/IhzjvD27y6bw9Xu7x53gFYBMW2DKy/54AAAAASUVORK5CYII=\" width=\"83\" height=\"20\"/></svg>\n</p>\n<hr>\n<h1>PCB Editor Design Compare Report</h1>\n</header>\n")
	) 
	foreach(sec data 
	    (sec_info = car(sec)) 
	    case((sec_info->name) 
		("general" 
		    foreach(block 
			cdr(sec) 
			(block_info = car(block)) 
			fprintf(port "<article id=\"%s\">\n" 
			    funcall(stringToHTML 
				(sec_info->name)
			    )
			) 
			fprintf(port "<h2> <span class=\"collapse-open-icon\"></span>%s</h2>\n" 
			    funcall(stringToHTML 
				(sec_info->title)
			    )
			)
			fprintf(port "  <section class=\"inneraccordion\">\n") 
			fprintf(port "    <header>\n") 
			fprintf(port "      <h3> <span class=\"collapse-open-icon\"></span>%s</h3>\n" 
			    funcall(stringToHTML 
				(block_info->title)
			    )
			) 
			fprintf(port "    </header>\n") 
			fprintf(port "    <div>\n")
			fprintf(port "      <table>\n") 
			foreach(entry 
			    cdr(block) 
			    (html_data = mapcar(lambda((x) 
					funcall(stringToHTML x)
				    ) entry
				)) 
			    fprintf(port "      <tr><td>%s</td><td>%s</td></tr>\n" 
				car(html_data) 
				cadr(html_data)
			    )
			) 
			fprintf(port "      </table>\n") 
			fprintf(port "    </div>\n") 
			fprintf(port "  </section>\n")
			fprintf(port "</article>\n")
		    )
		) 
		("stackup" 
		    fprintf(port "<article id=\"%s\">\n" 
			funcall(stringToHTML 
			    (sec_info->name)
			)
		    ) 
		    fprintf(port "  <h2><span class=\"collapse-open-icon\"></span>%s</h2>\n" 
			funcall(stringToHTML 
			    (sec_info->title)
			)
		    ) 
		    fprintf(port "  <section class=\"inneraccordion\">\n") 
		    foreach(block 
			cdr(sec) 
			(block_info = car(block)) 
			funcall(printHeader port block) 
			if(((block_info->name) == "stackup_details") then 
			    fprintf(port "  <div>\n") 
			    fprintf(port "    <table>\n") 
			    fprintf(port "       <tr><th>ID</th><th>Name</th><th>Type</th><th>Material</th><th>Thickness</th><th>Diel. Const.</th><th>Artwork</th><th>Shield</th></tr>\n")
			    foreach(entry 
				cdr(block) 
				(css_class = "dielec") 
				case(caddr(entry) 
				    ("DIELECTRIC" 
					(css_class = "dielec")
				    ) 
				    ("CONDUCTOR" 
					(css_class = "conduc")
				    ) 
				    ("PLANE" 
					(css_class = "plane")
				    ) 
				    ("DIESTACK" 
					(css_class = "diestk")
				    )
				    ("MASK" 
					(css_class = "mask")
				    ) 
				    ("SURFACE" 
					(css_class = "surface")
				    )
				) 
				(html_data = mapcar(lambda((x) 
					    funcall(stringToHTML x)
					) entry
				    ))
				fprintf(port "       <tr><td>%s</td><td>%s</td><td class=\"%s\">%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>\n" 
				    car(html_data) 
				    cadr(html_data) css_class
				    caddr(html_data) 
				    nth(3 html_data) 
				    nth(4 html_data) 
				    nth(5 html_data) 
				    nth(6 html_data)
				    nth(7 html_data)
				)
			    ) 
			    fprintf(port "    </table>\n") 
			    fprintf(port "  </div>\n") else 
			    fprintf(port "  <div>\n")
			    funcall(printTable port block 4) 
			    fprintf(port "  </div>\n")
			)
		    )
		    fprintf(port "  </section>\n") 
		    fprintf(port "</article>\n")
		) 
		(t 
		    fprintf(port "<article id=\"%s\">\n" 
			(sec_info->name)
		    ) 
		    fprintf(port "  <h2><span class=\"collapse-open-icon\"></span>%s</h2>\n" 
			(sec_info->title)
		    ) 
		    fprintf(port "  <section class=\"inneraccordion\">\n") 
		    foreach(block 
			cdr(sec) 
			funcall(printHeader port block) 
			fprintf(port "  <div>\n") 
			funcall(printTable port block 4)
			fprintf(port "  </div>\n")
		    )
		    fprintf(port "  </section>\n") 
		    fprintf(port "</article>\n")
		)
	    )
	) 
	(js_source = strcat(axlGetVariable("ALLEGRO_INSTALL_ROOT") "/share/pcb/toolbox/config/jQuery.js")) 
	if(isFile(js_source) then 
	    (inport = infile(js_source)) 
	    while((line = _gets(inport)) 
		fprintf(port "%s" line)
	    ) 
	    close(inport)
	    else 
	    printf("Warning: Cannot find file %L\n" js_source)
	) 
	fprintf(port "</body>\n")
	fprintf(port "</html>\n") 
	close(port) 
	printf("Note: File %L has been written\n" html_file) t
    )
)
procedure(TBX_DESCOMPARE_IPC_Boolean_Process(tile_poly_box v1_poly_data v2_poly_data cur_layer create_detailed_output
	oversize
    ) 
    let((v1_poly_data_tile v2_poly_data_tile and_poly_data v1_diff_poly_data v2_diff_poly_data
	    tmp_poly_data a_andnot_b b_andnot_a
	) 
	(v1_poly_data_tile = (axlPolyOperation tile_poly_box v1_poly_data 
		'AND
	    )) 
	(v2_poly_data_tile = (axlPolyOperation tile_poly_box v2_poly_data 
		'AND
	    )) 
	when(axlGetVariable("FLW_DEBUG") 
	    foreach(pl v1_poly_data_tile 
		(axlDBCreateShape pl t 
		    ((tbx_descompare_data->config)->dbgLayerV1)
		)
	    ) 
	    foreach(pl v2_poly_data_tile 
		(axlDBCreateShape pl t 
		    ((tbx_descompare_data->config)->dbgLayerV2)
		)
	    )
	) 
	if(oversize then 
	    (a_andnot_b = (axlPolyOperation v1_poly_data_tile 
		    (axlPolyExpand v2_poly_data_tile oversize 
			'ALL_ARC
		    ) 
		    'ANDNOT
		)) 
	    (b_andnot_a = (axlPolyOperation v2_poly_data_tile 
		    (axlPolyExpand v1_poly_data_tile oversize 
			'ALL_ARC
		    ) 
		    'ANDNOT
		)) else
	    (a_andnot_b = (axlPolyOperation v1_poly_data_tile v2_poly_data_tile 
		    'ANDNOT
		)) 
	    (b_andnot_a = (axlPolyOperation v2_poly_data_tile v1_poly_data_tile 
		    'ANDNOT
		))
	)
	when(car(a_andnot_b) 
	    foreach(pl a_andnot_b 
		(axlDBCreateShape pl t 
		    (cur_layer->diff)
		)
	    )
	) 
	when(car(b_andnot_a) 
	    foreach(pl b_andnot_a 
		(axlDBCreateShape pl t 
		    (cur_layer->diff)
		)
	    )
	) 
	when(create_detailed_output 
	    (and_poly_data = (axlPolyOperation v1_poly_data_tile v2_poly_data_tile 
		    'AND
		)) 
	    (and_poly_data = (axlPolyExpand and_poly_data oversize 
		    'ALL_ARC
		)) 
	    (tmp_poly_data = (axlPolyOperation tile_poly_box and_poly_data 
		    'ANDNOT
		)) 
	    when(oversize 
		(v1_poly_data_tile = (axlPolyExpand v1_poly_data_tile 
			(- oversize) 
			'ALL_ARC
		    )) 
		(v2_poly_data_tile = (axlPolyExpand v2_poly_data_tile 
			(- oversize) 
			'ALL_ARC
		    ))
	    )
	    (v1_diff_poly_data = (axlPolyOperation tmp_poly_data v1_poly_data_tile 
		    'AND
		)) 
	    (v2_diff_poly_data = (axlPolyOperation tmp_poly_data v2_poly_data_tile 
		    'AND
		)) 
	    when(car(and_poly_data) 
		foreach(pl and_poly_data 
		    (axlDBCreateShape pl t 
			(cur_layer->com)
		    )
		)
	    ) 
	    when(car(v1_diff_poly_data) 
		foreach(pl v1_diff_poly_data 
		    (axlDBCreateShape pl t 
			(cur_layer->v1r)
		    )
		)
	    ) 
	    when(car(v2_diff_poly_data) 
		foreach(pl v2_diff_poly_data 
		    (axlDBCreateShape pl t 
			(cur_layer->v2r)
		    )
		)
	    )
	)
    )
)
procedure(TBX_DESCOMPARE_IPC_Build_Layer_Sets() 
    let((mfg_layers first_info second_info lparam first_layer
	    second_layer diff_layer layer_set base_name com_layer
	    v1r_layer v2r_layer
	) 
	(mfg_layers = ((axlGetParam 
		    sprintf(nil "paramLayerGroup:%s" 
			(axlMapClassName "MANUFACTURING")
		    )
		)->groupMembers)) 
	(mfg_layers = mapcar(lambda((x) 
		    upperCase(x)
		) mfg_layers
	    )) 
	(mfg_layers = rexMatchList("^TBX_" mfg_layers)) 
	(first_info = makeTable("first_info_data" nil))
	(second_info = makeTable("second_info_data" nil)) 
	foreach(lyr mfg_layers 
	    rexCompile("^TBX_") 
	    (base_name = rexReplace(lyr "" 0)) 
	    cond((rexMatchp("_V1$" base_name) 
		    rexCompile("_V1$") 
		    (base_name = rexReplace(base_name "" 0)) 
		    (first_info[base_name] = t)
		) 
		(rexMatchp("_V2$" base_name) 
		    rexCompile("_V2$") 
		    (base_name = rexReplace(base_name "" 0)) 
		    (second_info[base_name] = t)
		)
	    )
	) 
	(layer_set = makeTable("layer_set_data" nil)) 
	foreach(bn first_info 
	    when((first_info[bn] && second_info[bn]) 
		(first_layer = strcat((axlMapClassName "MANUFACTURING") "/" "TBX_" bn "_V1")) 
		(second_layer = strcat((axlMapClassName "MANUFACTURING") "/" "TBX_" bn "_V2")) 
		(diff_layer = strcat((axlMapClassName "MANUFACTURING") "/" "TBX_" bn "_DIFF")) 
		(v1r_layer = strcat((axlMapClassName "MANUFACTURING") "/" "TBX_" bn "_V1R"))
		(v2r_layer = strcat((axlMapClassName "MANUFACTURING") "/" "TBX_" bn "_V2R")) 
		(com_layer = strcat((axlMapClassName "MANUFACTURING") "/" "TBX_" bn "_COM")) 
		(layer_set[bn] = list(first_layer second_layer diff_layer v1r_layer v2r_layer
			com_layer
		    )) 
		foreach(lyr 
		    cddr(layer_set[bn]) 
		    unless((axlIsLayer lyr) 
			(axlLayerCreateNonConductor lyr) 
			(lparam = (axlLayerGet lyr)) 
			(lparam->color = 81) 
			(axlLayerSet lparam)
		    )
		)
	    )
	) layer_set
    )
)
procedure(TBX_DESCOMPARE_IPC_Callback(form_handle) 
    let((selected_rows color_list param name_list bbox
	    layer_list msg
	) 
	case((form_handle->curField) 
	    ("layer_grid" 
		(selected_rows = (axlFormGridSelected form_handle "layer_grid")) 
		caseq((form_handle->event) 
		    (rightpopupPre 
			cond((zerop(length(selected_rows)) 
				printf("Info: Select at least one row before invoking context menu.\n") 
				(axlFormBuildPopup form_handle "layer_grid" 
				    ((tbx_descompare_data->gridPopup)->singleSelect)
				)
			    ) 
			    (onep(length(selected_rows)) 
				(axlFormBuildPopup form_handle "layer_grid" 
				    ((tbx_descompare_data->gridPopup)->singleSelect)
				)
			    ) 
			    (t 
				(axlFormBuildPopup form_handle "layer_grid" 
				    ((tbx_descompare_data->gridPopup)->multiSelect)
				)
			    )
			)
		    ) 
		    (rightpopup 
			(name_list = TBX_DESCOMPARE_IPC_Get_Base_Names(selected_rows)) 
			(layer_list = mapcar(lambda((x) 
				    car(x)
				) name_list
			    )) 
			when(name_list 
			    (bbox = ((tbx_descompare_data->session)->drawingExtents)) 
			    when((axlFormGetField form_handle "check_outline_area_only") 
				(bbox = ((tbx_descompare_data->session)->boardExtents))
			    ) 
			    case((form_handle->curValue) 
				("compare_selected" 
				    TBX_DESCOMPARE_IPC_Compare_Start(form_handle name_list bbox) 
				    TBX_DESCOMPARE_IPC_Show_Differences(name_list)
				) 
				("run_tolerance_check" 
				    TBX_DESCOMPARE_IPC_Run_Tolerance_Check(form_handle name_list) 
				    TBX_DESCOMPARE_IPC_Show_Differences(name_list)
				) 
				("show_diff_selected" 
				    TBX_DESCOMPARE_IPC_Show_Differences(name_list)
				) 
				("create_drc_selected" 
				    TBX_DESCOMPARE_IPC_Create_DRC(name_list)
				)
				("report_selected" 
				    printf("Report for: %L\n" layer_list)
				) 
				("clear_diff_selected" 
				    TBX_DESCOMPARE_IPC_Clear_Differences(name_list)
				) 
				("limit_view_default" 
				    TBX_DESCOMPARE_IPC_Limit_View(form_handle name_list "default")
				) 
				("limit_view_details" 
				    TBX_DESCOMPARE_IPC_Limit_View(form_handle name_list "details")
				)
			    )
			)
		    ) 
		    (rowselect t)
		)
	    ) 
	    ("on_off_v1" 
		(selected_rows = (axlFormGridSelected form_handle "layer_grid")) 
		(name_list = TBX_DESCOMPARE_IPC_Get_Base_Names(selected_rows)) 
		(layer_list = TBX_DESCOMPARE_IPC_Get_Layer_Names(name_list "V1")) 
		TBX_DESCOMPARE_IPC_Toggle_Display(layer_list)
	    ) 
	    ("color_v1" 
		(color_list = (axlCVFColorChooserDlg 0)) 
		when(color_list 
		    (selected_rows = (axlFormGridSelected form_handle "layer_grid")) 
		    (name_list = TBX_DESCOMPARE_IPC_Get_Base_Names(selected_rows)) 
		    (layer_list = TBX_DESCOMPARE_IPC_Get_Layer_Names(name_list "V1" t)) 
		    foreach(lyr layer_list 
			(param = (axlLayerGet lyr)) 
			(param->color = car(color_list)) 
			(axlLayerSet param)
		    )
		    (axlFormSetField form_handle "color_v1" 
			car(color_list)
		    )
		) 
		(axlVisibleUpdate t)
	    ) 
	    ("raise_v1" 
		(selected_rows = (axlFormGridSelected form_handle "layer_grid")) 
		(name_list = TBX_DESCOMPARE_IPC_Get_Base_Names(selected_rows)) 
		(layer_list = TBX_DESCOMPARE_IPC_Get_Layer_Names(name_list "V1")) 
		(axlVisibleLayer 
		    car(layer_list) t
		)
		(axlDBControl 
		    'activeLayer 
		    car(layer_list)
		) 
		(axlVisibleUpdate t)
	    )
	    ("on_off_v2" 
		(selected_rows = (axlFormGridSelected form_handle "layer_grid")) 
		(name_list = TBX_DESCOMPARE_IPC_Get_Base_Names(selected_rows)) 
		(layer_list = TBX_DESCOMPARE_IPC_Get_Layer_Names(name_list "V2")) 
		TBX_DESCOMPARE_IPC_Toggle_Display(layer_list)
	    ) 
	    ("color_v2" 
		(color_list = (axlCVFColorChooserDlg 0)) 
		when(color_list 
		    (selected_rows = (axlFormGridSelected form_handle "layer_grid")) 
		    (name_list = TBX_DESCOMPARE_IPC_Get_Base_Names(selected_rows)) 
		    (layer_list = TBX_DESCOMPARE_IPC_Get_Layer_Names(name_list "V2" t)) 
		    foreach(lyr layer_list 
			(param = (axlLayerGet lyr)) 
			(param->color = car(color_list)) 
			(axlLayerSet param)
		    )
		    (axlFormSetField form_handle "color_v2" 
			car(color_list)
		    )
		) 
		(axlVisibleUpdate t)
	    ) 
	    ("raise_v2" 
		(selected_rows = (axlFormGridSelected form_handle "layer_grid")) 
		(name_list = TBX_DESCOMPARE_IPC_Get_Base_Names(selected_rows)) 
		(layer_list = TBX_DESCOMPARE_IPC_Get_Layer_Names(name_list "V2")) 
		(axlVisibleLayer 
		    car(layer_list) t
		)
		(axlDBControl 
		    'activeLayer 
		    car(layer_list)
		) 
		(axlVisibleUpdate t)
	    ) 
	    ("on_off_diff" 
		(selected_rows = (axlFormGridSelected form_handle "layer_grid")) 
		(name_list = TBX_DESCOMPARE_IPC_Get_Base_Names(selected_rows)) 
		(layer_list = TBX_DESCOMPARE_IPC_Get_Layer_Names(name_list "DIFF")) 
		TBX_DESCOMPARE_IPC_Toggle_Display(layer_list)
	    ) 
	    ("color_diff" 
		(color_list = (axlCVFColorChooserDlg 0)) 
		when(color_list 
		    (selected_rows = (axlFormGridSelected form_handle "layer_grid")) 
		    (name_list = TBX_DESCOMPARE_IPC_Get_Base_Names(selected_rows)) 
		    (layer_list = TBX_DESCOMPARE_IPC_Get_Layer_Names(name_list "DIFF" t)) 
		    foreach(lyr layer_list 
			(param = (axlLayerGet lyr)) 
			(param->color = car(color_list)) 
			(axlLayerSet param)
		    )
		    (axlFormSetField form_handle "color_diff" 
			car(color_list)
		    )
		) 
		(axlVisibleUpdate t)
	    )
	    ("raise_diff" 
		(selected_rows = (axlFormGridSelected form_handle "layer_grid")) 
		(name_list = TBX_DESCOMPARE_IPC_Get_Base_Names(selected_rows)) 
		(layer_list = TBX_DESCOMPARE_IPC_Get_Layer_Names(name_list "DIFF")) 
		(axlVisibleLayer 
		    car(layer_list) t
		)
		(axlDBControl 
		    'activeLayer 
		    car(layer_list)
		) 
		(axlVisibleUpdate t)
	    ) 
	    ("create_detailed_output" 
		when((form_handle->curValue) 
		    ((tbx_descompare_data->session)->createDetailedOutput = t)
		)
	    ) 
	    ("detailed_output_mini_help" 
		(msg = "If enabled, 6 subclasses instead of 3 will be created for each IPC layer. Layer suffixes have following meaning:") 
		(msg = sprintf(nil "%s\n_V1: Original CAD data V1" msg)) 
		(msg = sprintf(nil "%s\n_V2: Original CAD data V2" msg)) 
		(msg = sprintf(nil "%s\n_DIFF: Differences between V1 and V2 (XOR)" msg))
		(msg = sprintf(nil "%s\n_COM: Common graphics of V1 and V2 (AND)" msg)) 
		(msg = sprintf(nil "%s\n_V1R: V1 remaining graphics (V1 ANDNOT Com)" msg)) 
		(msg = sprintf(nil "%s\n_V2R: V2 remaining graphics (V2 ANDNOT Com)" msg)) 
		(axlUIConfirm msg)
	    ) 
	    ("global_show" 
		TBX_DESCOMPARE_IPC_Change_Visibility((form_handle->curValue))
	    ) 
	    ("global_hide" 
		TBX_DESCOMPARE_IPC_Change_Visibility((form_handle->curValue))
	    )
	    ("compare" 
		(name_list = TBX_DESCOMPARE_IPC_Get_Base_Names("all")) 
		(layer_list = mapcar(lambda((x) 
			    car(x)
			) name_list
		    )) 
		when(name_list 
		    (bbox = ((tbx_descompare_data->session)->drawingExtents)) 
		    when((axlFormGetField form_handle "check_outline_area_only") 
			(bbox = ((tbx_descompare_data->session)->boardExtents))
		    ) 
		    TBX_DESCOMPARE_IPC_Compare_Start(form_handle name_list bbox) 
		    TBX_DESCOMPARE_IPC_Show_Differences(name_list)
		)
	    ) 
	    ("run_tolerance_check" 
		(name_list = TBX_DESCOMPARE_IPC_Get_Base_Names("all")) 
		(layer_list = mapcar(lambda((x) 
			    car(x)
			) name_list
		    )) 
		TBX_DESCOMPARE_IPC_Run_Tolerance_Check(form_handle name_list) 
		TBX_DESCOMPARE_IPC_Show_Differences(name_list)
	    ) 
	    ("create_drc" 
		(name_list = TBX_DESCOMPARE_IPC_Get_Base_Names("all")) 
		(layer_list = mapcar(lambda((x) 
			    car(x)
			) name_list
		    )) 
		TBX_DESCOMPARE_IPC_Create_DRC(name_list)
	    ) 
	    ("clear" 
		case((form_handle->curValue) 
		    ("clear_drc" 
			TBX_DESCOMPARE_IPC_Clear_DRC_Markers()
		    ) 
		    ("clear_differences" 
			(name_list = TBX_DESCOMPARE_IPC_Get_Base_Names("all")) 
			TBX_DESCOMPARE_IPC_Clear_Differences(name_list)
		    ) 
		    ("clear_ipc" 
			TBX_DESCOMPARE_IPC_Purge_Database()
		    )
		)
	    ) 
	    ("done" 
		TBX_DESCOMPARE_IPC_Save_Config() 
		(axlFinishEnterFun) 
		(axlFormClose form_handle) 
		(axlClearSelSet)
		(axlClearDynamics) 
		(axlSaveDesign ?noConfirm t)
	    )
	    ("cancel" 
		(axlCancelEnterFun)
	    ) 
	    ("my_help" 
		TBX_HELP_Launch("descompare")
	    )
	)
    )
)
procedure(TBX_DESCOMPARE_IPC_Change_Extents(v1_info v2_info) 
    let((box1 box2 cur_design_units new_box box_ll
	    box_ur x_ll y_ll x_ur y_ur
	    result
	) 
	(cur_design_units = car((axlDBGetDesignUnits))) 
	(box_ll = car((v1_info->extents))) 
	(box_ur = cadr((v1_info->extents))) 
	(x_ll = car(box_ll))
	(y_ll = cadr(box_ll)) 
	(x_ur = car(box_ur)) 
	(y_ur = cadr(box_ur)) 
	(x_ll = (axlMKSConvert x_ll 
		(v1_info->units) cur_design_units
	    )) 
	(y_ll = (axlMKSConvert y_ll 
		(v1_info->units) cur_design_units
	    ))
	(x_ur = (axlMKSConvert x_ur 
		(v1_info->units) cur_design_units
	    )) 
	(y_ur = (axlMKSConvert y_ur 
		(v1_info->units) cur_design_units
	    )) 
	(box1 = list((x_ll:y_ll) 
		(x_ur:y_ur)
	    )) 
	(box_ll = car((v2_info->extents))) 
	(box_ur = cadr((v2_info->extents)))
	(x_ll = car(box_ll)) 
	(y_ll = cadr(box_ll)) 
	(x_ur = car(box_ur)) 
	(y_ur = cadr(box_ur)) 
	(x_ll = (axlMKSConvert x_ll 
		(v2_info->units) cur_design_units
	    ))
	(y_ll = (axlMKSConvert y_ll 
		(v2_info->units) cur_design_units
	    )) 
	(x_ur = (axlMKSConvert x_ur 
		(v2_info->units) cur_design_units
	    )) 
	(y_ur = (axlMKSConvert y_ur 
		(v2_info->units) cur_design_units
	    )) 
	(box2 = list((x_ll:y_ll) 
		(x_ur:y_ur)
	    )) 
	(new_box = (bBoxAdd box1 box2))
	(result = (axlDBChangeDesignExtents new_box)) 
	(axlDBCheck 
	    'general
	) 
	(axlDBChangeDesignUnits 
	    (v1_info->units) 
	    (v1_info->accuracy)
	) 
	(axlDBCheck 
	    'general
	) result
    )
)
procedure(TBX_DESCOMPARE_IPC_Change_Visibility(arg) 
    let((drc_layer) 
	(drc_layer = strcat((axlMapClassName "DRC ERROR CLASS") "/ALL")) 
	case(arg 
	    ("all_layers_on" 
		(axlVisibleDesign t)
	    ) 
	    ("all_layers_off" 
		(axlVisibleDesign nil)
	    ) 
	    ("all_compare_layers_on" 
		foreach(bn 
		    (tbx_descompare_data->layerSet) 
		    foreach(lyr 
			(tbx_descompare_data->layerSet)[bn] 
			(axlVisibleLayer lyr t)
		    )
		)
	    ) 
	    ("all_compare_layers_off" 
		foreach(bn 
		    (tbx_descompare_data->layerSet) 
		    foreach(lyr 
			(tbx_descompare_data->layerSet)[bn] 
			(axlVisibleLayer lyr nil)
		    )
		)
	    )
	    ("all_v1_layers_on" 
		foreach(bn 
		    (tbx_descompare_data->layerSet) 
		    (axlVisibleLayer 
			car((tbx_descompare_data->layerSet)[bn]) t
		    )
		)
	    ) 
	    ("all_v1_layers_off" 
		foreach(bn 
		    (tbx_descompare_data->layerSet) 
		    (axlVisibleLayer 
			car((tbx_descompare_data->layerSet)[bn]) nil
		    )
		)
	    ) 
	    ("all_v2_layers_on" 
		foreach(bn 
		    (tbx_descompare_data->layerSet) 
		    (axlVisibleLayer 
			cadr((tbx_descompare_data->layerSet)[bn]) t
		    )
		)
	    ) 
	    ("all_v2_layers_off" 
		foreach(bn 
		    (tbx_descompare_data->layerSet) 
		    (axlVisibleLayer 
			cadr((tbx_descompare_data->layerSet)[bn]) nil
		    )
		)
	    ) 
	    ("all_diff_layers_on" 
		foreach(bn 
		    (tbx_descompare_data->layerSet) 
		    (axlVisibleLayer 
			caddr((tbx_descompare_data->layerSet)[bn]) t
		    )
		)
	    )
	    ("all_diff_layers_off" 
		foreach(bn 
		    (tbx_descompare_data->layerSet) 
		    (axlVisibleLayer 
			caddr((tbx_descompare_data->layerSet)[bn]) nil
		    )
		)
	    ) 
	    ("all_v1r_layers_on" 
		foreach(bn 
		    (tbx_descompare_data->layerSet) 
		    (axlVisibleLayer 
			nth(3 
			    (tbx_descompare_data->layerSet)[bn]
			) t
		    )
		)
	    ) 
	    ("all_v1r_layers_off" 
		foreach(bn 
		    (tbx_descompare_data->layerSet) 
		    (axlVisibleLayer 
			nth(3 
			    (tbx_descompare_data->layerSet)[bn]
			) nil
		    )
		)
	    ) 
	    ("all_v2r_layers_on" 
		foreach(bn 
		    (tbx_descompare_data->layerSet) 
		    (axlVisibleLayer 
			nth(4 
			    (tbx_descompare_data->layerSet)[bn]
			) t
		    )
		)
	    ) 
	    ("all_v2r_layers_off" 
		foreach(bn 
		    (tbx_descompare_data->layerSet) 
		    (axlVisibleLayer 
			nth(4 
			    (tbx_descompare_data->layerSet)[bn]
			) nil
		    )
		)
	    )
	    ("all_com_layers_on" 
		foreach(bn 
		    (tbx_descompare_data->layerSet) 
		    (axlVisibleLayer 
			nth(5 
			    (tbx_descompare_data->layerSet)[bn]
			) t
		    )
		)
	    ) 
	    ("all_com_layers_off" 
		foreach(bn 
		    (tbx_descompare_data->layerSet) 
		    (axlVisibleLayer 
			nth(5 
			    (tbx_descompare_data->layerSet)[bn]
			) nil
		    )
		)
	    ) 
	    ("drc_on" 
		(axlVisibleLayer drc_layer t)
	    ) 
	    ("drc_off" 
		(axlVisibleLayer drc_layer nil)
	    )
	) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_DESCOMPARE_IPC_Cleanup_Layers(cls_name match_regxp remove_layer) 
    let((layer_list full_layer_name) 
	(match_regxp = upperCase(match_regxp)) 
	foreach(lyr 
	    ((axlGetParam 
		    sprintf(nil "paramLayerGroup:%s" 
			(axlMapClassName cls_name)
		    )
		)->groupMembers) 
	    when(rexMatchp(match_regxp 
		    upperCase(lyr)
		) 
		(full_layer_name = strcat((axlMapClassName cls_name) "/" lyr)) 
		(layer_list = cons(full_layer_name layer_list)) 
		(axlVisibleLayer full_layer_name t)
	    )
	) 
	when(layer_list 
	    (axlDeleteByLayer layer_list 
		'fixed
	    )
	) 
	when(remove_layer 
	    foreach(lyr layer_list 
		printf("Info: Removing layer %L\n" lyr) 
		(axlDeleteObject 
		    (axlLayerGet lyr)
		)
	    )
	)
	t
    )
)
procedure(TBX_DESCOMPARE_IPC_Clear_DRC_Markers() 
    let((drc_list) 
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "drcs") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	(drc_list = setof(x 
		(axlGetSelSet) 
		(((x->name) == "Externally Determined Violation") && ((x->source) == "DESIGN-COMPARE"))
	    ))
	(axlClearSelSet) 
	when(drc_list 
	    (axlDeleteObject drc_list)
	) t
    )
)
procedure(TBX_DESCOMPARE_IPC_Clear_Differences(name_list) 
    let((base_name layer_set diff_layer diff_layer_list) 
	(axlVisibleDesign nil) 
	foreach(entry name_list 
	    (base_name = car(entry)) 
	    (layer_set = (tbx_descompare_data->layerSet)[base_name]) 
	    (diff_layer = caddr(layer_set))
	    (diff_layer_list = cons(diff_layer diff_layer_list)) 
	    (axlVisibleLayer diff_layer t)
	) 
	(axlVisibleUpdate nil) 
	(axlDeleteByLayer diff_layer_list 
	    'fixed
	)
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_DESCOMPARE_IPC_Compare_Data(bbox tile_size_x tile_size_y msg_data) 
    let((xy_ll xy_ur x_ll y_ll x_ur
	    y_ur sel_set rpath cur_x cur_y
	    tile_vertices tile_poly_box v2_data v1_data v1_poly_data
	    v2_poly_data tile_start_time tile_stop_time width height
	    tile_id_x tile_id_y elem_cnt elapse_time info_1
	    info_2 layer_name tile_cnt_x tile_cnt_y cur_tile_id
	    acc_value and_oversize
	) 
	when(axlGetVariable("TBX_DESCOMPARE_POLY_MODE") 
	    (acc_value = atoi(axlGetVariable("TBX_DESCOMPARE_POLY_MODE"))) 
	    (and_oversize = (1.0 / (10**acc_value))) 
	    (and_oversize = and_oversize)
	) 
	(xy_ll = car(bbox)) 
	(xy_ur = cadr(bbox)) 
	(x_ll = car(xy_ll))
	(y_ll = cadr(xy_ll)) 
	(x_ur = car(xy_ur)) 
	(y_ur = cadr(xy_ur)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "linesegs" "shapes") ?onButtons 
	    list("all")
	) 
	(cur_x = x_ll)
	(cur_y = y_ll) 
	(tile_id_y = 1) 
	when(msg_data 
	    (layer_name = car(msg_data)) 
	    (tile_cnt_x = cadr(msg_data)) 
	    (tile_cnt_y = caddr(msg_data)) 
	    (info_1 = sprintf(nil "Checking %s..." layer_name))
	    (info_2 = sprintf(nil "Tile 1 of %d" 
		    (tile_cnt_x * tile_cnt_y)
		)) 
	    (axlMeterCreate "Layer Compare" info_1 t nil
		info_2
	    )
	) 
	while(((cur_y < y_ur) && !(axlMeterIsCancelled)) 
	    (cur_x = x_ll) 
	    (tile_id_x = 1) 
	    while((cur_x < x_ur) 
		(tile_start_time = cputime()) 
		if(((cur_x + tile_size_x) < x_ur) then 
		    (width = tile_size_x) else 
		    (width = (x_ur - cur_x))
		) 
		if(((cur_y + tile_size_y) < y_ur) then 
		    (height = tile_size_y) else 
		    (height = (y_ur - cur_y))
		) 
		(tile_vertices = list((cur_x:cur_y) 
			((cur_x + width):cur_y) 
			((cur_x + width):(cur_y + height)) 
			(cur_x:(cur_y + height)) 
			(cur_x:cur_y)
		    ))
		(rpath = (axlPathStart tile_vertices 0.0)) 
		(axlDBCreateShape rpath nil 
		    ((tbx_descompare_data->config)->tmpLayer)
		) 
		(axlVisibleUpdate nil) 
		(tile_poly_box = car((axlPolyFromDB rpath))) 
		(axlClearSelSet)
		(axlSingleSelectBox 
		    list((cur_x:cur_y) 
			((cur_x + width):(cur_y + height))
		    )
		) 
		(sel_set = (axlGetSelSet)) 
		(axlClearSelSet) 
		(elem_cnt = length(sel_set)) 
		cond(((elem_cnt > 5000) 
			printf("Note: Starting adaptive tiling for master: %L  %L\n" tile_id_x tile_id_y) 
			TBX_DESCOMPARE_IPC_Compare_Data(list((cur_x:cur_y) 
				((cur_x + width):(cur_y + height))
			    ) 
			    (width / 2.0) 
			    (height / 2.0) nil
			)
		    ) 
		    ((elem_cnt > 0) 
			(v2_data = setof(x sel_set 
				((x->layer) == ((tbx_descompare_data->curLayer)->v2))
			    )) 
			(v1_data = setof(x sel_set 
				((x->layer) == ((tbx_descompare_data->curLayer)->v1))
			    )) 
			(elem_cnt = length(v2_data)) 
			(v1_poly_data = mapcar(lambda((x) 
				    car((axlPolyFromDB x ?endCapType 
					    'OCTAGON
					)
				    )
				) v1_data
			    ))
			(v2_poly_data = mapcar(lambda((x) 
				    car((axlPolyFromDB x ?endCapType 
					    'OCTAGON
					)
				    )
				) v2_data
			    )) 
			TBX_DESCOMPARE_IPC_Boolean_Process(tile_poly_box v1_poly_data v2_poly_data 
			    (tbx_descompare_data->curLayer) 
			    ((tbx_descompare_data->session)->createDetailedOutput)
			    ((tbx_descompare_data->session)->overSize)
			) 
			(v1_data = nil) 
			(v2_data = nil) 
			(v1_poly_data = nil)
			(v2_poly_data = nil) 
			(axlDBRefreshId nil)
		    ) 
		    (t t)
		)
		(cur_x = (cur_x + tile_size_x)) 
		(tile_stop_time = cputime()) 
		(elapse_time = ((tile_stop_time - tile_start_time) / 60.0)) 
		tconc((tbx_descompare_data->viewLog) 
		    list(tile_id_x tile_id_y elem_cnt elapse_time)
		) 
		++tile_id_x
		when(msg_data 
		    (cur_tile_id = (((tile_id_y - 1) * tile_cnt_x) + tile_id_x)) 
		    (info_1 = sprintf(nil "Checking %s..." layer_name)) 
		    (info_2 = sprintf(nil "Tile %d of %d" cur_tile_id 
			    (tile_cnt_x * tile_cnt_y)
			)) 
		    when((cur_tile_id <= (tile_cnt_x * tile_cnt_y)) 
			(axlMeterUpdate 
			    ((100 * cur_tile_id) / (tile_cnt_x * tile_cnt_y)) info_1 info_2
			)
		    )
		)
	    ) 
	    (cur_y = (cur_y + tile_size_y))
	    ++tile_id_y
	) 
	when(msg_data 
	    (axlMeterDestroy)
	)
	t
    )
)
procedure(TBX_DESCOMPARE_IPC_Compare_Launch() 
    let((result FORM_FILE fid create_film undef_width
	    v1_result v2_result param cur_dir current_design
	    continue
	) 
	((tbx_descompare_data->dbInfo)["v1"]->ipcOutput = strcat(((tbx_descompare_data->session)->runDirAbs) "/v1_ipc2581.xml")) 
	((tbx_descompare_data->dbInfo)["v2"]->ipcOutput = strcat(((tbx_descompare_data->session)->runDirAbs) "/v2_ipc2581.xml")) 
	(continue = TBX_DESCOMPARE_Save_Design_Prompt()) 
	when(continue 
	    unless(((tbx_descompare_data->session)->usePreviousSession) 
		TBX_UTIL_No_Confirm((tbx_descompare_data->env) "set") 
		if(((tbx_descompare_data->session)->useDefaultArtwork) then 
		    (create_film = list(nil 
			    'etch t 
			    'mask t
			    'outline t
			)) else 
		    (create_film = list(nil 
			    'etch nil 
			    'mask nil
			    'outline t
			))
		) 
		(undef_width = list(nil 
			'line 
			((tbx_descompare_data->session)->undefLineWidth) 
			'text 
			((tbx_descompare_data->session)->undefPhotoWidth)
			'units 
			((tbx_descompare_data->session)->masterUnits)
		    )) 
		(cur_dir = getWorkingDir())
		changeWorkingDir(((tbx_descompare_data->session)->runDirAbs)) 
		(current_design = caddr((axlDMFileParts 
			    (axlGetDrawingName)
			)
		    )) 
		((tbx_descompare_data->session)->tmpDesigns = TBX_DESCOMPARE_Copy_Designs()) 
		(axlOpenDesign ?design 
		    car(((tbx_descompare_data->session)->tmpDesigns)) ?mode "wf"
		) 
		(axlShell "show element; done")
		(v1_result = TBX_DESCOMPARE_IPC_Prepare_Design(create_film undef_width)) 
		(axlSaveDesign ?noConfirm t ?design 
		    car(((tbx_descompare_data->session)->tmpDesigns))
		) 
		(axlOpenDesign ?design 
		    cadr(((tbx_descompare_data->session)->tmpDesigns)) ?mode "wf"
		) 
		(axlShell "show element; done") 
		(v2_result = TBX_DESCOMPARE_IPC_Prepare_Design(create_film undef_width))
		(axlSaveDesign ?noConfirm t ?design 
		    cadr(((tbx_descompare_data->session)->tmpDesigns))
		) 
		when(v1_result 
		    ((tbx_descompare_data->dbInfo)["v1"]->ipcLayerInfo = (v1_result->ipcLayerInfo)) 
		    ((tbx_descompare_data->dbInfo)["v1"]->filmLayers = (v1_result->filmLayers)) 
		    ((tbx_descompare_data->dbInfo)["v1"]->extents = (v1_result->extents)) 
		    ((tbx_descompare_data->dbInfo)["v1"]->units = (v1_result->units))
		    ((tbx_descompare_data->dbInfo)["v1"]->accuracy = (v1_result->accuracy))
		) 
		when(v2_result 
		    ((tbx_descompare_data->dbInfo)["v2"]->ipcLayerInfo = (v2_result->ipcLayerInfo)) 
		    ((tbx_descompare_data->dbInfo)["v2"]->filmLayers = (v2_result->filmLayers)) 
		    ((tbx_descompare_data->dbInfo)["v2"]->extents = (v2_result->extents)) 
		    ((tbx_descompare_data->dbInfo)["v2"]->units = (v2_result->units))
		    ((tbx_descompare_data->dbInfo)["v2"]->accuracy = (v1_result->accuracy))
		) 
		changeWorkingDir(cur_dir) 
		(axlOpenDesign ?design current_design ?mode "wf")
		((tbx_descompare_data->dbInfo)["v1"]->designTmp = strcat(((tbx_descompare_data->session)->runDirAbs) "/" 
			car(((tbx_descompare_data->session)->tmpDesigns))
		    )) 
		((tbx_descompare_data->dbInfo)["v2"]->designTmp = strcat(((tbx_descompare_data->session)->runDirAbs) "/" 
			cadr(((tbx_descompare_data->session)->tmpDesigns))
		    )) 
		TBX_DESCOMPARE_IPC_Load_Data() 
		TBX_UTIL_No_Confirm((tbx_descompare_data->env) "reset")
	    ) 
	    unless((axlIsLayer 
		    ((tbx_descompare_data->config)->tmpLayer)
		) 
		(axlLayerCreateNonConductor 
		    ((tbx_descompare_data->config)->tmpLayer)
		) 
		(param = (axlLayerGet 
			((tbx_descompare_data->config)->tmpLayer)
		    )) 
		(param->color = (axlDBDisplayControl 
			'tempColor
		    )) 
		(axlSetParam param)
	    ) 
	    (tbx_descompare_data->layerSet = TBX_DESCOMPARE_IPC_Build_Layer_Sets()) 
	    unless(((tbx_descompare_data->session)->usePreviousSession) 
		TBX_DESCOMPARE_IPC_Convert_Figures((tbx_descompare_data->layerSet))
	    )
	    (result = TBX_DESCOMPARE_IPC_Get_Extents((tbx_descompare_data->layerSet))) 
	    when(result 
		((tbx_descompare_data->session)->boardExtents = (result->boardExtents)) 
		((tbx_descompare_data->session)->drawingExtents = (result->drawingExtents))
	    ) 
	    (tbx_descompare_data->gridData = TBX_DESCOMPARE_IPC_Setup_Grid_Data((tbx_descompare_data->layerSet) 
		    ((tbx_descompare_data->dbInfo)["v1"]->ipcLayerInfo)
		)) 
	    (FORM_FILE = TBX_FORM_Get_Name((tbx_descompare_data->licCheck) "descompare_ipc")) 
	    unless(boundp('tbxDescompareIPC) 
		defvar(tbxDescompareIPC nil)
	    )
	    (fid = (axlFormCreate 
		    'tbxDescompareIPC FORM_FILE 
		    '(e outer) 
		    'TBX_DESCOMPARE_IPC_Callback
		    t nil
		)) 
	    when(fid 
		TBX_DESCOMPARE_IPC_Init_Form(fid) 
		(axlFormDisplay fid) 
		TBX_FORM_Init_Header(fid "Licensed for " 
		    (tbx_descompare_data->licCheck) 
		    ((tbx_descompare_data->appInfo)->title)
		)
	    ) FORM_FILE
	)
    )
)
procedure(TBX_DESCOMPARE_IPC_Compare_Start(form_handle name_list bbox) 
    let((tile_size tile_size_x tile_size_y layer_list base_name
	    row_num cell diff_cnt msg_data box_ll
	    box_ur box_width box_height tile_cnt_x tile_cnt_y
	    merge_diff acc
	) 
	(merge_diff = (axlFormGetField form_handle "merge_differences")) 
	(axlWindowBoxSet bbox) 
	(axlVisibleUpdate t) 
	(tile_size = (axlMKSConvert "20.0 MM" 
		car((axlDBGetDesignUnits))
	    ))
	(tile_size_x = tile_size) 
	(tile_size_y = tile_size) 
	(box_ll = car(bbox)) 
	(box_ur = cadr(bbox)) 
	(box_width = abs((car(box_ur) - car(box_ll))))
	(box_height = abs((cadr(box_ur) - cadr(box_ll)))) 
	(tile_cnt_x = (floor((box_width / tile_size_x)) + 1)) 
	(tile_cnt_y = (floor((box_height / tile_size_y)) + 1)) 
	when(axlGetVariable("FLW_DEBUG") 
	    foreach(lyr 
		list(((tbx_descompare_data->config)->dbgLayerV1) 
		    ((tbx_descompare_data->config)->dbgLayerV2) 
		    ((tbx_descompare_data->config)->dbgLayerOR) 
		    ((tbx_descompare_data->config)->dbgLayerAND)
		) 
		unless((axlIsLayer lyr) 
		    (axlLayerCreateNonConductor lyr)
		)
	    )
	) 
	(acc = cadr((axlDBGetDesignUnits)))
	when((acc > 0) 
	    ((tbx_descompare_data->session)->overSize = (1.0 / (10**acc)))
	) 
	foreach(entry name_list 
	    (base_name = car(entry)) 
	    (row_num = cadr(entry)) 
	    (layer_list = (tbx_descompare_data->layerSet)[base_name])
	    (msg_data = list(base_name tile_cnt_x tile_cnt_y)) 
	    ((tbx_descompare_data->curLayer)->v1 = car(layer_list)) 
	    ((tbx_descompare_data->curLayer)->v2 = cadr(layer_list)) 
	    ((tbx_descompare_data->curLayer)->diff = caddr(layer_list)) 
	    ((tbx_descompare_data->curLayer)->v1r = nth(3 layer_list))
	    ((tbx_descompare_data->curLayer)->v2r = nth(4 layer_list)) 
	    ((tbx_descompare_data->curLayer)->com = nth(5 layer_list)) 
	    (axlVisibleDesign nil) 
	    (axlVisibleLayer 
		((tbx_descompare_data->config)->tmpLayer) t
	    ) 
	    (axlVisibleLayer 
		((tbx_descompare_data->curLayer)->diff) t
	    )
	    (axlVisibleUpdate t) 
	    (axlDeleteByLayer 
		((tbx_descompare_data->config)->tmpLayer) 
		'fixed
	    ) 
	    (axlDeleteByLayer 
		((tbx_descompare_data->curLayer)->diff) 
		'fixed
	    ) 
	    (axlVisibleLayer 
		((tbx_descompare_data->curLayer)->v1) t
	    ) 
	    (axlVisibleLayer 
		((tbx_descompare_data->curLayer)->v2) t
	    )
	    (axlVisibleUpdate t) 
	    TBX_DESCOMPARE_IPC_Compare_Data(bbox tile_size_x tile_size_y msg_data) 
	    (diff_cnt = TBX_DESCOMPARE_IPC_Get_Differences(((tbx_descompare_data->curLayer)->diff) merge_diff)) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 3)
	    (cell->row = row_num) 
	    (cell->value = sprintf(nil "%d" diff_cnt)) 
	    (cell->noEdit = t) 
	    (cell->backColor = 'white) 
	    (axlFormSetField form_handle "layer_grid" cell)
	    (axlFormGridUpdate form_handle "layer_grid")
	) t
    )
)
procedure(TBX_DESCOMPARE_IPC_Convert_Figures(layer_set) 
    let((orgvis figure_poly figure_layer) 
	(orgvis = (axlVisibleGet)) 
	(axlVisibleDesign nil) 
	foreach(bn layer_set 
	    (axlVisibleLayer 
		car(layer_set[bn]) t
	    ) 
	    (axlVisibleLayer 
		cadr(layer_set[bn]) t
	    )
	) 
	(axlVisibleUpdate nil)
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    list("noall" "figures") ?onButtons 
	    list("all")
	) 
	(axlAddSelectAll) 
	foreach(fg 
	    (axlGetSelSet) 
	    (figure_layer = (fg->layer)) 
	    (figure_poly = car(TBX_DBCORE_Poly_From_Figure(fg))) 
	    when(figure_poly 
		if(((fg->figureName) == "NULL") then 
		    (axlDBCreateShape figure_poly nil figure_layer) else 
		    (axlDBCreateShape figure_poly t figure_layer)
		)
	    )
	) 
	(axlClearSelSet)
	(axlVisibleSet orgvis)
    )
)
procedure(TBX_DESCOMPARE_IPC_Create_DRC(name_list) 
    let((orgvis base_name layer_set diff_layer first_seg
	    drc_xy drc_layer
	) 
	(orgvis = (axlVisibleGet)) 
	(axlVisibleDesign nil) 
	foreach(entry name_list 
	    (base_name = car(entry)) 
	    (layer_set = (tbx_descompare_data->layerSet)[base_name]) 
	    (diff_layer = caddr(layer_set))
	    (axlVisibleLayer diff_layer t)
	) 
	(axlSetFindFilter ?enabled 
	    list("noall" "boundary_shapes" "shapes") ?onButtons 
	    list("all")
	)
	(axlClearSelSet) 
	(axlAddSelectAll) 
	foreach(shp 
	    (axlGetSelSet) 
	    (first_seg = car((shp->segments))) 
	    (drc_xy = car((first_seg->startEnd))) 
	    (drc_layer = (shp->layer))
	    (axlDBCreateExternalDRC 
		list("DESIGN-COMPARE" "") drc_xy "DRC ERROR CLASS/ALL" shp
		nil drc_layer
	    )
	) 
	(axlClearSelSet) 
	(axlVisibleSet orgvis)
	(axlVisibleLayer "DRC ERROR CLASS/ALL" t) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_DESCOMPARE_IPC_Create_Default_Films(ok_etch ok_mask ok_outline) 
    let((sequence_id undef_line_width shape_bounding_box etch_layer pin_layer
	    via_layer pkg_layer board_layer is_negative ipc_layer_type
	    layer_list param outline_layers defined_outline_layers
	) 
	(undef_line_width = TBX_UTIL_Smart_Convert("0.05  MM" "2.0   MILS")) 
	(shape_bounding_box = TBX_UTIL_Smart_Convert("2.54  MM" "100.0 MILS")) 
	(ipc_layer_type = 'inner) 
	when((ok_etch && ok_mask && ok_outline) 
	    (axlDeleteObject 
		(axlGetParam "artwork")
	    ) 
	    (axlDBRefreshId nil)
	)
	(sequence_id = 1) 
	when(ok_etch 
	    foreach(lyr 
		(axlSubclassRoute) 
		(etch_layer = strcat((axlMapClassName "ETCH") "/" lyr)) 
		(pin_layer = strcat((axlMapClassName "PIN") "/" lyr)) 
		(via_layer = strcat((axlMapClassName "VIA CLASS") "/" lyr))
		(param = (axlLayerGet etch_layer)) 
		(is_negative = nil) 
		when((((param->type) == "PLANE") && ((param->drcPhotoType) == "negative")) 
		    (is_negative = t)
		) 
		(ipc_layer_type = 'inner) 
		when(((lyr == "TOP") || (lyr == "BOTTOM")) 
		    (ipc_layer_type = 'outer)
		)
		(axlFilmCreate lyr ?negative is_negative ?undefineLineWidth
		    undef_line_width ?sequence sequence_id ?rotation 0
		    ?xOffset 0.0 ?yOffset 0.0 ?shapeBoundingBox
		    shape_bounding_box ?mirrored nil ?fullContact nil
		    ?suppressUnconnectPads nil ?drawMissingPadApertures nil ?useApertureRotation
		    nil ?suppressShapeFill nil ?vectorBasedPad t
		    ?drawHolesOnly nil ?domains 
		    list('ipc2581 
			'pdf 
			'artwork 
			'visibility
		    ) ?ipc2581
		    list(ipc_layer_type) ?layers 
		    list(etch_layer pin_layer via_layer)
		) 
		++sequence_id
	    )
	) 
	when(ok_mask 
	    foreach(lyr 
		list("SOLDERMASK_TOP" "SOLDERMASK_BOTTOM" "PASTEMASK_TOP" "PASTEMASK_BOTTOM") 
		(pin_layer = strcat((axlMapClassName "PIN") "/" lyr)) 
		(via_layer = strcat((axlMapClassName "VIA CLASS") "/" lyr)) 
		(pkg_layer = strcat((axlMapClassName "PACKAGE GEOMETRY") "/" lyr))
		(board_layer = strcat((axlMapClassName "BOARD GEOMETRY") "/" lyr)) 
		(layer_list = nil) 
		foreach(smlyr 
		    list(pin_layer via_layer pkg_layer board_layer) 
		    when((axlIsLayer smlyr) 
			(layer_list = cons(smlyr layer_list))
		    )
		) 
		when(layer_list 
		    (is_negative = nil) 
		    (ipc_layer_type = 'soldermask) 
		    (axlFilmCreate lyr ?negative is_negative ?undefineLineWidth
			undef_line_width ?sequence sequence_id ?rotation 0
			?xOffset 0.0 ?yOffset 0.0 ?shapeBoundingBox
			shape_bounding_box ?mirrored nil ?fullContact nil
			?suppressUnconnectPads nil ?drawMissingPadApertures nil ?useApertureRotation
			nil ?suppressShapeFill nil ?vectorBasedPad t
			?drawHolesOnly nil ?domains 
			list('ipc2581 
			    'pdf 
			    'artwork 
			    'visibility
			) ?ipc2581
			list(ipc_layer_type) ?layers layer_list
		    ) 
		    ++sequence_id
		)
	    )
	) 
	when((ok_outline && !member("OUTLINE" 
			((axlGetParam "artwork")->groupMembers)
		    )) 
	    (board_layer = strcat((axlMapClassName "BOARD GEOMETRY") "/OUTLINE")) 
	    (outline_layers = list(strcat((axlMapClassName "BOARD GEOMETRY") "/OUTLINE") 
		    strcat((axlMapClassName "BOARD GEOMETRY") "/DESIGN_OUTLINE") 
		    strcat((axlMapClassName "BOARD GEOMETRY") "/CUTOUT")
		)) 
	    (defined_outline_layers = setof(x outline_layers 
		    (axlIsLayer x)
		)) 
	    when(defined_outline_layers 
		(is_negative = nil) 
		(ipc_layer_type = 'misc) 
		(axlFilmCreate "OUTLINE" ?negative is_negative ?undefineLineWidth
		    undef_line_width ?sequence sequence_id ?rotation 0
		    ?xOffset 0.0 ?yOffset 0.0 ?shapeBoundingBox
		    shape_bounding_box ?mirrored nil ?fullContact nil
		    ?suppressUnconnectPads nil ?drawMissingPadApertures nil ?useApertureRotation
		    nil ?suppressShapeFill nil ?vectorBasedPad t
		    ?drawHolesOnly nil ?domains 
		    list('ipc2581 
			'pdf 
			'artwork 
			'visibility
		    ) ?ipc2581
		    list(ipc_layer_type) ?layers defined_outline_layers
		) 
		++sequence_id
	    )
	) 
	(axlDBRefreshId nil)
	t
    )
)
procedure(TBX_DESCOMPARE_IPC_Export_XML(design_path output_file attr_file) 
    let((cmd_str dsn) 
	if((design_path == (axlGetDrawingName)) then 
	    (dsn = "%s") else 
	    (dsn = design_path)
	) 
	(cmd_str = sprintf(nil "ipc2581_out -u Millimeter -P OTHER -f 1.02 -o %s -l  -b  -p -t -d -c -R -n -D -O -I -M -S -e -g  %s  %s" output_file attr_file dsn)) 
	(axlRunBatchDBProgram "ipc2581_out" cmd_str)
    )
)
procedure(TBX_DESCOMPARE_IPC_Get_Base_Names(row_list) 
    let((name_list) 
	cond((((type(row_list) == 'string) && (row_list == "all")) 
		for(r 1 
		    (length((tbx_descompare_data->gridData)) - 1) 
		    (name_list = cons(list(((tbx_descompare_data->gridData)[r]->layerName) r) name_list))
		)
	    ) 
	    ((length(row_list) > 0) 
		foreach(r row_list 
		    (name_list = cons(list(((tbx_descompare_data->gridData)[r]->layerName) r) name_list))
		)
	    ) 
	    (t 
		(name_list = nil)
	    )
	) 
	(name_list = reverse(name_list)) name_list
    )
)
procedure(TBX_DESCOMPARE_IPC_Get_Differences(diff_layer merge_diff) 
    let((diff_cnt poly_list poly_list_merged cur_data) 
	(axlVisibleDesign nil) 
	(axlVisibleLayer diff_layer t) 
	(axlVisibleUpdate nil) 
	(axlSetFindFilter ?enabled 
	    list("noall" "boundary_shapes" "shapes") ?onButtons 
	    list("all")
	)
	(axlClearSelSet) 
	(axlAddSelectAll) 
	(cur_data = (axlGetSelSet)) 
	(axlClearSelSet) 
	(poly_list = mapcar(lambda((x) 
		    car((axlPolyFromDB x))
		) cur_data
	    ))
	(axlDeleteObject cur_data) 
	(diff_cnt = 0) 
	when(poly_list 
	    (poly_list_merged = poly_list) 
	    when((merge_diff && (length(poly_list) > 1)) 
		(poly_list_merged = (axlPolyOperation 
			car(poly_list) 
			cdr(poly_list) 
			'OR
		    ))
	    ) 
	    (diff_cnt = length(poly_list_merged)) 
	    foreach(pl poly_list_merged 
		(axlDBCreateShape pl t diff_layer)
	    )
	) diff_cnt
    )
)
procedure(TBX_DESCOMPARE_IPC_Get_Extents(layerSet) 
    let((orgvis layout_extents drawing_extents result offset
	    layout_extents_offset
	) 
	(offset = TBX_UTIL_Smart_Convert("1.0 MM" "40.0 MILS")) 
	(drawing_extents = (axlExtentDB 
		'obstacle
	    )) 
	(result = ncons(nil)) 
	if(layerSet["OUTLINE"] then 
	    (orgvis = (axlVisibleGet)) 
	    (axlVisibleDesign nil) 
	    (axlVisibleLayer 
		car(layerSet["OUTLINE"]) t
	    )
	    (axlVisibleLayer 
		cadr(layerSet["OUTLINE"]) t
	    ) 
	    (axlVisibleUpdate nil) 
	    (axlSetFindFilter ?enabled 
		list("noall" "lines" "shapes") ?onButtons 
		list("all")
	    ) 
	    (axlClearSelSet) 
	    (axlAddSelectAll)
	    when((axlGetSelSet) 
		(layout_extents = (axlDBGetExtents 
			(axlGetSelSet) nil
		    ))
	    ) 
	    (axlVisibleSet orgvis) 
	    (axlClearSelSet) 
	    (axlVisibleUpdate t) 
	    if(layout_extents then 
		(layout_extents_offset = (bBoxAdd layout_extents 
			list(((- offset):(- offset)) 
			    (offset:offset)
			)
		    )) 
		if(((axlIsPointInsideBox 
			    car(layout_extents_offset) drawing_extents
			) && (axlIsPointInsideBox 
			    cadr(layout_extents_offset) drawing_extents
			)) then 
		    (result->boardExtents = layout_extents_offset) else 
		    (result->boardExtents = layout_extents)
		) else
		(result->boardExtents = drawing_extents)
	    )
	    else 
	    (result->boardExtents = drawing_extents)
	)
	(result->drawingExtents = drawing_extents) result
    )
)
procedure(TBX_DESCOMPARE_IPC_Get_Layer_Info() 
    let((ipc_info art_info result film_name all_film_layers
	    intOrder cnt layerOrder pat base_name
	    etch_subclasses cond_cnt mask_cnt misc_cnt doc_cnt
	) 
	(intOrder = makeTable("int_order_table_data" nil)) 
	(layerOrder = makeTable("layer_order_table_data" nil)) 
	(cnt = 0) 
	(etch_subclasses = (axlSubclassRoute))
	foreach(scls etch_subclasses 
	    (intOrder[scls] = ++cnt) 
	    (layerOrder["ETCH"] = cons(list(cnt scls) 
		    layerOrder["ETCH"]
		))
	) 
	(ipc_info = makeTable("ipc_info_data" nil)) 
	(result = ncons(nil)) 
	foreach(artdef 
	    ((axlGetParam "artwork")->groupMembers) 
	    (art_info = (axlGetParam 
		    strcat("artwork:" artdef)
		)) 
	    (film_name = upperCase((art_info->name))) 
	    (ipc_info[film_name] = ncons(nil))
	    (all_film_layers = nconc(all_film_layers 
		    (art_info->groupMembers)
		)) 
	    if(member("ipc2581" 
		    (art_info->domains)
		) then 
		(ipc_info[film_name]->inDomain = t) else 
		(ipc_info[film_name]->inDomain = nil)
	    ) 
	    when((art_info->ipc2581) 
		case(car((art_info->ipc2581)) 
		    ("outer" 
			(ipc_info[film_name]->type = "etch")
		    ) 
		    ("inner" 
			(ipc_info[film_name]->type = "etch")
		    ) 
		    ("soldermask" 
			(ipc_info[film_name]->type = "mask")
		    ) 
		    ("doc" 
			(ipc_info[film_name]->type = "doc")
		    )
		    ("misc" 
			(ipc_info[film_name]->type = "misc")
		    )
		)
	    ) 
	    foreach(scls etch_subclasses 
		(pat = strcat("_" scls "$")) 
		when(rexMatchp(pat film_name) 
		    (base_name = rexReplace(film_name "" 0)) 
		    (layerOrder[base_name] = cons(list(intOrder[scls] scls) 
			    layerOrder[base_name]
			))
		)
	    )
	) 
	foreach(bn layerOrder 
	    (layerOrder[bn] = sortcar(layerOrder[bn] 
		    'lessp
		))
	)
	(cond_cnt = 0) 
	(mask_cnt = 0) 
	(misc_cnt = 0) 
	(doc_cnt = 0) 
	foreach(entry 
	    layerOrder["ETCH"] 
	    (film_name = cadr(entry)) 
	    when((ipc_info[film_name] && ((ipc_info[film_name]->type) == "etch")) 
		(ipc_info[film_name]->order = ++cond_cnt)
	    )
	)
	foreach(mtype 
	    list("SOLDERMASK" "PASTEMASK") 
	    foreach(entry 
		layerOrder[mtype] 
		(film_name = strcat(mtype "_" 
			cadr(entry)
		    )) 
		when((ipc_info[film_name] && ((ipc_info[film_name]->type) == "mask")) 
		    (ipc_info[film_name]->order = ++mask_cnt)
		)
	    )
	) 
	when(layerOrder["ETCH"] 
	    remove("ETCH" layerOrder)
	) 
	when(layerOrder["SOLDERMASK"] 
	    remove("SOLDERMASK" layerOrder)
	) 
	when(layerOrder["PASTEMASK"] 
	    remove("PASTEMASK" layerOrder)
	) 
	foreach(grp layerOrder 
	    foreach(entry 
		layerOrder[grp] 
		(film_name = strcat(grp "_" 
			cadr(entry)
		    )) 
		when(ipc_info[film_name] 
		    case((ipc_info[film_name]->type) 
			("etch" 
			    (ipc_info[film_name]->order = ++cond_cnt)
			) 
			("misc" 
			    (ipc_info[film_name]->order = ++misc_cnt)
			) 
			("doc" 
			    (ipc_info[film_name]->order = ++doc_cnt)
			) 
			("mask" 
			    (ipc_info[film_name]->order = ++mask_cnt)
			)
		    )
		)
	    )
	)
	foreach(fn ipc_info 
	    unless((ipc_info[fn]->order) 
		case((ipc_info[fn]->type) 
		    ("etch" 
			(ipc_info[fn]->order = ++cond_cnt)
		    ) 
		    ("misc" 
			(ipc_info[fn]->order = ++misc_cnt)
		    ) 
		    ("doc" 
			(ipc_info[fn]->order = ++doc_cnt)
		    ) 
		    ("mask" 
			(ipc_info[fn]->order = ++mask_cnt)
		    )
		)
	    )
	) 
	(result = list(ipc_info all_film_layers)) result
    )
)
procedure((TBX_DESCOMPARE_IPC_Get_Layer_Names name_list layer_type \@optional include_extended_layers) 
    let((base_name layer_list layer_set) 
	foreach(entry name_list 
	    (base_name = car(entry)) 
	    (layer_set = (tbx_descompare_data->layerSet)[base_name]) 
	    case(layer_type 
		("V1" 
		    (layer_list = cons(car(layer_set) layer_list)) 
		    when((include_extended_layers && nth(3 layer_set)) 
			(layer_list = cons(nth(3 layer_set) layer_list))
		    )
		) 
		("V2" 
		    (layer_list = cons(cadr(layer_set) layer_list)) 
		    when((include_extended_layers && nth(4 layer_set)) 
			(layer_list = cons(nth(4 layer_set) layer_list))
		    )
		) 
		("DIFF" 
		    (layer_list = cons(caddr(layer_set) layer_list)) 
		    when((include_extended_layers && nth(5 layer_set)) 
			(layer_list = cons(nth(5 layer_set) layer_list))
		    )
		) 
		(t t)
	    )
	) 
	(layer_list = sort(layer_list nil)) layer_list
    )
)
procedure(TBX_DESCOMPARE_IPC_Import_XML(input_file) 
    let((cmd_str ipc_layers) 
	(cmd_str = sprintf(nil "ipc2581_in -g  %s  -o %%s" input_file)) 
	(axlRunBatchDBProgram "ipc2581_in" cmd_str ?reloadDB t
	    ?silent t
	) 
	(axlVisibleUpdate t) 
	foreach(lyr 
	    ((axlGetParam 
		    sprintf(nil "paramLayerGroup:%s" 
			(axlMapClassName "MANUFACTURING")
		    )
		)->groupMembers) 
	    when(rexMatchp("^IPC_" 
		    upperCase(lyr)
		) 
		(ipc_layers = cons(upperCase(lyr) ipc_layers))
	    )
	)
	(ipc_layers = sort(ipc_layers nil)) ipc_layers
    )
)
procedure(TBX_DESCOMPARE_IPC_Init_Form(form_handle) 
    let((first_layer_base_name layer_set tmp_data layer_name field_name
	    layer_color
	) 
	(axlFormSetField form_handle "first_dsn" 
	    caddr((axlDMFileParts 
		    ((tbx_descompare_data->dbInfo)["v1"]->designPath)
		)
	    )
	) 
	(axlFormSetField form_handle "second_dsn" 
	    caddr((axlDMFileParts 
		    ((tbx_descompare_data->dbInfo)["v2"]->designPath)
		)
	    )
	) 
	(axlFormSetField form_handle "check_outline_area_only" t) 
	(axlFormSetField form_handle "min_ap" 
	    TBX_UTIL_Smart_Convert("0.005 MM" "0.2 MILS")
	)
	(axlFormSetField form_handle "min_area" 
	    TBX_UTIL_Smart_Convert("0.025 MM" "1.0 MILS")
	) 
	(axlFormGridReset form_handle "layer_grid") 
	TBX_DESCOMPARE_IPC_Init_Grid_Cols(form_handle) 
	TBX_DESCOMPARE_IPC_Init_Grid_Rows(form_handle) 
	(axlFormGridUpdate form_handle "layer_grid")
	(axlFormGridEvents form_handle "layer_grid" 
	    list('mrowselect 
		'rightpopup 
		'rightpopupPre
	    )
	) 
	when(((tbx_descompare_data->gridData) && (length((tbx_descompare_data->gridData)) > 1)) 
	    (first_layer_base_name = ((tbx_descompare_data->gridData)[1]->layerName)) 
	    (layer_set = (tbx_descompare_data->layerSet)[first_layer_base_name]) 
	    (tmp_data = list(list(car(layer_set) "color_v1") 
		    list(cadr(layer_set) "color_v2") 
		    list(caddr(layer_set) "color_diff")
		)) 
	    foreach(entry tmp_data 
		(layer_name = car(entry)) 
		(field_name = cadr(entry)) 
		(layer_color = ((axlLayerGet layer_name)->color))
		(axlFormSetField form_handle field_name layer_color)
	    )
	    (axlDBControl 
		'activeLayer 
		car(layer_set)
	    )
	) 
	(axlVisibleUpdate t)
    )
)
procedure(TBX_DESCOMPARE_IPC_Init_Grid_Cols(form_handle) 
    let((p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 12) 
	(p->fieldLength = 255)
	(p->headText = "Layer") 
	(p->scriptLabel = "layer_name") 
	(axlFormGridInsertCol form_handle "layer_grid" p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING)
	(p->colWidth = 5) 
	(p->fieldLength = 20) 
	(p->headText = "Type") 
	(p->scriptLabel = "layer_type") 
	(axlFormGridInsertCol form_handle "layer_grid" p)
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 5) 
	(p->fieldLength = 20) 
	(p->headText = "Differences")
	(p->scriptLabel = "diff_count") 
	(axlFormGridInsertCol form_handle "layer_grid" p)
    )
)
procedure(TBX_DESCOMPARE_IPC_Init_Grid_Rows(form_handle) 
    if(((tbx_descompare_data->gridData) && (length((tbx_descompare_data->gridData)) > 1)) then 
	(axlFormGridInsertRows form_handle "layer_grid" 0 
	    (length((tbx_descompare_data->gridData)) - 1)
	) 
	(axlFormGridSetBatch form_handle "layer_grid" 
	    'TBX_DESCOMPARE_IPC_Init_Grid_Rows_CB nil
	) else
	printf("Warning: Issues occurred while extracting, cannot fill grid...\n")
    )
)
procedure(TBX_DESCOMPARE_IPC_Init_Grid_Rows_CB(pvt_data) 
    let((cell rownum layer_name layer_type diff_cnt) 
	(pvt_data = pvt_data) 
	(rownum = 1) 
	for(i 1 
	    (length((tbx_descompare_data->gridData)) - 1) 
	    (layer_name = ((tbx_descompare_data->gridData)[i]->layerName)) 
	    (layer_type = ((tbx_descompare_data->gridData)[i]->layerType))
	    (diff_cnt = ((tbx_descompare_data->gridData)[i]->diffCnt)) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 1) 
	    (cell->row = rownum) 
	    (cell->value = layer_name)
	    (cell->noEdit = t) 
	    (cell->backColor = 'white) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 2)
	    (cell->row = rownum) 
	    (cell->value = layer_type) 
	    (cell->noEdit = t) 
	    (cell->backColor = 'white) 
	    (axlFormGridBatch cell)
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 3) 
	    (cell->row = rownum) 
	    (cell->value = diff_cnt) 
	    (cell->noEdit = t)
	    (cell->backColor = 'white) 
	    (axlFormGridBatch cell) 
	    rownum++
	)
    )
)
procedure(TBX_DESCOMPARE_IPC_Limit_View(fh name_list mode) 
    let((layer_set is_vis_drc outline_view_selected base_name tbx_layers
	    drc_layer v1_layer v2_layer diff_layer
	) 
	(drc_layer = strcat((axlMapClassName "DRC ERROR CLASS") "/ALL")) 
	(is_vis_drc = (axlIsVisibleLayer drc_layer)) 
	foreach(entry name_list 
	    (base_name = car(entry)) 
	    (layer_set = (tbx_descompare_data->layerSet)[base_name]) 
	    when((base_name == "OUTLINE") 
		(outline_view_selected = t)
	    )
	    unless(v1_layer 
		(v1_layer = car(layer_set))
	    ) 
	    unless(v2_layer 
		(v2_layer = cadr(layer_set))
	    ) 
	    unless(diff_layer 
		(diff_layer = caddr(layer_set))
	    ) 
	    if((mode == "details") then 
		(tbx_layers = cons(nth(3 layer_set) tbx_layers)) 
		(tbx_layers = cons(nth(4 layer_set) tbx_layers)) 
		(tbx_layers = cons(nth(5 layer_set) tbx_layers))
		else 
		(tbx_layers = cons(car(layer_set) tbx_layers)) 
		(tbx_layers = cons(cadr(layer_set) tbx_layers)) 
		(tbx_layers = cons(caddr(layer_set) tbx_layers))
	    )
	) 
	(tbx_layers = reverse(tbx_layers))
	(axlVisibleDesign nil) 
	(axlVisibleLayer drc_layer is_vis_drc) 
	foreach(lyr tbx_layers 
	    (axlVisibleLayer lyr t)
	) 
	when((tbx_descompare_data->layerSet)["OUTLINE"] 
	    if((outline_view_selected && (mode == "details")) then 
		(axlVisibleLayer 
		    car((tbx_descompare_data->layerSet)["OUTLINE"]) nil
		) 
		(axlVisibleLayer 
		    cadr((tbx_descompare_data->layerSet)["OUTLINE"]) nil
		) else
		(axlVisibleLayer 
		    car((tbx_descompare_data->layerSet)["OUTLINE"]) t
		) 
		(axlVisibleLayer 
		    cadr((tbx_descompare_data->layerSet)["OUTLINE"]) t
		)
	    )
	) 
	unless(tbx_layers 
	    (tbx_layers = (tbx_descompare_data->layerSet)["OUTLINE"])
	)
	(axlDBControl 
	    'activeLayer 
	    car(tbx_layers)
	) 
	(axlFormSetField fh "color_v1" 
	    ((axlLayerGet v1_layer)->color)
	) 
	(axlFormSetField fh "color_v2" 
	    ((axlLayerGet v2_layer)->color)
	) 
	(axlFormSetField fh "color_diff" 
	    ((axlLayerGet diff_layer)->color)
	) 
	(axlVisibleUpdate t)
    )
)
procedure(TBX_DESCOMPARE_IPC_Load_Data() 
    let((ipc_layers_first port ipc_layers_second attr_file fit_box
	    ipc2581_out_log ipc2581_out_log_v1 ipc2581_out_log_v2 ipc2581_in_log ipc2581_in_log_v1
	    ipc2581_in_log_v2
	) 
	if(((tbx_descompare_data->session)->newDiffDesign) then 
	    (axlOpenDesign ?design 
		((tbx_descompare_data->session)->newDiffDesign) ?mode "wf"
	    ) else 
	    (axlOpenDesign ?design 
		((tbx_descompare_data->session)->masterDesign) ?mode "wf"
	    )
	) 
	when(((tbx_descompare_data->session)->newDiffDesign) 
	    TBX_DESCOMPARE_IPC_Change_Extents((tbx_descompare_data->dbInfo)["v1"] 
		(tbx_descompare_data->dbInfo)["v2"]
	    )
	) 
	(axlSaveDesign) 
	TBX_DESCOMPARE_IPC_Cleanup_Layers("MANUFACTURING" "^TBX_.*_V1$" nil)
	TBX_DESCOMPARE_IPC_Cleanup_Layers("MANUFACTURING" "^TBX_.*_V2$" nil) 
	TBX_DESCOMPARE_IPC_Cleanup_Layers("MANUFACTURING" "^TBX_.*_DIFF$" nil) 
	(attr_file = strcat(((tbx_descompare_data->session)->runDirAbs) "/descompare_config.atr")) 
	(port = outfile(attr_file "w")) 
	fprintf(port "Component/PART_NUMBER\n")
	close(port) 
	(ipc2581_out_log = "./ipc2581_out.log") 
	(ipc2581_out_log_v1 = strcat(((tbx_descompare_data->session)->runDirAbs) "/ipc2581_out_v1.log")) 
	(ipc2581_out_log_v2 = strcat(((tbx_descompare_data->session)->runDirAbs) "/ipc2581_out_v2.log")) 
	TBX_DESCOMPARE_IPC_Export_XML(((tbx_descompare_data->dbInfo)["v1"]->designTmp) 
	    ((tbx_descompare_data->dbInfo)["v1"]->ipcOutput) attr_file
	)
	when(isFile(ipc2581_out_log) 
	    (axlOSFileMove ipc2581_out_log ipc2581_out_log_v1)
	) 
	TBX_DESCOMPARE_IPC_Export_XML(((tbx_descompare_data->dbInfo)["v2"]->designTmp) 
	    ((tbx_descompare_data->dbInfo)["v2"]->ipcOutput) attr_file
	) 
	when(isFile(ipc2581_out_log) 
	    (axlOSFileMove ipc2581_out_log ipc2581_out_log_v2)
	) 
	(ipc2581_in_log = "./ipc2581_in.log") 
	(ipc2581_in_log_v1 = strcat(((tbx_descompare_data->session)->runDirAbs) "/ipc2581_in_v1.log"))
	(ipc2581_in_log_v2 = strcat(((tbx_descompare_data->session)->runDirAbs) "/ipc2581_in_v2.log")) 
	(ipc_layers_first = TBX_DESCOMPARE_IPC_Import_XML(((tbx_descompare_data->dbInfo)["v1"]->ipcOutput))) 
	(axlSaveDesign) 
	(axlFinishEnterFun) 
	TBX_DESCOMPARE_IPC_Rename_Layers(ipc_layers_first "TBX_" "_V1")
	when(isFile(ipc2581_in_log) 
	    (axlOSFileMove ipc2581_in_log ipc2581_in_log_v1)
	) 
	(ipc_layers_second = TBX_DESCOMPARE_IPC_Import_XML(((tbx_descompare_data->dbInfo)["v2"]->ipcOutput))) 
	TBX_DESCOMPARE_IPC_Rename_Layers(ipc_layers_second "TBX_" "_V2") 
	when(isFile(ipc2581_in_log) 
	    (axlOSFileMove ipc2581_in_log ipc2581_in_log_v2)
	) 
	when(((tbx_descompare_data->session)->newDiffDesign) 
	    (axlSetFindFilter ?enabled 
		list("noall" "invisible" "lines" "shapes") ?onButtons 
		list("all")
	    ) 
	    (axlClearSelSet) 
	    (axlAddSelectAll) 
	    when((axlGetSelSet) 
		(fit_box = (axlDBGetExtents 
			(axlGetSelSet) nil
		    ))
	    )
	    (axlClearSelSet) 
	    when(fit_box 
		(axlDBCreateRectangle fit_box nil 
		    strcat((axlMapClassName "ROUTE KEEPIN") "/ALL")
		)
	    ) 
	    (axlVisibleUpdate nil)
	)
    )
)
procedure(TBX_DESCOMPARE_IPC_Popup_Callback(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_DESCOMPARE_IPC_RMB_Done
		    ) 
		    list("Cancel" 
			'TBX_DESCOMPARE_IPC_RMB_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_DESCOMPARE_IPC_Prepare_Design(create_film undef_width) 
    let((result design_param info orgvis polygon_list
	    polygon_layer delete_list txtparam line_width photo_width
	    zerow_segs
	) 
	(info = ncons(nil)) 
	(line_width = (axlMKSConvert 
		(undef_width->line) 
		(undef_width->units) 
		car((axlDBGetDesignUnits))
	    )) 
	(photo_width = (axlMKSConvert 
		(undef_width->text) 
		(undef_width->units) 
		car((axlDBGetDesignUnits))
	    )) 
	(axlSaveDesign ?noConfirm t)
	TBX_DESCOMPARE_IPC_Create_Default_Films((create_film->etch) 
	    (create_film->mask) 
	    (create_film->outline)
	) 
	(result = TBX_DESCOMPARE_IPC_Get_Layer_Info()) 
	(info->ipcLayerInfo = car(result)) 
	(info->filmLayers = cadr(result)) 
	(orgvis = (axlVisibleGet))
	(axlVisibleDesign nil) 
	foreach(lyr 
	    (info->filmLayers) 
	    (axlVisibleLayer lyr t)
	) 
	(axlVisibleUpdate nil) 
	(design_param = (axlGetParam "paramDesign")) 
	(info->extents = (design_param->bBox))
	(info->units = (design_param->units)) 
	(info->accuracy = (design_param->accuracy)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "boundary_shapes" "shapes") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll)
	(polygon_list = setof(x 
		(axlGetSelSet) 
		((x->objType) == "polygon")
	    )) 
	(axlClearSelSet) 
	foreach(ps polygon_list 
	    (polygon_layer = (ps->layer)) 
	    (result = TBX_DBCORE_Copy_Rpath((axlDB2Path ps) line_width nil)) 
	    when(result 
		(delete_list = cons(ps delete_list)) 
		(axlDBCreatePath 
		    car(result) polygon_layer 
		    'line
		)
	    )
	) 
	when(delete_list 
	    (axlDeleteObject delete_list)
	) 
	(axlDBRefreshId nil)
	(axlSetFindFilter ?enabled 
	    list("noall" "lines") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	when((axlGetSelSet) 
	    foreach(ln 
		(axlGetSelSet) 
		(zerow_segs = nconc(zerow_segs 
			setof(x 
			    (ln->segments) 
			    ((x->width) == 0.0)
			)
		    ))
	    )
	) 
	(axlClearSelSet)
	when(zerow_segs 
	    (axlChangeWidth zerow_segs line_width)
	) 
	for(i 1 
	    (axlDBGetTextBlockCount) 
	    (txtparam = (axlGetParam 
		    sprintf(nil "paramTextBlock:%d" i)
		)) 
	    when(((txtparam->photoWidth) == 0.0) 
		(txtparam->photoWidth = photo_width) 
		(axlSetParam txtparam)
	    )
	) 
	(axlDBRefreshId nil) 
	(axlVisibleSet orgvis) 
	(axlVisibleUpdate nil)
	(axlSaveDesign ?noConfirm t) info
    )
)
procedure(TBX_DESCOMPARE_IPC_Process_Shape(shp min_ap min_area) 
    let((shape_path rp_boundary_data poly_boundary_data poly_final_result rp_hole_data
	    poly_hole_data cur_remain_list cur_poly prev_poly next_poly
	    poly_cnt last_id not_data not_data_exp result
	    debug_mode shape_area shape_layer
	) 
	(debug_mode = axlGetVariable("FLW_DEBUG")) 
	(result = (axlPolyFromDB shp)) 
	when(result 
	    (shape_area = (car(result)->area)) 
	    if((shape_area <= min_area) then 
		(axlDeleteObject shp) else 
		(shape_layer = (shp->layer))
		(shape_path = (axlDB2Path shp)) 
		(rp_boundary_data = TBX_DBCORE_Copy_Rpath(shape_path min_ap t)) 
		foreach(rp rp_boundary_data 
		    (cur_poly = car((axlPolyFromDB rp ?line2poly t ?endCapType
				'ROUND
			    )
			)) 
		    when(cur_poly 
			(poly_boundary_data = cons(cur_poly poly_boundary_data))
		    )
		) 
		when(debug_mode 
		    foreach(pl poly_boundary_data 
			(axlDBCreateShape pl t 
			    ((tbx_descompare_data->config)->dbgLayerBoundary)
			)
		    )
		) 
		(rp_hole_data = list())
		foreach(vd 
		    (shp->voids) 
		    (result = TBX_DBCORE_Copy_Rpath((axlDB2Path vd) min_ap t)) 
		    when(result 
			(rp_hole_data = nconc(rp_hole_data result))
		    )
		) 
		foreach(rp rp_hole_data 
		    (cur_poly = car((axlPolyFromDB rp ?line2poly t ?endCapType
				'ROUND
			    )
			)) 
		    when(cur_poly 
			(poly_hole_data = cons(cur_poly poly_hole_data))
		    )
		) 
		when(debug_mode 
		    foreach(pl poly_hole_data 
			(axlDBCreateShape pl t 
			    ((tbx_descompare_data->config)->dbgLayerHole)
			)
		    )
		) 
		(poly_cnt = length(poly_boundary_data)) 
		(last_id = (poly_cnt - 1))
		for(i 0 last_id 
		    (cur_poly = nth(i poly_boundary_data)) 
		    cond((zerop(i) 
			    (prev_poly = (lastelem poly_boundary_data))
			) 
			((i == last_id) 
			    (prev_poly = nth((last_id - 1) poly_boundary_data)) 
			    (next_poly = car(poly_boundary_data))
			) 
			(t 
			    (prev_poly = nth((i - 1) poly_boundary_data)) 
			    (next_poly = nth((i + 1) poly_boundary_data))
			)
		    )
		    (cur_remain_list = setof(x poly_boundary_data 
			    ((x != cur_poly) && (x != prev_poly) && (x != next_poly))
			)) 
		    when(poly_hole_data 
			(result = (axlPolyOperation cur_poly poly_hole_data 
				'AND
			    )) 
			when(car(result) 
			    (not_data = nconc(not_data result))
			)
		    ) 
		    (result = (axlPolyOperation cur_poly cur_remain_list 
			    'AND
			)) 
		    when(car(result) 
			(not_data = nconc(not_data result))
		    )
		) 
		when(not_data 
		    foreach(nshp not_data 
			(result = (axlPolyExpand nshp 
				(min_ap / 2.0) 
				'ALL_ARC
			    )) 
			when(car(result) 
			    (not_data_exp = cons(car(result) not_data_exp))
			)
		    ) 
		    when(debug_mode 
			foreach(pl not_data_exp 
			    (axlDBCreateShape pl t 
				((tbx_descompare_data->config)->dbgLayerNOT)
			    )
			)
		    ) 
		    (poly_final_result = (axlPolyOperation 
			    car((axlPolyFromDB shp)) not_data_exp 
			    'ANDNOT
			))
		) 
		when(poly_final_result 
		    if(debug_mode then 
			foreach(pl poly_final_result 
			    (axlDBCreateShape pl t 
				((tbx_descompare_data->config)->dbgLayerRESULT)
			    )
			) else 
			(axlDeleteObject shp)
			foreach(pl poly_final_result 
			    (axlDBCreateShape pl t shape_layer)
			)
		    )
		)
	    )
	) poly_final_result
    )
)
procedure(TBX_DESCOMPARE_IPC_Purge_Database() 
    let((orgvis tbx_layers layer_set) 
	foreach(bn 
	    (tbx_descompare_data->layerSet) 
	    (layer_set = (tbx_descompare_data->layerSet)[bn]) 
	    (tbx_layers = nconc(tbx_layers 
		    copy(layer_set)
		))
	) 
	(tbx_layers = cons(((tbx_descompare_data->config)->tmpLayer) tbx_layers)) 
	(orgvis = (axlVisibleGet)) 
	(axlVisibleDesign nil)
	foreach(lyr tbx_layers 
	    (axlVisibleLayer lyr t)
	) 
	(axlVisibleUpdate nil) 
	(axlDeleteByLayer tbx_layers) 
	foreach(lyr tbx_layers 
	    (axlDeleteObject 
		(axlLayerGet lyr)
	    )
	) 
	(axlVisibleSet orgvis)
	(axlDeleteAttachment "tbx_descompare") 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_DESCOMPARE_IPC_RMB_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_DESCOMPARE_IPC_RMB_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_DESCOMPARE_IPC_Read_Config() 
    let((att att_data ipc_info dpl result
	    v1_design v2_design
	) 
	(att = (axlGetAttachment "tbx_descompare" 
		'string
	    )) 
	(result = ncons(nil)) 
	(ipc_info = makeTable("ipc_layer_info_data" nil)) 
	when(att 
	    (att_data = car(linereadstring((att->data)))) 
	    foreach(block att_data 
		caseq(car(block) 
		    (database 
			(dpl = cons(nil 
				cadr(block)
			    )) 
			(v1_design = (dpl->v1)) 
			(v2_design = (dpl->v2))
		    ) 
		    (ipc2581 
			foreach(entry 
			    cdr(block) 
			    (dpl = cons(nil entry)) 
			    (ipc_info[(dpl->name)] = dpl) 
			    remprop(ipc_info[(dpl->name)] 
				'name
			    )
			)
		    )
		)
	    )
	)
	(result = list(v1_design v2_design ipc_info)) result
    )
)
procedure(TBX_DESCOMPARE_IPC_Rename_Layers(layer_list prefix suffix) 
    let((port script_file cur_name new_name cmd
	    rename_list
	) 
	(script_file = strcat(getWorkingDir() "/" 
		((tbx_descompare_data->config)->runDir) "/descompare_rename.scr"
	    )) 
	foreach(lyr layer_list 
	    (cur_name = lyr) 
	    (new_name = lyr) 
	    when((upperCase(prefix) != "IPC_") 
		rexCompile("^[iI][pP][cC]_") 
		(new_name = rexReplace(new_name prefix 0))
	    )
	    (new_name = strcat(new_name suffix)) 
	    (rename_list = cons(list(cur_name new_name) rename_list))
	) 
	(rename_list = sortcar(rename_list nil)) 
	(port = outfile(script_file "w"))
	fprintf(port "version 16.6\n") 
	fprintf(port "\n") 
	fprintf(port "setwindow pcb\n") 
	fprintf(port "trapsize 0\n") 
	fprintf(port "generaledit\n")
	fprintf(port "define subclass \n") 
	fprintf(port "setwindow form.subclass\n") 
	fprintf(port "FORM subclass %s pick  \n" 
	    (axlMapClassName "MANUFACTURING")
	) 
	fprintf(port "setwindow form.subclass_nonetch\n") 
	foreach(entry rename_list 
	    fprintf(port "FORM subclass_nonetch %s rename %s\n" 
		car(entry) 
		cadr(entry)
	    )
	)
	fprintf(port "setwindow form.subclass\n") 
	fprintf(port "FORM subclass done  \n") 
	fprintf(port "setwindow pcb\n") 
	fprintf(port "generaledit \n") 
	close(port)
	(cmd = sprintf(nil "replay  %L" script_file)) 
	(axlShell cmd)
    )
)
procedure(TBX_DESCOMPARE_IPC_Run_Tolerance_Check(form_handle name_list) 
    let((base_name diff_layer orgvis shape_list debug_layers
	    min_ap min_area cell row_num diff_cnt
	    merge_diff
	) 
	(merge_diff = (axlFormGetField form_handle "merge_differences")) 
	when(axlGetVariable("FLW_DEBUG") 
	    (debug_layers = list(((tbx_descompare_data->config)->dbgLayerBoundary) 
		    ((tbx_descompare_data->config)->dbgLayerHole) 
		    ((tbx_descompare_data->config)->dbgLayerNOT) 
		    ((tbx_descompare_data->config)->dbgLayerResult)
		)) 
	    foreach(lyr debug_layers 
		unless((axlIsLayer lyr) 
		    (axlLayerCreateNonConductor lyr)
		) 
		(axlVisibleLayer lyr t)
	    ) 
	    (axlDeleteByLayer debug_layers 
		'fixed
	    )
	) 
	(min_ap = (axlFormGetField form_handle "min_ap")) 
	(min_area = (axlFormGetField form_handle "min_area"))
	(orgvis = (axlVisibleGet)) 
	foreach(entry name_list 
	    (base_name = car(entry)) 
	    (row_num = cadr(entry)) 
	    (diff_layer = caddr((tbx_descompare_data->layerSet)[base_name]))
	    (axlVisibleDesign nil) 
	    (axlVisibleLayer diff_layer t) 
	    (axlVisibleUpdate nil) 
	    (axlSetFindFilter ?enabled 
		list("noall" "boundary_shapes" "shapes") ?onButtons 
		list("all")
	    ) 
	    (axlClearSelSet)
	    (axlAddSelectAll) 
	    (shape_list = (axlGetSelSet)) 
	    (axlClearSelSet) 
	    foreach(shp shape_list 
		TBX_DESCOMPARE_IPC_Process_Shape(shp min_ap min_area)
	    ) 
	    (axlDBRefreshId nil)
	    (diff_cnt = TBX_DESCOMPARE_IPC_Get_Differences(diff_layer merge_diff)) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 3) 
	    (cell->row = row_num) 
	    (cell->value = sprintf(nil "%d" diff_cnt))
	    (cell->noEdit = t) 
	    (cell->backColor = 'white) 
	    (axlFormSetField form_handle "layer_grid" cell) 
	    (axlFormGridUpdate form_handle "layer_grid") 
	    (axlVisibleSet orgvis)
	    (axlVisibleUpdate t)
	) t
    )
)
procedure(TBX_DESCOMPARE_IPC_Save_Config() 
    let((data data_str db_info ipc_info dpl) 
	(db_info = list('database 
		list('v1 
		    ((tbx_descompare_data->dbInfo)["v1"]->designPath) 
		    'v2 
		    ((tbx_descompare_data->dbInfo)["v2"]->designPath)
		)
	    )) 
	foreach(bn 
	    ((tbx_descompare_data->dbInfo)["v1"]->ipcLayerInfo) 
	    (dpl = copy(((tbx_descompare_data->dbInfo)["v1"]->ipcLayerInfo)[bn])) 
	    (dpl->name = bn) 
	    (ipc_info = cons(cdr(dpl) ipc_info))
	) 
	(ipc_info = cons('ipc2581 ipc_info)) 
	(data = list(db_info ipc_info))
	(data_str = sprintf(nil "%L" data)) 
	(axlDeleteAttachment "tbx_descompare") 
	(axlCreateAttachment "tbx_descompare" nil 1 
	    'string
	    data_str
	) t
    )
)
procedure(TBX_DESCOMPARE_IPC_Setup_Grid_Data(layer_set ipc_layer_info) 
    let((display_order grid_id drill_id other_id grid_data
	    etch_order_list mask_order_list misc_order_list doc_order_list drill_order_list
	    other_order_list
	) 
	(drill_id = 0) 
	(other_id = 0) 
	(display_order = nil) 
	foreach(ln layer_set 
	    cond((ipc_layer_info[ln] 
		    case((ipc_layer_info[ln]->type) 
			("etch" 
			    (etch_order_list = cons(list((ipc_layer_info[ln]->order) ln) etch_order_list))
			) 
			("mask" 
			    (mask_order_list = cons(list((ipc_layer_info[ln]->order) ln) mask_order_list))
			) 
			("misc" 
			    (misc_order_list = cons(list((ipc_layer_info[ln]->order) ln) misc_order_list))
			) 
			("doc" 
			    (doc_order_list = cons(list((ipc_layer_info[ln]->order) ln) doc_order_list))
			)
		    )
		) 
		(rexMatchp("DRILL" 
			upperCase(ln)
		    ) 
		    (drill_order_list = cons(list(++drill_id ln) drill_order_list))
		) 
		(t 
		    (other_order_list = cons(list(++other_id ln) other_order_list))
		)
	    )
	)
	(etch_order_list = sortcar(etch_order_list 
		'lessp
	    )) 
	(mask_order_list = sortcar(mask_order_list 
		'lessp
	    )) 
	(misc_order_list = sortcar(misc_order_list 
		'lessp
	    )) 
	(drill_order_list = sortcar(drill_order_list 
		'lessp
	    )) 
	(grid_id = 0)
	(display_order = tconc(nil nil)) 
	foreach(entry etch_order_list 
	    tconc(display_order 
		list(++grid_id 
		    cadr(entry) "Etch"
		)
	    )
	) 
	foreach(entry drill_order_list 
	    tconc(display_order 
		list(++grid_id 
		    cadr(entry) "Drill"
		)
	    )
	) 
	foreach(entry mask_order_list 
	    tconc(display_order 
		list(++grid_id 
		    cadr(entry) "Mask"
		)
	    )
	) 
	foreach(entry doc_order_list 
	    tconc(display_order 
		list(++grid_id 
		    cadr(entry) "Doc"
		)
	    )
	)
	foreach(entry misc_order_list 
	    tconc(display_order 
		list(++grid_id 
		    cadr(entry) "Misc"
		)
	    )
	) 
	foreach(entry other_order_list 
	    tconc(display_order 
		list(++grid_id 
		    cadr(entry) "Other"
		)
	    )
	) 
	(display_order = cdar(display_order)) 
	declare(grid_data[(length(display_order) + 1)]) 
	foreach(entry display_order 
	    (grid_id = car(entry)) 
	    (grid_data[grid_id] = ncons(nil)) 
	    (grid_data[grid_id]->layerName = cadr(entry))
	    (grid_data[grid_id]->layerType = caddr(entry)) 
	    (grid_data[grid_id]->diffCnt = "Not processed")
	)
	grid_data
    )
)
procedure(TBX_DESCOMPARE_IPC_Show_Differences(name_list) 
    let((base_name layer_list diff_layer outline_layers drc_error_class) 
	(drc_error_class = "DRC ERROR CLASS/ALL") 
	foreach(entry name_list 
	    (base_name = car(entry)) 
	    (diff_layer = caddr((tbx_descompare_data->layerSet)[base_name])) 
	    (layer_list = cons(diff_layer layer_list))
	) 
	(layer_list = cons(drc_error_class layer_list)) 
	(outline_layers = (tbx_descompare_data->layerSet)["OUTLINE"])
	when(outline_layers 
	    unless(member(car(outline_layers) layer_list) 
		(layer_list = cons(car(outline_layers) layer_list))
	    ) 
	    unless(member(cadr(outline_layers) layer_list) 
		(layer_list = cons(cadr(outline_layers) layer_list))
	    )
	) 
	(axlVisibleDesign nil) 
	foreach(lyr outline_layers 
	    (axlVisibleLayer lyr t)
	) 
	(axlVisibleLayer drc_error_class t) 
	foreach(lyr layer_list 
	    (axlVisibleLayer lyr t)
	)
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_DESCOMPARE_IPC_Toggle_Display(layer_list) 
    let((is_invis switch_on) 
	(is_invis = setof(x layer_list 
		!(axlIsVisibleLayer x)
	    )) 
	if(is_invis then 
	    (switch_on = t) else 
	    (switch_on = nil)
	) 
	foreach(lyr layer_list 
	    (axlVisibleLayer lyr switch_on)
	) 
	(axlVisibleUpdate t)
	t
    )
)
procedure(TBX_DESCOMPARE_IPC_Viewlog() 
    let((port tile_id_x tile_id_y elem_cnt elapse_time) 
	(port = outfile("./compare.log" "w")) 
	fprintf(port " TileX  TileY  Elements  Time   Elements/Time\n") 
	foreach(entry 
	    cdar((tbx_descompare_data->viewLog)) 
	    (tile_id_x = car(entry)) 
	    (tile_id_y = cadr(entry)) 
	    (elem_cnt = caddr(entry))
	    (elapse_time = nth(3 entry)) 
	    fprintf(port "%3d    %3d    %4d    %f\n" tile_id_x tile_id_y elem_cnt
		elapse_time
	    )
	) 
	close(port)
	printf("Note: File ./compare.log has been written\n")
    )
)
procedure(TBX_DESCOMPARE_Init() 
    let((config grid_popup run_dir FC_FEATURE FC_VERSION
	    SUB_VERSION VERSION_STR app_info design_ext
	) 
	(FC_FEATURE = "DESCOMPARE") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "03") 
	(VERSION_STR = sprintf(nil "Design Compare %s (C)2017" FC_VERSION))
	(app_info = list(nil 
		'name FC_FEATURE 
		'version FC_VERSION
		'release SUB_VERSION 
		'title VERSION_STR
	    )) 
	(run_dir = "./toolbox.run") 
	unless(isDir(run_dir) 
	    createDir(run_dir)
	) 
	(design_ext = "brd") 
	case(lowerCase((axlDesignType t)) 
	    ("mcm" 
		(design_ext = "mcm")
	    ) 
	    ("sip" 
		(design_ext = "sip")
	    )
	)
	(config = ncons(nil)) 
	(config->runDir = "toolbox.run") 
	(config->tmpLayer = strcat((axlMapClassName "MANUFACTURING") "/TBX_DESCOMPARE_TILING")) 
	(config->dbgLayerV1 = strcat((axlMapClassName "DRAWING FORMAT") "/TBX_DBG_V1")) 
	(config->dbgLayerV2 = strcat((axlMapClassName "DRAWING FORMAT") "/TBX_DBG_V2"))
	(config->dbgLayerOR = strcat((axlMapClassName "DRAWING FORMAT") "/TBX_DBG_OR")) 
	(config->dbgLayerAND = strcat((axlMapClassName "DRAWING FORMAT") "/TBX_DBG_AND")) 
	(config->dbgLayerBoundary = strcat((axlMapClassName "DRAWING FORMAT") "/TBX_DBG_BOUNDARY")) 
	(config->dbgLayerHole = strcat((axlMapClassName "DRAWING FORMAT") "/TBX_DBG_HOLE")) 
	(config->dbgLayerNOT = strcat((axlMapClassName "DRAWING FORMAT") "/TBX_DBG_NOT"))
	(config->dbgLayerResult = strcat((axlMapClassName "DRAWING FORMAT") "/TBX_DBG_RESULT")) 
	(grid_popup = ncons(nil)) 
	(grid_popup->singleSelect = list(list("Compare" "compare_selected") 
		list("Tolerance Check" "run_tolerance_check") 
		list("Show Differences" "show_diff_selected") 
		list("Create DRC" "create_drc_selected") 
		list("Limit View (V1, V2, DIFF)" "limit_view_default")
		list("Limit View (V1R, V2R, COM)" "limit_view_details")
	    )) 
	(grid_popup->multiSelect = list(list("Compare" "compare_selected") 
		list("Tolerance Check" "run_tolerance_check") 
		list("Show Differences" "show_diff_selected") 
		list("Create DRC" "create_drc_selected") 
		list("Limit View (V1, V2, DIFF)" "limit_view_default")
		list("Limit View (V1R, V2R, COM)" "limit_view_details")
	    )) 
	(design_ext = TBX_UTIL_Get_Layout_File_Extension())
	unless(boundp('tbx_descompare_data) 
	    iliDefstruct('defstruct(tbx_descompare_data_struct viewLog layerSet config gridData
			gridPopup appInfo env session dbInfo
			curLayer licCheck designExt
		    )
	    ) 
	    defvar(tbx_descompare_data nil)
	) 
	if(!tbx_descompare_data then 
	    (tbx_descompare_data = (make_tbx_descompare_data_struct ?viewLog 
		    tconc(nil nil) ?dbInfo nil
		    ?layerSet nil ?curLayer 
		    ncons(nil) ?config
		    config ?gridData nil ?gridPopup grid_popup
		    ?appInfo app_info ?env 
		    ncons(nil) ?session
		    ncons(nil) ?licCheck nil ?designExt design_ext
		)) else 
	    (tbx_descompare_data->viewLog = tconc(nil nil))
	    (tbx_descompare_data->dbInfo = nil) 
	    (tbx_descompare_data->layerSet = nil) 
	    (tbx_descompare_data->curLayer = ncons(nil)) 
	    (tbx_descompare_data->config = config) 
	    (tbx_descompare_data->gridData = nil)
	    (tbx_descompare_data->gridPopup = grid_popup) 
	    (tbx_descompare_data->appInfo = app_info) 
	    (tbx_descompare_data->env = ncons(nil)) 
	    (tbx_descompare_data->session = ncons(nil)) 
	    (tbx_descompare_data->licCheck = nil)
	    (tbx_descompare_data->designExt = design_ext)
	) 
	(tbx_descompare_data->dbInfo = makeTable("db_info_table_data" nil)) 
	((tbx_descompare_data->dbInfo)["v1"] = ncons(nil)) 
	((tbx_descompare_data->dbInfo)["v2"] = ncons(nil))
	t
    )
)
procedure((TBX_DESCOMPARE_Main \@optional arg) 
    let((lic_check_result info_file port FORM_FILE VERSION_STR
	    fid record result master_units undef_default
	    undef_line_width undef_photo_width
	) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./design_compare_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Design Compare information:\n") 
		fprintf(port "===============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version      : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Design Compare: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		TBX_DESCOMPARE_Init() 
		printf("Current version is: %s.%s\n" 
		    ((tbx_descompare_data->appInfo)->version) 
		    ((tbx_descompare_data->appInfo)->release)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "reset")) 
		when((axlUIYesNo "Delete configuration from database?" nil 
			'no
		    ) 
		    (axlDeleteAttachment "tbx_descompare") 
		    printf("Deleting configuration from database...\n")
		)
	    ) 
	    ((arg && (lowerCase(arg) == "dump")) 
		TBX_DESCOMPARE_Dump()
	    ) 
	    ((arg && (lowerCase(arg) == "cleanup")) 
		TBX_DESCOMPARE_IPC_Cleanup_Layers("MANUFACTURING" "^TBX_.*_V1$" t) 
		TBX_DESCOMPARE_IPC_Cleanup_Layers("MANUFACTURING" "^TBX_.*_V2$" t) 
		TBX_DESCOMPARE_IPC_Cleanup_Layers("MANUFACTURING" "^TBX_.*_DIFF$" t) 
		TBX_DESCOMPARE_IPC_Cleanup_Layers("DRAWING FORMAT" "^TBX_DBG_*" t)
	    )
	    (t 
		TBX_DESCOMPARE_Init() 
		(lic_check_result = TBX_LIC_Validate(((tbx_descompare_data->appInfo)->name) 
			((tbx_descompare_data->appInfo)->version) t
		    )) 
		when(axlGetVariable("FLW_DEBUG") 
		    (axlUIConfirm "Running in debug mode driven by env variable FLW_DEBUG")
		) 
		when(lic_check_result 
		    (record = "descompare") 
		    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "descompare_main")) 
		    unless(boundp('tbxDescompareMain) 
			defvar(tbxDescompareMain nil)
		    ) 
		    (fid = (axlFormCreate 
			    'tbxDescompareMain FORM_FILE 
			    '(e outer) 
			    'TBX_DESCOMPARE_Selector_Callback
			    t nil
			))
		    when(fid 
			(VERSION_STR = ((tbx_descompare_data->appInfo)->title)) 
			(tbx_descompare_data->licCheck = lic_check_result) 
			TBX_FORM_Init_Header(fid "" lic_check_result VERSION_STR) 
			(axlUIWPerm fid t)
			(result = TBX_DESCOMPARE_IPC_Read_Config()) 
			((tbx_descompare_data->dbInfo)["v1"]->designPath = car(result)) 
			((tbx_descompare_data->dbInfo)["v2"]->designPath = cadr(result)) 
			((tbx_descompare_data->dbInfo)["v1"]->ipcLayerInfo = caddr(result)) 
			(tbx_descompare_data->layerSet = TBX_DESCOMPARE_IPC_Build_Layer_Sets())
			(master_units = lowerCase(TBX_SESSION_Get_Param(record "master_units" 
				    car((axlDBGetDesignUnits))
				)
			    )) 
			if(((master_units == "microns") || (master_units == "millimeters") || (master_units == "centimeters") || (master_units == "um") || (master_units == "mm") || (master_units == "cm")) then 
			    (undef_default = (axlMKSConvert "0.05 MM" master_units)) else 
			    (undef_default = (axlMKSConvert "2.0 MILS" master_units))
			) 
			(undef_line_width = TBX_SESSION_Get_Param(record "undef_line_width" undef_default t)) 
			(undef_photo_width = TBX_SESSION_Get_Param(record "undef_photo_width" undef_default t)) 
			(axlFormSetField fid "first_dsn" 
			    TBX_SESSION_Get_Param(record "first_dsn" 
				(axlGetDrawingName)
			    )
			)
			(axlFormSetField fid "second_dsn" 
			    TBX_SESSION_Get_Param(record "second_dsn" "")
			) 
			(axlFormSetField fid "standard_compare" 
			    TBX_SESSION_Get_Param(record "standard_compare" t)
			) 
			(axlFormSetField fid "layer_compare" 
			    TBX_SESSION_Get_Param(record "layer_compare" nil)
			) 
			(axlFormSetField fid "use_default_artwork" 
			    TBX_SESSION_Get_Param(record "use_default_artwork" t)
			) 
			(axlFormSetField fid "create_new_database" 
			    TBX_SESSION_Get_Param(record "create_new_database" t)
			)
			(axlFormSetField fid "diff_dsn" 
			    TBX_SESSION_Get_Param(record "diff_dsn" 
				sprintf(nil "ipc_compare.%s" 
				    (tbx_descompare_data->designExt)
				)
			    )
			) 
			(axlFormSetField fid "undef_line_width" undef_line_width) 
			(axlFormSetField fid "undef_photo_width" undef_photo_width) 
			(axlFormSetField fid "master_units" master_units) 
			((tbx_descompare_data->session)->lastUnits = (axlFormGetField fid "master_units"))
			TBX_DESCOMPARE_Selector_Update_Form(fid) 
			when(((((tbx_descompare_data->designExt) == "mcm") || ((tbx_descompare_data->designExt) == "sip")) && ((axlVersion 
					'version
				    ) < 17.2)) 
			    (axlFormSetFieldEditable fid "layer_compare" nil) 
			    printf("Note: Layer compare not supported in 16.6 and earlier.\n") 
			    when((axlFormGetField fid "layer_compare") 
				(axlFormSetField fid "standard_compare" t)
			    )
			) 
			(axlFormDisplay fid) 
			TBX_DESCOMPARE_Selector_Event_Loop(fid) 
			TBX_FORM_Delete(lic_check_result FORM_FILE)
			when(((tbx_descompare_data->session)->ok2Proceed) 
			    ((tbx_descompare_data->session)->runDirAbs = strcat(getWorkingDir() "/" 
				    ((tbx_descompare_data->config)->runDir)
				)) 
			    if((((tbx_descompare_data->session)->mode) == "standard_compare") then 
				TBX_DESCOMPARE_GEN_Compare_Launch() else 
				(FORM_FILE = TBX_DESCOMPARE_IPC_Compare_Launch())
				TBX_FORM_Delete(lic_check_result FORM_FILE)
			    )
			) 
			(axlClearSelSet) 
			(axlFinishEnterFun)
		    )
		)
	    )
	)
    )
)
procedure(TBX_DESCOMPARE_Save_Design_Prompt() 
    let((msg continue) 
	if((axlSaveEnable) then 
	    (msg = "Do you want save current database?") 
	    caseq((axlUIYesNoCancel msg nil 
		    'yes
		) 
		(0 
		    (continue = t)
		) 
		(1 
		    (axlSaveDesign ?noConfirm t) 
		    (continue = t)
		) 
		(2 
		    (continue = nil)
		)
	    ) else
	    (continue = t)
	) continue
    )
)
procedure(TBX_DESCOMPARE_Selector_Callback(form_handle) 
    let((design_name file_parts ok_start dsn_path last_units
	    new_units undef_photo_width undef_line_width
	) 
	case((form_handle->curField) 
	    ("standard_compare" 
		TBX_DESCOMPARE_Selector_Update_Form(form_handle)
	    ) 
	    ("layer_compare" 
		TBX_DESCOMPARE_Selector_Update_Form(form_handle)
	    ) 
	    ("create_new_database" 
		TBX_DESCOMPARE_Selector_Update_Form(form_handle)
	    ) 
	    ("first_dsn_browse" 
		(dsn_path = (axlDMFileBrowse nil nil ?optFilters 
			TBX_UTIL_Get_Database_Filter_String()
		    )) 
		when(dsn_path 
		    (axlFormSetField form_handle "first_dsn" dsn_path)
		)
	    )
	    ("second_dsn_browse" 
		(dsn_path = (axlDMFileBrowse nil nil ?optFilters 
			TBX_UTIL_Get_Database_Filter_String()
		    )) 
		when(dsn_path 
		    (axlFormSetField form_handle "second_dsn" dsn_path)
		)
	    ) 
	    ("diff_dsn" 
		(design_name = (form_handle->curValue)) 
		(file_parts = (axlDMFileParts design_name)) 
		unless(nth(3 file_parts) 
		    (design_name = strcat(design_name "." 
			    (tbx_descompare_data->designExt)
			)) 
		    (axlFormSetField form_handle "diff_dsn" design_name)
		)
	    ) 
	    ("use_previous_session" 
		TBX_DESCOMPARE_Selector_Update_Form(form_handle)
	    ) 
	    ("master_units" 
		(last_units = ((tbx_descompare_data->session)->lastUnits)) 
		(new_units = (form_handle->curValue)) 
		(undef_photo_width = (axlFormGetField form_handle "undef_photo_width")) 
		(undef_line_width = (axlFormGetField form_handle "undef_line_width"))
		(undef_photo_width = (axlMKSConvert undef_photo_width last_units new_units)) 
		(undef_line_width = (axlMKSConvert undef_line_width last_units new_units)) 
		(axlFormSetField form_handle "undef_photo_width" undef_photo_width) 
		(axlFormSetField form_handle "undef_line_width" undef_line_width) 
		((tbx_descompare_data->session)->lastUnits = new_units)
	    ) 
	    ("cancel" 
		((tbx_descompare_data->dbInfo)["v2"]->designPath = nil) 
		(axlCancelEnterFun)
	    )
	    ("load_data" 
		(ok_start = TBX_DESCOMPARE_Selector_Check(form_handle)) 
		if(ok_start then 
		    (axlFormClose form_handle) 
		    (axlClearSelSet) 
		    (axlFinishEnterFun)
		    ((tbx_descompare_data->session)->ok2Proceed = t) else 
		    printf("Adjust settings\n")
		)
	    ) 
	    ("my_help" 
		TBX_HELP_Launch("descompare")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_DESCOMPARE_Selector_Check(form_handle) 
    prog((msg first_dsn second_dsn diff_dsn diff_dsn_path
	    ok_proceed
	) 
	TBX_DESCOMPARE_Cache_Param(form_handle) 
	(first_dsn = (axlOSSlash 
		simplifyFilename((axlFormGetField form_handle "first_dsn"))
	    )) 
	(second_dsn = (axlOSSlash 
		simplifyFilename((axlFormGetField form_handle "second_dsn"))
	    )) 
	((tbx_descompare_data->session)->undefLineWidth = (axlFormGetField form_handle "undef_line_width"))
	((tbx_descompare_data->session)->undefPhotoWidth = (axlFormGetField form_handle "undef_photo_width")) 
	((tbx_descompare_data->session)->masterUnits = (axlFormGetField form_handle "master_units")) 
	((tbx_descompare_data->session)->masterDesign = caddr((axlDMFileParts 
		    (axlGetDrawingName)
		)
	    )) 
	when((axlFormGetField form_handle "standard_compare") 
	    if((first_dsn && (first_dsn != "") && isFile(first_dsn) && second_dsn && (second_dsn != "") && isFile(second_dsn)) then 
		((tbx_descompare_data->session)->mode = "standard_compare") 
		((tbx_descompare_data->dbInfo)["v1"]->designPath = first_dsn) 
		((tbx_descompare_data->dbInfo)["v2"]->designPath = second_dsn)
		(ok_proceed = t) 
		return(ok_proceed) else 
		return()
	    )
	) 
	when((axlFormGetField form_handle "layer_compare") 
	    ((tbx_descompare_data->session)->mode = "layer_compare") 
	    if((axlFormGetField form_handle "use_previous_session") then 
		((tbx_descompare_data->session)->usePreviousSession = t) 
		(ok_proceed = t) 
		return(ok_proceed)
		else 
		((tbx_descompare_data->dbInfo)["v1"]->designPath = first_dsn) 
		((tbx_descompare_data->dbInfo)["v2"]->designPath = second_dsn) 
		if((axlFormGetField form_handle "use_default_artwork") then 
		    ((tbx_descompare_data->session)->useDefaultArtwork = t) else 
		    (msg = "Info: Please ensure that IPC layer mapping is defined and saved to database for both designs.\nContinue?\n")
		    if((axlUIYesNo msg nil 
			    'no
			) then 
			((tbx_descompare_data->session)->useDefaultArtwork = nil) else 
			return()
		    )
		) 
		when(((axlFormGetField form_handle "create_new_database") && 
			(axlFormGetField form_handle "diff_dsn")) 
		    (diff_dsn = (axlFormGetField form_handle "diff_dsn")) 
		    (diff_dsn_path = (axlOSSlash 
			    simplifyFilename(diff_dsn)
			)) 
		    ((tbx_descompare_data->session)->newDiffDesign = diff_dsn) 
		    when(isFile(diff_dsn_path) 
			(msg = sprintf(nil "File: %s exists\nOverwrite?\n" diff_dsn_path)) 
			if((axlUIYesNo msg nil 
				'no
			    ) then 
			    deleteFile(diff_dsn_path) 
			    (ok_proceed = t) 
			    return(ok_proceed)
			    else 
			    printf("Warning: Please specify another design name.\n") 
			    return()
			)
		    )
		)
	    )
	)
	return(t)
    )
)
procedure(TBX_DESCOMPARE_Selector_Event_Loop(form_handle) 
    let((eventMask loop event) 
	(axlEventSetStartPopup 
	    'TBX_DESCOMPARE_IPC_Popup_Callback
	) 
	(eventMask = list('PICK)) 
	(loop = t) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil nil)) 
	    caseq((event->type) 
		(PICK t) 
		(DONE 
		    (loop = nil) 
		    (axlFormClose form_handle)
		) 
		(CANCEL 
		    (loop = nil) 
		    (axlFormClose form_handle)
		)
	    )
	)
	(axlEventSetStartPopup)
    )
)
procedure(TBX_DESCOMPARE_Selector_Update_Form(form_handle) 
    if((axlFormGetField form_handle "standard_compare") then 
	(axlFormSetFieldEditable form_handle "use_default_artwork" nil) 
	(axlFormSetFieldEditable form_handle "create_new_database" nil) 
	(axlFormSetFieldEditable form_handle "diff_dsn" nil)
	(axlFormSetFieldEditable form_handle "use_previous_session" nil) 
	(axlFormSetFieldEditable form_handle "undef_line_width" nil) 
	(axlFormSetFieldEditable form_handle "undef_photo_width" nil) else 
	(axlFormSetFieldEditable form_handle "use_default_artwork" t)
	(axlFormSetFieldEditable form_handle "create_new_database" t) 
	if((axlFormGetField form_handle "create_new_database") then 
	    (axlFormSetFieldEditable form_handle "diff_dsn" t) else 
	    (axlFormSetFieldEditable form_handle "diff_dsn" nil)
	) 
	if((((tbx_descompare_data->dbInfo)["v1"]->designPath) && ((tbx_descompare_data->dbInfo)["v2"]->designPath) && (length(((tbx_descompare_data->dbInfo)["v1"]->ipcLayerInfo)) > 0) && (length((tbx_descompare_data->layerSet)) > 0)) then 
	    (axlFormSetFieldEditable form_handle "use_previous_session" t) else 
	    (axlFormSetFieldEditable form_handle "use_previous_session" nil)
	) 
	(axlFormSetFieldEditable form_handle "undef_line_width" t) 
	(axlFormSetFieldEditable form_handle "undef_photo_width" t)
	if((axlFormGetField form_handle "use_previous_session") then 
	    (axlFormSetFieldEditable form_handle "use_default_artwork" nil) 
	    (axlFormSetFieldEditable form_handle "create_new_database" nil) 
	    (axlFormSetFieldEditable form_handle "diff_dsn" nil)
	    (axlFormSetFieldEditable form_handle "undef_line_width" nil) 
	    (axlFormSetFieldEditable form_handle "undef_photo_width" nil) else 
	    (axlFormSetFieldEditable form_handle "use_default_artwork" t) 
	    (axlFormSetFieldEditable form_handle "create_new_database" t)
	    (axlFormSetFieldEditable form_handle "diff_dsn" t) 
	    (axlFormSetFieldEditable form_handle "undef_line_width" t) 
	    (axlFormSetFieldEditable form_handle "undef_photo_width" t)
	)
    )
)
procedure(TBX_DRAWINGSIZE_Callback(form_handle) 
    case((form_handle->curField) 
	("done" 
	    (axlFormClose form_handle) 
	    (axlFinishEnterFun)
	) 
	("expand" 
	    TBX_DRAWINGSIZE_Update_Form(form_handle) 
	    ((tbx_drawingsize_global->session)->radioButtonChange = t) 
	    (axlCancelEnterFun)
	) 
	("contract" 
	    TBX_DRAWINGSIZE_Update_Form(form_handle) 
	    ((tbx_drawingsize_global->session)->radioButtonChange = t) 
	    (axlCancelEnterFun)
	) 
	("min_extents" 
	    TBX_DRAWINGSIZE_Update_Form(form_handle) 
	    ((tbx_drawingsize_global->session)->radioButtonChange = t) 
	    (axlCancelEnterFun)
	)
	("drag_window" 
	    TBX_DRAWINGSIZE_Update_Form(form_handle) 
	    ((tbx_drawingsize_global->session)->radioButtonChange = t) 
	    (axlCancelEnterFun)
	) 
	("apply" 
	    TBX_DRAWINGSIZE_Run(form_handle)
	) 
	("myhelp" 
	    (axlShell "tbx help drawingsize")
	)
    )
)
procedure(TBX_DRAWINGSIZE_Event_Loop(form_handle) 
    let((loop event start_pick bBox result) 
	(loop = t) 
	(axlEventSetStartPopup 
	    'TBX_DRAWINGSIZE_Popup_Callback
	) 
	(axlClearSelSet) 
	while(loop 
	    (event = (axlEnterEvent 
		    list('STARTDRAG 
			'STOPDRAG
		    ) nil t
		)) 
	    caseq((event->type) 
		(STARTDRAG 
		    TBX_DRAWING_SITE_Cleanup_Tmp_View() 
		    when((axlFormGetField form_handle "drag_window") 
			(axlAddSimpleRbandDynamics 
			    (event->xySnap) "box" ?origin 
			    (0.0:0.0)
			) 
			(start_pick = (event->xySnap))
		    )
		) 
		(STOPDRAG 
		    when((axlFormGetField form_handle "drag_window") 
			(bBox = list(start_pick 
				(event->xySnap)
			    )) 
			((tbx_drawingsize_global->session)->userBox = bBox) 
			(axlClearDynamics) 
			(start_pick = nil)
			(result = (axlDBCreateRectangle bBox nil 
				(tbx_drawingsize_global->tmpLayer)
			    )) 
			when(car(result) 
			    ((tbx_drawingsize_global->session)->tmpShape = car(result))
			)
		    )
		) 
		(DONE 
		    (axlFormClose form_handle) 
		    (loop = nil)
		) 
		(CANCEL 
		    cond((((tbx_drawingsize_global->session)->radioButtonChange) 
			    TBX_DRAWING_SITE_Cleanup_Tmp_View()
			) 
			(t 
			    (loop = nil) 
			    (axlFormClose form_handle)
			)
		    )
		)
	    )
	)
	(axlEventSetStartPopup)
    )
)
procedure(TBX_DRAWINGSIZE_Init() 
    let((tmp_layer design_type design_extents) 
	(tmp_layer = strcat((axlMapClassName "MANUFACTURING") "/TMP_DRAFTING")) 
	(design_type = upperCase((axlDesignType t))) 
	if(exists(x 
		list("FLASH" "SHAPE") 
		(x == design_type)
	    ) then 
	    (tmp_layer = nil) else 
	    unless((axlIsLayer tmp_layer) 
		(axlLayerCreateNonConductor tmp_layer) 
		TBX_DBDISPLAY_Set_Layer_Color(tmp_layer 
		    list(255 255 255) 
		    list(255 0 0)
		)
	    )
	) 
	(design_extents = (axlExtentDB 
		'obstacle
	    ))
	unless(boundp('tbx_drawingsize_global) 
	    iliDefstruct('defstruct(tbx_drawingsize_global_struct formid designExtents licCheck orgVis
			tmpLayer session
		    )
	    ) 
	    defvar(tbx_drawingsize_global nil)
	) 
	if(!tbx_drawingsize_global then 
	    (tbx_drawingsize_global = (make_tbx_drawingsize_global_struct ?formid nil ?session 
		    ncons(nil)
		    ?designExtents design_extents ?licCheck nil ?orgVis
		    nil ?tmpLayer tmp_layer
		)) else 
	    (tbx_drawingsize_global->formid = nil)
	    (tbx_drawingsize_global->session = ncons(nil)) 
	    (tbx_drawingsize_global->designExtents = design_extents) 
	    (tbx_drawingsize_global->licCheck = nil) 
	    (tbx_drawingsize_global->orgVis = nil) 
	    (tbx_drawingsize_global->tmpLayer = tmp_layer)
	)
    )
)
procedure((TBX_DRAWINGSIZE_Main \@optional arg) 
    let((lic_check_result FORM_FILE fid FC_FEATURE FC_VERSION
	    SUB_VERSION VERSION_STR port info_file ok_start_app
	    design_type param
	) 
	(FC_FEATURE = "DRAWINGSIZE") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Drawing Size %s (C)2017" FC_VERSION))
	(ok_start_app = t) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./drawingsize_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Drawing Size information:\n") 
		fprintf(port "====================================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Drawing Size: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION) 
		(ok_start_app = nil)
	    )
	) 
	when(ok_start_app 
	    (lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
	    when(lic_check_result 
		(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "drawingsize_main")) 
		unless(boundp('tbxDrawingsizeMainHandle) 
		    defvar(tbxDrawingsizeMainHandle nil)
		) 
		(fid = (axlFormCreate 
			'tbxDrawingsizeMainHandle FORM_FILE 
			'(e outer) 
			'TBX_DRAWINGSIZE_Callback
			t
		    )) 
		when(fid 
		    TBX_DRAWINGSIZE_Init() 
		    (tbx_drawingsize_global->formid = fid) 
		    (tbx_drawingsize_global->licCheck = lic_check_result) 
		    TBX_FORM_Init_Header(fid "Licensed for " lic_check_result VERSION_STR)
		    (axlFormSetField fid "expand" t) 
		    (axlFormSetField fid "offset_name" "Offset") 
		    (axlFormSetField fid "offset" 
			(axlMKSConvert "2.0 MM" 
			    car((axlDBGetDesignUnits))
			)
		    ) 
		    (axlFormSetField fid "side" "all") 
		    (tbx_drawingsize_global->orgVis = (axlVisibleGet))
		    (axlVisibleDesign t) 
		    (axlVisibleUpdate t) 
		    (design_type = upperCase((axlDesignType t))) 
		    if(exists(x 
			    list("FLASH" "SHAPE") 
			    (x == design_type)
			) then 
			(axlFormSetFieldEditable fid "drag_window" nil) else 
			(axlDeleteByLayer 
			    (tbx_drawingsize_global->tmpLayer)
			)
		    ) 
		    (axlFormDisplay fid)
		    TBX_DRAWINGSIZE_Event_Loop(fid) 
		    TBX_FORM_Delete(lic_check_result FORM_FILE) 
		    (axlVisibleSet 
			(tbx_drawingsize_global->orgVis)
		    ) 
		    (axlVisibleLayer 
			(tbx_drawingsize_global->tmpLayer) t
		    ) 
		    (axlDeleteByLayer 
			(tbx_drawingsize_global->tmpLayer)
		    )
		    (param = (axlLayerGet 
			    (tbx_drawingsize_global->tmpLayer)
			)) 
		    when(param 
			(axlDeleteObject param)
		    ) 
		    (axlVisibleUpdate t)
		)
	    )
	)
    )
)
procedure(TBX_DRAWINGSIZE_Popup_Callback(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_DRAWINGSIZE_RMB_Done
		    ) 
		    list("Cancel" 
			'TBX_DRAWINGSIZE_RMB_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_DRAWINGSIZE_RMB_Cancel() 
    remprop((tbx_drawingsize_global->session) 
	'radioButtonChange
    ) 
    (axlCancelEnterFun)
)
procedure(TBX_DRAWINGSIZE_RMB_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_DRAWINGSIZE_Run(form_handle) 
    let((box box_ll box_ur box_ll_x box_ll_y
	    box_ur_x box_ur_y new_box result offset
	) 
	cond(((axlFormGetField form_handle "min_extents") 
		(box = (axlExtentDB 
			'obstacle
		    ))
	    ) 
	    ((axlFormGetField form_handle "drag_window") 
		if(((tbx_drawingsize_global->session)->userBox) then 
		    (box = TBX_UTIL_Normalize_Box(((tbx_drawingsize_global->session)->userBox))) else 
		    (axlUIConfirm "Please specify valid box.\n")
		)
	    ) 
	    (t 
		(box = ((axlGetParam "paramDesign")->bBox))
	    )
	) 
	(box_ll = car(box)) 
	(box_ur = cadr(box)) 
	(box_ll_x = car(box_ll))
	(box_ll_y = cadr(box_ll)) 
	(box_ur_x = car(box_ur)) 
	(box_ur_y = cadr(box_ur)) 
	(offset = (axlFormGetField form_handle "offset")) 
	cond(((axlFormGetField form_handle "expand") 
		case((axlFormGetField form_handle "side") 
		    ("all" 
			(box_ll_x = (box_ll_x - offset)) 
			(box_ll_y = (box_ll_y - offset)) 
			(box_ur_x = (box_ur_x + offset)) 
			(box_ur_y = (box_ur_y + offset))
		    ) 
		    ("north" 
			(box_ur_y = (box_ur_y + offset))
		    ) 
		    ("east" 
			(box_ur_x = (box_ur_x + offset))
		    ) 
		    ("south" 
			(box_ll_y = (box_ll_y - offset))
		    )
		    ("west" 
			(box_ll_x = (box_ll_x - offset))
		    )
		) 
		(new_box = list((box_ll_x:box_ll_y) 
			(box_ur_x:box_ur_y)
		    ))
	    ) 
	    ((axlFormGetField form_handle "contract") 
		if(((abs(box_ll_x) < offset) || (abs(box_ll_y) < offset) || (abs(box_ur_x) < offset) || (abs(box_ur_y) < offset)) then 
		    (axlUIConfirm "Warning: Operation failed, design origin not allowed outside extents\n") else 
		    case((axlFormGetField form_handle "side") 
			("all" 
			    (box_ll_x = (box_ll_x + offset)) 
			    (box_ll_y = (box_ll_y + offset)) 
			    (box_ur_x = (box_ur_x - offset)) 
			    (box_ur_y = (box_ur_y - offset))
			) 
			("north" 
			    (box_ur_y = (box_ur_y - offset))
			) 
			("east" 
			    (box_ur_x = (box_ur_x - offset))
			) 
			("south" 
			    (box_ll_y = (box_ll_y + offset))
			)
			("west" 
			    (box_ll_x = (box_ll_x + offset))
			)
		    )
		    (new_box = list((box_ll_x:box_ll_y) 
			    (box_ur_x:box_ur_y)
			))
		)
	    ) 
	    ((axlFormGetField form_handle "min_extents") 
		(box_ll_x = (box_ll_x - offset)) 
		(box_ll_y = (box_ll_y - offset)) 
		(box_ur_x = (box_ur_x + offset)) 
		(box_ur_y = (box_ur_y + offset))
		(new_box = list((box_ll_x:box_ll_y) 
			(box_ur_x:box_ur_y)
		    ))
	    ) 
	    ((axlFormGetField form_handle "drag_window") 
		cond((!(axlIsPointInsideBox 
				(0.0:0.0) box
			    ) 
			(axlUIConfirm "Warning: Design origin outside specified window. Selection must enclose design origin." 
			    'warn
			) 
			TBX_DRAWING_SITE_Cleanup_Tmp_View()
		    ) 
		    ((!(axlIsPointInsideBox 
				    car((tbx_drawingsize_global->designExtents)) box
				) || !(axlIsPointInsideBox 
				    cadr((tbx_drawingsize_global->designExtents)) box
				)) 
			(axlUIConfirm "Warning: Selected window must include all elements.\n" 
			    'warn
			) 
			TBX_DRAWING_SITE_Cleanup_Tmp_View()
		    ) 
		    (t 
			(new_box = box)
		    )
		)
	    )
	)
	when(new_box 
	    TBX_DRAWING_SITE_Cleanup_Tmp_View() 
	    (axlDBRefreshId nil) 
	    (result = (axlDBChangeDesignExtents new_box)) 
	    if(result then 
		printf("Changing drawing extents to %L\n" new_box) else 
		printf("Error: Could not change drawing extents\n")
	    )
	    (axlShell "zoom world") 
	    (axlVisibleUpdate t) 
	    (axlDBRefreshId nil)
	) t
    )
)
procedure(TBX_DRAWINGSIZE_Update_Form(form_handle) 
    (axlFormSetFieldEditable form_handle "offset" t) 
    (axlFormSetFieldEditable form_handle "side" t) 
    cond(((axlFormGetField form_handle "expand") 
	    (axlFormSetField form_handle "offset_name" "Offset")
	) 
	((axlFormGetField form_handle "contract") 
	    (axlFormSetField form_handle "offset_name" "Offset")
	) 
	((axlFormGetField form_handle "min_extents") 
	    (axlFormSetField form_handle "offset_name" "Margin") 
	    (axlFormSetFieldEditable form_handle "side" nil)
	) 
	((axlFormGetField form_handle "drag_window") 
	    (axlFormSetFieldEditable form_handle "side" nil)
	)
    )
)
procedure(TBX_DRAWING_SITE_Cleanup_Tmp_View() 
    when(((tbx_drawingsize_global->session)->tmpShape) 
	(axlDeleteObject 
	    ((tbx_drawingsize_global->session)->tmpShape)
	) 
	((tbx_drawingsize_global->session)->tmpShape = nil)
    )
)
procedure(TBX_DUMMYPINCOL_Cache_Param() 
    let((rec session_param) 
	(rec = "dummypincol") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	putprop(session_param[rec] 
	    (axlFormGetField 
		(tbx_dummypincol_data->formId) "highlight_mode"
	    ) 
	    stringToSymbol("highlight_mode")
	)
	putprop(session_param[rec] 
	    (axlFormGetField 
		(tbx_dummypincol_data->formId) "report_only_mode"
	    ) 
	    stringToSymbol("report_only_mode")
	) 
	putprop(session_param[rec] 
	    (tbx_dummypincol_data->colorId) 
	    stringToSymbol("highlight_color")
	)
    )
)
procedure(TBX_DUMMYPINCOL_Callback(form_handle) 
    let((color_list) 
	case((form_handle->curField) 
	    ("done" 
		TBX_DUMMYPINCOL_Cache_Param() 
		(axlFinishEnterFun)
	    ) 
	    ("highlight_mode" 
		when((form_handle->curValue) 
		    (axlFormSetFieldEditable form_handle "highlight_color" t)
		)
	    ) 
	    ("highlight_color" 
		(color_list = (axlCVFColorChooserDlg 0)) 
		when(color_list 
		    (tbx_dummypincol_data->colorId = car(color_list)) 
		    (axlFormSetField form_handle "highlight_color" 
			car(color_list)
		    ) 
		    (axlVisibleUpdate t)
		)
	    ) 
	    ("clear_colors" 
		TBX_DBDISPLAY_Dehighlight_By_Type(list("pins")) 
		(axlVisibleUpdate t)
	    )
	    ("report_only_mode" 
		when((form_handle->curValue) 
		    (axlFormSetFieldEditable form_handle "highlight_color" nil)
		)
	    ) 
	    ("run" 
		TBX_DUMMYPINCOL_Process(form_handle)
	    ) 
	    ("myhelp" 
		(axlShell "tbx help dummypincol")
	    )
	)
    )
)
procedure(TBX_DUMMYPINCOL_Dehighlight() 
    let((dbid_list) 
	foreach(pin 
	    (axlSelectByName "PIN" "*.*" t) 
	    when(((((pin->net)->name) == "") && ((pin->parent)->xy)) 
		(dbid_list = cons(pin dbid_list))
	    )
	) 
	if(dbid_list then 
	    (axlClearSelSet) 
	    (axlClearObjectCustomColor dbid_list) 
	    (axlVisibleUpdate t)
	    else 
	    printf("Info: Design has no dummy pins.\n")
	) 
	(axlClearSelSet)
    )
)
procedure(TBX_DUMMYPINCOL_Done() 
    TBX_DUMMYPINCOL_Cache_Param() 
    (axlFinishEnterFun)
)
procedure(TBX_DUMMYPINCOL_Event_Loop(form_handle) 
    let((loop event) 
	(loop = t) 
	(axlEventSetStartPopup 
	    'TBX_DUMMYPINCOL_Popup_Callback
	) 
	while(loop 
	    (event = (axlEnterEvent 
		    list('PICK) nil nil
		)) 
	    caseq((event->type) 
		(PICK t) 
		(DONE 
		    (axlFormClose form_handle) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    (loop = nil)
		) 
		(CANCEL 
		    (axlFormClose form_handle) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    (loop = nil)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_DUMMYPINCOL_Get_Unconnected_Pins(dummyNet singleNode) 
    let((netInfo dbid_list) 
	(netInfo = makeTable("net_info_data" nil)) 
	foreach(n 
	    ((axlDBGetDesign)->nets) 
	    (netInfo[(n->name)] = (axlPinsOfNet 
		    (n->name) 
		    'pin
		))
	) 
	(axlClearSelSet) 
	foreach(pin 
	    (axlSelectByName "PIN" "*.*" t) 
	    when(((((pin->net)->name) == "") && ((pin->parent)->xy)) 
		(netInfo[""] = cons(pin 
			netInfo[""]
		    ))
	    )
	)
	(axlClearSelSet) 
	when(dummyNet 
	    (dbid_list = nconc(dbid_list 
		    netInfo[""]
		))
	) 
	when(singleNode 
	    foreach(n netInfo 
		when(((n != "") && onep(length(netInfo[n]))) 
		    (dbid_list = nconc(dbid_list 
			    netInfo[n]
			))
		)
	    )
	) dbid_list
    )
)
procedure(TBX_DUMMYPINCOL_Init() 
    unless(boundp('tbx_dummypincol_data) 
	iliDefstruct('defstruct(tbx_dummypincol_data_struct colorId licCheck formId)) 
	defvar(tbx_dummypincol_data nil)
    ) 
    if(!tbx_dummypincol_data then 
	(tbx_dummypincol_data = (make_tbx_dummypincol_data_struct ?colorId nil ?licCheck nil
		?formId nil
	    )) else 
	(tbx_dummypincol_data->colorId = nil)
	(tbx_dummypincol_data->licCheck = nil) 
	(tbx_dummypincol_data->formId = nil)
    )
)
procedure((TBX_DUMMYPINCOL_Main \@optional arg) 
    let((lic_check_result VERSION_STR FC_FEATURE FC_VERSION SUB_VERSION
	    FORM_FILE fid info_file port record
	    color_id
	) 
	(FC_FEATURE = "DUMMYPINCOL") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Highlight Dummy Pins %s (C)2017" FC_VERSION))
	(VERSION_STR = VERSION_STR) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./dummypincol_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Highlight Dummy Pins nformation:\n") 
		fprintf(port "===============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Highlight Dummy Pins: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    TBX_DUMMYPINCOL_Init() 
		    (tbx_dummypincol_data->colorId = 1) 
		    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "dummypincol_main")) 
		    (fid = (axlFormCreate 
			    gensym("tbxdummypincolmain") FORM_FILE 
			    '(e outer) 
			    'TBX_DUMMYPINCOL_Callback
			    t
			))
		    (tbx_dummypincol_data->licCheck = lic_check_result) 
		    (tbx_dummypincol_data->formId = fid) 
		    TBX_FORM_Init_Header(fid nil lic_check_result VERSION_STR) 
		    (record = "dummypincol") 
		    (axlFormSetField fid "highlight_mode" 
			TBX_SESSION_Get_Param(record "highlight_mode" t)
		    )
		    (axlFormSetField fid "report_only_mode" 
			TBX_SESSION_Get_Param(record "report_only_mode" nil)
		    ) 
		    (color_id = TBX_SESSION_Get_Param(record "highlight_color" 
			    (tbx_dummypincol_data->colorId)
			)) 
		    (axlFormSetField fid "highlight_color" color_id) 
		    (tbx_dummypincol_data->colorId = color_id) 
		    if((axlFormGetField fid "report_only_mode") then 
			(axlFormSetFieldEditable fid "highlight_color" nil) else 
			(axlFormSetFieldEditable fid "highlight_color" t)
		    )
		    (axlVisibleUpdate t) 
		    (axlFormDisplay fid) 
		    TBX_DUMMYPINCOL_Event_Loop(fid) 
		    TBX_FORM_Delete(lic_check_result FORM_FILE)
		)
	    )
	) t
    )
)
procedure(TBX_DUMMYPINCOL_Popup_Callback(event) 
    let((popid) 
	(event = event) 
	(popid = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_DUMMYPINCOL_Done
		    ) 
		    list("Dehighlight Dummy Pins" 
			'TBX_DUMMYPINCOL_Dehighlight
		    )
		)
	    )) 
	(axlUIPopupSet popid)
    )
)
procedure(TBX_DUMMYPINCOL_Process(form_handle) 
    let((port dbid_list info_list report_file get_dummy
	    get_single
	) 
	(axlDBDisplayControl 
	    'customColorEnabled t
	) 
	(axlVisibleUpdate t) 
	(get_dummy = (axlFormGetField form_handle "dummy_nets")) 
	(get_single = (axlFormGetField form_handle "single_node_nets"))
	if((!get_dummy && !get_single) then 
	    printf("Warning: Select at least one item\n") else 
	    (dbid_list = TBX_DUMMYPINCOL_Get_Unconnected_Pins(get_dummy get_single))
	    (info_list = mapcar(lambda((p) 
			list(strcat(((p->parent)->refdes) "." 
				(p->number)
			    ) 
			    (p->xy) 
			    ((p->net)->name)
			)
		    ) dbid_list
		)) 
	    (info_list = sortcar(info_list nil)) 
	    if(dbid_list then 
		(axlClearSelSet) 
		when((axlFormGetField form_handle "highlight_mode") 
		    (axlCustomColorObject dbid_list 
			(tbx_dummypincol_data->colorId)
		    ) 
		    (axlVisibleUpdate t)
		) 
		(report_file = strcat(getWorkingDir() "/tbx_dummy_pin_report.txt"))
		(port = outfile(report_file "w")) 
		fprintf(port "%-13s  %-25s  %s\n" "Pin" "Location" "Net") 
		fprintf(port "=====================================================\n") 
		foreach(entry info_list 
		    fprintf(port "%-13s  %-25s  %s\n" 
			car(entry) 
			sprintf(nil "%L" 
			    cadr(entry)
			) 
			caddr(entry)
		    )
		) 
		close(port)
		(axlUIViewFileCreate report_file "Dummy Pin Report" nil) else 
		printf("Info: Design has no dummy pins.\n")
	    ) 
	    (axlClearSelSet)
	)
    )
)
procedure(TBX_FILMSETUP_Build_String(list_data) 
    let((ret_value list_data_quoted) 
	if(list_data then 
	    (list_data_quoted = mapcar(lambda((x) 
			sprintf(nil "%L" x)
		    ) list_data
		)) 
	    (list_data_quoted = sort(list_data_quoted nil)) 
	    (ret_value = buildString(list_data_quoted " "))
	    else 
	    (ret_value = "nil")
	) ret_value
    )
)
procedure(TBX_FILMSETUP_Check_Data(data) 
    let((ret_data prop value) 
	if(memq(car(data) 
		list('negative 
		    'undefineLineWidth 
		    'sequence 
		    'rotation 
		    'xOffset
		    'yOffset 
		    'shapeBoundingBox 
		    'mirrored 
		    'fullContact 
		    'suppressUnconnectPads
		    'drawMissingPadApertures 
		    'useApertureRotation 
		    'suppressShapeFill 
		    'vectorBasedPad 
		    'drawHolesOnly
		    'domains 
		    'ipc2581 
		    'layers 
		    'layersPrimary 
		    'layersSecondary
		)
	    ) then 
	    cond((memq(car(data) 
			list('undefineLineWidth 
			    'xOffset 
			    'yOffset 
			    'shapeBoundingBox
			)
		    ) 
		    (prop = car(data)) 
		    (value = TBX_FILMSETUP_Format_Value(cadr(data) 
			    'unit
			))
		) 
		(memq(car(data) 
			list('domains 
			    'ipc2581
			)
		    ) 
		    (prop = car(data)) 
		    if(cadr(data) then 
			(value = mapcar(lambda((x) 
				    TBX_FILMSETUP_Format_Value(x 
					'symbol
				    )
				) 
				cdr(data)
			    )) else 
			(value = nil)
		    )
		) 
		((eq(car(data) 
			    'layers
			) || eq(car(data) 
			    'layersPrimary
			) || eq(car(data) 
			    'layersSecondary
			)) 
		    (prop = car(data)) 
		    if(cadr(data) then 
			(value = cdr(data)) else 
			(value = nil)
		    )
		) 
		(t 
		    (prop = car(data)) 
		    (value = cadr(data))
		)
	    ) 
	    when(prop 
		(ret_data = list(prop value))
	    ) else
	    (ret_data = nil)
	) ret_data
    )
)
procedure(TBX_FILMSETUP_Create_Films(film_data) 
    let((result sequence_counter check_layers number_of_films_created) 
	(axlDeleteObject 
	    (axlGetParam "artwork")
	) 
	(sequence_counter = 0) 
	(number_of_films_created = 0) 
	foreach(film film_data 
	    foreach(lyr 
		(film->layersPrimary) 
		unless(exists(x 
			(film->layers) 
			(x == lyr)
		    ) 
		    (film->layers = cons(lyr 
			    (film->layers)
			))
		)
	    ) 
	    (check_layers = copy((film->layers))) 
	    foreach(lyr 
		(film->layersSecondary) 
		unless(exists(x 
			(film->layers) 
			(x == lyr)
		    ) 
		    (film->layers = cons(lyr 
			    (film->layers)
			))
		)
	    )
	    if(TBX_FILMSETUP_Get_Layer_Data(check_layers) then 
		unless((film->sequence) 
		    (film->sequence = ++sequence_counter)
		) 
		(result = (axlFilmCreate 
			(film->name) ?negative 
			(film->negative) ?undefineLineWidth
			(film->undefineLineWidth) ?sequence 
			(film->sequence) ?rotation 
			(film->rotation)
			?xOffset 
			(film->xOffset) ?yOffset 
			(film->yOffset) ?shapeBoundingBox
			(film->shapeBoundingBox) ?mirrored 
			(film->mirrored) ?fullContact 
			(film->fullContact)
			?suppressUnconnectPads 
			(film->suppressUnconnectPads) ?drawMissingPadApertures 
			(film->drawMissingPadApertures) ?useApertureRotation
			(film->useApertureRotation) ?suppressShapeFill 
			(film->suppressShapeFill) ?vectorBasedPad 
			(film->vectorBasedPad)
			?drawHolesOnly 
			(film->drawHolesOnly) ?domains 
			(film->domains) ?ipc2581
			(film->ipc2581) ?layers 
			(film->layers)
		    )) 
		if(result then 
		    printf("Info: Creating film definition %L\n" 
			(film->name)
		    ) 
		    ++number_of_films_created else
		    printf("Warning: Could not create film definition %L\n" 
			(film->name)
		    )
		)
		else 
		printf("Info: Skipping film %s, no data on specified layers\n" 
		    (film->name)
		)
	    )
	)
	printf("Info: Total number of films created: %d\n" number_of_films_created) number_of_films_created
    )
)
procedure((TBX_FILMSETUP_Determine_Default occ_cnt \@optional arg) 
    let((tmp_list ret_value) 
	if((arg && (arg == "true_false")) then 
	    (ret_value = nil) 
	    when((occ_cnt[t] > occ_cnt[nil]) 
		(ret_value = t)
	    ) else
	    foreach(key occ_cnt 
		(tmp_list = cons(list(occ_cnt[key] key) tmp_list))
	    ) 
	    (tmp_list = sortcar(tmp_list 
		    'greaterp
		)) 
	    (ret_value = cadr(car(tmp_list))) 
	    when((ret_value && (arg == "split_value") && (type(ret_value) == 'string)) 
		(ret_value = parseString(ret_value "!"))
	    )
	) ret_value
    )
)
procedure(TBX_FILMSETUP_Dump() 
    let((port dump_file result) 
	(dump_file = "./film_setup_dump.txt") 
	when((tbx_filmsetup_global->filmData) 
	    (port = outfile(dump_file "w")) 
	    pprint((tbx_filmsetup_global->filmData) port) 
	    close(port) 
	    printf("Note: File %L has been written\n" dump_file)
	    (result = t)
	) result
    )
)
procedure(TBX_FILMSETUP_Expand_Layers(layer_list) 
    let((arr class_name subclass_str subclass_str_regxp all_subclasses
	    match_layers ret_layers
	) 
	foreach(lyr layer_list 
	    if(rexMatchp("[*]" lyr) then 
		printf("Expanding layer %L\n" lyr) 
		(arr = parseString(upperCase(lyr) "/")) 
		(class_name = car(arr))
		(subclass_str = cadr(arr)) 
		when((class_name && subclass_str) 
		    (all_subclasses = (axlSubclasses class_name)) 
		    (subclass_str_regxp = TBX_UTIL_Regex_From_Shell(subclass_str t)) 
		    (match_layers = rexMatchList(subclass_str_regxp all_subclasses)) 
		    foreach(scls match_layers 
			(ret_layers = cons(strcat(class_name "/" scls) ret_layers))
		    )
		) else 
		(ret_layers = cons(lyr ret_layers))
	    )
	) 
	(ret_layers = sort(ret_layers nil))
    )
)
procedure(TBX_FILMSETUP_Export() 
    let((occ_negative occ_undefineLineWidth occ_rotation occ_xOffset occ_yOffset
	    occ_shapeBoundingBox occ_mirrored occ_fullContact occ_suppressUnconnectedPads occ_drawMissingApertures
	    occ_useApertureRotation occ_suppressShapeFill occ_vectorBasedPad occ_drawHolesOnly occ_ipc2581
	    occ_domains cfg_file port short_units defaultParam
	    param param_str
	) 
	(occ_negative = makeTable("occ_negative" 0)) 
	(occ_undefineLineWidth = makeTable("occ_undefineLineWidth_data" 0)) 
	(occ_rotation = makeTable("occ_rotation_data" 0)) 
	(occ_xOffset = makeTable("occ_xOffset_data" 0))
	(occ_yOffset = makeTable("occ_yOffset_data" 0)) 
	(occ_shapeBoundingBox = makeTable("occ_shapeBoundingBox" 0)) 
	(occ_mirrored = makeTable("occ_mirrored" 0)) 
	(occ_fullContact = makeTable("occ_fullContact" 0)) 
	(occ_suppressUnconnectedPads = makeTable("occ_suppressUnconnectedPads" 0))
	(occ_drawMissingApertures = makeTable("occ_drawMissingApertures" 0)) 
	(occ_useApertureRotation = makeTable("occ_useApertureRotation" 0)) 
	(occ_suppressShapeFill = makeTable("occ_suppressShapeFill" 0)) 
	(occ_vectorBasedPad = makeTable("occ_vectorBasedPad" 0)) 
	(occ_drawHolesOnly = makeTable("occ_drawHolesOnly" 0))
	(occ_ipc2581 = makeTable("occ_ipc2581" 0)) 
	(occ_domains = makeTable("occ_domains" 0)) 
	foreach(aw 
	    ((axlGetParam "artwork")->groupMembers) 
	    (param = (axlGetParam 
		    strcat("artwork:" aw)
		)) 
	    ++occ_negative[(param->negative)] 
	    ++occ_undefineLineWidth[(param->undefineLineWidth)]
	    ++occ_rotation[(param->rotation)] 
	    ++occ_xOffset[car((param->offset))] 
	    ++occ_yOffset[cadr((param->offset))] 
	    ++occ_shapeBoundingBox[(param->shapeBoundingBox)] 
	    ++occ_mirrored[(param->mirrored)]
	    ++occ_fullContact[(param->fullContact)] 
	    ++occ_suppressUnconnectedPads[(param->suppressUnconnectPads)] 
	    ++occ_drawMissingApertures[(param->drawMissingPadApertures)] 
	    ++occ_useApertureRotation[(param->useApertureRotation)] 
	    ++occ_suppressShapeFill[(param->suppressShapeFill)]
	    ++occ_vectorBasedPad[(param->vectorBasedPad)] 
	    ++occ_drawHolesOnly[(param->drawHolesOnly)] 
	    (param_str = nil) 
	    when((param->ipc2581) 
		(param_str = buildString(sort((param->ipc2581) nil) "!"))
	    ) 
	    ++occ_ipc2581[param_str]
	    (param_str = nil) 
	    when((param->domains) 
		(param_str = buildString(sort((param->domains) nil) "!"))
	    ) 
	    ++occ_domains[param_str]
	) 
	(defaultParam = ncons(nil)) 
	(defaultParam->negative = TBX_FILMSETUP_Determine_Default(occ_negative "true_false"))
	(defaultParam->mirrored = TBX_FILMSETUP_Determine_Default(occ_mirrored "true_false")) 
	(defaultParam->fullContact = TBX_FILMSETUP_Determine_Default(occ_fullContact "true_false")) 
	(defaultParam->suppressUnconnectPads = TBX_FILMSETUP_Determine_Default(occ_suppressUnconnectedPads "true_false")) 
	(defaultParam->drawMissingPadApertures = TBX_FILMSETUP_Determine_Default(occ_drawMissingApertures "true_false")) 
	(defaultParam->useApertureRotation = TBX_FILMSETUP_Determine_Default(occ_useApertureRotation "true_false"))
	(defaultParam->suppressShapeFill = TBX_FILMSETUP_Determine_Default(occ_suppressShapeFill "true_false")) 
	(defaultParam->vectorBasedPad = TBX_FILMSETUP_Determine_Default(occ_vectorBasedPad "true_false")) 
	(defaultParam->drawHolesOnly = TBX_FILMSETUP_Determine_Default(occ_drawHolesOnly "true_false")) 
	(defaultParam->undefineLineWidth = TBX_FILMSETUP_Determine_Default(occ_undefineLineWidth)) 
	(defaultParam->rotation = TBX_FILMSETUP_Determine_Default(occ_rotation))
	(defaultParam->xOffset = TBX_FILMSETUP_Determine_Default(occ_xOffset)) 
	(defaultParam->yOffset = TBX_FILMSETUP_Determine_Default(occ_yOffset)) 
	(defaultParam->shapeBoundingBox = TBX_FILMSETUP_Determine_Default(occ_shapeBoundingBox)) 
	(defaultParam->domains = TBX_FILMSETUP_Determine_Default(occ_domains "split_value")) 
	(defaultParam->ipc2581 = TBX_FILMSETUP_Determine_Default(occ_ipc2581 "split_value"))
	(cfg_file = "./film_setup.cfg") 
	(port = outfile(cfg_file "w")) 
	(short_units = TBX_UTIL_Get_Short_Units()) 
	fprintf(port "(\n") 
	fprintf(port "/* \n")
	fprintf(port "  --------------------------------------------------------------------------------\n") 
	fprintf(port "  This configuration file can be used to control dynamic film setup in PCB Editor.\n") 
	fprintf(port "  --------------------------------------------------------------------------------\n") 
	fprintf(port "  - A film definition will be created only if data exists on specified layers, otherwise it will be skipped.\n") 
	fprintf(port "\n")
	fprintf(port "  - Parameters in default section will be used for every film record if not specified explicitely.\n") 
	fprintf(port "\n") 
	fprintf(port "  - Layers described in film definitions may contain wildcards, e.g \"MANUFACTURING/NCLEGEND*\"\n") 
	fprintf(port "\n") 
	fprintf(port "  - A special variable $ROUTE can be used to drive film definition for etch/route related layers.\n")
	fprintf(port "    The variable $ROUTE refers to the actual subclass name of the cross section (e.g. \"TOP\" \"GND\"  \"VCC\"... \"BOTTOM\").\n") 
	fprintf(port "    The ipc2581 layer type (\"inner\" and \"outer\") will be derived automatically.\n") 
	fprintf(port "\n") 
	fprintf(port "  - A special variable $LAYERSPAN can be used to drive film definitions for legend related layers.\n") 
	fprintf(port "    The variable $LAYERSPAN refers to the actual layer span as indicated by the suffix of a legend layer \n")
	fprintf(port "    (e.g. \"1-8\", \"1-2\", \"2-3\", \"3-6\" ...) \n") 
	fprintf(port "\n") 
	fprintf(port "  - The variables mentioned above are not mandatory. Of course you can also specify each etch film explicitely \n") 
	fprintf(port "    using fixed layer names.\n") 
	fprintf(port "\n")
	fprintf(port "  - Furthermore you may distinguish between layers,  layersPrimary  and layersSecondary. The idea behind is as follows:\n") 
	fprintf(port "    By default a film is created only if data exists on specified layers. However there are situation where \n") 
	fprintf(port "    additional layers are included (e.g. \"BOARD GEOMETRY/OUTLINE\" ). In case of  of a legend layer without data, \n") 
	fprintf(port "    the film control record would be generated unconditionally since board outline graphics exist. In order to cope\n") 
	fprintf(port "    with this you may specify data relevant layers with layersPrimary  and additional layers as layersSecondary. \n")
	fprintf(port "    A film control record will be created only, if data exists on layersPrimary. For the final control record of course \n") 
	fprintf(port "    all layers will be merged.\n") 
	fprintf(port "\n") 
	fprintf(port "  - Note: Legal values for ipc2581 are: \"outer\", \"inner\",  \"doc\", \"soldermask\" and \"misc\"\n") 
	fprintf(port "\n")
	fprintf(port "  - You can export a template file for an existing design using command: \"tbx filmsetup export\"\n") 
	fprintf(port "\n") 
	fprintf(port "  - Watch parenthesis while editing this file!!\n") 
	fprintf(port "*/\n") 
	fprintf(port "\n")
	fprintf(port "  (defaults\n") 
	fprintf(port "     ( negative                 %L ) \n" 
	    (defaultParam->negative)
	) 
	fprintf(port "     ( undefineLineWidth       \"%.3f %s\" )\n" 
	    (defaultParam->undefineLineWidth) short_units
	) 
	fprintf(port "     ( rotation                 %d )\n" 
	    (defaultParam->rotation)
	) 
	fprintf(port "     ( xOffset                 \"%.3f %s\" )\n" 
	    (defaultParam->xOffset) short_units
	)
	fprintf(port "     ( yOffset                 \"%.3f %s\" )\n" 
	    (defaultParam->yOffset) short_units
	) 
	fprintf(port "     ( shapeBoundingBox        \"%.3f %s\" )\n" 
	    (defaultParam->shapeBoundingBox) short_units
	) 
	fprintf(port "     ( mirrored                 %L ) \n" 
	    (defaultParam->mirrored)
	) 
	fprintf(port "     ( fullContact              %L ) \n" 
	    (defaultParam->fullContact)
	) 
	fprintf(port "     ( suppressUnconnectPads    %L ) \n" 
	    (defaultParam->suppressUnconnectPads)
	)
	fprintf(port "     ( drawMissingPadApertures  %L ) \n" 
	    (defaultParam->drawMissingPadApertures)
	) 
	fprintf(port "     ( useApertureRotation      %L ) \n" 
	    (defaultParam->useApertureRotation)
	) 
	fprintf(port "     ( suppressShapeFill        %L ) \n" 
	    (defaultParam->suppressShapeFill)
	) 
	fprintf(port "     ( vectorBasedPad           %L ) \n" 
	    (defaultParam->vectorBasedPad)
	) 
	fprintf(port "     ( drawHolesOnly            %L ) \n" 
	    (defaultParam->drawHolesOnly)
	)
	fprintf(port "     ( domains                  %s ) \n" 
	    TBX_FILMSETUP_Build_String((defaultParam->domains))
	) 
	fprintf(port "     ( ipc2581                  %s ) \n" 
	    TBX_FILMSETUP_Build_String((defaultParam->ipc2581))
	) 
	fprintf(port "  )\n") 
	foreach(aw 
	    ((axlGetParam "artwork")->groupMembers) 
	    (param = (axlGetParam 
		    strcat("artwork:" aw)
		)) 
	    fprintf(port "  (film %L\n" aw) 
	    if((param->groupMembers) then 
		fprintf(port "     %L\n" 
		    cons('layers 
			(param->groupMembers)
		    )
		) else 
		fprintf(port "     %L\n" 
		    list('layers nil)
		)
	    )
	    when(((param->negative) != (defaultParam->negative)) 
		fprintf(port "     %L\n" 
		    list('negative 
			(param->negative)
		    )
		)
	    ) 
	    when(((param->sequence) != (defaultParam->sequence)) 
		fprintf(port "     %L\n" 
		    list('sequence 
			(param->sequence)
		    )
		)
	    ) 
	    when(((param->undefineLineWidth) != (defaultParam->undefineLineWidth)) 
		fprintf(port "     %L\n" 
		    list('undefineLineWidth 
			sprintf(nil "%.3f %s" 
			    (param->undefineLineWidth) short_units
			)
		    )
		)
	    ) 
	    when(((param->rotation) != (defaultParam->rotation)) 
		fprintf(port "     %L\n" 
		    list('rotation 
			(param->rotation)
		    )
		)
	    ) 
	    when((car((param->offset)) != (defaultParam->xOffset)) 
		fprintf(port "     %L\n" 
		    list('xOffset 
			sprintf(nil "%.3f %s" 
			    car((param->offset)) short_units
			)
		    )
		)
	    )
	    when((cadr((param->offset)) != (defaultParam->yOffset)) 
		fprintf(port "     %L\n" 
		    list('yOffset 
			sprintf(nil "%.3f %s" 
			    cadr((param->offset)) short_units
			)
		    )
		)
	    ) 
	    when(((param->shapeBoundingBox) != (defaultParam->shapeBoundingBox)) 
		fprintf(port "     %L\n" 
		    list('shapeBoundingBox 
			sprintf(nil "%.3f %s" 
			    (param->shapeBoundingBox) short_units
			)
		    )
		)
	    ) 
	    when(((param->mirrored) != (defaultParam->mirrored)) 
		fprintf(port "     %L\n" 
		    list('mirrored 
			(param->mirrored)
		    )
		)
	    ) 
	    when(((param->fullContact) != (defaultParam->fullContact)) 
		fprintf(port "     %L\n" 
		    list('fullContact 
			(param->fullContact)
		    )
		)
	    ) 
	    when(((param->suppressUnconnectPads) != (defaultParam->suppressUnconnectPads)) 
		fprintf(port "     %L\n" 
		    list('suppressUnconnectPads 
			(param->suppressUnconnectPads)
		    )
		)
	    )
	    when(((param->drawMissingPadApertures) != (defaultParam->drawMissingPadApertures)) 
		fprintf(port "     %L\n" 
		    list('drawMissingPadApertures 
			(param->drawMissingPadApertures)
		    )
		)
	    ) 
	    when(((param->useApertureRotation) != (defaultParam->useApertureRotation)) 
		fprintf(port "     %L\n" 
		    list('useApertureRotation 
			(param->useApertureRotation)
		    )
		)
	    ) 
	    when(((param->suppressShapeFill) != (defaultParam->suppressShapeFill)) 
		fprintf(port "     %L\n" 
		    list('suppressShapeFill 
			(param->suppressShapeFill)
		    )
		)
	    ) 
	    when(((param->vectorBasedPad) != (defaultParam->vectorBasedPad)) 
		fprintf(port "     %L\n" 
		    list('vectorBasedPad 
			(param->vectorBasedPad)
		    )
		)
	    ) 
	    when(((param->drawHolesOnly) != (defaultParam->drawHolesOnly)) 
		fprintf(port "     %L\n" 
		    list('drawHolesOnly 
			(param->drawHolesOnly)
		    )
		)
	    )
	    when((TBX_FILMSETUP_Build_String((param->domains)) != TBX_FILMSETUP_Build_String((defaultParam->domains))) 
		if((param->domains) then 
		    fprintf(port "     %L\n" 
			cons('domains 
			    (param->domains)
			)
		    ) else 
		    fprintf(port "     %L\n" 
			list('domains nil)
		    )
		)
	    ) 
	    when((TBX_FILMSETUP_Build_String((param->ip2581)) != TBX_FILMSETUP_Build_String((defaultParam->ipc2581))) 
		if((param->ipc2581) then 
		    fprintf(port "     %L\n" 
			cons('ipc2581 
			    (param->ipc2581)
			)
		    ) else 
		    fprintf(port "     %L\n" 
			list('ipc2581 nil)
		    )
		)
	    ) 
	    fprintf(port "  )\n")
	) 
	fprintf(port ")\n")
	close(port) 
	printf("Note: File %L has been written\n" cfg_file)
    )
)
procedure(TBX_FILMSETUP_Format_Value(value mode) 
    let((design_units ret_value) 
	(design_units = car((axlDBGetDesignUnits))) 
	caseq(mode 
	    (unit 
		cond((((type(value) == 'fixnum) || (type(value) == 'flonum)) 
			(ret_value = value)
		    ) 
		    ((type(value) == 'string) 
			(ret_value = (axlMKSConvert value design_units))
		    ) 
		    (t 
			(ret_value = nil)
		    )
		)
	    ) 
	    (symbol 
		cond(((type(value) == 'symbol) 
			(ret_value = value)
		    ) 
		    ((type(value) == 'string) 
			(ret_value = stringToSymbol(value))
		    ) 
		    (t 
			(ret_value = nil)
		    )
		)
	    ) 
	    (string 
		cond(((type(value) == 'string) 
			(ret_value = value)
		    ) 
		    ((type(value) == 'symbol) 
			(ret_value = symbolToString(value))
		    ) 
		    (t 
			(ret_value = nil)
		    )
		)
	    )
	) ret_value
    )
)
procedure(TBX_FILMSETUP_Get_Layer_Data(layer_list) 
    let((ok_data) 
	(axlVisibleDesign nil) 
	(axlSetFindFilter ?enabled 
	    list("noall" "boundary_shapes" "pins" "vias" "clines"
		"lines" "shapes" "text" "figures"
	    ) ?onButtons 
	    list("all")
	) 
	foreach(lyr layer_list 
	    (axlVisibleLayer lyr t)
	) 
	(axlVisibleUpdate nil)
	(axlClearSelSet) 
	(axlAddSelectAll) 
	when((axlGetSelSet) 
	    (ok_data = t)
	) ok_data
    )
)
procedure(TBX_FILMSETUP_Get_Layer_Spans() 
    let((mfg_subclasses nc_legend_layers layer_span layer_span_list) 
	(mfg_subclasses = mapcar(lambda((x) 
		    upperCase(x)
		) 
		(axlSubclasses 
		    (axlMapClassName "MANUFACTURING")
		)
	    )) 
	(nc_legend_layers = rexMatchList("^NCLEGEND" mfg_subclasses)) 
	foreach(lyr nc_legend_layers 
	    rexCompile("[0-9][0-9]*-[0-9][0-9]*$") 
	    when(rexExecute(lyr) 
		(layer_span = rexSubstitute("\\0")) 
		unless(exists(x layer_span_list 
			(x == layer_span)
		    ) 
		    (layer_span_list = cons(layer_span layer_span_list))
		)
	    )
	) 
	(layer_span_list = sort(layer_span_list nil))
	layer_span_list
    )
)
procedure(TBX_FILMSETUP_Init() 
    unless(boundp('tbx_filmsetup_global) 
	iliDefstruct('defstruct(tbx_filmsetup_global_struct filmData)) 
	defvar(tbx_filmsetup_global nil)
    ) 
    if(!tbx_filmsetup_global then 
	(tbx_filmsetup_global = (make_tbx_filmsetup_global_struct ?filmData nil)) else 
	(tbx_filmsetup_global->filmData = nil)
    )
)
procedure((TBX_FILMSETUP_Main \@optional arg) 
    let((lic_check_result FC_FEATURE FC_VERSION SUB_VERSION info_file
	    ok_start_app cfg_file port cfg_data defaultParam
	    currentParam filmParam name_string artwork_name film_data
	    pattern arg2 layer_name orgvis param
	    result outer_layers msg number_of_films_created
	) 
	(FC_FEATURE = "FILMSETUP") 
	(FC_VERSION = "16.4") 
	(SUB_VERSION = "02") 
	(ok_start_app = t)
	(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./filmsetup_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Film Setup information:\n") 
		fprintf(port "===============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "  export   : Writes a  configuration file from existing artwork definition\n") 
		fprintf(port "\n") 
		close(port)
		(axlUIViewFileCreate info_file "Film Setup: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "dump")) 
		TBX_FILMSETUP_Dump() 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "export") && lic_check_result) 
		TBX_FILMSETUP_Export() 
		(ok_start_app = nil)
	    ) 
	    (t 
		(ok_start_app = t)
	    )
	) 
	when((ok_start_app && lic_check_result) 
	    TBX_FILMSETUP_Init() 
	    (cfg_file = car(TBX_UTIL_Search_Config("film_setup.cfg" nil nil ?includeWorkDir t))) 
	    (defaultParam = ncons(nil)) 
	    (msg = sprintf(nil "This command will create film control records based on configuration data in %s.\nExisting film records will be deleted.\nDo you want to continue?" cfg_file))
	    when((axlUIYesNo msg nil 
		    'no
		) 
		when((isFile(cfg_file) && isReadable(cfg_file)) 
		    printf("Reading film configuration settings from %L\n" cfg_file) 
		    (port = infile(cfg_file)) 
		    (cfg_data = car(lineread(port))) 
		    close(port)
		) 
		foreach(sec cfg_data 
		    when((car(sec) == 'defaults) 
			foreach(entry 
			    cdr(sec) 
			    (result = TBX_FILMSETUP_Check_Data(entry)) 
			    when(result 
				putprop(defaultParam 
				    cadr(result) 
				    car(result)
				)
			    )
			)
		    )
		) 
		if(zerop(length((defaultParam->?))) then 
		    (axlUIConfirm "Error: Missing defaults section in configuration file %L. Check setup." cfg_file) else 
		    (orgvis = (axlVisibleGet))
		    foreach(sec cfg_data 
			(arg2 = TBX_FILMSETUP_Format_Value(cadr(sec) 
				'string
			    )) 
			when(((car(sec) == 'film) && arg2) 
			    (name_string = arg2) 
			    cond((rexMatchp("[$]ROUTE" 
					upperCase(name_string)
				    ) 
				    (currentParam = copy(defaultParam)) 
				    (outer_layers = list((axlConductorTopLayer) 
					    (axlConductorBottomLayer)
					)) 
				    foreach(entry 
					cddr(sec) 
					(result = TBX_FILMSETUP_Check_Data(entry)) 
					when(result 
					    putprop(currentParam 
						cadr(result) 
						car(result)
					    )
					)
				    ) 
				    (pattern = "[$][rR][oO][uU][tT][eE]")
				    foreach(lyr 
					(axlSubclassRoute) 
					(filmParam = copy(currentParam)) 
					if(exists(x outer_layers 
						(x == upperCase(lyr))
					    ) then 
					    (filmParam->ipc2581 = list('outer)) else 
					    (filmParam->ipc2581 = list('inner))
					) 
					(filmParam->name = TBX_FILMSETUP_String_Replace(name_string pattern lyr))
					(filmParam->layers = TBX_FILMSETUP_String_Replace((filmParam->layers) pattern lyr)) 
					(filmParam->layersPrimary = TBX_FILMSETUP_String_Replace((filmParam->layersPrimary) pattern lyr)) 
					(filmParam->layersSecondary = TBX_FILMSETUP_String_Replace((filmParam->layersSecondary) pattern lyr)) 
					(layer_name = strcat((axlMapClassName "ETCH") "/" lyr)) 
					(param = (axlLayerGet layer_name))
					(filmParam->negative = nil) 
					when((((param->type) == "PLANE") && ((param->drcPhotoType) == "negative")) 
					    (filmParam->negative = t)
					) 
					(filmParam->layers = TBX_FILMSETUP_Expand_Layers((filmParam->layers))) 
					(filmParam->layersPrimary = TBX_FILMSETUP_Expand_Layers((filmParam->layersPrimary))) 
					(filmParam->layersSecondary = TBX_FILMSETUP_Expand_Layers((filmParam->layersSecondary)))
					(film_data = cons(filmParam film_data))
				    )
				) 
				(rexMatchp("[$]LAYERSPAN" 
					upperCase(name_string)
				    ) 
				    (currentParam = copy(defaultParam)) 
				    foreach(entry 
					cddr(sec) 
					(result = TBX_FILMSETUP_Check_Data(entry)) 
					when(result 
					    putprop(currentParam 
						cadr(result) 
						car(result)
					    )
					)
				    ) 
				    (pattern = "[$][lL][aA][yY][eE][rR][sS][pP][aA][nN]") 
				    foreach(lsp 
					TBX_FILMSETUP_Get_Layer_Spans() 
					(filmParam = copy(currentParam)) 
					(filmParam->name = TBX_FILMSETUP_String_Replace(name_string pattern lsp)) 
					(filmParam->layers = TBX_FILMSETUP_String_Replace((filmParam->layers) pattern lsp))
					(filmParam->layersPrimary = TBX_FILMSETUP_String_Replace((filmParam->layersPrimary) pattern lsp)) 
					(filmParam->layersSecondary = TBX_FILMSETUP_String_Replace((filmParam->layersSecondary) pattern lsp)) 
					(filmParam->layers = TBX_FILMSETUP_Expand_Layers((filmParam->layers))) 
					(filmParam->layersPrimary = TBX_FILMSETUP_Expand_Layers((filmParam->layersPrimary))) 
					(filmParam->layersSecondary = TBX_FILMSETUP_Expand_Layers((filmParam->layersSecondary)))
					(film_data = cons(filmParam film_data))
				    )
				) 
				(t 
				    (filmParam = copy(defaultParam)) 
				    (artwork_name = arg2) 
				    foreach(entry 
					cddr(sec) 
					(result = TBX_FILMSETUP_Check_Data(entry)) 
					when(result 
					    putprop(filmParam 
						cadr(result) 
						car(result)
					    )
					)
				    ) 
				    (filmParam->name = artwork_name)
				    (filmParam->layers = TBX_FILMSETUP_Expand_Layers((filmParam->layers))) 
				    (filmParam->layersPrimary = TBX_FILMSETUP_Expand_Layers((filmParam->layersPrimary))) 
				    (filmParam->layersSecondary = TBX_FILMSETUP_Expand_Layers((filmParam->layersSecondary))) 
				    (film_data = cons(filmParam film_data))
				)
			    )
			)
		    ) 
		    (film_data = reverse(film_data)) 
		    (tbx_filmsetup_global->filmData = film_data) 
		    TBX_FILMSETUP_Create_Films(film_data) 
		    (axlVisibleSet orgvis)
		    (axlClearSelSet) 
		    (axlVisibleUpdate t)
		) 
		when(zerop(number_of_films_created) 
		    (axlUIConfirm "Warning: No films were created. PCB Editor will create defaults films when launching Artwork control form." 
			'warning
		    )
		)
	    )
	)
    )
)
procedure(TBX_FILMSETUP_String_Replace(lt_string pattern value) 
    let((ret_data string_list) 
	if((type(lt_string) == 'string) then 
	    (string_list = list(lt_string)) else 
	    (string_list = lt_string)
	) 
	foreach(str string_list 
	    rexCompile(pattern) 
	    (ret_data = cons(rexReplace(str value 0) ret_data))
	) 
	(ret_data = reverse(ret_data)) 
	when((type(lt_string) == 'string) 
	    (ret_data = car(ret_data))
	)
	ret_data
    )
)
procedure(TBX_FINDPADSTACK_Cache_Param() 
    let((rec session_param) 
	(rec = "findpadstack") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	putprop(session_param[rec] 
	    (axlFormGetField 
		(tbx_findpadstack_data->formId) "highlight_mode"
	    ) 
	    stringToSymbol("highlight_mode")
	)
	putprop(session_param[rec] 
	    (axlFormGetField 
		(tbx_findpadstack_data->formId) "report_only_mode"
	    ) 
	    stringToSymbol("report_only_mode")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField 
		(tbx_findpadstack_data->formId) "group_name"
	    ) 
	    stringToSymbol("group_name")
	) 
	putprop(session_param[rec] 
	    (tbx_findpadstack_data->colorId) 
	    stringToSymbol("highlight_color")
	)
    )
)
procedure(TBX_FINDPADSTACK_Callback(form_handle) 
    let((color_list group_name) 
	case((form_handle->curField) 
	    ("done" 
		TBX_FINDPADSTACK_Cache_Param() 
		(axlFinishEnterFun)
	    ) 
	    ("show_pins" 
		TBX_FINDPADSTACK_Filter(form_handle)
	    ) 
	    ("show_vias" 
		TBX_FINDPADSTACK_Filter(form_handle)
	    ) 
	    ("drill_size" 
		TBX_FINDPADSTACK_Filter(form_handle)
	    )
	    ("name_pattern" 
		TBX_FINDPADSTACK_Filter(form_handle)
	    ) 
	    ("highlight_mode" 
		when((form_handle->curValue) 
		    (axlFormSetFieldEditable form_handle "highlight_color" t)
		)
	    ) 
	    ("highlight_color" 
		(color_list = (axlCVFColorChooserDlg 0)) 
		when(color_list 
		    (tbx_findpadstack_data->colorId = car(color_list)) 
		    (axlFormSetField form_handle "highlight_color" 
			car(color_list)
		    ) 
		    (axlVisibleUpdate t)
		)
	    ) 
	    ("group_name" 
		(group_name = upperCase((form_handle->curValue))) 
		when(group_name 
		    if(rexMatchp("[^-_A-Z0-9]" 
			    upperCase(group_name)
			) then 
			printf("Warning: Invalid characters in group name. Use A-Z, 0-9, - and _ only. Reset value to default.\n") 
			(axlFormSetField form_handle "group_name" "DEFAULT") else
			when(((group_name != "DEFAULT") && !member(group_name 
					(tbx_findpadstack_data->groupNames)
				    )) 
			    (tbx_findpadstack_data->groupNames = cons(group_name 
				    (tbx_findpadstack_data->groupNames)
				))
			) 
			(tbx_findpadstack_data->groupNames = sort((tbx_findpadstack_data->groupNames) nil)) 
			(axlFormBuildPopup form_handle "group_name" 
			    cons("DEFAULT" 
				(tbx_findpadstack_data->groupNames)
			    )
			) 
			(axlFormSetField form_handle "group_name" group_name)
		    )
		)
	    ) 
	    ("clear_all_groups" 
		foreach(grp 
		    (axlSelectByName "GROUP" "TBX_FINDPAD_*" t) 
		    (axlDBDisbandGroup grp)
		) 
		(tbx_findpadstack_data->groupNames = nil) 
		(axlFormBuildPopup form_handle "group_name" 
		    list("DEFAULT")
		) 
		(axlFormSetField form_handle "group_name" "DEFAULT")
	    )
	    ("report_only_mode" 
		when((form_handle->curValue) 
		    (axlFormSetFieldEditable form_handle "highlight_color" nil)
		)
	    ) 
	    ("run" 
		(axlDBDisplayControl 
		    'customColorEnabled t
		) 
		(axlVisibleUpdate t) 
		when((axlFormGetField form_handle "highlight_mode") 
		    (axlDBTransactionMark 
			(tbx_findpadstack_data->transMark)
		    )
		) 
		TBX_FINDPADSTACK_Run(form_handle)
	    ) 
	    ("myhelp" 
		(axlShell "tbx help findpadstack")
	    )
	)
    )
)
procedure(TBX_FINDPADSTACK_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_FINDPADSTACK_Color_Group(group_name color_id) 
    let((port script_file cmd) 
	(script_file = strcat(getWorkingDir() "/color_script.scr")) 
	(port = outfile(script_file "w")) 
	fprintf(port "scriptmode +i +n\n") 
	fprintf(port "setwindow pcb\n")
	fprintf(port "trapsize 0\n") 
	fprintf(port "generaledit\n") 
	fprintf(port "assign color\n") 
	fprintf(port "setwindow form.mini\n") 
	fprintf(port "FORM mini hlt_candicane_state Solid \n")
	fprintf(port "FORM mini color_choose\n") 
	fprintf(port "cvf_chooser %d\n" color_id) 
	fprintf(port "setwindow form.find\n") 
	fprintf(port "FORM find all_off\n") 
	fprintf(port "FORM find groups YES\n")
	if(((axlVersion 
		    'version
		) >= 16.6) then 
	    fprintf(port "FORM find name_type Generic Group\n") else 
	    fprintf(port "FORM find name_type Group\n")
	) 
	fprintf(port "FORM find find_name %s\n" group_name) 
	fprintf(port "setwindow pcb\n") 
	fprintf(port "done\n") 
	close(port)
	(cmd = sprintf(nil "replay %L" script_file)) 
	(axlShell cmd) 
	when(isFile(script_file) t) t
    )
)
procedure(TBX_FINDPADSTACK_Done() 
    TBX_FINDPADSTACK_Cache_Param() 
    (axlFinishEnterFun)
)
procedure(TBX_FINDPADSTACK_Event_Loop(form_handle) 
    let((loop event) 
	(loop = t) 
	(axlEventSetStartPopup 
	    'TBX_FINDPADSTACK_Popup_Callback
	) 
	(tbx_findpadstack_data->transMark = (axlDBTransactionStart)) 
	while(loop 
	    (event = (axlEnterEvent 
		    list('PICK) nil nil
		)) 
	    caseq((event->type) 
		(PICK t) 
		(DONE 
		    (axlDBTransactionCommit 
			(tbx_findpadstack_data->transMark)
		    ) 
		    (axlFormClose form_handle) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics)
		    (loop = nil)
		) 
		(CANCEL 
		    (axlDBTransactionOops 
			(tbx_findpadstack_data->transMark)
		    ) 
		    (axlDBTransactionCommit 
			(tbx_findpadstack_data->transMark)
		    ) 
		    (axlFormClose form_handle) 
		    (axlUIPopupSet nil)
		    (axlClearDynamics) 
		    (loop = nil)
		)
	    )
	)
	(axlEventSetStartPopup)
    )
)
procedure(TBX_FINDPADSTACK_Filter(form_handle) 
    let((show_pins show_vias name_pattern drill_pattern okay_type
	    drill_size_str name_list padstack_list
	) 
	(show_pins = (axlFormGetField form_handle "show_pins")) 
	(show_vias = (axlFormGetField form_handle "show_vias")) 
	(drill_pattern = (axlFormGetField form_handle "drill_size")) 
	(name_pattern = (axlFormGetField form_handle "name_pattern"))
	(name_pattern = TBX_UTIL_Regex_From_Shell(name_pattern t)) 
	(drill_pattern = TBX_UTIL_Regex_From_Shell(drill_pattern t)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "pins" "vias") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll)
	(padstack_list = (axlGetSelSet)) 
	(axlClearSelSet) 
	foreach(pdbid padstack_list 
	    (okay_type = nil) 
	    when((show_pins && ((pdbid->objType) == "pin")) 
		(okay_type = t)
	    ) 
	    when((show_vias && ((pdbid->objType) == "via")) 
		(okay_type = t)
	    )
	    if(((pdbid->definition)->drillDiameter) then 
		(drill_size_str = sprintf(nil "%L" 
			((pdbid->definition)->drillDiameter)
		    )) else 
		(drill_size_str = "nil")
	    ) 
	    when((okay_type && rexMatchp(name_pattern 
			(pdbid->name)
		    ) && rexMatchp(drill_pattern drill_size_str)) 
		unless(exists(x name_list 
			(x == (pdbid->name))
		    ) 
		    (name_list = cons((pdbid->name) name_list))
		)
	    )
	) 
	(name_list = sort(name_list nil)) 
	(axlFormListDeleteAll form_handle "padstack_list")
	(axlFormSetField form_handle "padstack_list" name_list) t
    )
)
procedure(TBX_FINDPADSTACK_Get_Base_Info() 
    let((name_table drill_table name_info drill_info padstack_list) 
	(name_table = makeTable("name_table_info" nil)) 
	(drill_table = makeTable("drill_table_info" nil)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "pins" "vias" "fingers") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet)
	(axlAddSelectAll) 
	(padstack_list = (axlGetSelSet)) 
	foreach(pstck padstack_list 
	    (name_table[(pstck->name)] = t) 
	    (drill_table[((pstck->definition)->drillDiameter)] = t)
	) 
	foreach(key name_table 
	    (name_info = cons(key name_info))
	) 
	(name_info = sort(name_info nil))
	foreach(key drill_table 
	    (drill_info = cons(sprintf(nil "%L" key) drill_info))
	) 
	(drill_info = sort(drill_info nil)) 
	(drill_info = cons("*" drill_info)) 
	list(name_info drill_info)
    )
)
procedure(TBX_FINDPADSTACK_Init() 
    unless(boundp('tbx_findpadstack_data) 
	iliDefstruct('defstruct(tbx_findpadstack_data_struct colorId groupNames licCheck transMark
		    formId
		)
	) 
	defvar(tbx_findpadstack_data nil)
    ) 
    if(!tbx_findpadstack_data then 
	(tbx_findpadstack_data = (make_tbx_findpadstack_data_struct ?colorId nil ?groupNames nil
		?licCheck nil ?transMark nil ?formId
		nil
	    )) else 
	(tbx_findpadstack_data->colorId = nil)
	(tbx_findpadstack_data->groupNames = nil) 
	(tbx_findpadstack_data->licCheck = nil) 
	(tbx_findpadstack_data->transMark = nil) 
	(tbx_findpadstack_data->formId = nil)
    )
)
procedure(TBX_FINDPADSTACK_Init_Form(form_handle) 
    let((design_type result old_name new_name group_list
	    record color_id
	) 
	(design_type = lowerCase((axlDesignType t))) 
	(axlFormSetField form_handle "show_pins" t) 
	(axlFormSetField form_handle "show_vias" t) 
	(axlFormSetField form_handle "name_pattern" "*")
	(result = TBX_FINDPADSTACK_Get_Base_Info()) 
	when(result 
	    (axlFormSetField form_handle "padstack_list" 
		car(result)
	    ) 
	    (axlFormBuildPopup form_handle "drill_size" 
		cadr(result)
	    ) 
	    (axlFormSetField form_handle "drill_size" "*")
	) 
	foreach(grp 
	    (axlSelectByName "GROUP" "FLW_FINDPAD_*" t) 
	    (old_name = (grp->name)) 
	    (new_name = rexReplace(old_name "TBX_FINDPAD_" 0)) 
	    (axlDBGroupRename grp new_name)
	) 
	(axlDBRefreshId nil) 
	rexCompile("TBX_FINDPAD_")
	foreach(grp 
	    (axlSelectByName "GROUP" "TBX_FINDPAD_*" t) 
	    (group_list = cons(rexReplace((grp->name) "" 0) group_list))
	) 
	when(member("DEFAULT" group_list) 
	    (group_list = remove("DEFAULT" group_list))
	) 
	(group_list = sort(group_list nil)) 
	(tbx_findpadstack_data->groupNames = group_list) 
	(axlClearSelSet)
	(axlFormBuildPopup form_handle "group_name" 
	    cons("DEFAULT" 
		(tbx_findpadstack_data->groupNames)
	    )
	) 
	(record = "findpadstack") 
	(axlFormSetField form_handle "highlight_mode" 
	    TBX_SESSION_Get_Param(record "highlight_mode" t)
	) 
	(axlFormSetField form_handle "report_only_mode" 
	    TBX_SESSION_Get_Param(record "report_only_mode" nil)
	) 
	(color_id = TBX_SESSION_Get_Param(record "highlight_color" 
		(tbx_findpadstack_data->colorId)
	    ))
	(axlFormSetField form_handle "highlight_color" color_id) 
	(tbx_findpadstack_data->colorId = color_id) 
	(axlFormSetField form_handle "group_name" 
	    TBX_SESSION_Get_Param(record "group_name" "DEFAULT")
	) 
	if(exists(x 
		list("board" "module" "mcm" "sip") 
		(x == design_type)
	    ) then 
	    (axlFormSetFieldEditable form_handle "highlight_mode" t) else 
	    (axlFormSetFieldEditable form_handle "highlight_mode" nil)
	) 
	if((axlFormGetField form_handle "report_only_mode") then 
	    (axlFormSetFieldEditable form_handle "highlight_color" nil) else 
	    (axlFormSetFieldEditable form_handle "highlight_color" t)
	)
	(axlVisibleUpdate t) 
	(axlClearSelSet) t
    )
)
procedure((TBX_FINDPADSTACK_Main \@optional arg) 
    let((lic_check_result FC_FEATURE FC_VERSION SUB_VERSION VERSION_STR
	    FORM_FILE fid port info_file
	) 
	(FC_FEATURE = "FINDPADSTACK") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Padstack Finder %s (C)2017" FC_VERSION))
	(VERSION_STR = VERSION_STR) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./finfpadstack_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Padstack Finder information:\n") 
		fprintf(port "====================================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Drawing Size: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    TBX_FINDPADSTACK_Init() 
		    (tbx_findpadstack_data->colorId = 1) 
		    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "findpadstack_main")) 
		    (fid = (axlFormCreate 
			    gensym("tbxfindpadstackmain") FORM_FILE 
			    '(e outer) 
			    'TBX_FINDPADSTACK_Callback
			    t
			))
		    TBX_FORM_Init_Header(fid nil lic_check_result nil) 
		    (tbx_findpadstack_data->formId = fid) 
		    TBX_FINDPADSTACK_Init_Form(fid) 
		    (axlFormDisplay fid) 
		    TBX_FINDPADSTACK_Event_Loop(fid)
		    TBX_FORM_Delete(lic_check_result FORM_FILE)
		)
	    )
	) t
    )
)
procedure(TBX_FINDPADSTACK_Oops() 
    (axlDBTransactionOops 
	(tbx_findpadstack_data->transMark)
    ) 
    (axlCancelEnterFun)
)
procedure(TBX_FINDPADSTACK_Popup_Callback(event) 
    let((popid) 
	(event = event) 
	(popid = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_FINDPADSTACK_Done
		    ) 
		    list("Oops" 
			'TBX_FINDPADSTACK_Oops
		    ) 
		    list("Cancel" 
			'TBX_FINDPADSTACK_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popid)
    )
)
procedure(TBX_FINDPADSTACK_Run(form_handle) 
    let((name_list padstack_list report_file port name
	    xy start_end drill_size report_data start_layer
	    end_layer group_name group_name_int group_dbid
	) 
	(name_list = (axlFormListGetSelItems form_handle "padstack_list")) 
	if(name_list then 
	    (group_name = (axlFormGetField form_handle "group_name")) 
	    (group_name_int = strcat("TBX_FINDPAD_" group_name)) 
	    foreach(grp 
		(axlSelectByName "GROUP" group_name_int) 
		(axlDBDisbandGroup grp)
	    )
	    (axlDBRefreshId nil) 
	    (group_dbid = (axlDBCreateGroup group_name_int "generic" nil)) 
	    (axlSetFindFilter ?enabled 
		list("noall" "invisible" "pins" "vias" "fingers") ?onButtons 
		list("all")
	    ) 
	    (axlClearSelSet) 
	    (axlAddSelectAll)
	    (padstack_list = setof(p 
		    (axlGetSelSet) 
		    member((p->name) name_list)
		)) 
	    when(padstack_list 
		(axlDBAddGroupObjects group_dbid padstack_list) 
		(report_data = mapcar(lambda((p) 
			    list((p->name) 
				(p->xy) 
				((p->definition)->drillDiameter) 
				(p->startEnd)
			    )
			) padstack_list
		    )) 
		(report_data = sortcar(report_data nil)) 
		(axlClearSelSet)
		when((axlFormGetField form_handle "highlight_mode") 
		    (axlCustomColorObject group_dbid 
			(tbx_findpadstack_data->colorId)
		    )
		) 
		(report_file = strcat(getWorkingDir() "/tbx_padstack_report.txt")) 
		(port = outfile(report_file "w")) 
		fprintf(port "%-25s  %-20s  %-15s  %s\n" "Name" "Location" "DrillSize"
		    "Start<->End"
		) 
		fprintf(port "==========================================================================================\n")
		foreach(entry report_data 
		    (name = car(entry)) 
		    (xy = cadr(entry)) 
		    (drill_size = caddr(entry))
		    (start_end = nth(3 entry)) 
		    (xy = sprintf(nil "%L" xy)) 
		    (drill_size = sprintf(nil "%L" drill_size)) 
		    if((start_end != list(nil nil)) then 
			(start_layer = car(start_end)) 
			(start_layer = cadr(parseString(start_layer "/"))) 
			(end_layer = cadr(start_end))
			(end_layer = cadr(parseString(end_layer "/"))) 
			(start_end = strcat(start_layer "<->" end_layer)) else 
			(start_end = "NA")
		    ) 
		    fprintf(port "%-25s  %-20s  %-15s  %s\n" name xy drill_size
			start_end
		    )
		) 
		close(port) 
		(axlUIViewFileCreate report_file "Padstack Report" nil)
	    ) else 
	    printf("Warning: Select at least one padstack from the list\n")
	) 
	(axlClearSelSet) t
    )
)
procedure(TBX_FORM_Cancel(form_handle trans_mark) 
    (axlCancelEnterFun) 
    (axlUIPopupSet nil) 
    (axlClearDynamics) 
    (axlVisibleUpdate t)
    when(form_handle 
	(axlFormClose form_handle)
    ) 
    when(trans_mark 
	(axlDBTransactionRollback trans_mark)
    )
)
procedure(TBX_FORM_Cross_Select(available selected masterApp) 
    let((FORM_FILE fid) 
	TBX_FORM_Init() 
	(FORM_FILE = TBX_FORM_Get_Name((masterApp->licCheck) "ctrl_cross_select")) 
	unless(boundp('tbxCtrlMainHandle) 
	    defvar(tbxCtrlMainHandle nil)
	) 
	(fid = (axlFormCreate 
		'tbxCtrlMainHandle FORM_FILE 
		'(e outer) 
		'TBX_FORM_Cross_Select_Callback
		nil nil
	    ))
	when(fid 
	    when((type((masterApp->licCheck)) == 'string) 
		(axlFormSetField fid "lic_info" 
		    sprintf(nil "Licensed for %s" 
			(masterApp->licCheck)
		    )
		)
	    ) 
	    (tbx_form_data->appName = (masterApp->name)) 
	    (axlFormTitle fid 
		(masterApp->version)
	    ) 
	    TBX_FORM_Init_Header(fid "Licensed for " 
		(masterApp->licCheck) 
		(masterApp->version)
	    )
	    (axlFormSetField fid "available_items" available) 
	    (axlFormSetField fid "selected_items" selected) 
	    when((masterApp->selectorMsg) 
		(axlFormSetField fid "info_msg" 
		    (masterApp->selectorMsg)
		)
	    ) 
	    ((tbx_form_data->crossSelect)->tmp = selected) 
	    (axlFormDisplay fid)
	    when((masterApp->selectorDummyEven) 
		TBX_FORM_Dummy_Loop()
	    ) 
	    TBX_FORM_Delete((masterApp->licCheck) FORM_FILE)
	) 
	((tbx_form_data->crossSelect)->selected)
    )
)
procedure(TBX_FORM_Cross_Select_Callback(form_handle) 
    case((form_handle->curField) 
	("add_selected" 
	    foreach(itm 
		(axlFormListGetSelItems form_handle "available_items") 
		unless(exists(x 
			((tbx_form_data->crossSelect)->tmp) 
			(x == itm)
		    ) 
		    ((tbx_form_data->crossSelect)->tmp = cons(itm 
			    ((tbx_form_data->crossSelect)->tmp)
			))
		)
	    ) 
	    (axlFormListDeleteAll form_handle "selected_items") 
	    (axlFormSetField form_handle "selected_items" 
		((tbx_form_data->crossSelect)->tmp)
	    )
	) 
	("remove_selected" 
	    foreach(itm 
		(axlFormListGetSelItems form_handle "selected_items") 
		((tbx_form_data->crossSelect)->tmp = remove(itm 
			((tbx_form_data->crossSelect)->tmp)
		    ))
	    ) 
	    (axlFormListDeleteAll form_handle "selected_items") 
	    (axlFormSetField form_handle "selected_items" 
		((tbx_form_data->crossSelect)->tmp)
	    )
	) 
	("cancel" 
	    (axlFormClose form_handle) 
	    (axlFinishEnterFun)
	) 
	("done" 
	    ((tbx_form_data->crossSelect)->selected = ((tbx_form_data->crossSelect)->tmp)) 
	    (axlFormClose form_handle) 
	    (axlFinishEnterFun)
	)
	("myhelp" 
	    TBX_HELP_Launch(lowerCase((tbx_form_data->appName)))
	)
    )
)
procedure(TBX_FORM_Delete(lcheck FORM_FILE) 
    when((type(lcheck) == 'string) 
	deleteFile(FORM_FILE)
    )
)
procedure(TBX_FORM_Done(form_handle trans_mark) 
    (axlFinishEnterFun) 
    (axlUIPopupSet nil) 
    (axlClearDynamics) 
    (axlVisibleUpdate t)
    when(form_handle 
	(axlFormClose form_handle)
    ) 
    when(trans_mark 
	(axlDBTransactionCommit trans_mark)
    )
)
procedure(TBX_FORM_Dummy_Loop() 
    let((loop event event_mask) 
	(loop = t) 
	(axlEventSetStartPopup 
	    'TBX_FORM_Popup_Callback
	) 
	(event_mask = list('PICK 
		'STARTDRAG 
		'STOPDRAG
	    )) 
	while(loop 
	    (event = (axlEnterEvent event_mask nil nil)) 
	    caseq((event->type) 
		(PICK t) 
		(STARTDRAG 
		    (axlAddSimpleRbandDynamics 
			(event->xy) "box" ?origin 
			(0.0:0.0)
		    )
		) 
		(STOPDRAG 
		    (axlClearDynamics)
		) 
		(DONE 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    (loop = nil)
		)
		(CANCEL 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    (loop = nil)
		)
	    )
	)
	(axlEventSetStartPopup)
    )
)
procedure(TBX_FORM_Get_Name(lcheck application) 
    let((form_file flw_form_file tbx_form_file skill_file_path il_list
	    forms_dir
	) 
	unless(boundp('tbx_session_param) 
	    defvar(tbx_session_param 
		makeTable("tbx_session_param_table" nil)
	    )
	) 
	(flw_form_file = strcat(getWorkingDir() "/tbx_" 
		lowerCase(application) ".form"
	    )) 
	(tbx_form_file = strcat("tbx_" 
		lowerCase(application) ".form"
	    )) 
	(application = lowerCase(application))
	if((type(lcheck) == 'string) then 
	    (tbx_session_param["curForm"] = flw_form_file) 
	    (tbx_session_param["debug"] = nil) 
	    when((axlGetVariable("FLOWARE_ROOT") && (type(axlGetVariable("FLOWARE_ROOT")) == 'string)) 
		(forms_dir = strcat(axlGetVariable("FLOWARE_ROOT") "/forms")) 
		(il_list = rexMatchList(sprintf(nil "%s.*[.]il$" application) 
			getDirFiles(forms_dir)
		    )) 
		if(il_list then 
		    (skill_file_path = strcat(forms_dir "/" 
			    car(il_list)
			)) 
		    printf("Note: Executing form file: %L\n" skill_file_path) else
		    (skill_file_path = strcat(forms_dir "/" application ".ile"))
		) 
		if(isFile(skill_file_path) then 
		    load(skill_file_path "floware_package") else 
		    (axlUIConfirm 
			sprintf(nil "Cannot find/load file %L. You may need to update FloWare installation.\n" skill_file_path) 
			'error
		    )
		)
	    )
	    if(tbx_session_param["debug"] then 
		(form_file = flw_form_file) else 
		when(isFile(flw_form_file) 
		    deleteFile(flw_form_file)
		)
		(form_file = nil)
	    ) else 
	    (form_file = tbx_form_file)
	) form_file
    )
)
procedure(TBX_FORM_Init() 
    unless(boundp('tbx_form_data) 
	iliDefstruct('defstruct(tbx_form_data_struct crossSelect etchLayers appName)) 
	defvar(tbx_form_data nil)
    ) 
    if(!tbx_form_data then 
	(tbx_form_data = (make_tbx_form_data_struct ?crossSelect 
		ncons(nil) ?etchLayers 
		ncons(nil)
		?appName nil
	    )) else 
	(tbx_form_data->crossSelect = ncons(nil))
	(tbx_form_data->etchLayers = ncons(nil)) 
	(tbx_form_data->appName = nil)
    )
)
procedure(TBX_FORM_Init_Header(form_handle cn_prefix cn ts) 
    if((type(cn) == 'string) then 
	when((ts && (type(ts) == 'string)) 
	    (axlFormTitle form_handle ts)
	) 
	if((cn_prefix && (type(cn_prefix) == 'string)) then 
	    (axlFormSetField form_handle "lic_info" 
		strcat(cn_prefix cn)
	    ) else 
	    (axlFormSetField form_handle "lic_info" cn)
	) else
	t
    )
)
procedure(TBX_FORM_Popup_Callback(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_FORM_RMB_Done
		    ) 
		    list("Cancel" 
			'TBX_FORM_RMB_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_FORM_RMB_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_FORM_RMB_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_FORM_Specify_Etch_Layers(preselected) 
    let((FORM_FILE fid layer_list) 
	TBX_FORM_Init() 
	(FORM_FILE = "tbx_ctrl_list_select") 
	unless(boundp('tbxCtrlMainHandle) 
	    defvar(tbxCtrlMainHandle nil)
	) 
	(fid = (axlFormCreate 
		'tbxCtrlMainHandle FORM_FILE 
		'(e outer) 
		'TBX_FORM_Specify_Etch_Layers_Callback
		t nil
	    ))
	when(fid 
	    (axlFormTitle fid "Specify Layers") 
	    (layer_list = (axlSubclassRoute)) 
	    (layer_list = cons("Plane" layer_list)) 
	    (layer_list = cons("Signal" layer_list))
	    (layer_list = cons("Inner" layer_list)) 
	    (layer_list = cons("Outer" layer_list)) 
	    (layer_list = cons("All" layer_list)) 
	    (axlFormListDeleteAll fid "name_list") 
	    (axlFormSetField fid "name_list" layer_list)
	    foreach(lyr preselected 
		(axlFormListSelect fid "name_list" lyr)
	    ) 
	    (axlFormDisplay fid) 
	    (axlUIWBlock fid)
	) 
	((tbx_form_data->etchLayers)->selected)
    )
)
procedure(TBX_FORM_Specify_Etch_Layers_Callback(form_handle) 
    let((msg) 
	(msg = msg) 
	case((form_handle->curField) 
	    ("done" 
		((tbx_form_data->etchLayers)->selected = reverse((axlFormListGetSelItems form_handle "name_list"))) 
		(axlFormClose form_handle)
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_GENMASK_Callback(form_handle) 
    let((layer_list user_input msk_base_name top_layer bottom_layer
	    pin_oversize via_oversize pin_map via_map base_layers
	    result orgvis
	) 
	case((form_handle->curField) 
	    ("new_subclass" 
		(user_input = (axlEnterString ?prompts 
			list("Enter layer name. Suffix _TOP, _BOTTOM not needed as handled by application.")
		    )) 
		when(user_input 
		    (msk_base_name = TBX_GENMASK_Get_Base_Name(user_input)) 
		    (top_layer = strcat((axlMapClassName "MANUFACTURING") "/" msk_base_name "_TOP")) 
		    (bottom_layer = strcat((axlMapClassName "MANUFACTURING") "/" msk_base_name "_BOTTOM")) 
		    (base_layers = TBX_GENMASK_Get_System_Base_Layers())
		    if(exists(x base_layers 
			    (x == msk_base_name)
			) then 
			printf("Info: Mask layer already  exists\n") else 
			(base_layers = cons(msk_base_name base_layers))
		    ) 
		    (base_layers = sort(base_layers nil)) 
		    if(base_layers then 
			(axlFormBuildPopup form_handle "mfg_subclass" base_layers) 
			(axlFormSetField form_handle "mfg_subclass" msk_base_name) else
			(axlFormBuildPopup form_handle "mfg_subclass" 
			    list(" ")
			)
		    )
		)
	    ) 
	    ("done" 
		(axlFormClose form_handle) 
		(axlVisibleUpdate t)
	    ) 
	    ("run" 
		(msk_base_name = (axlFormGetField form_handle "mfg_subclass")) 
		if((msk_base_name && (msk_base_name != "") && (msk_base_name != " ")) then 
		    (orgvis = (axlVisibleGet)) 
		    (top_layer = strcat((axlMapClassName "MANUFACTURING") "/" msk_base_name "_TOP")) 
		    (bottom_layer = strcat((axlMapClassName "MANUFACTURING") "/" msk_base_name "_BOTTOM"))
		    case((axlFormGetField form_handle "side") 
			("top" 
			    (layer_list = list(top_layer))
			) 
			("bottom" 
			    (layer_list = list(bottom_layer))
			) 
			("both" 
			    (layer_list = list(top_layer bottom_layer))
			)
		    ) 
		    TBX_GENMASK_Init_Layers(layer_list) 
		    (result = TBX_GENMASK_Get_Layer_Mapping(form_handle top_layer bottom_layer)) 
		    (pin_map = car(result)) 
		    (via_map = cadr(result))
		    (pin_oversize = (axlFormGetField form_handle "pin_oversize_value")) 
		    (via_oversize = (axlFormGetField form_handle "via_oversize_value")) 
		    TBX_GENMASK_Oversize_Padstack(pin_oversize via_oversize pin_map via_map) 
		    (axlVisibleSet orgvis) 
		    (axlVisibleUpdate t)
		    else 
		    (axlUIConfirm "Please specify mask name (without _TOP, _BOTTOM suffix)")
		)
	    ) 
	    ("myhelp" 
		TBX_HELP_Launch("genmask")
	    )
	    (t t)
	)
    )
)
procedure(TBX_GENMASK_Get_Base_Name(str) 
    let((base_name) 
	(base_name = upperCase(str)) 
	rexCompile("-") 
	(base_name = rexReplace(base_name "_" 0)) 
	rexCompile("^MSK_")
	(base_name = rexReplace(base_name "" 0)) 
	rexCompile("_TOP$") 
	(base_name = rexReplace(base_name "" 0)) 
	rexCompile("^TOP_") 
	(base_name = rexReplace(base_name "" 0))
	rexCompile("_TOP_") 
	(base_name = rexReplace(base_name "_" 0)) 
	rexCompile("_BOTTOM$") 
	(base_name = rexReplace(base_name "" 0)) 
	rexCompile("^BOTTOM_")
	(base_name = rexReplace(base_name "" 0)) 
	rexCompile("_BOTTOM_") 
	(base_name = rexReplace(base_name "_" 0)) 
	(base_name = strcat("MSK_" base_name)) base_name
    )
)
procedure(TBX_GENMASK_Get_Layer_Mapping(form_handle top_layer bottom_layer) 
    let((side pin_map via_map COND_TOP_LAYER COND_BOTTOM_LAYER) 
	(side = (axlFormGetField form_handle "side")) 
	(COND_TOP_LAYER = strcat((axlMapClassName "ETCH") "/" 
		(axlConductorTopLayer)
	    )) 
	(COND_BOTTOM_LAYER = strcat((axlMapClassName "ETCH") "/" 
		(axlConductorBottomLayer)
	    )) 
	case(lowerCase((axlFormGetField form_handle "pin_source")) 
	    ("soldermask" 
		case(side 
		    ("top" 
			(pin_map = list(list("PIN/SOLDERMASK_TOP" top_layer)))
		    ) 
		    ("bottom" 
			(pin_map = list(list("PIN/SOLDERMASK_BOTTOM" bottom_layer)))
		    ) 
		    ("both" 
			(pin_map = list(list("PIN/SOLDERMASK_TOP" top_layer) 
				list("PIN/SOLDERMASK_BOTTOM" bottom_layer)
			    ))
		    )
		)
	    ) 
	    ("pastemask" 
		case(side 
		    ("top" 
			(pin_map = list(list("PIN/PASTEMASK_TOP" top_layer)))
		    ) 
		    ("bottom" 
			(pin_map = list(list("PIN/PASTEMASK_BOTTOM" bottom_layer)))
		    ) 
		    ("both" 
			(pin_map = list(list("PIN/PASTEMASK_TOP" top_layer) 
				list("PIN/PASTEMASK_BOTTOM" bottom_layer)
			    ))
		    )
		)
	    ) 
	    ("etch" 
		case(side 
		    ("top" 
			(pin_map = list(list(COND_TOP_LAYER top_layer)))
		    ) 
		    ("bottom" 
			(pin_map = list(list(COND_BOTTOM_LAYER bottom_layer)))
		    ) 
		    ("both" 
			(pin_map = list(list(COND_TOP_LAYER top_layer) 
				list(COND_BOTTOM_LAYER bottom_layer)
			    ))
		    )
		)
	    )
	)
	case(lowerCase((axlFormGetField form_handle "via_source")) 
	    ("soldermask" 
		case(side 
		    ("top" 
			(via_map = list(list("VIA CLASS/SOLDERMASK_TOP" top_layer)))
		    ) 
		    ("bottom" 
			(via_map = list(list("VIA CLASS/SOLDERMASK_BOTTOM" bottom_layer)))
		    ) 
		    ("both" 
			(via_map = list(list("VIA CLASS/SOLDERMASK_TOP" top_layer) 
				list("VIA CLASS/SOLDERMASK_BOTTOM" bottom_layer)
			    ))
		    )
		)
	    ) 
	    ("pastemask" 
		case(side 
		    ("top" 
			(via_map = list(list("VIA CLASS/PASTEMASK_TOP" top_layer)))
		    ) 
		    ("bottom" 
			(via_map = list(list("VIA CLASS/PASTEMASK_BOTTOM" bottom_layer)))
		    ) 
		    ("both" 
			(via_map = list(list("VIA CLASS/PASTEMASK_TOP" top_layer) 
				list("VIA CLASS/PASTEMASK_BOTTOM" bottom_layer)
			    ))
		    )
		)
	    ) 
	    ("etch" 
		case(side 
		    ("top" 
			(via_map = list(list(COND_TOP_LAYER top_layer)))
		    ) 
		    ("bottom" 
			(via_map = list(list(COND_BOTTOM_LAYER bottom_layer)))
		    ) 
		    ("both" 
			(via_map = list(list(COND_TOP_LAYER top_layer) 
				list(COND_BOTTOM_LAYER bottom_layer)
			    ))
		    )
		)
	    ) 
	    ("drill" 
		case(side 
		    ("top" 
			(via_map = list(list("DRILL_TOP" top_layer)))
		    ) 
		    ("bottom" 
			(via_map = list(list("DRILL_BOTTOM" bottom_layer)))
		    ) 
		    ("both" 
			(via_map = list(list("DRILL_TOP" top_layer) 
				list("DRILL_BOTTOM" bottom_layer)
			    ))
		    )
		)
	    )
	) 
	list(pin_map via_map)
    )
)
procedure(TBX_GENMASK_Get_System_Base_Layers() 
    let((layer_name msk_base_name msk_base_list) 
	foreach(lyr 
	    ((axlGetParam "paramLayerGroup:MANUFACTURING")->groupMembers) 
	    (layer_name = upperCase(lyr)) 
	    when(rexMatchp("^MSK_" layer_name) 
		rexCompile("_TOP$") 
		(msk_base_name = rexReplace(layer_name "" 0)) 
		rexCompile("_BOTTOM$") 
		(msk_base_name = rexReplace(msk_base_name "" 0))
		if((rexMatchp("[-_]TOP[-_]" msk_base_name) || 
			rexMatchp("[-_]BOTTOM[-_]" msk_base_name)) then 
		    printf("Info: Ignoring layer %L, Top and Bottom layers are managed by suffix only.\n" lyr) else 
		    unless(exists(x msk_base_list 
			    (x == msk_base_name)
			) 
			(msk_base_list = cons(msk_base_name msk_base_list))
		    )
		)
	    )
	) 
	(msk_base_list = sort(msk_base_list nil)) msk_base_list
    )
)
procedure(TBX_GENMASK_Init() 
    unless(boundp('tbx_genmask_global) 
	iliDefstruct('defstruct(tbx_genmask_global_struct formid licCheck)) 
	defvar(tbx_genmask_global nil)
    ) 
    if(!tbx_genmask_global then 
	(tbx_genmask_global = (make_tbx_genmask_global_struct ?formid nil ?licCheck nil)) else 
	(tbx_genmask_global->formid = nil)
	(tbx_genmask_global->licCheck = nil)
    )
)
procedure(TBX_GENMASK_Init_Layers(layer_list) 
    let((param) 
	foreach(lyr layer_list 
	    unless((axlIsLayer lyr) 
		(axlLayerCreateNonConductor lyr) 
		if(rexMatchp("_TOP$" lyr) then 
		    (param = (axlLayerGet lyr)) 
		    (param->color = 65) 
		    (axlLayerSet param)
		    else 
		    (param = (axlLayerGet lyr)) 
		    (param->color = 81) 
		    (axlLayerSet param)
		)
	    )
	) 
	foreach(lyr layer_list 
	    (axlVisibleLayer lyr t)
	) 
	(axlDBIgnoreFixed t) 
	(axlDeleteByLayer layer_list 
	    'fixed
	)
	(axlDBIgnoreFixed nil) t
    )
)
procedure((TBX_GENMASK_Main \@optional arg) 
    let((lic_check_result FORM_FILE fid VERSION_STR FC_FEATURE
	    FC_VERSION SUB_VERSION sys_base_layers info_file port
	    ok_start_app
	) 
	(FC_FEATURE = "GENMASK") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Mask Generator %s (C)2017" FC_VERSION))
	(ok_start_app = t) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./genmask_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Mask Generator information:\n") 
		fprintf(port "===============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Mask Generator: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION) 
		(ok_start_app = nil)
	    ) 
	    (t 
		(ok_start_app = t)
	    )
	) 
	when(ok_start_app 
	    (lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
	    when(lic_check_result 
		TBX_GENMASK_Init() 
		unless(boundp('tbxGenmaskMain) 
		    defvar(tbxGenmaskMain nil)
		) 
		(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "genmask_main")) 
		(fid = (axlFormCreate 
			'tbxGenmaskMain FORM_FILE 
			'(e outer) 
			'TBX_GENMASK_Callback
			t
		    ))
		(tbx_genmask_global->formid = fid) 
		(tbx_genmask_global->licCheck = lic_check_result) 
		TBX_FORM_Init_Header(fid nil lic_check_result VERSION_STR) 
		(axlFormSetField fid "pin_source" "soldermask") 
		(axlFormSetField fid "via_source" "soldermask")
		(axlFormSetField fid "pin_oversize_value" 0.0) 
		(axlFormSetField fid "via_oversize_value" 0.0) 
		(axlFormSetField fid "side" "both") 
		(sys_base_layers = TBX_GENMASK_Get_System_Base_Layers()) 
		if(sys_base_layers then 
		    (axlFormBuildPopup fid "mfg_subclass" sys_base_layers) 
		    (axlFormSetField fid "mfg_subclass" 
			car(sys_base_layers)
		    ) else
		    (axlFormBuildPopup fid "mfg_subclass" 
			list(" ")
		    )
		)
		(axlFormDisplay fid) 
		(axlVisibleUpdate t) 
		TBX_FORM_Delete(lic_check_result FORM_FILE)
	    )
	)
    )
)
procedure(TBX_GENMASK_Oversize_Padstack(pin_oversize via_oversize pin_map via_map) 
    let((layer_map poly_list pad_source dest_layer poly_list_new
	    oversize result info_1 pin_via_cnt pv_cnt
	    last_percent cur_percent COND_TOP_LAYER COND_BOTTOM_LAYER PIN_TOP_LAYER
	    PIN_BOTTOM_LAYER VIA_TOP_LAYER VIA_BOTTOM_LAYER
	) 
	(COND_TOP_LAYER = strcat((axlMapClassName "ETCH") "/" 
		(axlConductorTopLayer)
	    )) 
	(COND_BOTTOM_LAYER = strcat((axlMapClassName "ETCH") "/" 
		(axlConductorBottomLayer)
	    )) 
	(PIN_TOP_LAYER = strcat((axlMapClassName "PIN") "/" 
		(axlConductorTopLayer)
	    )) 
	(PIN_BOTTOM_LAYER = strcat((axlMapClassName "PIN") "/" 
		(axlConductorBottomLayer)
	    ))
	(VIA_TOP_LAYER = strcat((axlMapClassName "VIA CLASS") "/" 
		(axlConductorTopLayer)
	    )) 
	(VIA_BOTTOM_LAYER = strcat((axlMapClassName "VIA CLASS") "/" 
		(axlConductorBottomLayer)
	    )) 
	(axlVisibleDesign nil) 
	(axlVisibleLayer PIN_TOP_LAYER t) 
	(axlVisibleLayer PIN_BOTTOM_LAYER t)
	(axlVisibleLayer VIA_TOP_LAYER t) 
	(axlVisibleLayer VIA_BOTTOM_LAYER t) 
	(axlVisibleUpdate nil) 
	(axlSetFindFilter ?enabled 
	    list("noall" "pins" "vias" "fingers") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet)
	(axlAddSelectAll) 
	(pin_via_cnt = length((axlGetSelSet))) 
	(info_1 = sprintf(nil "")) 
	(axlMeterCreate "Generate Mask" info_1 t nil) 
	(pv_cnt = 0)
	(last_percent = 0) 
	foreach(pstack 
	    (axlGetSelSet) 
	    ++pv_cnt 
	    case((pstack->objType) 
		("pin" 
		    (layer_map = pin_map) 
		    (oversize = pin_oversize)
		) 
		("via" 
		    (layer_map = via_map) 
		    (oversize = via_oversize)
		)
	    ) 
	    foreach(entry layer_map 
		(poly_list = list()) 
		(pad_source = car(entry)) 
		(dest_layer = cadr(entry))
		if(((pad_source == "DRILL_TOP") || (pad_source == "DRILL_BOTTOM")) then 
		    case(pad_source 
			("DRILL_TOP" 
			    when(exists(x 
				    (pstack->startEnd) 
				    (x == COND_TOP_LAYER)
				) 
				(poly_list = TBX_DBCORE_Poly_From_Drill(pstack))
			    )
			) 
			("DRILL_BOTTOM" 
			    when(exists(x 
				    (pstack->startEnd) 
				    (x == COND_BOTTOM_LAYER)
				) 
				(poly_list = TBX_DBCORE_Poly_From_Drill(pstack))
			    )
			)
		    ) else 
		    (poly_list = (axlPolyFromDB pstack ?layer pad_source ?padType
			    'REGULAR
			))
		) 
		if((poly_list && (oversize != 0.0)) then 
		    (poly_list_new = (axlPolyExpand poly_list oversize 
			    'NONE
			)) else 
		    (poly_list_new = poly_list)
		) 
		foreach(p poly_list_new 
		    (result = (axlDBCreateShape p t dest_layer nil
			    nil
			)) 
		    when(result 
			(axlDBAddProp 
			    car(result) 
			    list("FIXED" t)
			)
		    )
		)
	    )
	    (cur_percent = ((100 * pv_cnt) / pin_via_cnt)) 
	    when((cur_percent != last_percent) 
		(info_1 = sprintf(nil "Completed: %d%% (%d of %d)" cur_percent pv_cnt pin_via_cnt)) 
		(axlMeterUpdate cur_percent info_1) 
		(last_percent = cur_percent)
	    )
	) 
	(axlMeterDestroy) 
	(axlClearSelSet) t
    )
)
procedure(TBX_GEOM_Add_Offset(lo_arg offset) 
    let((return_data) 
	cond(((isBoxp lo_arg) 
		(return_data = (bBoxAdd lo_arg 
			list(offset offset)
		    ))
	    ) 
	    (((length(lo_arg) == 2) && atom(car(lo_arg)) && atom(cadr(lo_arg))) 
		(return_data = ((car(lo_arg) + car(offset)):(cadr(lo_arg) + cadr(offset))))
	    ) 
	    (t 
		(return_data = tconc(nil nil)) 
		foreach(arg lo_arg 
		    cond(((isBoxp arg) 
			    tconc(return_data 
				(bBoxAdd arg 
				    list(offset offset)
				)
			    )
			) 
			((atom(car(arg)) && atom(cadr(arg))) 
			    tconc(return_data 
				((car(arg) + car(offset)):(cadr(arg) + cadr(offset)))
			    )
			)
		    )
		) 
		(return_data = cdar(return_data))
	    )
	) return_data
    )
)
procedure(TBX_GEOM_Closest_Point_on_Seg(pt seg snap_to_start_end) 
    let((pi ref_angle result tmp_x tmp_y
	    tmp_seg pt_closest distance_list box_ll box_ur
	) 
	(pi = (defMathConstants('mymathconst)->PI)) 
	case((seg->objType) 
	    ("line" 
		(ref_angle = TBX_GEOM_Get_Vector_Angle(car((seg->startEnd)) 
			cadr((seg->startEnd))
		    )) 
		(ref_angle = (ref_angle + 90.0)) 
		(tmp_x = (car(pt) + (cos(((ref_angle / 360.0) * 2 * pi)) * (axlMKSConvert "1.0 MM" 
				car((axlDBGetDesignUnits))
			    )))) 
		(tmp_y = (cadr(pt) + (sin(((ref_angle / 360.0) * 2 * pi)) * (axlMKSConvert "1.0 MM" 
				car((axlDBGetDesignUnits))
			    ))))
		(tmp_seg = list(nil 
			'objType "line" 
			'startEnd 
			list(pt 
			    (tmp_x:tmp_y)
			)
			'width 0.0
		    ))
	    ) 
	    ("arc" 
		(tmp_seg = list(nil 
			'objType "line" 
			'startEnd 
			list((seg->xy) pt)
			'width 0.0
		    ))
	    )
	) 
	when(tmp_seg 
	    (result = TBX_GEOM_Get_Intersection(tmp_seg seg nil t)) 
	    foreach(isec result 
		(distance_list = cons(list((axlDistance pt isec) isec) distance_list))
	    ) 
	    (distance_list = sortcar(distance_list 
		    'lessp
		)) 
	    (pt_closest = cadar(distance_list))
	) 
	when((pt_closest && snap_to_start_end && ((seg->width) > 0.0)) 
	    foreach(xy 
		(seg->startEnd) 
		(box_ll = ((car(xy) - (seg->width)):(cadr(xy) - ((seg->width) / 2.0)))) 
		(box_ur = ((car(xy) + (seg->width)):(cadr(xy) + ((seg->width) / 2.0)))) 
		when((axlIsPointInsideBox pt_closest 
			list(box_ll box_ur)
		    ) 
		    (pt_closest = xy)
		)
	    )
	)
	pt_closest
    )
)
procedure(TBX_GEOM_Convert_Unit_String(str_value to_units) 
    let((arr new_value from_units) 
	(arr = parseString(str_value)) 
	caseq(length(arr) 
	    (1 
		if(atof(car(arr)) then 
		    (new_value = atof(car(arr))) else 
		    printf("Warning: Invalid number %L\n" str_value)
		)
	    ) 
	    (2 
		if(atof(car(arr)) then 
		    (from_units = lowerCase(cadr(arr))) 
		    if(exists(x 
			    list("mm" "cm" "um" "mils" "mil"
				"inches" "in"
			    ) 
			    (x == from_units)
			) then 
			(new_value = (axlMKSConvert str_value to_units)) else 
			printf("Warning: Invalid unit specifier %L\n" from_units)
		    ) else
		    printf("Warning: Invalid number %L\n" 
			car(arr)
		    )
		)
	    ) 
	    (t 
		printf("Warning: Invalid unit format %L\n" str_value)
	    )
	) new_value
    )
)
procedure(TBX_GEOM_Get_Arc_Angles(start_xy end_xy center_xy isClockwise force_ccw) 
    let((start_angle end_angle sector_angle tmp info) 
	(start_angle = car(TBX_GEOM_Get_Vector_Info(start_xy center_xy))) 
	(end_angle = car(TBX_GEOM_Get_Vector_Info(end_xy center_xy))) 
	if((start_angle && end_angle) then 
	    cond(((isClockwise && (start_angle < end_angle)) 
		    (start_angle = (start_angle + 360.0))
		) 
		((!isClockwise && (start_angle > end_angle)) 
		    (end_angle = (end_angle + 360.0))
		)
	    ) 
	    (sector_angle = abs((end_angle - start_angle))) 
	    when((force_ccw && isClockwise) 
		(tmp = start_angle) 
		(start_angle = end_angle) 
		(end_angle = tmp)
	    )
	    when((start_angle > 360.0) 
		(start_angle = (start_angle - 360.0))
	    ) 
	    when((end_angle > 360.0) 
		(end_angle = (end_angle - 360.0))
	    ) 
	    (info = ncons(nil)) 
	    (info->startAngle = start_angle) 
	    (info->endAngle = end_angle)
	    (info->sectorAngle = sector_angle) else 
	    (info = nil)
	) info
    )
)
procedure(TBX_GEOM_Get_Arc_Length(start_xy end_xy arc_origin arc_radius arc_cw) 
    let((pi arc_length angle_start angle_end angle_diff) 
	(pi = (defMathConstants('mymathconst)->PI)) 
	(arc_radius = arc_radius) 
	(angle_start = TBX_GEOM_Get_Vector_Angle(arc_origin start_xy)) 
	(angle_end = TBX_GEOM_Get_Vector_Angle(arc_origin end_xy))
	if(arc_cw then 
	    (angle_diff = TBX_GEOM_Get_Vector_Angle_Difference(angle_start angle_end "cw")) else 
	    (angle_diff = TBX_GEOM_Get_Vector_Angle_Difference(angle_start angle_end "ccw"))
	) 
	(arc_length = ((2.0 * pi * arc_radius * angle_diff) / 360.0)) arc_length
    )
)
procedure(TBX_GEOM_Get_Arc_Sector_Angle(start_xy end_xy arc_origin arc_cw) 
    let((angle_start angle_end angle_diff) 
	(angle_start = TBX_GEOM_Get_Vector_Angle(arc_origin start_xy)) 
	(angle_end = TBX_GEOM_Get_Vector_Angle(arc_origin end_xy)) 
	if(arc_cw then 
	    (angle_diff = TBX_GEOM_Get_Vector_Angle_Difference(angle_start angle_end "cw")) else 
	    (angle_diff = TBX_GEOM_Get_Vector_Angle_Difference(angle_start angle_end "ccw"))
	) angle_diff
    )
)
procedure(TBX_GEOM_Get_Arc_Spin_Angle(start_xy end_xy center_xy isClockwise isCircle) 
    let((start_vec end_vec diff_angle result) 
	(start_vec = TBX_MATH_Get_Vector(center_xy start_xy)) 
	(end_vec = TBX_MATH_Get_Vector(center_xy end_xy)) 
	(diff_angle = TBX_MATH_Get_Angle_Between_Vectors(start_vec end_vec)) 
	cond(((isClockwise && isCircle) 
		(result = -360.0)
	    ) 
	    ((!isClockwise && isCircle) 
		(result = 360.0)
	    ) 
	    ((isClockwise && (diff_angle > 0.0)) 
		(result = (diff_angle - 360.0))
	    ) 
	    ((!isClockwise && (diff_angle < 0.0)) 
		(result = (360.0 + diff_angle))
	    ) 
	    (t 
		(result = diff_angle)
	    )
	)
	result
    )
)
procedure(TBX_GEOM_Get_Intersection(seg1 seg2 seg1_mode seg2_mode \@optional
	(inside_extents 
	    't
	)
    ) 
    let((isec_list result ok_pt_on_seg2 ok_pt_on_seg1 ok_isec
	    debug_radius
	) 
	(isec_list = TBX_MATH_Calculate_Intersection(list(car((seg1->startEnd)) 
		    cadr((seg1->startEnd)) 
		    (seg1->xy)
		) 
		list(car((seg2->startEnd)) 
		    cadr((seg2->startEnd)) 
		    (seg2->xy)
		)
	    )) 
	when(boundp('tbxGeomIsecDebug) 
	    (debug_radius = (axlMKSConvert "0.3 MM" 
		    car((axlDBGetDesignUnits))
		)) 
	    foreach(pt isec_list 
		(axlDBCreateCircle 
		    list(pt debug_radius) 0.0 "DRAWING FORMAT/OUTLINE"
		)
	    )
	) 
	when((seg1_mode || seg2_mode) 
	    (inside_extents = t)
	) 
	when(car(isec_list) 
	    foreach(isec isec_list 
		(ok_isec = nil) 
		if(((seg2->objType) == "arc") then 
		    (ok_pt_on_seg2 = TBX_GEOM_Is_Point_on_Arc(isec 
			    car((seg2->startEnd)) 
			    cadr((seg2->startEnd)) 
			    (seg2->xy) 
			    (seg2->radius)
			    (seg2->isClockwise) 
			    (seg2->isCircle)
			)) else 
		    (ok_pt_on_seg2 = TBX_GEOM_Is_Point_on_Line(isec 
			    car((seg2->startEnd)) 
			    cadr((seg2->startEnd))
			))
		) 
		if(((seg1->objType) == "arc") then 
		    (ok_pt_on_seg1 = TBX_GEOM_Is_Point_on_Arc(isec 
			    car((seg1->startEnd)) 
			    cadr((seg1->startEnd)) 
			    (seg1->xy) 
			    (seg1->radius)
			    (seg1->isClockwise) 
			    (seg1->isCircle)
			)) else 
		    (ok_pt_on_seg1 = TBX_GEOM_Is_Point_on_Line(isec 
			    car((seg1->startEnd)) 
			    cadr((seg1->startEnd))
			))
		)
		cond(((seg2_mode && seg1_mode) 
			when((ok_pt_on_seg2 && ok_pt_on_seg1) 
			    (ok_isec = t)
			)
		    ) 
		    ((seg2_mode && !seg1_mode) 
			when(ok_pt_on_seg2 
			    (ok_isec = t)
			)
		    ) 
		    ((!seg2_mode && seg1_mode) 
			when(ok_pt_on_seg1 
			    (ok_isec = t)
			)
		    ) 
		    ((!seg2_mode && !seg1_mode) 
			(ok_isec = t)
		    )
		) 
		when(ok_isec 
		    if((!inside_extents || (inside_extents && (axlIsPointInsideBox isec 
				    ((axlGetParam "paramDesign")->bBox)
				))) then 
			(result = cons(isec result)) else t
		    )
		)
	    )
	)
	result
    )
)
procedure(TBX_GEOM_Get_Tangent_Angle(seg_info ref) 
    let((angle tangent_angle) 
	if(((seg_info->segType) == "arc") then 
	    case(ref 
		("start" 
		    (angle = car(TBX_GEOM_Get_Vector_Info((seg_info->startXY) 
				(seg_info->centerXY)
			    )
			))
		) 
		("end" 
		    (angle = car(TBX_GEOM_Get_Vector_Info((seg_info->endXY) 
				(seg_info->centerXY)
			    )
			))
		)
	    ) 
	    if((seg_info->isClockwise) then 
		(tangent_angle = (angle - 90.0)) else 
		(tangent_angle = (angle + 90.0))
	    ) 
	    cond(((tangent_angle >= 360.0) 
		    (tangent_angle = (tangent_angle - 360.0))
		) 
		((tangent_angle < 0.0) 
		    (tangent_angle = (tangent_angle + 360.0))
		)
	    )
	    else 
	    (tangent_angle = car(TBX_GEOM_Get_Vector_Info((seg_info->endXY) 
			(seg_info->startXY)
		    )
		))
	) tangent_angle
    )
)
procedure(TBX_GEOM_Get_Vector_Angle(start_xy end_xy) 
    let((vec_x vec_y angle atan_angle result
	    pi
	) 
	(pi = (defMathConstants('mymathconst)->PI)) 
	(vec_x = (car(end_xy) - car(start_xy))) 
	(vec_y = (cadr(end_xy) - cadr(start_xy))) 
	cond(((vec_x == 0.0) 
		cond(((vec_y > 0.0) 
			(angle = 90.0)
		    ) 
		    ((vec_y < 0.0) 
			(angle = 270.0)
		    ) 
		    (t 
			(angle = nil)
		    )
		)
	    ) 
	    ((vec_y == 0.0) 
		cond(((vec_x > 0.0) 
			(angle = 0.0)
		    ) 
		    ((vec_x < 0.0) 
			(angle = 180.0)
		    ) 
		    (t 
			(angle = nil)
		    )
		)
	    ) 
	    ((atan((vec_y / vec_x)) > 0.0) 
		(atan_angle = ((atan((vec_y / vec_x)) / (2 * pi)) * 360.0)) 
		if((vec_x > 0.0) then 
		    (angle = atan_angle) else 
		    (angle = (atan_angle + 180.0))
		)
	    ) 
	    ((atan((vec_y / vec_x)) < 0.0) 
		(atan_angle = ((atan((vec_y / vec_x)) / (2 * pi)) * 360.0)) 
		if((vec_x > 0.0) then 
		    (angle = (atan_angle + 360.0)) else 
		    (angle = (180.0 + atan_angle))
		)
	    ) 
	    (t 
		(angle = nil)
	    )
	)
	if(angle then 
	    (angle = atof((axlGeo2Str angle))) 
	    (angle = (angle - (fix((angle / 360.0)) * 360.0))) 
	    (result = angle)
	    else 
	    (result = nil)
	) result
    )
)
procedure(TBX_GEOM_Get_Vector_Angle_Difference(from_angle to_angle mode) 
    let((angle_diff angle_diff_cw angle_diff_ccw ret_angle) 
	when((from_angle > 180.0) 
	    (from_angle = (from_angle - 360.0))
	) 
	(angle_diff = (to_angle - from_angle)) 
	cond(((angle_diff >= 360.0) 
		(angle_diff = (angle_diff - 360.0))
	    ) 
	    ((angle_diff < 0.0) 
		(angle_diff = (360.0 + angle_diff))
	    )
	) 
	(angle_diff_ccw = angle_diff)
	(angle_diff_cw = (360.0 - angle_diff)) 
	case(mode 
	    ("ccw" 
		(ret_angle = angle_diff_ccw)
	    ) 
	    ("cw" 
		(ret_angle = angle_diff_cw)
	    ) 
	    ("min" 
		(ret_angle = min(angle_diff_ccw angle_diff_cw))
	    )
	) ret_angle
    )
)
procedure(TBX_GEOM_Get_Vector_Info(xy ref) 
    let((vec_x vec_y angle atan_angle vec_len
	    center_x center_y result pi
	) 
	(pi = (defMathConstants('mymathconst)->PI)) 
	(vec_x = (car(xy) - car(ref))) 
	(vec_y = (cadr(xy) - cadr(ref))) 
	cond(((vec_x == 0.0) 
		cond(((vec_y > 0.0) 
			(angle = 90.0)
		    ) 
		    ((vec_y < 0.0) 
			(angle = 270.0)
		    ) 
		    (t 
			(angle = nil)
		    )
		)
	    ) 
	    ((vec_y == 0.0) 
		cond(((vec_x > 0.0) 
			(angle = 0.0)
		    ) 
		    ((vec_x < 0.0) 
			(angle = 180.0)
		    ) 
		    (t 
			(angle = nil)
		    )
		)
	    ) 
	    ((atan((vec_y / vec_x)) > 0.0) 
		(atan_angle = ((atan((vec_y / vec_x)) / (2 * pi)) * 360.0)) 
		if((vec_x > 0.0) then 
		    (angle = atan_angle) else 
		    (angle = (atan_angle + 180.0))
		)
	    ) 
	    ((atan((vec_y / vec_x)) < 0.0) 
		(atan_angle = ((atan((vec_y / vec_x)) / (2 * pi)) * 360.0)) 
		if((vec_x > 0.0) then 
		    (angle = (atan_angle + 360.0)) else 
		    (angle = (180.0 + atan_angle))
		)
	    ) 
	    (t 
		(angle = nil)
	    )
	)
	if(angle then 
	    (angle = atof((axlGeo2Str angle))) 
	    (angle = (angle - (fix((angle / 360.0)) * 360.0))) 
	    (vec_len = (axlMPythag 
		    (0:0) 
		    (vec_x:vec_y)
		))
	    (center_x = ((cos(((angle / 360.0) * 2 * pi)) * vec_len) / 2.0)) 
	    (center_y = ((sin(((angle / 360.0) * 2 * pi)) * vec_len) / 2.0)) 
	    (result = list(angle 
		    (center_x:center_y) vec_len
		)) else 
	    (result = list(nil nil nil))
	) result
    )
)
procedure(TBX_GEOM_Is_Point_on_Arc(pt start_xy end_xy center_xy radius
	isClockwise isCircle
    ) 
    let((result radius_diff diff_angle_arc diff_angle_pt) 
	(radius_diff = ((axlDistance pt center_xy) - radius)) 
	(diff_angle_arc = TBX_GEOM_Get_Arc_Spin_Angle(start_xy end_xy center_xy isClockwise isCircle)) 
	(diff_angle_pt = TBX_GEOM_Get_Arc_Spin_Angle(start_xy pt center_xy isClockwise nil)) 
	(radius_diff = TBX_MATH_Round(radius_diff "reduce" 1))
	when((radius_diff == 0.0) 
	    cond((isCircle 
		    (result = t)
		) 
		((abs(diff_angle_pt) <= abs(diff_angle_arc)) 
		    (result = t)
		) 
		(t 
		    (result = nil)
		)
	    )
	) result
    )
)
procedure(TBX_GEOM_Is_Point_on_Line(pt line_start line_end) 
    let((result ref_angle pt_angle pt_length ref_length
	    line_vec pt_vec
	) 
	if((((axlGeo2Str pt) == 
		    (axlGeo2Str line_start)) || 
		((axlGeo2Str pt) == 
		    (axlGeo2Str line_end))) then 
	    (result = t) else 
	    (line_vec = TBX_MATH_Get_Vector(line_start line_end))
	    (pt_vec = TBX_MATH_Get_Vector(line_start pt)) 
	    (ref_angle = TBX_MATH_Get_Vector_Angle(line_vec t)) 
	    (pt_angle = TBX_MATH_Get_Vector_Angle(pt_vec t)) 
	    (ref_length = (axlDistance line_end line_start)) 
	    (pt_length = (axlDistance pt line_start))
	    (ref_angle = TBX_MATH_Round(ref_angle "absolute" 1)) 
	    (pt_angle = TBX_MATH_Round(pt_angle "absolute" 1)) 
	    if(((ref_angle == pt_angle) && (pt_length <= ref_length)) then 
		(result = t)
	    )
	) result
    )
)
procedure(TBX_GEOM_Order_Points_on_Arc(pt_list start_xy end_xy center_xy isClockwise
	include_start_end
    ) 
    let((spin_angle tmp_list order_list) 
	foreach(pt pt_list 
	    (spin_angle = TBX_GEOM_Get_Arc_Spin_Angle(start_xy pt center_xy isClockwise nil)) 
	    (tmp_list = cons(list(spin_angle pt) tmp_list))
	) 
	(tmp_list = sortcar(tmp_list 
		'lessp
	    )) 
	(order_list = mapcar(lambda((x) 
		    cadr(x)
		) tmp_list
	    )) 
	when(isClockwise 
	    (order_list = reverse(order_list))
	)
	when(include_start_end 
	    (order_list = cons(start_xy order_list)) 
	    (order_list = append1(order_list end_xy))
	) order_list
    )
)
procedure(TBX_GEOM_Order_Points_on_Line(pt_list start_xy end_xy include_start_end) 
    let((tmp_list order_list) 
	foreach(pt pt_list 
	    (tmp_list = cons(list((axlDistance pt start_xy) pt) tmp_list))
	) 
	(tmp_list = sortcar(tmp_list 
		'lessp
	    )) 
	(order_list = mapcar(lambda((x) 
		    cadr(x)
		) tmp_list
	    )) 
	when(include_start_end 
	    (order_list = cons(start_xy order_list)) 
	    (order_list = append1(order_list end_xy))
	)
	order_list
    )
)
procedure(TBX_GEOM_Point_On_Grid(cur_xy grid_name) 
    let((grid_info cur_x_g cur_y_g cur_x cur_y
	    result
	) 
	(grid_info = (axlDBGridGet grid_name)) 
	(cur_x = (car(cur_xy) - (grid_info->xOrigin))) 
	(cur_y = (cadr(cur_xy) - (grid_info->yOrigin))) 
	(cur_x_g = ((round((cur_x / (grid_info->xMajor))) * (grid_info->xMajor)) + (grid_info->xOrigin)))
	(cur_y_g = ((round((cur_y / (grid_info->yMajor))) * (grid_info->yMajor)) + (grid_info->yOrigin))) 
	if((((axlGeo2Str cur_x) == 
		    (axlGeo2Str cur_x_g)) && 
		((axlGeo2Str cur_y) == 
		    (axlGeo2Str cur_y_g))) then 
	    (result = list(t 
		    (0.0:0.0)
		)) else 
	    (result = list(nil 
		    ((cur_x - cur_x_g):(cur_y - cur_y_g))
		))
	) result
    )
)
procedure(TBX_GEOM_Point_On_Segment(pt seg_info isec_safe_mode) 
    let((add_info point_on_seg) 
	if(((seg_info->segType) == "arc") then 
	    when((!(seg_info->startAngle) || !(seg_info->endAngle) || !(seg_info->sectorAngle)) 
		(seg_info = copy(seg_info)) 
		(add_info = TBX_GEOM_Get_Arc_Angles((seg_info->startXY) 
			(seg_info->endXY) 
			(seg_info->centerXY) 
			(seg_info->isClockwise) nil
		    )) 
		(seg_info->startAngle = (add_info->startAngle)) 
		(seg_info->endAngle = (add_info->endAngle))
		(seg_info->sectorAngle = (add_info->sectorAngle))
	    ) 
	    (point_on_seg = TBX_GEOM_Point_on_Arc(pt seg_info isec_safe_mode)) else
	    (point_on_seg = TBX_GEOM_Point_on_Line(pt 
		    list((seg_info->startXY) 
			(seg_info->endXY)
		    ) isec_safe_mode
		))
	) point_on_seg
    )
)
procedure(TBX_GEOM_Point_To_Grid(cur_xy grid_name) 
    let((grid_info cur_x_g cur_y_g cur_x cur_y
	    result
	) 
	(grid_info = (axlDBGridGet grid_name)) 
	(cur_x = (car(cur_xy) - (grid_info->xOrigin))) 
	(cur_y = (cadr(cur_xy) - (grid_info->yOrigin))) 
	(cur_x_g = ((round((cur_x / (grid_info->xMajor))) * (grid_info->xMajor)) + (grid_info->xOrigin)))
	(cur_y_g = ((round((cur_y / (grid_info->yMajor))) * (grid_info->yMajor)) + (grid_info->yOrigin))) 
	(result = (cur_x_g:cur_y_g)) result
    )
)
procedure(TBX_GEOM_Point_on_Arc(pt arc_info isec_safe_mode) 
    let((pt_angle pt_angle_alias start_angle end_angle result
	    angle_range continue
	) 
	(continue = t) 
	when((!isec_safe_mode && ((axlGeo2Str 
			(axlDistance pt 
			    (arc_info->centerXY)
			)
		    ) != (axlGeo2Str 
			(arc_info->radius)
		    ))) 
	    (continue = nil)
	) 
	when(continue 
	    (pt_angle = car(TBX_GEOM_Get_Vector_Info(pt 
			(arc_info->centerXY)
		    )
		)) 
	    (pt_angle_alias = (pt_angle + 360.0)) 
	    (start_angle = (arc_info->startAngle)) 
	    (end_angle = (arc_info->endAngle))
	    if((arc_info->isCircle) then 
		(angle_range = list(0.0 360.0)) else 
		if((arc_info->isClockwise) then 
		    when((start_angle < end_angle) 
			(start_angle = (start_angle + 360.0))
		    ) 
		    (angle_range = list(end_angle start_angle)) else
		    when((start_angle > end_angle) 
			(end_angle = (end_angle + 360.0))
		    ) 
		    (angle_range = list(start_angle end_angle))
		)
	    ) 
	    when(((car(angle_range) <= pt_angle) && (pt_angle <= cadr(angle_range))) 
		(result = t)
	    ) 
	    when(((car(angle_range) <= pt_angle_alias) && (pt_angle_alias <= cadr(angle_range))) 
		(result = t)
	    )
	) result
    )
)
procedure(TBX_GEOM_Point_on_Line(pt start_end isec_safe_mode) 
    let((angle1 angle2 result diff) 
	if((((axlGeo2Str pt) == 
		    (axlGeo2Str 
			car(start_end)
		    )) || ((axlGeo2Str pt) == 
		    (axlGeo2Str 
			cadr(start_end)
		    ))) then 
	    (result = t) else 
	    (angle1 = car(TBX_GEOM_Get_Vector_Info(pt 
			car(start_end)
		    )
		))
	    (angle2 = car(TBX_GEOM_Get_Vector_Info(pt 
			cadr(start_end)
		    )
		)) 
	    (diff = abs((angle1 - angle2))) 
	    if(isec_safe_mode then 
		when((atof((axlGeo2Str diff)) > 90.0) 
		    (result = t)
		) else 
		when((atof((axlGeo2Str diff)) == 180.0) 
		    (result = t)
		)
	    )
	) result
    )
)
procedure((TBX_GEOM_Round data \@optional mode acc) 
    let((design_accuracy new_accuracy factor return_data rval) 
	(design_accuracy = cadr((axlDBGetDesignUnits))) 
	(new_accuracy = design_accuracy) 
	when((mode && acc) 
	    case(mode 
		("absolute" 
		    (new_accuracy = acc)
		) 
		("reduce" 
		    (new_accuracy = (design_accuracy - acc)) 
		    when((new_accuracy < 0) 
			(new_accuracy = 0)
		    )
		) 
		(t 
		    printf("Warning: Unknown rounding mode %L\n" mode) 
		    (new_accuracy = design_accuracy)
		)
	    )
	) 
	(factor = ((10**new_accuracy) * 1.0))
	cond(((eq(type(data) 
			'flonum
		    ) || eq(type(data) 
			'fixnum
		    )) 
		(rval = data) 
		(rval = (rval * factor)) 
		(rval = round(rval)) 
		(rval = (rval / factor))
		(return_data = rval)
	    ) 
	    (eq(type(data) 
		    'list
		) 
		foreach(entry data 
		    (rval = entry) 
		    (rval = (rval * factor)) 
		    (rval = round(rval))
		    (rval = (rval / factor)) 
		    (return_data = cons(rval return_data))
		) 
		(return_data = reverse(return_data))
	    )
	) return_data
    )
)
procedure(TBX_GEOM_Sort_Intersection(isec_list seg_info ref) 
    let((tmp_list pt_angle add_info angle_diff isec_sorted
	    ref_xy
	) 
	case((seg_info->segType) 
	    ("line" 
		(ref_xy = (seg_info->startXY)) 
		when((ref == "end") 
		    (ref_xy = (seg_info->endXY))
		) 
		foreach(isec isec_list 
		    (tmp_list = cons(list((axlDistance isec ref_xy) isec) tmp_list))
		) 
		(tmp_list = sortcar(tmp_list 
			'lessp
		    ))
		foreach(entry tmp_list 
		    (isec_sorted = cons(cadr(entry) isec_sorted))
		) 
		(isec_sorted = reverse(isec_sorted))
	    ) 
	    ("arc" 
		when((!(seg_info->startAngle) || !(seg_info->endAngle) || !(seg_info->sectorAngle)) 
		    (seg_info = copy(seg_info)) 
		    (add_info = TBX_GEOM_Get_Arc_Angles((seg_info->startXY) 
			    (seg_info->endXY) 
			    (seg_info->centerXY) 
			    (seg_info->isClockwise) nil
			)) 
		    (seg_info->startAngle = (add_info->startAngle)) 
		    (seg_info->endAngle = (add_info->endAngle))
		    (seg_info->sectorAngle = (add_info->sectorAngle))
		) 
		if((seg_info->isClockwise) then 
		    foreach(isec isec_list 
			(pt_angle = car(TBX_GEOM_Get_Vector_Info(isec 
				    (seg_info->centerXY)
				)
			    )) 
			when((pt_angle > (seg_info->startAngle)) 
			    (pt_angle = (pt_angle - 360.0))
			) 
			(angle_diff = ((seg_info->startAngle) - pt_angle))
			(tmp_list = cons(list(angle_diff isec) tmp_list))
		    ) else 
		    foreach(isec isec_list 
			(pt_angle = car(TBX_GEOM_Get_Vector_Info(isec 
				    (seg_info->centerXY)
				)
			    )) 
			when((pt_angle < (seg_info->startAngle)) 
			    (pt_angle = (pt_angle + 360.0))
			) 
			(angle_diff = (pt_angle - (seg_info->startAngle)))
			(tmp_list = cons(list(angle_diff isec) tmp_list))
		    )
		) 
		(tmp_list = sortcar(tmp_list 
			'lessp
		    )) 
		foreach(entry tmp_list 
		    (isec_sorted = cons(cadr(entry) isec_sorted))
		)
		(isec_sorted = reverse(isec_sorted)) 
		when((ref == "end") 
		    (isec_sorted = reverse(isec_sorted))
		)
	    )
	) isec_sorted
    )
)
procedure((TBX_GEOM_Vectorize_Arc start_xy end_xy center_xy isClockwise
	isCircle \@optional nrSegs
    ) 
    let((diff_angle PI seg_angle start_angle pt_list
	    radius pt_x pt_y end_angle angle_rad
	    cur_angle
	) 
	(PI = (defMathConstants('mymathconst)->PI)) 
	unless(nrSegs 
	    (nrSegs = 32)
	) 
	(seg_angle = (360.0 / (nrSegs * 1.0))) 
	(start_angle = TBX_GEOM_Get_Vector_Angle(center_xy start_xy))
	(diff_angle = TBX_GEOM_Get_Arc_Spin_Angle(start_xy end_xy center_xy isClockwise isCircle)) 
	(end_angle = (start_angle + diff_angle)) 
	(pt_list = tconc(nil nil)) 
	tconc(pt_list start_xy) 
	when(isClockwise 
	    (seg_angle = (- seg_angle))
	)
	(cur_angle = (start_angle + seg_angle)) 
	(radius = (axlDistance start_xy center_xy)) 
	if(isClockwise then 
	    while((cur_angle > end_angle) 
		(angle_rad = ((cur_angle / 360.0) * 2 * PI)) 
		(pt_x = (car(center_xy) + (cos(angle_rad) * radius))) 
		(pt_y = (cadr(center_xy) + (sin(angle_rad) * radius))) 
		tconc(pt_list 
		    (pt_x:pt_y)
		)
		(cur_angle = (cur_angle + seg_angle))
	    ) else 
	    while((cur_angle < end_angle) 
		(angle_rad = ((cur_angle / 360.0) * 2 * PI)) 
		(pt_x = (car(center_xy) + (cos(angle_rad) * radius))) 
		(pt_y = (cadr(center_xy) + (sin(angle_rad) * radius))) 
		tconc(pt_list 
		    (pt_x:pt_y)
		)
		(cur_angle = (cur_angle + seg_angle))
	    )
	) 
	tconc(pt_list end_xy) 
	(pt_list = cdar(pt_list))
	pt_list
    )
)
procedure(TBX_HELP_Get_Version() 
    let((tbx_version) 
	(tbx_version = "17.4.07  Build Date: Dec 11 2017") 
	printf("Toolbox Version: %s\n" tbx_version) tbx_version
    )
)
procedure((TBX_HELP_Launch \@optional module_name) 
    let((cmd floware_doc_path html_file) 
	if((module_name && (lowerCase(cdsPlat()) == "wint")) then 
	    if(isDir(sprintf(nil "%s/local/doc/%s" 
			axlGetVariable("allegro_install_root") module_name
		    )
		) then 
		(cmd = sprintf(nil "cdnshelp FloWare %s" module_name)) 
		(axlShell cmd) else
		(floware_doc_path = strcat(axlGetVariable("allegro_install_root") "/share/pcb/toolbox/help")) 
		(floware_doc_path = (axlOSSlash floware_doc_path)) 
		(cmd = sprintf(nil "acroread %s/%s.pdf" floware_doc_path module_name)) 
		(axlShell cmd)
	    ) else 
	    (html_file = sprintf(nil "file:///%s/share/pcb/toolbox/help/tbx.htm" 
		    axlGetVariable("allegro_install_root")
		))
	    (cmd = sprintf(nil "http %s" html_file)) 
	    (axlShell cmd)
	)
    )
)
procedure(TBX_LABELTUNE_Cache_Param(form_handle) 
    let((rec session_param unit_str) 
	(rec = "labeltune") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	(unit_str = TBX_UTIL_Get_Short_Units())
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "label_name") 
	    'labelName
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "label_layer") 
	    'labelLayer
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "outline_layer") 
	    'outlineLayer
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "mirror_bottom") 
	    'mirrorBottom
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "rotate_text") 
	    'rotateText
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "center_text") 
	    'centerText
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "fit_text") 
	    'fitText
	) 
	putprop(session_param[rec] 
	    sprintf(nil "%.4f %s" 
		(axlFormGetField form_handle "offset_x") unit_str
	    ) 
	    'offsetX
	) 
	putprop(session_param[rec] 
	    sprintf(nil "%.4f %s" 
		(axlFormGetField form_handle "offset_y") unit_str
	    ) 
	    'offsetY
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "text_match_minmax_height") 
	    'textMatchMinMaxHeight
	)
	putprop(session_param[rec] 
	    sprintf(nil "%.4f %s" 
		(axlFormGetField form_handle "min_height") unit_str
	    ) 
	    'minHeight
	) 
	putprop(session_param[rec] 
	    sprintf(nil "%.4f %s" 
		(axlFormGetField form_handle "max_height") unit_str
	    ) 
	    'maxHeight
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "text_match_block_range") 
	    'textMatchBlockRange
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "block_range") 
	    'blockRange
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "spin_long_side") 
	    'spinLongSide
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "spin_absolute") 
	    'spinAbsolute
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "spin_relative") 
	    'spinRelative
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "deg_top_horizontal") 
	    'degTopHorizontal
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "deg_top_vertical") 
	    'degTopVertical
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "deg_bottom_horizontal") 
	    'degBottomHorizontal
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "deg_bottom_vertical") 
	    'degBottomVertical
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "deg_absolute") 
	    'degAbsolute
	) 
	putprop(session_param[rec] 
	    sprintf(nil "%.4f %s" 
		(axlFormGetField form_handle "offset_correction") unit_str
	    ) 
	    'offsetCorrection
	) 
	putprop(session_param[rec] 
	    sprintf(nil "%.4f %s" 
		(axlFormGetField form_handle "boundary_clearance") unit_str
	    ) 
	    'boundaryClearance
	) t
    )
)
procedure(TBX_LABELTUNE_Calculate_Text_Block(sym_inst_data sym_def_data text_value text_rotation text_rotation_def) 
    let((sym_box_corners sym_box_center text_xy text_block block_nr
	    block_height block_width block_space loop char_cnt
	    text_width text_height boundary_clearance max_text_width max_text_height
	    sym_box_width sym_box_height cnt fit_cnt block_info
	) 
	(sym_box_center = car(sym_inst_data)) 
	cond((((axlFormGetField 
			(tbx_labeltune_data->formid) "spin_long_side"
		    ) || (axlFormGetField 
			(tbx_labeltune_data->formid) "spin_absolute"
		    )) 
		(sym_box_corners = cadr(sym_inst_data)) 
		(sym_box_width = abs((car((upperRight sym_box_corners)) - 
			    car((lowerLeft sym_box_corners)))
		    )) 
		(sym_box_height = abs((cadr((upperRight sym_box_corners)) - 
			    cadr((lowerLeft sym_box_corners)))
		    )) 
		if((zerop(round(text_rotation)) || (round(text_rotation) == 180)) then 
		    (max_text_width = sym_box_width) 
		    (max_text_height = sym_box_height) else
		    (max_text_width = sym_box_height) 
		    (max_text_height = sym_box_width)
		)
	    ) 
	    ((axlFormGetField 
		    (tbx_labeltune_data->formid) "spin_relative"
		) 
		(sym_box_corners = cadr(sym_def_data)) 
		(sym_box_width = abs((car((upperRight sym_box_corners)) - 
			    car((lowerLeft sym_box_corners)))
		    )) 
		(sym_box_height = abs((cadr((upperRight sym_box_corners)) - 
			    cadr((lowerLeft sym_box_corners)))
		    )) 
		cond((((text_rotation_def >= 0.0) && (text_rotation_def <= 45.0)) 
			(max_text_width = sym_box_width) 
			(max_text_height = sym_box_height)
		    ) 
		    (((text_rotation_def > 45.0) && (text_rotation_def < 135.0)) 
			(max_text_width = sym_box_height) 
			(max_text_height = sym_box_width)
		    ) 
		    (((text_rotation_def >= 135.0) && (text_rotation_def <= 225.0)) 
			(max_text_width = sym_box_width) 
			(max_text_height = sym_box_height)
		    ) 
		    (((text_rotation_def > 225.0) && (text_rotation_def < 315.0)) 
			(max_text_width = sym_box_height) 
			(max_text_height = sym_box_width)
		    ) 
		    (((text_rotation_def >= 315.0) && (text_rotation_def <= 360.0)) 
			(max_text_width = sym_box_width) 
			(max_text_height = sym_box_height)
		    )
		)
	    ) 
	    (t t)
	) 
	(block_info = listToVector((tbx_labeltune_data->blockInfo))) 
	(cnt = 0)
	(loop = t) 
	while(loop 
	    if(((cnt < length(block_info)) && block_info[cnt]) then 
		(block_height = cadr(block_info[cnt])) 
		(block_width = caddr(block_info[cnt])) 
		(block_space = nth(3 
			block_info[cnt]
		    ))
		(char_cnt = strlen(text_value)) 
		(text_width = ((char_cnt * block_width) + ((char_cnt - 1) * block_space))) 
		(text_height = block_height) 
		(boundary_clearance = (axlFormGetField 
			(tbx_labeltune_data->formid) "boundary_clearance"
		    )) 
		when((boundary_clearance > 0.0) 
		    (text_width = (text_width + (2 * boundary_clearance))) 
		    (text_height = (text_height + (2 * boundary_clearance)))
		)
		if(((text_width > max_text_width) || (text_height > max_text_height)) then 
		    (loop = nil) else 
		    (fit_cnt = cnt)
		    ++cnt
		) else 
		(loop = nil)
	    )
	) 
	if(fit_cnt then 
	    (block_nr = car(block_info[fit_cnt])) else 
	    (block_nr = car(block_info[0]))
	    (block_height = cadr(block_info[0])) 
	    printf("Warning: Cannot fit text within component %s, using minimum block %d with height %.4f\n" text_value block_nr block_height)
	) 
	(text_block = sprintf(nil "%d" block_nr)) 
	(text_xy = TBX_LABELTUNE_Offset_Correction(sym_box_center text_block text_rotation))
	list(text_xy text_block)
    )
)
procedure(TBX_LABELTUNE_Calculate_Text_Rotation(sym_inst_data sym_def_data text_inst_dbid text_def_dbid) 
    let((text_rotation text_rotation_def rotation_top_h rotation_top_v rotation_bot_h
	    rotation_bot_v total_rotation rotation_mode odd_angle sym_box_width
	    sym_box_height factor sym_inst_corners sym_inst_rotation sym_inst_mirror
	    rotation_force
	) 
	(text_inst_dbid = text_inst_dbid) 
	(sym_def_data = sym_def_data) 
	(rotation_top_h = atof((axlFormGetField 
		    (tbx_labeltune_data->formid) "deg_top_horizontal"
		)
	    )) 
	(rotation_top_v = atof((axlFormGetField 
		    (tbx_labeltune_data->formid) "deg_top_vertical"
		)
	    ))
	(rotation_bot_h = atof((axlFormGetField 
		    (tbx_labeltune_data->formid) "deg_bottom_horizontal"
		)
	    )) 
	(rotation_bot_v = atof((axlFormGetField 
		    (tbx_labeltune_data->formid) "deg_bottom_vertical"
		)
	    )) 
	(rotation_force = atof((axlFormGetField 
		    (tbx_labeltune_data->formid) "deg_absolute"
		)
	    )) 
	cond(((axlFormGetField 
		    (tbx_labeltune_data->formid) "spin_long_side"
		) 
		(rotation_mode = "long_side")
	    ) 
	    ((axlFormGetField 
		    (tbx_labeltune_data->formid) "spin_relative"
		) 
		(rotation_mode = "label_angle")
	    ) 
	    ((axlFormGetField 
		    (tbx_labeltune_data->formid) "spin_absolute"
		) 
		(rotation_mode = "deg_absolute")
	    )
	) 
	(sym_inst_corners = cadr(sym_inst_data))
	(sym_inst_rotation = caddr(sym_inst_data)) 
	(sym_inst_mirror = nth(3 sym_inst_data)) 
	unless(((sym_inst_rotation == 0.0) || (sym_inst_rotation == 90.0) || (sym_inst_rotation == 180.0) || (sym_inst_rotation == 270.0)) 
	    (odd_angle = t)
	) 
	(odd_angle = odd_angle) 
	case(rotation_mode 
	    ("long_side" 
		(sym_box_height = abs((cadr((upperRight sym_inst_corners)) - 
			    cadr((lowerLeft sym_inst_corners)))
		    )) 
		(sym_box_width = abs((car((upperRight sym_inst_corners)) - 
			    car((lowerLeft sym_inst_corners)))
		    )) 
		(factor = cadr((axlDBGetDesignUnits))) 
		(sym_box_width = (sym_box_width + (1.0 / (10.0**factor))))
		if(((sym_box_height - sym_box_width) > 0.0) then 
		    if(sym_inst_mirror then 
			(text_rotation = rotation_bot_v) else 
			(text_rotation = rotation_top_v)
		    ) else 
		    if(sym_inst_mirror then 
			(text_rotation = rotation_bot_h) else 
			(text_rotation = rotation_top_h)
		    )
		)
	    ) 
	    ("label_angle" 
		(text_rotation_def = (text_def_dbid->rotation)) 
		(total_rotation = (sym_inst_rotation + text_rotation_def)) 
		(total_rotation = (total_rotation * 10.0)) 
		(total_rotation = round(total_rotation))
		(total_rotation = (total_rotation / 10.0)) 
		when((total_rotation >= 360.0) 
		    (total_rotation = (total_rotation - 360.0))
		) 
		if((sym_inst_mirror && (axlFormGetField 
			    (tbx_labeltune_data->formid) "mirror_bottom"
			)) then 
		    cond((((total_rotation >= 0.0) && (total_rotation <= 45.0)) 
			    (text_rotation = total_rotation)
			) 
			(((total_rotation > 45.0) && (total_rotation <= 225.0)) 
			    (text_rotation = (total_rotation + 180.0)) 
			    when((text_rotation >= 360.0) 
				(text_rotation = (text_rotation - 360.0))
			    )
			) 
			(((total_rotation > 225.0) && (total_rotation <= 360.0)) 
			    (text_rotation = total_rotation)
			)
		    ) else 
		    cond((((total_rotation >= 0.0) && (total_rotation < 135.0)) 
			    (text_rotation = total_rotation)
			) 
			(((total_rotation >= 135.0) && (total_rotation < 315.0)) 
			    (text_rotation = (total_rotation + 180.0)) 
			    when((text_rotation >= 360.0) 
				(text_rotation = (text_rotation - 360.0))
			    )
			) 
			(((total_rotation >= 315.0) && (total_rotation <= 360.0)) 
			    (text_rotation = total_rotation)
			)
		    )
		)
	    ) 
	    ("deg_absolute" 
		(text_rotation = rotation_force)
	    )
	)
	text_rotation
    )
)
procedure(TBX_LABELTUNE_Callback(form_handle) 
    let((max_val min_val label_name msg) 
	case((form_handle->curField) 
	    ("done" 
		(axlFinishEnterFun)
	    ) 
	    ("cancel" 
		(axlCancelEnterFun)
	    ) 
	    ("label_name" 
		(label_name = (form_handle->curValue)) 
		(axlFormBuildPopup form_handle "label_layer" 
		    (tbx_labeltune_data->popupInfo)[label_name]
		) 
		(axlFormSetField form_handle "label_layer" 
		    cadar((tbx_labeltune_data->popupInfo)[label_name])
		)
	    ) 
	    ("limit_layers" 
		TBX_LABELTUNE_Limit_Layer_Visibility(form_handle)
	    )
	    ("toggle_top" 
		TBX_LABELTUNE_Display_Toggle(form_handle "top")
	    ) 
	    ("toggle_bottom" 
		TBX_LABELTUNE_Display_Toggle(form_handle "bottom")
	    ) 
	    ("text_match_minmax_height" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "min_height" t) 
		    (axlFormSetFieldEditable form_handle "max_height" t) 
		    (axlFormSetFieldEditable form_handle "block_range" nil)
		    else 
		    (axlFormSetFieldEditable form_handle "min_height" nil) 
		    (axlFormSetFieldEditable form_handle "max_height" nil) 
		    (axlFormSetFieldEditable form_handle "block_range" t)
		) 
		(tbx_labeltune_data->blockInfo = TBX_LABELTUNE_Get_Block_Info(form_handle))
	    ) 
	    ("min_height" 
		when(((form_handle->curValue) > (axlFormGetField form_handle "max_height")) 
		    (axlUIWPrint form_handle "Error: Min height must not be greater than max height!") 
		    (max_val = (axlFormGetField form_handle "max_height")) 
		    (axlFormSetField form_handle "min_height" max_val)
		) 
		(tbx_labeltune_data->blockInfo = TBX_LABELTUNE_Get_Block_Info(form_handle))
	    ) 
	    ("max_height" 
		when(((form_handle->curValue) < (axlFormGetField form_handle "min_height")) 
		    (axlUIWPrint form_handle "Error: Max height  must not be smaller than min height!") 
		    (min_val = (axlFormGetField form_handle "min_height")) 
		    (axlFormSetField form_handle "max_height" min_val)
		) 
		(tbx_labeltune_data->blockInfo = TBX_LABELTUNE_Get_Block_Info(form_handle))
	    )
	    ("text_match_block_range" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "min_height" nil) 
		    (axlFormSetFieldEditable form_handle "max_height" nil) 
		    (axlFormSetFieldEditable form_handle "block_range" t)
		    else 
		    (axlFormSetFieldEditable form_handle "min_height" t) 
		    (axlFormSetFieldEditable form_handle "max_height" t) 
		    (axlFormSetFieldEditable form_handle "block_range" nil)
		) 
		(tbx_labeltune_data->blockInfo = TBX_LABELTUNE_Get_Block_Info(form_handle))
	    ) 
	    ("user_info" 
		(msg = "") 
		(msg = strcat(msg "Use white space to separate individual blocks from each other.\n")) 
		(msg = strcat(msg "Use dash to specify a block range.\n")) 
		(msg = strcat(msg "Blocks can be specified in arbitrary order.\n"))
		(msg = strcat(msg "\n")) 
		(msg = strcat(msg "Example: \"1 2 3 4-10 15 30-35\"")) 
		(msg = sprintf(nil "%s\n\nNote: Max block number found in design is %d" msg 
			((tbx_labeltune_data->textInfo)->maxBlock)
		    )) 
		(axlUIConfirm msg)
	    ) 
	    ("block_range" 
		(tbx_labeltune_data->blockInfo = TBX_LABELTUNE_Get_Block_Info(form_handle))
	    ) 
	    ("rotate_text" 
		unless((axlFormGetField form_handle "rotate_text") 
		    (axlFormSetField form_handle "fit_text" nil)
		)
	    ) 
	    ("center_text" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "offset_x" t) 
		    (axlFormSetFieldEditable form_handle "offset_y" t) else
		    (axlFormSetField form_handle "fit_text" nil) 
		    (axlFormSetFieldEditable form_handle "offset_x" nil) 
		    (axlFormSetFieldEditable form_handle "offset_y" nil)
		)
	    )
	    ("fit_text" 
		if((axlFormGetField form_handle "fit_text") then 
		    (axlFormSetField form_handle "rotate_text" t) 
		    (axlFormSetField form_handle "center_text" t) 
		    (axlFormSetFieldEditable form_handle "offset_x" t)
		    (axlFormSetFieldEditable form_handle "offset_y" t) else t
		)
	    ) 
	    ("mirror_bottom" 
		if((form_handle->curValue) then 
		    (axlFormSetField form_handle "deg_bottom_horizontal" 0.0) 
		    (axlFormSetField form_handle "deg_bottom_vertical" 270.0) else
		    (axlFormSetField form_handle "deg_bottom_horizontal" 0.0) 
		    (axlFormSetField form_handle "deg_bottom_vertical" 90.0)
		)
	    ) 
	    ("spin_long_side" 
		(axlFormSetFieldEditable form_handle "deg_top_horizontal" t) 
		(axlFormSetFieldEditable form_handle "deg_top_vertical" t) 
		(axlFormSetFieldEditable form_handle "deg_bottom_horizontal" t) 
		(axlFormSetFieldEditable form_handle "deg_bottom_vertical" t)
		(axlFormSetFieldEditable form_handle "deg_absolute" nil)
	    ) 
	    ("spin_absolute" 
		(axlFormSetFieldEditable form_handle "deg_top_horizontal" nil) 
		(axlFormSetFieldEditable form_handle "deg_top_vertical" nil) 
		(axlFormSetFieldEditable form_handle "deg_bottom_horizontal" nil) 
		(axlFormSetFieldEditable form_handle "deg_bottom_vertical" nil)
		(axlFormSetFieldEditable form_handle "deg_absolute" t)
	    ) 
	    ("spin_relative" 
		(axlFormSetFieldEditable form_handle "deg_top_horizontal" nil) 
		(axlFormSetFieldEditable form_handle "deg_top_vertical" nil) 
		(axlFormSetFieldEditable form_handle "deg_bottom_horizontal" nil) 
		(axlFormSetFieldEditable form_handle "deg_bottom_vertical" nil)
		(axlFormSetFieldEditable form_handle "deg_absolute" nil)
	    )
	    ("myhelp" 
		TBX_HELP_Launch("labeltune")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_LABELTUNE_Display_Toggle(form_handle side) 
    let((text_layer_top text_layer_bottom comp_outline_layer_top comp_outline_layer_bottom layer_list) 
	(text_layer_top = strcat((axlFormGetField form_handle "label_layer") "TOP")) 
	(text_layer_bottom = strcat((axlFormGetField form_handle "label_layer") "BOTTOM")) 
	(comp_outline_layer_top = strcat((axlFormGetField form_handle "outline_layer") "TOP")) 
	(comp_outline_layer_bottom = strcat((axlFormGetField form_handle "outline_layer") "BOTTOM"))
	case(side 
	    ("top" 
		(layer_list = list(text_layer_top comp_outline_layer_top))
	    ) 
	    ("bottom" 
		(layer_list = list(text_layer_bottom comp_outline_layer_bottom))
	    ) 
	    (t 
		printf("Invalid value, nothing to toggle\n")
	    )
	) 
	foreach(lyr layer_list 
	    if((axlIsVisibleLayer lyr) then 
		(axlVisibleLayer lyr nil) else 
		(axlVisibleLayer lyr t)
	    )
	) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_LABELTUNE_Event_Loop() 
    let((eventMask loop bBox comp_list event) 
	(axlSetFindFilter ?enabled 
	    list("noall" "components") ?onButtons 
	    list("all")
	) 
	(axlEventSetStartPopup 
	    'TBX_LABELTUNE_Popup
	) 
	(eventMask = list('STARTDRAG 
		'STOPDRAG 
		'PICK
	    )) 
	(loop = t)
	(tbx_labeltune_data->mark = (axlDBTransactionStart)) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil nil)) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(STARTDRAG 
		    (axlAddSimpleRbandDynamics 
			(event->xy) "box" ?origin 
			(0.0:0.0)
		    ) 
		    (bBox = (event->xy))
		) 
		(STOPDRAG 
		    (comp_list = list()) 
		    (bBox = list(bBox 
			    (event->xy)
			)) 
		    (axlSingleSelectBox bBox) 
		    (comp_list = (axlGetSelSet))
		    when(comp_list 
			(axlDBTransactionMark 
			    (tbx_labeltune_data->mark)
			) 
			TBX_LABELTUNE_Modify_Text(comp_list)
		    ) 
		    (bBox = nil) 
		    (axlClearSelSet)
		) 
		(PICK 
		    (comp_list = list()) 
		    (bBox = nil) 
		    (axlSingleSelectPoint 
			(event->xy)
		    ) 
		    (comp_list = (axlGetSelSet))
		    when(comp_list 
			(axlDBTransactionMark 
			    (tbx_labeltune_data->mark)
			) 
			TBX_LABELTUNE_Modify_Text(comp_list)
		    ) 
		    (axlClearSelSet)
		) 
		(DONE 
		    (loop = nil) 
		    TBX_LABELTUNE_Cache_Param((tbx_labeltune_data->formid)) 
		    (axlFinishEnterFun) 
		    (axlDBTransactionCommit 
			(tbx_labeltune_data->mark)
		    )
		    (axlFormClose 
			(tbx_labeltune_data->formid)
		    ) 
		    (axlClearDynamics) 
		    (axlVisibleUpdate t)
		)
		(CANCEL 
		    (loop = nil) 
		    (axlCancelEnterFun) 
		    (axlDBTransactionOops 
			(tbx_labeltune_data->mark)
		    ) 
		    (axlDBTransactionCommit 
			(tbx_labeltune_data->mark)
		    )
		    (axlClearDynamics) 
		    (axlFormClose 
			(tbx_labeltune_data->formid)
		    ) 
		    (axlClearDynamics) 
		    (axlVisibleUpdate t)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_LABELTUNE_Get_Block_Info(form_handle) 
    let((cur_block_range cur_height cur_block range_str text_param
	    int_block_list max_height min_height arr start
	    end tmp_list full_block_range ret_data block_range_init
	) 
	(full_block_range = tconc(nil nil)) 
	(cur_block_range = tconc(nil nil)) 
	cond(((axlFormGetField form_handle "text_match_minmax_height") 
		(min_height = (axlFormGetField form_handle "min_height")) 
		(max_height = (axlFormGetField form_handle "max_height")) 
		foreach(entry 
		    (tbx_labeltune_data->textList) 
		    (cur_height = car(entry)) 
		    (cur_block = cadr(entry)) 
		    (text_param = (axlGetParam 
			    sprintf(nil "paramTextBlock:%d" cur_block)
			))
		    tconc(full_block_range 
			list(cur_block 
			    (text_param->height) 
			    (text_param->width) 
			    (text_param->charSpace)
			)
		    ) 
		    when(((min_height <= cur_height) && (cur_height <= max_height)) 
			tconc(cur_block_range 
			    list(cur_block 
				(text_param->height) 
				(text_param->width) 
				(text_param->charSpace)
			    )
			)
		    )
		) 
		(full_block_range = cdar(full_block_range))
		(cur_block_range = cdar(cur_block_range)) 
		if((length(cur_block_range) > 0) then 
		    (ret_data = cur_block_range) else 
		    printf("Warning: Invalid block min/max height settings. Using defaults  min = %L  max = %L\n" 
			((tbx_labeltune_data->textInfo)->minHeight) 
			((tbx_labeltune_data->textInfo)->maxHeight)
		    )
		    (axlFormSetField form_handle "min_height" 
			((tbx_labeltune_data->textInfo)->minHeight)
		    ) 
		    (axlFormSetField form_handle "max_height" 
			((tbx_labeltune_data->textInfo)->maxHeight)
		    ) 
		    (ret_data = full_block_range)
		)
	    ) 
	    (t 
		(range_str = (axlFormGetField form_handle "block_range")) 
		rexCompile(" *- *") 
		(range_str = rexReplace(range_str "-" 0)) 
		rexCompile("  *")
		(range_str = rexReplace(range_str " " 0)) 
		(range_str = (axlStringRemoveSpaces range_str)) 
		foreach(spec 
		    parseString(range_str " ") 
		    cond((rexMatchp("-" spec) 
			    (arr = parseString(spec "-")) 
			    if(((length(arr) == 2) && atoi(car(arr)) && atoi(cadr(arr))) then 
				(tmp_list = list(atoi(car(arr)) 
					atoi(cadr(arr))
				    )) 
				(tmp_list = sort(tmp_list 
					'lessp
				    )) 
				(start = car(tmp_list))
				(end = cadr(tmp_list)) 
				for(i start end 
				    unless(member(i int_block_list) 
					(int_block_list = cons(i int_block_list))
				    )
				) else 
				printf("Warning: Ignoring invalid block specifier %L\n" spec)
			    )
			) 
			(atoi(spec) 
			    unless(member(atoi(spec) int_block_list) 
				(int_block_list = cons(atoi(spec) int_block_list))
			    )
			) 
			(t 
			    printf("Warning: Ignoring invalid block specifier %L\n" spec)
			)
		    )
		) 
		foreach(entry 
		    (tbx_labeltune_data->textList) 
		    (cur_block = cadr(entry)) 
		    (text_param = (axlGetParam 
			    sprintf(nil "paramTextBlock:%d" cur_block)
			)) 
		    tconc(full_block_range 
			list(cur_block 
			    (text_param->height) 
			    (text_param->width) 
			    (text_param->charSpace)
			)
		    )
		    when(member(cur_block int_block_list) 
			tconc(cur_block_range 
			    list(cur_block 
				(text_param->height) 
				(text_param->width) 
				(text_param->charSpace)
			    )
			)
		    )
		) 
		(full_block_range = cdar(full_block_range))
		(cur_block_range = cdar(cur_block_range)) 
		if((length(cur_block_range) > 0) then 
		    (ret_data = cur_block_range) else 
		    (block_range_init = sprintf(nil "%d-%d" 
			    ((tbx_labeltune_data->textInfo)->minBlock) 
			    ((tbx_labeltune_data->textInfo)->maxBlock)
			))
		    printf("Warning: Invalid block range settings. Using default range %s\n" block_range_init) 
		    (axlFormSetField form_handle "block_range" block_range_init) 
		    (ret_data = full_block_range)
		)
	    )
	) ret_data
    )
)
procedure(TBX_LABELTUNE_Get_Box_Center(box) 
    let((x_ll y_ll x_ur y_ur x_center
	    y_center ret
	) 
	(x_ll = car((lowerLeft box))) 
	(y_ll = cadr((lowerLeft box))) 
	(x_ur = car((upperRight box))) 
	(y_ur = cadr((upperRight box)))
	foreach(xy box 
	    when((car(xy) < x_ll) 
		(x_ll = car(xy))
	    ) 
	    when((cadr(xy) < y_ll) 
		(y_ll = cadr(xy))
	    ) 
	    when((car(xy) > x_ur) 
		(x_ur = car(xy))
	    )
	    when((cadr(xy) > y_ur) 
		(y_ur = cadr(xy))
	    )
	) 
	(x_ll = (x_ll * 1.0)) 
	(y_ll = (y_ll * 1.0)) 
	(x_ur = (x_ur * 1.0)) 
	(y_ur = (y_ur * 1.0))
	(x_center = (x_ll + ((x_ur - x_ll) / 2.0))) 
	(y_center = (y_ll + ((y_ur - y_ll) / 2.0))) 
	(ret = (x_center:y_center)) ret
    )
)
procedure(TBX_LABELTUNE_Get_Defaults() 
    let((cfg_file default_dpl file_data design_units session_param
	    cur_value
	) 
	(default_dpl = ncons(nil)) 
	(design_units = lowerCase(car((axlDBGetDesignUnits)))) 
	if(((design_units == "microns") || (design_units == "millimeters") || (design_units == "centimeters")) then 
	    (default_dpl->minHeight = (axlMKSConvert "0.5 MM" design_units)) 
	    (default_dpl->maxHeight = (axlMKSConvert "5.0 MM" design_units)) 
	    (default_dpl->boundaryClearance = (axlMKSConvert "0.2 MM" design_units))
	    else 
	    (default_dpl->minHeight = (axlMKSConvert "20.0 MILS" design_units)) 
	    (default_dpl->maxHeight = (axlMKSConvert "200.0 MILS" design_units)) 
	    (default_dpl->boundaryClearance = (axlMKSConvert "8.0 MILS" design_units))
	) 
	(default_dpl->offsetX = 0.0)
	(default_dpl->offsetY = 0.0) 
	(default_dpl->offsetCorrection = 0.0) 
	(default_dpl->labelName = "refdes") 
	(default_dpl->labelLayer = cadar((tbx_labeltune_data->popupInfo)["refdes"])) 
	(default_dpl->outlineLayer = cadar((tbx_labeltune_data->popupInfo)["package_geom"]))
	(default_dpl->mirrorBottom = t) 
	(default_dpl->rotateText = t) 
	(default_dpl->centerText = t) 
	(default_dpl->fitText = nil) 
	(default_dpl->textMatchMinMaxHeight = t)
	(default_dpl->textMatchBlockRange = nil) 
	(default_dpl->blockRange = sprintf(nil "%d-%d" 
		((tbx_labeltune_data->textInfo)->minBlock) 
		((tbx_labeltune_data->textInfo)->maxBlock)
	    )) 
	(default_dpl->spinLongSide = t) 
	(default_dpl->spinAbsolute = nil) 
	(default_dpl->spinRelative = nil)
	(default_dpl->degTopHorizontal = "0") 
	(default_dpl->degTopVertical = "90") 
	(default_dpl->degBottomHorizontal = "0") 
	(default_dpl->degBottomVertical = "90") 
	(default_dpl->degAbsolute = "0")
	(session_param = eval('tbx_session_param)) 
	if(session_param["labeltune"] then 
	    foreach(token 
		(session_param["labeltune"]->?) 
		if(memq(token 
			list('minHeight 
			    'maxHeight 
			    'offsetX 
			    'offsetY 
			    'offsetCorrection
			    'boundaryClearance
			)
		    ) then 
		    (cur_value = (axlMKSConvert 
			    get(session_param["labeltune"] token) design_units
			)) else 
		    (cur_value = get(session_param["labeltune"] token))
		) 
		putprop(default_dpl cur_value token)
	    ) else 
	    (cfg_file = car(TBX_UTIL_Search_Config("labeltune.ini" nil nil ?includeWorkDir t)))
	    when(cfg_file 
		printf("Reading defaults from %L\n" cfg_file) 
		(file_data = TBX_UTIL_File_Lineread(cfg_file))
	    ) 
	    foreach(entry file_data 
		if(memq(car(entry) 
			list('minHeight 
			    'maxHeight 
			    'offsetX 
			    'offsetY 
			    'offsetCorrection
			    'boundaryClearance
			)
		    ) then 
		    putprop(default_dpl 
			(axlMKSConvert 
			    cadr(entry) design_units
			) 
			car(entry)
		    ) else 
		    putprop(default_dpl 
			cadr(entry) 
			car(entry)
		    )
		)
	    )
	) default_dpl
    )
)
procedure(TBX_LABELTUNE_Get_Label(comp_dbid sym_type) 
    let((label_layer_pat text_dbid sym_dbid result) 
	(label_layer_pat = (axlFormGetField 
		(tbx_labeltune_data->formid) "label_layer"
	    )) 
	case(sym_type 
	    ("instance" 
		(sym_dbid = (comp_dbid->symbol))
	    ) 
	    ("definition" 
		(sym_dbid = ((comp_dbid->symbol)->definition))
	    )
	) 
	(result = setof(ch 
		(sym_dbid->children) 
		(((ch->objType) == "text") && rexMatchp(label_layer_pat 
			(ch->layer)
		    ))
	    )) 
	if(result then 
	    (text_dbid = car(result)) else t
	)
	text_dbid
    )
)
procedure(TBX_LABELTUNE_Get_Max_Extents(box_list) 
    let((x_ll y_ll x_ur y_ur ret_list) 
	foreach(b box_list 
	    unless(x_ll 
		(x_ll = car((lowerLeft b)))
	    ) 
	    unless(y_ll 
		(y_ll = cadr((lowerLeft b)))
	    ) 
	    unless(x_ur 
		(x_ur = car((upperRight b)))
	    )
	    unless(y_ur 
		(y_ur = cadr((upperRight b)))
	    ) 
	    when((car((lowerLeft b)) < x_ll) 
		(x_ll = car((lowerLeft b)))
	    ) 
	    when((cadr((lowerLeft b)) < y_ll) 
		(y_ll = cadr((lowerLeft b)))
	    ) 
	    when((car((upperRight b)) > x_ur) 
		(x_ur = car((upperRight b)))
	    ) 
	    when((cadr((upperRight b)) > y_ur) 
		(y_ur = cadr((upperRight b)))
	    )
	) 
	(ret_list = list((x_ll:y_ll) 
		(x_ur:y_ur)
	    )) ret_list
    )
)
procedure(TBX_LABELTUNE_Get_Outline(comp_dbid sym_type text_dbid) 
    let((outline_layer_pat outline_layer sym_dbid list_of_boxes box_corners
	    box_center ret_list pp pm x
	    y x_ll y_ll x_ul y_ul
	    rotation mirror result
	) 
	(outline_layer_pat = (axlFormGetField 
		(tbx_labeltune_data->formid) "outline_layer"
	    )) 
	cond((rexMatchp("_TOP$" 
		    (text_dbid->layer)
		) 
		(outline_layer = strcat(outline_layer_pat "TOP"))
	    ) 
	    (rexMatchp("_BOTTOM$" 
		    (text_dbid->layer)
		) 
		(outline_layer = strcat(outline_layer_pat "BOTTOM"))
	    )
	) 
	case(sym_type 
	    ("instance" 
		(sym_dbid = (comp_dbid->symbol))
	    ) 
	    ("definition" 
		(sym_dbid = ((comp_dbid->symbol)->definition))
	    ) 
	    (t)
	) 
	if(sym_dbid then 
	    (result = setof(ch 
		    (sym_dbid->children) 
		    ((ch->layer) && (upperCase((ch->layer)) == outline_layer))
		)) 
	    foreach(ch result 
		when((((ch->objType) == "path") || ((ch->objType) == "shape") || ((ch->objType) == "polygon")) 
		    (list_of_boxes = cons((ch->bBox) list_of_boxes))
		)
	    ) 
	    if((length(list_of_boxes) > 0) then 
		(box_corners = TBX_LABELTUNE_Get_Max_Extents(list_of_boxes)) 
		(box_center = TBX_LABELTUNE_Get_Box_Center(box_corners)) 
		(rotation = (sym_dbid->rotation))
		(mirror = (sym_dbid->isMirrored)) else 
		(pp = (1.0 / (10**cadr((axlDBGetDesignUnits))))) 
		(pm = (pp * -1.0)) 
		if((sym_dbid->xy) then 
		    (x = car((sym_dbid->xy))) 
		    (y = cadr((sym_dbid->xy))) 
		    (x_ll = (x - pp))
		    (y_ll = (y - pp)) 
		    (x_ul = (x + pp)) 
		    (y_ul = (y + pp)) 
		    (box_corners = list((x_ll:y_ll) 
			    (x_ul:y_ul)
			)) 
		    (box_center = (sym_dbid->xy))
		    (rotation = (sym_dbid->rotation)) 
		    (mirror = (sym_dbid->isMirrored)) else 
		    printf("Warning no outline data found for component:%s\n" 
			(comp_dbid->name)
		    ) 
		    (box_corners = list((pm:pm) 
			    (pp:pp)
			))
		    (box_center = nil) 
		    (rotation = nil) 
		    (mirror = nil)
		)
	    )
	    (ret_list = list(box_center box_corners rotation mirror)) else 
	    (ret_list = nil)
	)
	ret_list
    )
)
procedure(TBX_LABELTUNE_Init() 
    let((userdata text_param text_list height_list block_list
	    min_height max_height min_block max_block text_info
	) 
	(userdata = (axlUIGetUserData)) 
	remprop(userdata 
	    'transaction
	) 
	putprop(userdata 
	    (userdata->popupId) 
	    'oldPopupId
	) 
	for(n 1 200 
	    (text_param = (axlGetParam 
		    sprintf(nil "paramTextBlock:%d" n)
		)) 
	    when(((text_param->height) && (text_param->width) && ((text_param->height) > 0.0) && ((text_param->width) > 0.0)) 
		(height_list = cons((text_param->height) height_list)) 
		(block_list = cons(n block_list)) 
		(text_list = cons(list((text_param->height) n) text_list))
	    )
	)
	(height_list = sort(height_list 
		'lessp
	    )) 
	(block_list = sort(block_list 
		'lessp
	    )) 
	(min_block = car(block_list)) 
	(max_block = (lastelem block_list)) 
	(min_height = car(height_list))
	(max_height = (lastelem height_list)) 
	(text_info = ncons(nil)) 
	(text_info->minBlock = min_block) 
	(text_info->maxBlock = max_block) 
	(text_info->minHeight = min_height)
	(text_info->maxHeight = max_height) 
	(text_list = sortcar(text_list 
		'lessp
	    )) 
	unless(boundp('tbx_labeltune_data) 
	    iliDefstruct('defstruct(tbx_labeltune_data_struct formid tmplayer mark textList
			textInfo blockInfo popupInfo
		    )
	    ) 
	    defvar(tbx_labeltune_data nil)
	) 
	if(!tbx_labeltune_data then 
	    (tbx_labeltune_data = (make_tbx_labeltune_data_struct ?formid nil ?tmplayer "DRAWING FORMAT/OUTLINE"
		    ?mark nil ?popupInfo nil ?textList
		    text_list ?textInfo text_info ?blockInfo nil
		)) else 
	    (tbx_labeltune_data->formid = nil)
	    (tbx_labeltune_data->tmplayer = "DRAWING FORMAT/OUTLINE") 
	    (tbx_labeltune_data->mark = nil) 
	    (tbx_labeltune_data->popupInfo = nil) 
	    (tbx_labeltune_data->textList = text_list) 
	    (tbx_labeltune_data->textInfo = text_info)
	    (tbx_labeltune_data->blockInfo = nil)
	)
    )
)
procedure(TBX_LABELTUNE_Layer_Popup_Setup() 
    let((base_name base_list layer_top layer_bot class_name
	    nice_name config_list pkg_nick_name popup_info nick_name
	    popup_list
	) 
	(nice_name = makeTable("nice_name_table" nil)) 
	(nice_name["ASSEMBLY"] = "Assembly") 
	(nice_name["PLACE_BOUND"] = "Place_Bound") 
	(nice_name["SILKSCREEN"] = "Silkscreen")
	(nice_name["DISPLAY"] = "Display") 
	(nice_name["DFA_BOUND"] = "DFA_Bound") 
	(pkg_nick_name = "package_geom") 
	(config_list = list(list("refdes" 
		    (axlMapClassName "REF DES")
		) 
		list("value" 
		    (axlMapClassName "COMPONENT VALUE")
		) 
		list("part_number" 
		    (axlMapClassName "USER PART NUMBER")
		) 
		list("device_type" 
		    (axlMapClassName "DEVICE TYPE")
		) 
		list("tolerance" 
		    (axlMapClassName "TOLERANCE")
		)
		list(pkg_nick_name 
		    (axlMapClassName "PACKAGE GEOMETRY")
		)
	    )) 
	(popup_info = makeTable("layer_info_table" nil))
	foreach(entry config_list 
	    (nick_name = car(entry)) 
	    (class_name = cadr(entry)) 
	    (base_list = list())
	    foreach(lyr 
		((axlGetParam 
			strcat("paramLayerGroup:" class_name)
		    )->groupMembers) 
		(base_name = upperCase(lyr)) 
		when((rexMatchp("_TOP" base_name) || 
			rexMatchp("_BOTTOM" base_name)) 
		    rexCompile("_TOP") 
		    (base_name = rexReplace(base_name "" 0)) 
		    rexCompile("_BOTTOM") 
		    (base_name = rexReplace(base_name "" 0))
		    unless(member(base_name base_list) 
			(base_list = cons(base_name base_list))
		    )
		)
	    ) 
	    (base_list = sort(base_list nil)) 
	    when((nick_name == pkg_nick_name) 
		(base_list = remove("SOLDERMASK" base_list)) 
		(base_list = remove("PASTEMASK" base_list))
	    ) 
	    foreach(name base_list 
		(layer_top = strcat(class_name "/" name "_TOP")) 
		(layer_bot = strcat(class_name "/" name "_BOTTOM")) 
		unless((axlIsLayer layer_top) 
		    (axlLayerCreateNonConductor layer_top)
		)
		unless((axlIsLayer layer_bot) 
		    (axlLayerCreateNonConductor layer_bot)
		)
	    ) 
	    (popup_list = list())
	    foreach(base base_list 
		if(nice_name[base] then 
		    (base_name = nice_name[base]) else 
		    (base_name = strcat(upperCase(substring(base 1 1)) 
			    lowerCase(substring(base 2))
			))
		) 
		(popup_list = cons(list(base_name 
			    strcat(class_name "/" base "_")
			) popup_list
		    ))
	    ) 
	    (popup_list = reverse(popup_list)) 
	    (popup_info[nick_name] = popup_list)
	) popup_info
    )
)
procedure(TBX_LABELTUNE_Limit_Layer_Visibility(form_handle) 
    let((text_layer_top text_layer_bottom board_outline_layer comp_outline_layer_top comp_outline_layer_bottom) 
	(text_layer_top = strcat((axlFormGetField form_handle "label_layer") "TOP")) 
	(text_layer_bottom = strcat((axlFormGetField form_handle "label_layer") "BOTTOM")) 
	(comp_outline_layer_top = strcat((axlFormGetField form_handle "outline_layer") "TOP")) 
	(comp_outline_layer_bottom = strcat((axlFormGetField form_handle "outline_layer") "BOTTOM"))
	(board_outline_layer = strcat((axlMapClassName "BOARD GEOMETRY") "/OUTLINE")) 
	(axlVisibleDesign nil) 
	(axlVisibleLayer board_outline_layer t) 
	(axlVisibleLayer comp_outline_layer_top t) 
	(axlVisibleLayer comp_outline_layer_bottom t)
	(axlVisibleLayer text_layer_top t) 
	(axlVisibleLayer text_layer_bottom t) 
	(axlVisibleUpdate t) t
    )
)
procedure((TBX_LABELTUNE_Main \@optional arg) 
    let((lic_check_result FORM_FILE fid FC_FEATURE VERSION_STR
	    FC_VERSION SUB_VERSION port info_file default_value
	    ok_start_app
	) 
	(FC_VERSION = "17.1") 
	(FC_FEATURE = "LABELTUNE") 
	(SUB_VERSION = "02") 
	(VERSION_STR = sprintf(nil "LabelTune %s (C)2017" FC_VERSION))
	(ok_start_app = t) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./labeltune_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Label Tune information:\n") 
		fprintf(port "=======================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version   : Prints the current version of the module\n") 
		fprintf(port "  save_ini  : Saves INI file to disk\n") 
		fprintf(port "\n") 
		close(port)
		(axlUIViewFileCreate info_file "Label Tune: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is %s.%s\n" FC_VERSION SUB_VERSION) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "save_ini")) 
		TBX_LABELTUNE_Save_INI() 
		(ok_start_app = nil)
	    )
	) 
	when(ok_start_app 
	    (lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
	    when((lic_check_result && (axlOKToProceed t)) 
		(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "labeltune_main")) 
		unless(boundp('tbxLabeltuneMainHandle) 
		    defvar(tbxLabeltuneMainHandle nil)
		) 
		(fid = (axlFormCreate 
			'tbxLabeltuneMainHandle FORM_FILE 
			'(e outer) 
			'TBX_LABELTUNE_Callback
			t nil
		    )) 
		when(fid 
		    TBX_LABELTUNE_Init() 
		    TBX_FORM_Init_Header(fid "" lic_check_result VERSION_STR) 
		    (tbx_labeltune_data->formid = fid) 
		    (tbx_labeltune_data->popupInfo = TBX_LABELTUNE_Layer_Popup_Setup())
		    (default_value = TBX_LABELTUNE_Get_Defaults()) 
		    when((default_value->outlineLayer) 
			(default_value->outlineLayer = TBX_UTIL_Map_Layer_Name((default_value->outlineLayer) nil))
		    ) 
		    when((default_value->labelLayer) 
			(default_value->labelLayer = TBX_UTIL_Map_Layer_Name((default_value->labelLayer) nil))
		    ) 
		    (axlFormSetField fid "label_name" 
			(default_value->labelName)
		    ) 
		    (axlFormBuildPopup fid "label_layer" 
			(tbx_labeltune_data->popupInfo)[(default_value->labelName)]
		    )
		    (axlFormSetField fid "label_layer" 
			(default_value->labelLayer)
		    ) 
		    (axlFormBuildPopup fid "outline_layer" 
			(tbx_labeltune_data->popupInfo)["package_geom"]
		    ) 
		    (axlFormSetField fid "outline_layer" 
			(default_value->outlineLayer)
		    ) 
		    (axlFormSetField fid "mirror_bottom" 
			(default_value->mirrorBottom)
		    ) 
		    (axlFormSetField fid "rotate_text" 
			(default_value->rotateText)
		    )
		    (axlFormSetField fid "center_text" 
			(default_value->centerText)
		    ) 
		    (axlFormSetField fid "fit_text" 
			(default_value->fitText)
		    ) 
		    (axlFormSetField fid "offset_x" 
			(default_value->offsetX)
		    ) 
		    (axlFormSetField fid "offset_y" 
			(default_value->offsetY)
		    ) 
		    (axlFormSetField fid "text_match_minmax_height" 
			(default_value->textMatchMinMaxHeight)
		    )
		    (axlFormSetField fid "text_match_block_range" 
			(default_value->textMatchBlockRange)
		    ) 
		    (axlFormSetField fid "min_height" 
			(default_value->minHeight)
		    ) 
		    (axlFormSetField fid "max_height" 
			(default_value->maxHeight)
		    ) 
		    (axlFormSetField fid "block_range" 
			(default_value->blockRange)
		    ) 
		    (tbx_labeltune_data->blockInfo = TBX_LABELTUNE_Get_Block_Info(fid))
		    (axlFormSetField fid "spin_long_side" 
			(default_value->spinLongSide)
		    ) 
		    (axlFormSetField fid "spin_absolute" 
			(default_value->spinAbsolute)
		    ) 
		    (axlFormSetField fid "spin_relative" 
			(default_value->spinRelative)
		    ) 
		    (axlFormSetField fid "deg_top_horizontal" 
			(default_value->degTopHorizontal)
		    ) 
		    (axlFormSetField fid "deg_top_vertical" 
			(default_value->degTopVertical)
		    )
		    (axlFormSetField fid "deg_bottom_horizontal" 
			(default_value->degBottomHorizontal)
		    ) 
		    (axlFormSetField fid "deg_bottom_vertical" 
			(default_value->degBottomVertical)
		    ) 
		    (axlFormSetField fid "deg_absolute" 
			(default_value->degAbsolute)
		    ) 
		    (axlFormSetField fid "offset_correction" 
			(default_value->offsetCorrection)
		    ) 
		    (axlFormSetField fid "boundary_clearance" 
			(default_value->boundaryClearance)
		    )
		    if((axlFormGetField fid "text_match_minmax_height") then 
			(axlFormSetFieldEditable fid "min_height" t) 
			(axlFormSetFieldEditable fid "max_height" t) 
			(axlFormSetFieldEditable fid "block_range" nil)
			else 
			(axlFormSetFieldEditable fid "min_height" nil) 
			(axlFormSetFieldEditable fid "max_height" nil) 
			(axlFormSetFieldEditable fid "block_range" t)
		    ) 
		    if((axlFormGetField fid "center_text") then 
			(axlFormSetFieldEditable fid "offset_x" t) 
			(axlFormSetFieldEditable fid "offset_y" t) else
			(axlFormSetFieldEditable fid "offset_x" nil) 
			(axlFormSetFieldEditable fid "offset_y" nil)
		    ) 
		    cond(((axlFormGetField fid "spin_long_side") 
			    (axlFormSetFieldEditable fid "deg_top_horizontal" t) 
			    (axlFormSetFieldEditable fid "deg_top_vertical" t) 
			    (axlFormSetFieldEditable fid "deg_bottom_horizontal" t) 
			    (axlFormSetFieldEditable fid "deg_bottom_vertical" t)
			    (axlFormSetFieldEditable fid "deg_absolute" nil)
			) 
			((axlFormGetField fid "spin_absolute") 
			    (axlFormSetFieldEditable fid "deg_top_horizontal" nil) 
			    (axlFormSetFieldEditable fid "deg_top_vertical" nil) 
			    (axlFormSetFieldEditable fid "deg_bottom_horizontal" nil) 
			    (axlFormSetFieldEditable fid "deg_bottom_vertical" nil)
			    (axlFormSetFieldEditable fid "deg_absolute" t)
			) 
			((axlFormGetField fid "spin_relative") 
			    (axlFormSetFieldEditable fid "deg_top_horizontal" nil) 
			    (axlFormSetFieldEditable fid "deg_top_vertical" nil) 
			    (axlFormSetFieldEditable fid "deg_bottom_horizontal" nil) 
			    (axlFormSetFieldEditable fid "deg_bottom_vertical" nil)
			    (axlFormSetFieldEditable fid "deg_absolute" nil)
			)
		    ) 
		    (axlFormDisplay fid) 
		    TBX_LABELTUNE_Event_Loop()
		    TBX_FORM_Delete(lic_check_result FORM_FILE)
		)
	    )
	)
    )
)
procedure(TBX_LABELTUNE_Modify_Text(c_list) 
    let((text_inst_dbid text_def_dbid text_xy text_block text_rotation_new
	    text_rotation_def text_justify text_mirror my_orient result
	    sym_box_center sym_inst_data sym_def_data text_value text_layer
	    ok_to_proceed
	) 
	foreach(c c_list 
	    (ok_to_proceed = nil) 
	    (sym_inst_data = nil) 
	    (sym_def_data = nil)
	    (text_inst_dbid = TBX_LABELTUNE_Get_Label(c "instance")) 
	    (text_def_dbid = TBX_LABELTUNE_Get_Label(c "definition")) 
	    when(text_inst_dbid 
		(sym_inst_data = TBX_LABELTUNE_Get_Outline(c "instance" text_inst_dbid))
	    ) 
	    when(text_def_dbid 
		(sym_def_data = TBX_LABELTUNE_Get_Outline(c "definition" text_def_dbid))
	    ) 
	    if((text_inst_dbid && sym_inst_data && sym_def_data) then 
		(text_value = (text_inst_dbid->text)) 
		(text_layer = (text_inst_dbid->layer)) 
		(text_xy = (text_inst_dbid->xy))
		(text_justify = (text_inst_dbid->justify)) 
		(text_block = (text_inst_dbid->textBlock)) 
		(text_mirror = (text_inst_dbid->isMirrored)) 
		(text_rotation_new = (text_inst_dbid->rotation)) 
		(text_rotation_def = (text_def_dbid->rotation))
		when((axlFormGetField 
			(tbx_labeltune_data->formid) "rotate_text"
		    ) 
		    (ok_to_proceed = t) 
		    (text_rotation_new = TBX_LABELTUNE_Calculate_Text_Rotation(sym_inst_data sym_def_data text_inst_dbid text_def_dbid))
		) 
		when((axlFormGetField 
			(tbx_labeltune_data->formid) "center_text"
		    ) 
		    (ok_to_proceed = t) 
		    (text_justify = "CENTER") 
		    (sym_box_center = car(sym_inst_data)) 
		    (text_xy = TBX_LABELTUNE_Offset_Correction(sym_box_center text_block text_rotation_new))
		) 
		when((axlFormGetField 
			(tbx_labeltune_data->formid) "fit_text"
		    ) 
		    (ok_to_proceed = t) 
		    if((length((tbx_labeltune_data->blockInfo)) > 0) then 
			(result = TBX_LABELTUNE_Calculate_Text_Block(sym_inst_data sym_def_data text_value text_rotation_new text_rotation_def)) 
			(text_xy = car(result)) 
			(text_block = cadr(result))
			else 
			(ok_to_proceed = nil) 
			(axlUIConfirm "Warning: No valid text blocks found for fitting operation. Adjust settings in Advanced - Text fit accordingly.")
		    )
		) 
		unless(ok_to_proceed 
		    printf("Please select at least one item from \"Mode\" options\n")
		) 
		when(ok_to_proceed 
		    (text_mirror = nil) 
		    when(((axlFormGetField 
				(tbx_labeltune_data->formid) "mirror_bottom"
			    ) && ((c->symbol)->isMirrored)) 
			(text_mirror = t)
		    ) 
		    (my_orient = (make_axlTextOrientation ?textBlock text_block ?rotation text_rotation_new
			    ?mirrored text_mirror ?justify text_justify
			)) 
		    (axlDeleteObject text_inst_dbid)
		    (result = (axlDBCreateText text_value text_xy my_orient text_layer
			    (c->symbol)
			)) 
		    (axlDBRefreshId 
			(c->symbol)
		    ) 
		    (axlDBRefreshId c) 
		    unless(result 
			printf("Could not create Text for %s\n" 
			    (c->name)
			)
		    )
		)
		else 
		printf("Data not valid for component %s, check text label and/or outline data corresponding to selected options\n" 
		    (c->name)
		)
	    )
	)
    )
)
procedure(TBX_LABELTUNE_Offset_Correction(text_xy text_block text_rotation) 
    let((correction_factor text_height text_offset delta_x delta_y
	    angle text_x text_y PI text_param
	    user_dx user_dy
	) 
	(text_param = (axlGetParam 
		strcat("paramTextBlock:" text_block)
	    )) 
	(PI = 3.141593) 
	(correction_factor = (axlFormGetField 
		(tbx_labeltune_data->formid) "offset_correction"
	    )) 
	(user_dx = (axlFormGetField 
		(tbx_labeltune_data->formid) "offset_x"
	    ))
	(user_dy = (axlFormGetField 
		(tbx_labeltune_data->formid) "offset_y"
	    )) 
	(text_height = (text_param->height)) 
	(text_offset = ((text_height / 2.0) - (text_height * correction_factor))) 
	cond((((text_rotation >= 0.0) && (text_rotation <= 90.0)) 
		(angle = ((text_rotation / 180.0) * PI)) 
		(delta_x = abs((cos(((PI / 2) - angle)) * text_offset))) 
		(delta_y = (- abs((sin(((PI / 2) - angle)) * text_offset))))
	    ) 
	    (((text_rotation > 90.0) && (text_rotation <= 180.0)) 
		(angle = (((180.0 - text_rotation) / 180.0) * PI)) 
		(delta_x = abs((cos(((PI / 2) - angle)) * text_offset))) 
		(delta_y = abs((sin(((PI / 2) - angle)) * text_offset)))
	    ) 
	    (((text_rotation > 180.0) && (text_rotation <= 270.0)) 
		(angle = (((text_rotation - 180.0) / 180.0) * PI)) 
		(delta_x = (- abs((cos(((PI / 2) - angle)) * text_offset)))) 
		(delta_y = abs((sin(((PI / 2) - angle)) * text_offset)))
	    ) 
	    (((text_rotation > 270.0) && (text_rotation <= 360.0)) 
		(angle = (((360.0 - text_rotation) / 180.0) * PI)) 
		(delta_x = (- abs((cos(((PI / 2) - angle)) * text_offset)))) 
		(delta_y = (- abs((sin(((PI / 2) - angle)) * text_offset))))
	    )
	) 
	(text_x = (car(text_xy) + delta_x))
	(text_y = (cadr(text_xy) + delta_y)) 
	(text_x = (text_x + user_dx)) 
	(text_y = (text_y + user_dy)) 
	list(text_x text_y)
    )
)
procedure(TBX_LABELTUNE_Popup(event) 
    let((popup dummy) 
	(dummy = event) 
	(dummy = dummy) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_LABELTUNE_Popup_Done
		    ) 
		    list("Oops" 
			'TBX_LABELTUNE_Popup_Oops
		    ) 
		    list("Cancel" 
			'TBX_LABELTUNE_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_LABELTUNE_Popup_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_LABELTUNE_Popup_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_LABELTUNE_Popup_Oops() 
    (axlDBTransactionOops 
	(tbx_labeltune_data->mark)
    )
)
procedure(TBX_LABELTUNE_Save_INI() 
    let((cur_param session_param ini_data ini_file port
	    msg
	) 
	if(boundp('tbx_session_param) then 
	    (session_param = eval('tbx_session_param)) 
	    if(session_param["labeltune"] then 
		(ini_data = tconc(nil nil)) 
		(ini_file = strcat(getWorkingDir() "/labeltune.ini")) 
		(cur_param = session_param["labeltune"])
		when((cur_param->outlineLayer) 
		    (cur_param->outlineLayer = TBX_UTIL_Map_Layer_Name((cur_param->outlineLayer) t))
		) 
		when((cur_param->labelLayer) 
		    (cur_param->labelLayer = TBX_UTIL_Map_Layer_Name((cur_param->labelLayer) t))
		) 
		foreach(key 
		    list('labelName 
			'labelLayer 
			'outlineLayer 
			'mirrorBottom 
			'rotateText
			'centerText 
			'fitText 
			'offsetX 
			'offsetY 
			'textMatchMinMaxHeight
			'minHeight 
			'maxHeight 
			'textMatchBlockRange 
			'blockRange 
			'spinLongSide
			'spinAbsolute 
			'spinRelative 
			'degTopHorizontal 
			'degTopVertical 
			'degBottomHorizontal
			'degBottomVertical 
			'degAbsolute 
			'offsetCorrection 
			'boundaryClearance
		    ) 
		    tconc(ini_data 
			list(key 
			    get(cur_param key)
			)
		    )
		) 
		(port = outfile(ini_file "w")) 
		pprint(cdar(ini_data) port)
		close(port) 
		printf("Note: File %L has been written\n" ini_file) else 
		(msg = "You need to launch application at least once in the current session and adjust parameters")
	    ) else
	    (msg = "You need to launch application at least once in the current session and adjust parameters")
	) 
	when(msg 
	    (axlUIConfirm msg)
	) t
    )
)
procedure(TBX_LIBUTIL_Dump_JSON() 
    let((sym_info canvas_info design_type orgvis) 
	(orgvis = (axlVisibleGet)) 
	TBX_LIBUTIL_Init() 
	(design_type = lowerCase((axlDesignType t))) 
	when(((design_type == "package") || (design_type == "mechanical")) 
	    (sym_info = TBX_LIBUTIL_Get_Symbol_Info()) 
	    (canvas_info = TBX_LIBUTIL_Get_Canvas_Info()) 
	    TBX_LIBUTIL_Export_JSON(sym_info canvas_info)
	)
	(axlVisibleSet orgvis) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_LIBUTIL_Export_JSON(sym_info canvas_info) 
    let((port file_name cont_char cnt view_order
	    size_x size_y
	) 
	(view_order = (canvas_info[""]->viewOrder)) 
	(size_x = (canvas_info[""]->sizeX)) 
	(size_y = (canvas_info[""]->sizeY)) 
	(file_name = sprintf(nil "./%s.json" 
		(sym_info->name)
	    ))
	(port = outfile(file_name "w")) 
	fprintf(port "{\n") 
	fprintf(port "   \"name\":%L,\n" 
	    (sym_info->name)
	) 
	fprintf(port "   \"type\":%L,\n" 
	    (sym_info->type)
	) 
	fprintf(port "   \"units\":%L,\n" 
	    (sym_info->units)
	)
	fprintf(port "   \"electricalPins\":%d,\n" 
	    (sym_info->electricalPins)
	) 
	fprintf(port "   \"mechanicalPins\":%d,\n" 
	    (sym_info->mechanicalPins)
	) 
	fprintf(port "   \"sizeX\":%L,\n" 
	    (sym_info->sizeX)
	) 
	fprintf(port "   \"sizeY\":%L,\n" 
	    (sym_info->sizeY)
	) 
	fprintf(port "   \"height\":%L,\n" 
	    (sym_info->height)
	)
	fprintf(port "   \"pinDetails\":[\n") 
	(cnt = 0) 
	(cont_char = ",") 
	foreach(pe 
	    (sym_info->pinDetails) 
	    ++cnt 
	    when((cnt == length((sym_info->pinDetails))) 
		(cont_char = "")
	    ) 
	    fprintf(port "         {\"type\":%L, \"number\":%L, \"posX\":%L, \"posY\":%L, \"padstack\":%L, \"bBox\":%s}%s\n" 
		(pe->type) 
		(pe->number) 
		(pe->posX)
		(pe->posY) 
		(pe->name) 
		TBX_LIBUTIL_JSON_Format_Box((pe->bBox)) cont_char
	    )
	) 
	fprintf(port "   ],\n")
	fprintf(port "   \"canvas\":{\n") 
	fprintf(port "      \"viewOrder\":%s,\n" 
	    TBX_LIBUTIL_JSON_Format_List(view_order)
	) 
	fprintf(port "      \"sizeX\":%L,\n" size_x) 
	fprintf(port "      \"sizeY\":%L,\n" size_y) 
	fprintf(port "      \"view:\":[\n")
	TBX_LIBUTIL_JSON_Write_Views(port 6 canvas_info view_order) 
	fprintf(port "      ]\n") 
	fprintf(port "   }\n") 
	fprintf(port "}\n") 
	close(port)
	printf("Note: File %L has been written\n" file_name)
    )
)
procedure(TBX_LIBUTIL_Get_Canvas_Info() 
    let((viewParam data box_list box_ll box_ur
	    pin_via_list shape_list path_list text_list pad_info
	    path_info shape_info text_info view_extents view_color
	    canvas_info graphic_data size_x size_y total_extents
	    extract_pad extract_drill
	) 
	(canvas_info = makeTable("canvas_info_data_table" nil)) 
	(viewParam = (tbx_libutil_global->viewParam)) 
	foreach(vp viewParam 
	    (extract_pad = nil) 
	    (extract_drill = nil) 
	    (graphic_data = nil)
	    (axlVisibleDesign nil) 
	    foreach(lyr 
		(viewParam[vp]->layers) 
		(axlVisibleLayer lyr t)
	    ) 
	    (axlVisibleUpdate nil) 
	    (axlClearSelSet) 
	    (axlSetFindFilter ?enabled 
		cons("noall" 
		    (viewParam[vp]->objects)
		) ?onButtons 
		list("all")
	    )
	    (axlAddSelectAll) 
	    (data = (axlGetSelSet)) 
	    (axlClearSelSet) 
	    (view_extents = (axlDBGetExtents data t)) 
	    (view_color = (viewParam[vp]->color))
	    (pin_via_list = setof(x data 
		    (((x->objType) == "pin") || ((x->objType) == "via"))
		)) 
	    (path_list = setof(x data 
		    ((x->objType) == "path")
		)) 
	    (shape_list = setof(x data 
		    ((x->objType) == "shape")
		)) 
	    (text_list = setof(x data 
		    ((x->objType) == "text")
		)) 
	    when(pin_via_list 
		cond(((!(viewParam[vp]->padMode) || (lowerCase((viewParam[vp]->padMode)) == "both")) 
			(extract_pad = t) 
			(extract_drill = t)
		    ) 
		    ((lowerCase((viewParam[vp]->padMode)) == "padonly") 
			(extract_pad = t) 
			(extract_drill = nil)
		    ) 
		    ((lowerCase((viewParam[vp]->padMode)) == "drillonly") 
			(extract_pad = nil) 
			(extract_drill = t)
		    )
		) 
		(pad_info = TBX_LIBUTIL_Get_Pad_Geo(pin_via_list extract_pad extract_drill)) 
		foreach(entry pad_info 
		    (graphic_data = cons(entry graphic_data))
		)
	    )
	    when(shape_list 
		(shape_info = TBX_LIBUTIL_Get_Shape_Geo(shape_list)) 
		foreach(entry shape_info 
		    (graphic_data = cons(entry graphic_data))
		)
	    ) 
	    when(path_list 
		(path_info = TBX_LIBUTIL_Get_Path_Geo(path_list)) 
		foreach(entry path_info 
		    (graphic_data = cons(entry graphic_data))
		)
	    ) 
	    when(text_list 
		(text_info = TBX_LIBUTIL_Get_Text_Geo(text_list)) 
		foreach(entry text_info 
		    (graphic_data = cons(entry graphic_data))
		)
	    ) 
	    (canvas_info[vp] = list(nil 
		    'bBox view_extents 
		    'graphicData graphic_data
		    'color view_color
		))
	) 
	foreach(vp canvas_info 
	    (box_list = cons((canvas_info[vp]->bBox) box_list))
	)
	(total_extents = TBX_UTIL_Get_Extents(box_list)) 
	(box_ll = car(total_extents)) 
	(box_ur = cadr(total_extents)) 
	(size_x = (car(box_ur) - car(box_ll))) 
	(size_y = (cadr(box_ur) - cadr(box_ll)))
	(canvas_info[""] = list(nil 
		'viewOrder 
		(tbx_libutil_global->viewOrder) 
		'sizeX size_x
		'sizeY size_y
	    )) canvas_info
    )
)
procedure(TBX_LIBUTIL_Get_Pad_Geo(pad_list extract_pad extract_drill) 
    let((pad_poly drill_polys rpath geo_info boundary
	    cutouts pad_info
	) 
	foreach(pv pad_list 
	    (boundary = nil) 
	    (cutouts = nil) 
	    when(extract_pad 
		(pad_poly = car(TBX_DBCORE_Poly_From_Padstack(pv))) 
		(rpath = TBX_DBCORE_Rpath_From_Poly(pad_poly ?compactArc t)) 
		(geo_info = TBX_LIBUTIL_Get_Rpath_Info(rpath t)) 
		(boundary = geo_info)
	    )
	    when(extract_drill 
		(drill_polys = TBX_DBCORE_Poly_From_Drill(pv)) 
		foreach(pl drill_polys 
		    (rpath = TBX_DBCORE_Rpath_From_Poly(pl ?compactArc t)) 
		    (geo_info = TBX_LIBUTIL_Get_Rpath_Info(rpath t)) 
		    (cutouts = cons(geo_info cutouts))
		)
	    ) 
	    if((!extract_pad && extract_drill) then 
		(pad_info = cons(list((pv->objType) "poly" cutouts nil) pad_info)) else 
		(pad_info = cons(list((pv->objType) "poly" 
			    list(boundary) cutouts
			) pad_info
		    ))
	    )
	) pad_info
    )
)
procedure(TBX_LIBUTIL_Get_Path_Geo(path_list) 
    let((rpath path_info line_path) 
	foreach(pth path_list 
	    (rpath = (axlDB2Path pth)) 
	    (line_path = TBX_LIBUTIL_Get_Rpath_Info(rpath)) 
	    (path_info = cons(list((pth->objType) "line" 
			list(line_path) nil
		    ) path_info
		))
	) path_info
    )
)
procedure((TBX_LIBUTIL_Get_Rpath_Info rpath \@optional poly_mode) 
    let((geo_info seg_list end_xy center path_width
	    width clockwise cur_seg
	) 
	(geo_info = tconc(nil nil)) 
	(seg_list = (axlPathGetPathSegs rpath)) 
	(path_width = (axlPathGetWidth rpath)) 
	(end_xy = (axlPathSegGetEndPoint 
		car(seg_list)
	    ))
	if(poly_mode then 
	    tconc(geo_info 
		list(nil 
		    'xy end_xy
		)
	    ) else 
	    tconc(geo_info 
		list(nil 
		    'xy end_xy 
		    'width 0.0
		)
	    )
	) 
	foreach(sg 
	    cdr(seg_list) 
	    (end_xy = (axlPathSegGetEndPoint sg)) 
	    (center = (axlPathSegGetArcCenter sg)) 
	    if(center then 
		(clockwise = (axlPathSegGetArcClockwise sg)) 
		(cur_seg = list(nil 
			'xy end_xy 
			'center center
			'clockwise clockwise
		    )) else
		(cur_seg = list(nil 
			'xy end_xy
		    ))
	    )
	    unless(poly_mode 
		(width = (axlPathSegGetWidth sg)) 
		if(width then 
		    (cur_seg->width = width) else 
		    (cur_seg->width = path_width)
		)
	    ) 
	    tconc(geo_info cur_seg)
	) 
	(geo_info = cdar(geo_info)) geo_info
    )
)
procedure(TBX_LIBUTIL_Get_Shape_Geo(shape_list) 
    let((rpath geo_info shape_info boundary cutouts) 
	foreach(shp shape_list 
	    (boundary = nil) 
	    (cutouts = nil) 
	    (rpath = (axlDB2Path shp))
	    (boundary = TBX_LIBUTIL_Get_Rpath_Info(rpath t)) 
	    foreach(vd 
		(shp->voids) 
		(rpath = (axlDB2Path vd)) 
		(geo_info = TBX_LIBUTIL_Get_Rpath_Info(rpath t)) 
		(cutouts = cons(geo_info cutouts))
	    ) 
	    (shape_info = cons(list((shp->objType) "poly" 
			list(boundary) cutouts
		    ) shape_info
		))
	) shape_info
    )
)
procedure(TBX_LIBUTIL_Get_Symbol_Info() 
    let((design_name design_type design_units mech_pin_cnt conn_pin_cnt
	    data pin_type cur_pin pin_details place_bound_layer
	    pb_shapes pb_box xy_ll xy_ur pb_size_x
	    pb_size_y height_list sym_info symbol_height tmp_list
	) 
	(design_name = (axlCurrentDesign)) 
	(design_type = (axlDesignType t)) 
	(design_units = car((axlDBGetDesignUnits))) 
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "pins" "vias" "shapes") ?onButtons 
	    list("all")
	)
	(axlClearSelSet) 
	(axlAddSelectAll) 
	(data = (axlGetSelSet)) 
	(axlClearSelSet) 
	(mech_pin_cnt = 0)
	(conn_pin_cnt = 0) 
	foreach(pin 
	    setof(x data 
		((x->objType) == "pin")
	    ) 
	    if((pin->isMech) then 
		++mech_pin_cnt 
		(pin_type = "mechanical") else
		++conn_pin_cnt 
		(pin_type = "electrical")
	    ) 
	    (cur_pin = list(nil 
		    'type pin_type 
		    'number 
		    (pin->number)
		    'posX 
		    car((pin->xy)) 
		    'posY 
		    cadr((pin->xy)) 
		    'name
		    (pin->name) 
		    'bBox 
		    (pin->bBox)
		)) 
	    (pin_details = cons(cur_pin pin_details))
	) 
	foreach(entry pin_details 
	    (tmp_list = cons(list((entry->number) entry) tmp_list))
	) 
	(tmp_list = sortcar(tmp_list 
		'axlStrcmpAlpNum
	    )) 
	(pin_details = mapcar(lambda((x) 
		    cadr(x)
		) tmp_list
	    ))
	(place_bound_layer = strcat((axlMapClassName "PACKAGE GEOMETRY") "/PLACE_BOUND_TOP")) 
	(pb_shapes = setof(x data 
		(((x->objType) == "shape") && ((x->layer) == place_bound_layer))
	    )) 
	(pb_box = (axlDBGetExtents pb_shapes nil)) 
	(xy_ll = car(pb_box)) 
	(xy_ur = cadr(pb_box))
	(pb_size_x = (car(xy_ur) - car(xy_ll))) 
	(pb_size_y = (cadr(xy_ur) - cadr(xy_ll))) 
	foreach(shp pb_shapes 
	    when(((shp->prop)->PACKAGE_HEIGHT_MAX) 
		(height_list = cons((axlMKSConvert 
			    ((shp->prop)->PACKAGE_HEIGHT_MAX) design_units
			) height_list
		    ))
	    )
	) 
	when(height_list 
	    (height_list = sort(height_list 
		    'greaterp
		)) 
	    (symbol_height = car(height_list))
	) 
	(sym_info = list(nil 
		'name design_name 
		'type design_type
		'units design_units 
		'electricalPins conn_pin_cnt 
		'mechanicalPins
		mech_pin_cnt 
		'sizeX pb_size_x 
		'sizeY pb_size_y
		'height symbol_height 
		'pinDetails pin_details
	    ))
	sym_info
    )
)
procedure(TBX_LIBUTIL_Get_Text_Geo(text_list) 
    let((flatten path_data geo_info text_info) 
	foreach(txt text_list 
	    (path_data = nil) 
	    (flatten = mapcan(lambda((x) x) 
		    (axlText2Lines txt)
		)) 
	    foreach(rp flatten 
		(geo_info = TBX_LIBUTIL_Get_Rpath_Info(rp)) 
		(path_data = cons(geo_info path_data))
	    )
	    (text_info = cons(list((txt->objType) "line" path_data nil) text_info))
	) text_info
    )
)
procedure(TBX_LIBUTIL_Init() 
    let((view_param view_order constant_values margin svg_width
	    svg_height
	) 
	(margin = TBX_UTIL_Smart_Convert("0.5 MM" "20.0 MILS")) 
	(svg_width = 1000) 
	(svg_height = 1000) 
	(constant_values = list(nil 
		'margin margin 
		'svgWidth svg_width
		'svgHeight svg_height
	    ))
	(view_param = makeTable("view_param_data" nil)) 
	(view_param["ETCH"] = list(nil 
		'objects 
		list("pins" "vias" "clines" "shapes" "text") 
		'layers 
		list("ETCH/TOP" "PIN/TOP" "VIA CLASS/TOP" "ETCH/BOTTOM" "PIN/BOTTOM"
		    "VIA CLASS/BOTTOM"
		)
		'padMode "both" 
		'color "#ff0000"
	    )) 
	(view_param["DRILL"] = list(nil 
		'objects 
		list("pins" "vias") 
		'layers 
		list("PIN/TOP" "VIA CLASS/TOP")
		'padMode "drillOnly" 
		'color "#00ff00"
	    )) 
	(view_param["GEOM"] = list(nil 
		'objects 
		list("lines" "shapes" "text") 
		'layers 
		list("PACKAGE GEOMETRY/ASSEMBLY_TOP" "PACKAGE GEOMETRY/ASSEMBLY_BOTTOM")
		'shapeMode "unfill" 
		'color "#585858"
	    )) 
	(view_param["LABEL"] = list(nil 
		'objects 
		list("text") 
		'layers 
		list("PACKAGE GEOMETRY/PIN_NUMBER" "REF DES/ASSEMBLY_TOP" "REF DES/ASSEMBLY_BOTTOM")
		'color "#0000ff"
	    ))
	(view_order = list("ETCH" "DRILL" "GEOM" "LABEL")) 
	unless(boundp('tbx_libutil_global) 
	    iliDefstruct('defstruct(tbx_libutil_global_struct formId licCheck viewParam viewOrder
			constValue
		    )
	    ) 
	    defvar(tbx_libutil_global nil)
	) 
	if(!tbx_libutil_global then 
	    (tbx_libutil_global = (make_tbx_libutil_global_struct ?formId nil ?licCheck nil
		    ?viewParam view_param ?viewOrder view_order ?constValue
		    constant_values
		)) else 
	    (tbx_libutil_global->formId = nil)
	    (tbx_libutil_global->licCheck = nil) 
	    (tbx_libutil_global->viewParam = view_param) 
	    (tbx_libutil_global->viewOrder = view_order) 
	    (tbx_libutil_global->constValue = constant_values)
	)
    )
)
procedure(TBX_LIBUTIL_JSON_Format_Box(box) 
    let((box_ll box_ur ll_x ll_y ur_x
	    ur_y ret_str
	) 
	(box_ll = car(box)) 
	(box_ur = cadr(box)) 
	(ll_x = car(box_ll)) 
	(ll_y = cadr(box_ll))
	(ur_x = car(box_ur)) 
	(ur_y = cadr(box_ur)) 
	(ret_str = sprintf(nil "[%L, %L, %L, %L]" ll_x ll_y ur_x
		ur_y
	    )) ret_str
    )
)
procedure(TBX_LIBUTIL_JSON_Format_List(data) 
    let((ret_str tmp_list) 
	(tmp_list = mapcar(lambda((x) 
		    sprintf(nil "%L" x)
		) data
	    )) 
	(ret_str = buildString(tmp_list ", ")) 
	(ret_str = sprintf(nil "[%s]" ret_str)) ret_str
    )
)
procedure(TBX_LIBUTIL_JSON_Format_Path(data) 
    let((ret_str tmp_list cw_flag) 
	(tmp_list = tconc(nil nil)) 
	foreach(rec data 
	    if((rec->center) then 
		(cw_flag = "false") 
		when((rec->clockwise) 
		    (cw_flag = "true")
		) 
		if((rec->width) then 
		    tconc(tmp_list 
			sprintf(nil "[%L, %L, %L, %L, %s, %L]" 
			    car((rec->xy)) 
			    cadr((rec->xy)) 
			    car((rec->center))
			    cadr((rec->center)) cw_flag 
			    (rec->width)
			)
		    ) else 
		    tconc(tmp_list 
			sprintf(nil "[%L, %L, %L, %L, %s]" 
			    car((rec->xy)) 
			    cadr((rec->xy)) 
			    car((rec->center))
			    cadr((rec->center)) cw_flag
			)
		    )
		)
		else 
		if((rec->width) then 
		    tconc(tmp_list 
			sprintf(nil "[%L, %L, %L]" 
			    car((rec->xy)) 
			    cadr((rec->xy)) 
			    (rec->width)
			)
		    ) else 
		    tconc(tmp_list 
			sprintf(nil "[%L, %L]" 
			    car((rec->xy)) 
			    cadr((rec->xy))
			)
		    )
		)
	    )
	) 
	(tmp_list = cdar(tmp_list)) 
	(ret_str = buildString(tmp_list ", "))
	(ret_str = sprintf(nil "[%s]" ret_str)) ret_str
    )
)
procedure(TBX_LIBUTIL_JSON_Write_Graphics(port ind graphics) 
    let((format_str ind_str_1 ind_str_2 cnt cont_char
	    geometry cont_char_2 geo_type
	) 
	(format_str = strcat("%-" 
		sprintf(nil "%d" ind) "s"
	    )) 
	(ind_str_1 = sprintf(nil format_str " ")) 
	(ind_str_2 = strcat(ind_str_1 "   ")) 
	(cnt = 0)
	(cont_char = ",") 
	foreach(entry graphics 
	    ++cnt 
	    (geometry = cadr(entry)) 
	    when((cnt == length(graphics)) 
		(cont_char = "")
	    )
	    (cont_char_2 = ",") 
	    when(((geometry == "line") || !nth(3 entry)) 
		(cont_char_2 = "")
	    ) 
	    when((length(caddr(entry)) > 0) 
		fprintf(port "%s {  \"objType\":%L, \"geometry\":%L,\n" ind_str_2 
		    car(entry) geometry
		) 
		if((geometry == "line") then 
		    (geo_type = "path") else 
		    (geo_type = "boundary")
		) 
		fprintf(port "%s    \"%s\":[\n" ind_str_2 geo_type) 
		TBX_LIBUTIL_JSON_Write_Pathes(port 
		    (ind + 5) 
		    caddr(entry)
		)
		fprintf(port "%s    ]%s\n" ind_str_2 cont_char_2) 
		when(((geometry != "line") && nth(3 entry)) 
		    fprintf(port "%s    \"cutout\":[\n" ind_str_2) 
		    TBX_LIBUTIL_JSON_Write_Pathes(port 
			(ind + 5) 
			nth(3 entry)
		    ) 
		    fprintf(port "%s    ]\n" ind_str_2)
		) 
		fprintf(port "%s }%s\n" ind_str_2 cont_char)
	    )
	)
    )
)
procedure(TBX_LIBUTIL_JSON_Write_Pathes(port ind geo_data) 
    let((format_str ind_str_1 ind_str_2 cnt cont_char
	    path_str
	) 
	(format_str = strcat("%-" 
		sprintf(nil "%d" ind) "s"
	    )) 
	(ind_str_1 = sprintf(nil format_str " ")) 
	(ind_str_2 = strcat(ind_str_1 "   ")) 
	(cnt = 0)
	(cont_char = ",") 
	foreach(entry geo_data 
	    ++cnt 
	    when((cnt == length(geo_data)) 
		(cont_char = "")
	    ) 
	    (path_str = TBX_LIBUTIL_JSON_Format_Path(entry))
	    fprintf(port "%s %s%s\n" ind_str_2 path_str cont_char)
	)
    )
)
procedure(TBX_LIBUTIL_JSON_Write_Views(port ind canvas_info view_order) 
    let((format_str ind_str_1 ind_str_2 cnt cont_char) 
	(format_str = strcat("%-" 
		sprintf(nil "%d" ind) "s"
	    )) 
	(ind_str_1 = sprintf(nil format_str " ")) 
	(ind_str_2 = strcat(ind_str_1 "   ")) 
	(cnt = 0)
	(cont_char = ",") 
	foreach(view view_order 
	    ++cnt 
	    when((cnt == length(canvas_info)) 
		(cont_char = "")
	    ) 
	    when((canvas_info[view]->bBox) 
		fprintf(port "%s{  \"name\":%L,\n" ind_str_2 view) 
		fprintf(port "%s   \"bBox\":%s,\n" ind_str_2 
		    TBX_LIBUTIL_JSON_Format_Box((canvas_info[view]->bBox))
		) 
		fprintf(port "%s   \"color\":%L,\n" ind_str_2 
		    (canvas_info[view]->color)
		) 
		fprintf(port "%s   \"graphicData:\":[\n" ind_str_2)
		TBX_LIBUTIL_JSON_Write_Graphics(port 
		    (ind + 5) 
		    (canvas_info[view]->graphicData)
		) 
		fprintf(port "%s   ]\n" ind_str_2) 
		fprintf(port "%s}%s\n" ind_str_2 cont_char)
	    )
	)
    )
)
procedure(TBX_MATH_Add_Vector(vec1 arg) 
    let((new_vec vec_list) 
	(new_vec = vec1) 
	when((type(arg) == 'list) 
	    if(((length(arg) == 2) && atom(car(arg)) && atom(cadr(arg))) then 
		(vec_list = list(arg)) else 
		(vec_list = arg)
	    )
	) 
	foreach(vec vec_list 
	    (new_vec = ((car(new_vec) + car(vec)):(cadr(new_vec) + cadr(vec))))
	) new_vec
    )
)
procedure(TBX_MATH_Calculate_Intersection(el1 el2) 
    let((isCircle1 isCircle2 start end a
	    b c d a1 b1
	    c1 a2 b2 c2 r
	    r1 r2 center x0 y0
	    x1 y1 x2 y2 denom
	    radic mode xi1 yi1 xi2
	    yi2 result
	) 
	when(caddr(el1) 
	    (isCircle1 = t)
	) 
	when(caddr(el2) 
	    (isCircle2 = t)
	) 
	cond(((!isCircle1 && !isCircle2) 
		(start = car(el1)) 
		(end = cadr(el1)) 
		(a1 = (cadr(start) - cadr(end))) 
		(b1 = (car(end) - car(start)))
		(c1 = ((car(end) * cadr(start)) - (car(start) * cadr(end)))) 
		(start = car(el2)) 
		(end = cadr(el2)) 
		(a2 = (cadr(start) - cadr(end))) 
		(b2 = (car(end) - car(start)))
		(c2 = ((car(end) * cadr(start)) - (car(start) * cadr(end)))) 
		(mode = 'line_line)
	    ) 
	    ((!isCircle1 && isCircle2) 
		(start = car(el1)) 
		(end = cadr(el1)) 
		(a = (cadr(start) - cadr(end))) 
		(b = (car(end) - car(start)))
		(c = ((car(end) * cadr(start)) - (car(start) * cadr(end)))) 
		(center = caddr(el2)) 
		(r = (axlDistance 
			car(el2) center
		    )) 
		(x0 = car(center)) 
		(y0 = cadr(center))
		(d = (c - (a * x0) - (b * y0))) 
		(mode = 'line_circle)
	    ) 
	    ((isCircle1 && !isCircle2) 
		(center = caddr(el1)) 
		(r = (axlDistance 
			car(el1) center
		    )) 
		(x0 = car(center)) 
		(y0 = cadr(center))
		(start = car(el2)) 
		(end = cadr(el2)) 
		(a = (cadr(start) - cadr(end))) 
		(b = (car(end) - car(start))) 
		(c = ((car(end) * cadr(start)) - (car(start) * cadr(end))))
		(d = (c - (a * x0) - (b * y0))) 
		(mode = 'line_circle)
	    ) 
	    ((isCircle1 && isCircle2) 
		(r1 = (axlDistance 
			car(el1) 
			caddr(el1)
		    )) 
		(center = caddr(el1)) 
		(x1 = car(center)) 
		(y1 = cadr(center))
		(r2 = (axlDistance 
			car(el2) 
			caddr(el2)
		    )) 
		(center = caddr(el2)) 
		(x2 = car(center)) 
		(y2 = cadr(center)) 
		(a = (2 * (x2 - x1)))
		(b = (2 * (y2 - y1))) 
		(c = (((r1**2) - (x1**2) - (y1**2) - (r2**2)) + (x2**2) + (y2**2))) 
		(d = (c - (a * x2) - (b * y2))) 
		(r = r2) 
		(x0 = x2)
		(y0 = y2) 
		(mode = 'line_circle)
	    )
	) 
	caseq(mode 
	    (line_line 
		(denom = ((a1 * b2) - (a2 * b1))) 
		when((abs(denom) < 1.0) 
		    (denom = TBX_MATH_Round(denom))
		) 
		if((denom == 0.0) then 
		    (result = nil) else 
		    (xi1 = (((c1 * b2) - (c2 * b1)) / denom))
		    (yi1 = (((a1 * c2) - (a2 * c1)) / denom)) 
		    (result = list((xi1:yi1)))
		)
	    ) 
	    (line_circle 
		(denom = ((a**2) + (b**2))) 
		(radic = (((r**2) * ((a**2) + (b**2))) - (d**2))) 
		when((abs(radic) < 1.0) 
		    (radic = TBX_MATH_Round(radic))
		) 
		cond(((radic < 0.0) 
			(result = nil)
		    ) 
		    ((radic == 0.0) 
			(xi1 = (x0 + ((a * d) / denom))) 
			(yi1 = (y0 + ((b * d) / denom))) 
			(result = list((xi1:yi1)))
		    ) 
		    (t 
			(xi1 = (x0 + (((a * d) + (b * sqrt(radic))) / denom))) 
			(yi1 = (y0 + (((b * d) - (a * sqrt(radic))) / denom))) 
			(xi2 = (x0 + (((a * d) - (b * sqrt(radic))) / denom))) 
			(yi2 = (y0 + (((b * d) + (a * sqrt(radic))) / denom)))
			(result = list((xi1:yi1) 
				(xi2:yi2)
			    ))
		    )
		)
	    )
	)
	result
    )
)
procedure(TBX_MATH_Get_Angle_Between_Vectors(v1 v2) 
    let((PI v2_angle v1_angle diff_angle) 
	(PI = (defMathConstants('mymathconst)->PI)) 
	(v2_angle = atan2(cadr(v2) 
		car(v2)
	    )) 
	(v1_angle = atan2(cadr(v1) 
		car(v1)
	    )) 
	(diff_angle = (v2_angle - v1_angle))
	(diff_angle = ((diff_angle / 2 / PI) * 360.0)) 
	when((abs(diff_angle) > 180.0) 
	    if((diff_angle < 0.0) then 
		(diff_angle = (360.0 + diff_angle)) else 
		(diff_angle = (diff_angle - 360.0))
	    )
	) diff_angle
    )
)
procedure(TBX_MATH_Get_Sign(fnum) 
    let((sign_value) 
	(fnum = (fnum * 1.0)) 
	if((fnum >= 0) then 
	    (sign_value = 1) else 
	    (sign_value = -1)
	) sign_value
    )
)
procedure(TBX_MATH_Get_Vector(from to) 
    let((vec_x vec_y) 
	(vec_x = (car(to) - car(from))) 
	(vec_y = (cadr(to) - cadr(from))) 
	(vec_x:vec_y)
    )
)
procedure((TBX_MATH_Get_Vector_Angle vec \@optional ccw) 
    let((PI angle) 
	(PI = (defMathConstants('mymathconst)->PI)) 
	(angle = atan2(cadr(vec) 
		car(vec)
	    )) 
	(angle = ((angle / 2 / PI) * 360.0)) 
	when(ccw 
	    (angle = TBX_MATH_Normalize_Angle(angle))
	)
	angle
    )
)
procedure(TBX_MATH_Get_Vector_Size(vec) 
    let((size) 
	(size = (axlDistance 
		(car(vec):cadr(vec)) 
		(0.0:0.0)
	    )) size
    )
)
procedure(TBX_MATH_Normalize_Angle(angle) 
    let((new_angle factor) 
	(factor = 1.0) 
	(new_angle = angle) 
	when((new_angle < 0) 
	    (factor = -1.0)
	) 
	(new_angle = abs(new_angle))
	(new_angle = (new_angle - (floor((new_angle / 360.0)) * 360.0))) 
	(new_angle = (new_angle * factor)) 
	(new_angle = round(new_angle)) 
	when((new_angle < 0) 
	    (new_angle = (360.0 + new_angle))
	) new_angle
    )
)
procedure((TBX_MATH_Round data \@optional mode acc) 
    let((design_accuracy new_accuracy factor return_data int_value
	    dec_value
	) 
	(design_accuracy = cadr((axlDBGetDesignUnits))) 
	(new_accuracy = design_accuracy) 
	when((mode && acc) 
	    case(mode 
		("absolute" 
		    (new_accuracy = acc)
		) 
		("reduce" 
		    (new_accuracy = (design_accuracy - acc)) 
		    when((new_accuracy < 0) 
			(new_accuracy = 0)
		    )
		) 
		(t 
		    printf("Warning: Unknown rounding mode %L\n" mode) 
		    (new_accuracy = design_accuracy)
		)
	    )
	) 
	(factor = ((10**new_accuracy) * 1.0))
	cond(((eq(type(data) 
			'flonum
		    ) || eq(type(data) 
			'fixnum
		    )) 
		(int_value = int(data)) 
		(dec_value = (data - int_value)) 
		(dec_value = (dec_value * factor)) 
		(dec_value = round(dec_value))
		(dec_value = (dec_value / factor)) 
		(return_data = (int_value + dec_value))
	    ) 
	    (eq(type(data) 
		    'list
		) 
		foreach(entry data 
		    (int_value = int(entry)) 
		    (dec_value = (entry - int_value)) 
		    (dec_value = (dec_value * factor))
		    (dec_value = round(dec_value)) 
		    (dec_value = (dec_value / factor)) 
		    (return_data = cons((int_value + dec_value) return_data))
		) 
		(return_data = reverse(return_data))
	    )
	) return_data
    )
)
procedure((TBX_MATH_Transform_Vector vec \@key 
	(angle 0.0) 
	(scale 1.0)
	size
    ) 
    let((new_vec cur_size factor) 
	(new_vec = vec) 
	when(((type(angle) == 'flonum) || ((type(angle) == 'fixnum) && (angle > 0.0))) 
	    (new_vec = (axlGeoRotatePt angle new_vec 
		    (0.0:0.0)
		))
	) 
	when(((type(scale) == 'flonum) || ((type(scale) == 'fixnum) && (scale != 1.0))) 
	    (new_vec = ((scale * car(new_vec)):(scale * cadr(new_vec))))
	) 
	when(((type(size) == 'flonum) || (type(size) == 'fixnum)) 
	    (cur_size = (axlDistance new_vec 
		    (0.0:0.0)
		)) 
	    (factor = (size / cur_size)) 
	    (new_vec = ((factor * car(new_vec)):(factor * cadr(new_vec))))
	)
	new_vec
    )
)
procedure(TBX_MFGCOLLECT_Callback(fh) 
    let((cell tmp_list input_file output_file port
	    data result FORM_FILE fid dir_name
	) 
	case((fh->curField) 
	    ("run" 
		(tbx_mfgcollect_data->customvarDef = TBX_MFGCOLLECT_Get_Custom_Variables((tbx_mfgcollect_data->options))) 
		(tbx_mfgcollect_data->rules = TBX_MFGCOLLECT_Extract_Grid_Data(t)) 
		TBX_MFGCOLLECT_Run((tbx_mfgcollect_data->rules) 
		    (tbx_mfgcollect_data->variables)
		) 
		TBX_MFGCOLLECT_Save_Config((tbx_mfgcollect_data->rules) 
		    (tbx_mfgcollect_data->variables) 
		    (tbx_mfgcollect_data->options) nil
		)
	    ) 
	    ("grid" 
		caseq((fh->event) 
		    (rightpopup 
			case((fh->curValue) 
			    ("add_row" 
				((tbx_mfgcollect_data->gridRows)->rules = (((tbx_mfgcollect_data->gridRows)->rules) + 1)) 
				(axlFormGridInsertRows fh "grid" 
				    ((tbx_mfgcollect_data->gridRows)->rules) 1
				) 
				(tmp_list = list("" "" "" "" "")) 
				for(i 1 5 
				    (cell = (axlFormGridNewCell)) 
				    (cell->col = i)
				    (cell->row = ((tbx_mfgcollect_data->gridRows)->rules)) 
				    (cell->value = nth((i - 1) tmp_list)) 
				    (axlFormSetField fh "grid" cell)
				)
			    ) 
			    ("delete_row" 
				if((((tbx_mfgcollect_data->gridRows)->rules) >= 2) then 
				    (axlFormGridDeleteRows fh "grid" 
					(fh->row) 1
				    ) 
				    ((tbx_mfgcollect_data->gridRows)->rules = (((tbx_mfgcollect_data->gridRows)->rules) - 1)) else
				    (tmp_list = list("" "" "" "" "")) 
				    for(i 1 5 
					(cell = (axlFormGridNewCell)) 
					(cell->col = i)
					(cell->row = 1) 
					(cell->value = nth((i - 1) tmp_list)) 
					(axlFormSetField fh "grid" cell)
				    )
				) 
				(axlFormGridUpdate fh "grid")
			    )
			) 
			(axlFormGridUpdate fh "grid")
		    ) 
		    (change 
			when((((fh->col) == 2) || ((fh->col) == 6)) 
			    (cell = (axlFormGridNewCell)) 
			    (cell->col = (fh->col)) 
			    (cell->row = (fh->row)) 
			    (dir_name = ((axlFormGridGetCell fh "grid" cell)->value))
			    (dir_name = (axlOSSlash dir_name)) 
			    when(dir_name 
				(cell = (axlFormGridNewCell)) 
				(cell->col = (fh->col)) 
				(cell->row = (fh->row)) 
				(cell->value = dir_name)
				(axlFormSetField fh "grid" cell) 
				(axlFormGridUpdate fh "grid")
			    )
			)
		    )
		)
	    ) 
	    ("define_variables" 
		(FORM_FILE = TBX_FORM_Get_Name((tbx_mfgcollect_data->licCheck) "mfgcollect_vardef")) 
		(fid = (axlFormCreate 
			gensym("tbxmfgcollectvardef") FORM_FILE 
			'(e outer) 
			'TBX_MFGCOLLECT_VDEF_Form_Action
			t nil
		    )) 
		TBX_FORM_Init_Header(fid "Licensed for " 
		    (tbx_mfgcollect_data->licCheck) 
		    (tbx_mfgcollect_data->version)
		) 
		((tbx_mfgcollect_data->formHandle)->vardef = fid)
		(axlFormDisplay fid) 
		(axlFormSetField fid "cv_source_cpm" 
		    ((tbx_mfgcollect_data->options)->customvarSourceCpm)
		) 
		(axlFormSetField fid "cv_source_local" 
		    ((tbx_mfgcollect_data->options)->customvarSourceLocal)
		) 
		if(zerop(length((tbx_mfgcollect_data->variables))) then 
		    ((tbx_mfgcollect_data->gridRows)->vardef = 1) else 
		    ((tbx_mfgcollect_data->gridRows)->vardef = length((tbx_mfgcollect_data->variables)))
		) 
		(axlFormGridReset fid "grid")
		TBX_MFGCOLLECT_VDEF_Init_Grid_Cols() 
		TBX_MFGCOLLECT_VDEF_Init_Grid_Rows() 
		(axlFormGridUpdate fid "grid") 
		(axlFormGridEvents fid "grid" 
		    list('cellselect 
			'change 
			'rightpopup
		    )
		) 
		TBX_FORM_Delete((tbx_mfgcollect_data->licCheck) FORM_FILE)
	    ) 
	    ("save_config" 
		(output_file = (axlDMFileBrowse "ALLEGRO_TEXT" t)) 
		when(output_file 
		    (tbx_mfgcollect_data->rules = TBX_MFGCOLLECT_Extract_Grid_Data(t)) 
		    TBX_MFGCOLLECT_Save_Config((tbx_mfgcollect_data->rules) 
			(tbx_mfgcollect_data->variables) 
			(tbx_mfgcollect_data->options) output_file
		    )
		)
	    )
	    ("load_config" 
		(input_file = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
		when(input_file 
		    (port = infile(input_file)) 
		    (data = car(lineread(port))) 
		    close(port) 
		    (result = TBX_MFGCOLLECT_Parse_Config(data))
		    (tbx_mfgcollect_data->rules = car(result)) 
		    (tbx_mfgcollect_data->variables = cadr(result)) 
		    (tbx_mfgcollect_data->options = caddr(result)) 
		    if(zerop(length((tbx_mfgcollect_data->rules))) then 
			((tbx_mfgcollect_data->gridRows)->rules = 1) else 
			((tbx_mfgcollect_data->gridRows)->rules = length((tbx_mfgcollect_data->rules)))
		    ) 
		    if(zerop(length((tbx_mfgcollect_data->variables))) then 
			((tbx_mfgcollect_data->gridRows)->vardef = 1) else 
			((tbx_mfgcollect_data->gridRows)->vardef = length((tbx_mfgcollect_data->variables)))
		    )
		    (axlFormGridReset fh "grid") 
		    TBX_MFGCOLLECT_Init_Grid_Cols() 
		    TBX_MFGCOLLECT_Init_Grid_Rows() 
		    (axlFormGridUpdate fh "grid") 
		    (axlFormGridEvents fh "grid" 
			list('cellselect 
			    'change 
			    'rightpopup
			)
		    )
		)
	    ) 
	    ("done" 
		(tbx_mfgcollect_data->rules = TBX_MFGCOLLECT_Extract_Grid_Data(t)) 
		when(((tbx_mfgcollect_data->formHandle)->vardef) 
		    printf("Extracting data from Variables grid\n") 
		    (tbx_mfgcollect_data->variables = TBX_MFGCOLLECT_VDEF_Extract_Grid_Data(t))
		) 
		printf("Saving data to design\n") 
		TBX_MFGCOLLECT_Save_Config((tbx_mfgcollect_data->rules) 
		    (tbx_mfgcollect_data->variables) 
		    (tbx_mfgcollect_data->options) nil
		)
		TBX_FORM_Done(fh nil)
	    ) 
	    ("cancel" 
		TBX_FORM_Cancel(fh nil)
	    ) 
	    ("my_help" 
		(axlShell "tbx help mfgcollect")
	    )
	)
    )
)
procedure(TBX_MFGCOLLECT_Extract_Grid_Data(valid_rows_only) 
    let((grid_info cell value tmp_list) 
	(grid_info = list()) 
	for(r 1 
	    ((tbx_mfgcollect_data->gridRows)->rules) 
	    (tmp_list = list()) 
	    for(c 1 6 
		(cell = (axlFormGridNewCell)) 
		(cell->row = r)
		(cell->col = c) 
		(value = ((axlFormGridGetCell 
			    ((tbx_mfgcollect_data->formHandle)->main) "grid" cell
			)->value)) 
		(value = TBX_MFGCOLLECT_Validate_Input(value "string" "asIs")) 
		(tmp_list = cons(value tmp_list))
	    )
	    (tmp_list = reverse(tmp_list)) 
	    if(valid_rows_only then 
		when((car(tmp_list) && cadr(tmp_list) && caddr(tmp_list) && nth(3 tmp_list) && 
			nth(4 tmp_list) && 
			nth(5 tmp_list)) 
		    (grid_info = cons(tmp_list grid_info))
		) else 
		(grid_info = cons(tmp_list grid_info))
	    )
	) 
	(grid_info = reverse(grid_info)) grid_info
    )
)
procedure(TBX_MFGCOLLECT_Get_Custom_Variables(options) 
    let((local_file1 local_file2 local_data cpm_file cpm_data
	    cvdef variable_name
	) 
	(cvdef = makeTable("cvdef_table_data" nil)) 
	when((options->customvarSourceLocal) 
	    (local_file1 = strcat(getWorkingDir() "/customvar.cfg")) 
	    (local_file2 = strcat(getWorkingDir() "../customvar.cfg")) 
	    cond(((isFile(local_file1) && isFile(local_file2)) 
		    (local_data = TBX_CUSTOMVAR_Read_Local_Data(local_file1))
		) 
		((!isFile(local_file1) && isFile(local_file2)) 
		    (local_data = TBX_CUSTOMVAR_Read_Local_Data(local_file2))
		) 
		(t 
		    (local_data = TBX_CUSTOMVAR_Read_Local_Data(local_file1))
		)
	    )
	) 
	when((options->customvarSourceCpm) 
	    (cpm_file = TBX_CPM_Determine_Project_File(t)) 
	    (cpm_data = TBX_CUSTOMVAR_Read_Cpm_Data(cpm_file))
	) 
	foreach(vd local_data 
	    if((cadr(vd) == "BASE") then 
		(variable_name = car(vd)) else 
		(variable_name = strcat(car(vd) "|" 
			cadr(vd)
		    ))
	    ) 
	    (cvdef[upperCase(variable_name)] = caddr(vd))
	)
	foreach(vd cpm_data 
	    if((cadr(vd) == "BASE") then 
		(variable_name = car(vd)) else 
		(variable_name = strcat(car(vd) "|" 
			cadr(vd)
		    ))
	    ) 
	    (cvdef[upperCase(variable_name)] = caddr(vd))
	) cvdef
    )
)
procedure(TBX_MFGCOLLECT_Get_Pattern_Tags(str regxp_pattern) 
    let((pattern_tag) 
	declare(pattern_tag[10]) 
	rexCompile(regxp_pattern) 
	rexExecute(str) 
	for(i 1 9 
	    (pattern_tag[i] = rexSubstitute(sprintf(nil "%s%d" 
			symbolToString('\\) i
		    )
		))
	)
	(pattern_tag[0] = rexSubstitute("\\0")) pattern_tag
    )
)
procedure(TBX_MFGCOLLECT_Init() 
    unless(boundp('tbx_mfgcollect_data) 
	iliDefstruct('defstruct(tbx_mfgcollect_data_struct formHandle version customvarDef licCheck
		    gridRows options rules variables
		)
	) 
	defvar(tbx_mfgcollect_data nil)
    ) 
    if(!tbx_mfgcollect_data then 
	(tbx_mfgcollect_data = (make_tbx_mfgcollect_data_struct ?licCheck nil ?formHandle 
		ncons(nil)
		?gridRows 
		ncons(nil) ?version nil ?customvarDef
		nil ?options nil ?rules nil
		?variables nil
	    )) else 
	(tbx_mfgcollect_data->licCheck = nil)
	(tbx_mfgcollect_data->formHandle = ncons(nil)) 
	(tbx_mfgcollect_data->gridRows = ncons(nil)) 
	(tbx_mfgcollect_data->version = nil) 
	(tbx_mfgcollect_data->customvarDef = nil) 
	(tbx_mfgcollect_data->options = nil)
	(tbx_mfgcollect_data->rules = nil) 
	(tbx_mfgcollect_data->variables = nil)
    ) t
)
procedure(TBX_MFGCOLLECT_Init_Grid_Cols() 
    let((p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 6) 
	(p->popup = "mode_popup")
	(p->fieldLength = 10) 
	(p->headText = "Mode") 
	(p->scriptLabel = "grid_mode") 
	(axlFormGridInsertCol 
	    ((tbx_mfgcollect_data->formHandle)->main) "grid" p
	) 
	(p = (make_formGridCol))
	(p->fieldType = 'STRING) 
	(p->colWidth = 6) 
	(p->fieldLength = 10) 
	(p->headText = "Dir") 
	(p->scriptLabel = "grid_source_dir")
	(axlFormGridInsertCol 
	    ((tbx_mfgcollect_data->formHandle)->main) "grid" p
	) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 6) 
	(p->fieldLength = 1024)
	(p->headText = "Ext.") 
	(p->scriptLabel = "grid_file_extension") 
	(axlFormGridInsertCol 
	    ((tbx_mfgcollect_data->formHandle)->main) "grid" p
	) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING)
	(p->colWidth = 15) 
	(p->fieldLength = 1024) 
	(p->headText = "Match") 
	(p->scriptLabel = "grid_file_match") 
	(axlFormGridInsertCol 
	    ((tbx_mfgcollect_data->formHandle)->main) "grid" p
	)
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 25) 
	(p->fieldLength = 1024) 
	(p->headText = "Rename to")
	(p->scriptLabel = "grid_rename_to") 
	(axlFormGridInsertCol 
	    ((tbx_mfgcollect_data->formHandle)->main) "grid" p
	) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 6)
	(p->fieldLength = 1024) 
	(p->headText = "Dest.") 
	(p->scriptLabel = "grid_move_to") 
	(axlFormGridInsertCol 
	    ((tbx_mfgcollect_data->formHandle)->main) "grid" p
	)
    )
)
procedure(TBX_MFGCOLLECT_Init_Grid_Rows() 
    if(zerop(((tbx_mfgcollect_data->gridRows)->rules)) then 
	(axlFormGridInsertRows 
	    ((tbx_mfgcollect_data->formHandle)->main) "grid" 0 1
	) 
	((tbx_mfgcollect_data->gridRows)->rules = 1) else
	(axlFormGridInsertRows 
	    ((tbx_mfgcollect_data->formHandle)->main) "grid" 0 
	    ((tbx_mfgcollect_data->gridRows)->rules)
	)
    ) 
    (axlFormGridSetBatch 
	((tbx_mfgcollect_data->formHandle)->main) "grid" 
	'TBX_MFGCOLLECT_Init_Grid_Rows_Callback nil
    )
)
procedure(TBX_MFGCOLLECT_Init_Grid_Rows_Callback(pvt_data) 
    let((cell row_num rule_info source_dir destination_dir
	    file_ext match_str action_str mode
	) 
	(pvt_data = pvt_data) 
	(row_num = 1) 
	if((length((tbx_mfgcollect_data->rules)) >= 1) then 
	    (rule_info = (tbx_mfgcollect_data->rules)) else 
	    (rule_info = list(list("" "" "" "" "")))
	) 
	foreach(entry rule_info 
	    (mode = car(entry)) 
	    (source_dir = cadr(entry)) 
	    (file_ext = caddr(entry))
	    (match_str = nth(3 entry)) 
	    (action_str = nth(4 entry)) 
	    (destination_dir = nth(5 entry)) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 1)
	    (cell->row = row_num) 
	    (cell->value = mode) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 2)
	    (cell->row = row_num) 
	    (cell->value = source_dir) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 3)
	    (cell->row = row_num) 
	    (cell->value = file_ext) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 4)
	    (cell->row = row_num) 
	    (cell->value = match_str) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 5)
	    (cell->row = row_num) 
	    (cell->value = action_str) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 6)
	    (cell->row = row_num) 
	    (cell->value = destination_dir) 
	    (axlFormGridBatch cell) 
	    ++row_num
	)
	t
    )
)
procedure((TBX_MFGCOLLECT_Main \@optional arg) 
    let((lic_check_result fid FORM_FILE VERSION_STR FC_FEATURE
	    FC_VERSION SUB_VERSION att data result
	    info_file port ini_file
	) 
	(FC_FEATURE = "POSTPROC") 
	(FC_VERSION = "17.1") 
	(SUB_VERSION = "02") 
	(VERSION_STR = sprintf(nil "Mfg Collector %s (C)2017" FC_VERSION))
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./mfgcollector_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Mfg Collector information:\n") 
		fprintf(port "=============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  reset   : Deletes configuration from database. Default settings will be used after launch\n") 
		fprintf(port "  version : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port)
		(axlUIViewFileCreate info_file "Mfg Collector: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    ((arg && (lowerCase(arg) == "reset")) 
		when((axlUIYesNo "Delete configuration from database?" nil 
			'no
		    ) 
		    printf("Deleting configuration from database...\n") 
		    (axlDeleteAttachment "tbx_mfgcollect")
		)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    TBX_MFGCOLLECT_Init() 
		    TBX_UTIL_Migrate("flw_filerename" "tbx_mfgcollect") 
		    (tbx_mfgcollect_data->licCheck = lic_check_result) 
		    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "mfgcollect_main"))
		    (fid = (axlFormCreate 
			    gensym("tbxmfgcollectmain") FORM_FILE 
			    '(e outer) 
			    'TBX_MFGCOLLECT_Callback
			    t nil
			)) 
		    TBX_FORM_Init_Header(fid "Licensed for " lic_check_result VERSION_STR) 
		    ((tbx_mfgcollect_data->formHandle)->main = fid) 
		    (tbx_mfgcollect_data->version = VERSION_STR) 
		    (axlFormDisplay fid)
		    (att = (axlGetAttachment "tbx_mfgcollect" 
			    'string
			)) 
		    if(att then 
			(data = car(linereadstring((att->data)))) else 
			(ini_file = car(TBX_UTIL_Search_Config("mfgcollect.ini" nil nil ?includeWorkDir t)))
			when(ini_file 
			    printf("Reading defaults from %L\n" ini_file) 
			    (data = TBX_UTIL_File_Lineread(ini_file))
			)
		    ) 
		    (result = TBX_MFGCOLLECT_Parse_Config(data)) 
		    (tbx_mfgcollect_data->rules = car(result)) 
		    (tbx_mfgcollect_data->variables = cadr(result))
		    (tbx_mfgcollect_data->options = caddr(result)) 
		    unless((tbx_mfgcollect_data->options) 
			(tbx_mfgcollect_data->options = ncons(nil))
		    ) 
		    (tbx_mfgcollect_data->customvarDef = TBX_MFGCOLLECT_Get_Custom_Variables((tbx_mfgcollect_data->options))) 
		    if(zerop(length((tbx_mfgcollect_data->rules))) then 
			((tbx_mfgcollect_data->gridRows)->rules = 1) else 
			((tbx_mfgcollect_data->gridRows)->rules = length((tbx_mfgcollect_data->rules)))
		    ) 
		    (axlFormGridReset fid "grid")
		    TBX_MFGCOLLECT_Init_Grid_Cols() 
		    TBX_MFGCOLLECT_Init_Grid_Rows() 
		    (axlFormGridUpdate fid "grid") 
		    (axlFormGridEvents fid "grid" 
			list('cellselect 
			    'change 
			    'rightpopup
			)
		    ) 
		    TBX_FORM_Delete(lic_check_result FORM_FILE)
		)
	    )
	)
    )
)
procedure(TBX_MFGCOLLECT_Parse_Config(data) 
    let((var_info result rule_info options) 
	(options = ncons(nil)) 
	foreach(entry data 
	    caseq(car(entry) 
		(rules 
		    foreach(rl 
			cdr(entry) 
			if((length(rl) == 5) then 
			    (rule_info = cons(cons("move" rl) rule_info)) else 
			    (rule_info = cons(rl rule_info))
			)
		    ) 
		    (rule_info = reverse(rule_info))
		) 
		(variables 
		    (var_info = cdr(entry))
		) 
		(options 
		    (options = cadr(entry))
		) 
		(t t)
	    )
	) 
	(result = list(rule_info var_info options)) result
    )
)
procedure(TBX_MFGCOLLECT_Run(rule_info var_info) 
    let((source_dir target_dir target_dir_fp ext_str ext_regxp
	    dir_files name_str name_regxp new_name result
	    file_name file_ext file_namewext file_info action_str
	    cur_dir source_dir_fp old_file_fp new_file_fp ok_match
	    pattern_tag_info old_file_simple new_file_simple mode
	) 
	foreach(rle rule_info 
	    (ok_match = nil) 
	    (mode = car(rle)) 
	    (source_dir = cadr(rle))
	    (source_dir_fp = (axlOSSlash 
		    simplifyFilename(strcat(getWorkingDir() "/" source_dir))
		)) 
	    (ext_str = caddr(rle)) 
	    (name_str = nth(3 rle)) 
	    (action_str = nth(4 rle)) 
	    (target_dir = nth(5 rle))
	    unless(isDir(target_dir) 
		printf("Creating target directory %s\n" target_dir) 
		(cur_dir = ".") 
		foreach(dn 
		    parseString(target_dir "/") 
		    (cur_dir = strcat(cur_dir "/" dn)) 
		    cond((((dn == ".") || (dn == "..")) t) 
			(!isDir(cur_dir) 
			    createDir(cur_dir)
			)
		    )
		)
	    ) 
	    (target_dir_fp = (axlOSSlash 
		    simplifyFilename(strcat(getWorkingDir() "/" target_dir))
		)) 
	    if(isDir(source_dir_fp) then 
		(dir_files = getDirFiles(source_dir_fp)) 
		(dir_files = remove("." dir_files)) 
		(dir_files = remove(".." dir_files))
		(file_info = list()) 
		foreach(fle dir_files 
		    (result = (axlDMFileParts fle)) 
		    (file_name = cadr(result)) 
		    (file_namewext = caddr(result))
		    (file_ext = nth(3 result)) 
		    when(file_ext 
			(file_info = cons(list(file_name file_ext file_namewext) file_info))
		    )
		) 
		(file_info = reverse(file_info)) 
		(ext_regxp = TBX_UTIL_Regex_From_Shell(ext_str t)) 
		(name_regxp = TBX_UTIL_Regex_From_Shell(name_str t t))
		foreach(entry file_info 
		    (file_name = car(entry)) 
		    (file_ext = cadr(entry)) 
		    (file_namewext = caddr(entry))
		    when((rexMatchp(ext_regxp file_ext) && 
			    rexMatchp(name_regxp file_name)) 
			(ok_match = t) 
			(pattern_tag_info = TBX_MFGCOLLECT_Get_Pattern_Tags(file_name name_regxp)) 
			(new_name = TBX_MFGCOLLECT_Substitute_Pattern_Tags(action_str pattern_tag_info)) 
			(new_name = TBX_MFGCOLLECT_Substitute_Variables(new_name var_info))
			(old_file_fp = strcat(source_dir_fp "/" file_namewext)) 
			(new_file_fp = strcat(target_dir_fp "/" new_name)) 
			rexCompile(strcat(getWorkingDir() "/")) 
			(old_file_simple = rexReplace(old_file_fp "" 0)) 
			(new_file_simple = rexReplace(new_file_fp "" 0))
			when((lowerCase(old_file_fp) != lowerCase(new_file_fp)) 
			    if((mode == "copy") then 
				printf("Copying %L to %L\n" old_file_simple new_file_simple) 
				(axlOSFileCopy old_file_fp new_file_fp nil) else
				printf("Moving %L to %L\n" old_file_simple new_file_simple) 
				(axlOSFileMove old_file_fp new_file_fp)
			    )
			)
		    )
		) 
		unless(ok_match 
		    printf("Warning: No files found in directory %L with extension %L, matching file name %L\n" source_dir ext_str name_str)
		) else 
		printf("Warning: Directory %L does not exist\n" source_dir_fp)
	    )
	)
    )
)
procedure(TBX_MFGCOLLECT_Save_Config(rule_info vardef_info cmd_param file_arg) 
    let((port data_str) 
	(data_str = "(\n") 
	(data_str = sprintf(nil "%s   (rules\n" data_str)) 
	foreach(rle rule_info 
	    (data_str = sprintf(nil "%s      %L\n" data_str rle))
	) 
	(data_str = sprintf(nil "%s   )\n" data_str))
	(data_str = sprintf(nil "%s   (variables\n" data_str)) 
	foreach(var vardef_info 
	    (data_str = sprintf(nil "%s      %L\n" data_str var))
	) 
	(data_str = sprintf(nil "%s   )\n" data_str)) 
	(data_str = sprintf(nil "%s   (options\n" data_str)) 
	(data_str = sprintf(nil "%s      %L\n" data_str cmd_param))
	(data_str = sprintf(nil "%s   )\n" data_str)) 
	(data_str = sprintf(nil "%s)\n" data_str)) 
	if(file_arg then 
	    (port = outfile(file_arg "w")) 
	    if(port then 
		fprintf(port "%s" data_str) 
		close(port) else
		printf("Error: Cannot open file %s for write access\n" file_arg)
	    ) else
	    (axlDeleteAttachment "tbx_mfgcollect") 
	    when((rule_info || vardef_info || cmd_param) 
		(axlCreateAttachment "tbx_mfgcollect" nil 1 
		    'string
		    data_str
		)
	    )
	) t
    )
)
procedure(TBX_MFGCOLLECT_Substitute_Pattern_Tags(name_str pattern_tag) 
    let((test_regxp new_str) 
	(new_str = name_str) 
	for(i 1 9 
	    (test_regxp = sprintf(nil "<%d>" i)) 
	    when((rexMatchp(test_regxp name_str) && 
		    (pattern_tag[i] != "")) 
		rexCompile(test_regxp) 
		(new_str = rexReplace(new_str 
			pattern_tag[i] 0
		    ))
	    )
	) 
	(test_regxp = "<[Ff][Ii][Ll][Ee]>") 
	when((rexMatchp(test_regxp name_str) && 
		(pattern_tag[0] != "")) 
	    rexCompile(test_regxp) 
	    (new_str = rexReplace(new_str 
		    pattern_tag[0] 0
		))
	)
	new_str
    )
)
procedure(TBX_MFGCOLLECT_Substitute_Variables(name_str var_info) 
    let((test_regxp new_str var_name var_value) 
	(new_str = name_str) 
	foreach(v var_info 
	    (var_name = car(v)) 
	    (var_value = cadr(v)) 
	    (test_regxp = TBX_UTIL_Regex_From_Shell(strcat("<" var_name ">") t nil t))
	    when((rexMatchp(test_regxp name_str) && var_value) 
		rexCompile(test_regxp) 
		(new_str = rexReplace(new_str var_value 0))
	    )
	) new_str
    )
)
procedure(TBX_MFGCOLLECT_VDEF_Extract_Grid_Data(valid_rows_only) 
    let((grid_info cell value tmp_list) 
	(grid_info = list()) 
	for(r 1 
	    ((tbx_mfgcollect_data->gridRows)->vardef) 
	    (tmp_list = list()) 
	    for(c 1 2 
		(cell = (axlFormGridNewCell)) 
		(cell->row = r)
		(cell->col = c) 
		(value = ((axlFormGridGetCell 
			    ((tbx_mfgcollect_data->formHandle)->vardef) "grid" cell
			)->value)) 
		(value = TBX_MFGCOLLECT_Validate_Input(value "string" "asIs")) 
		(tmp_list = cons(value tmp_list))
	    )
	    (tmp_list = reverse(tmp_list)) 
	    if(valid_rows_only then 
		when((car(tmp_list) && cadr(tmp_list)) 
		    (grid_info = cons(tmp_list grid_info))
		) else 
		(grid_info = cons(tmp_list grid_info))
	    )
	) 
	(grid_info = reverse(grid_info)) grid_info
    )
)
procedure(TBX_MFGCOLLECT_VDEF_Form_Action(fh) 
    let((cell tmp_list var_name) 
	case((fh->curField) 
	    ("grid" 
		caseq((fh->event) 
		    (rightpopup 
			case((fh->curValue) 
			    ("add_row" 
				((tbx_mfgcollect_data->gridRows)->vardef = (((tbx_mfgcollect_data->gridRows)->vardef) + 1)) 
				(axlFormGridInsertRows fh "grid" 
				    ((tbx_mfgcollect_data->gridRows)->vardef) 1
				) 
				(tmp_list = list("" "")) 
				for(i 1 2 
				    (cell = (axlFormGridNewCell)) 
				    (cell->col = i)
				    (cell->row = ((tbx_mfgcollect_data->gridRows)->vardef)) 
				    (cell->value = nth((i - 1) tmp_list)) 
				    (axlFormSetField fh "grid" cell)
				)
			    ) 
			    ("delete_row" 
				if((((tbx_mfgcollect_data->gridRows)->vardef) >= 2) then 
				    (axlFormGridDeleteRows fh "grid" 
					(fh->row) 1
				    ) 
				    ((tbx_mfgcollect_data->gridRows)->vardef = (((tbx_mfgcollect_data->gridRows)->vardef) - 1)) else
				    (tmp_list = list("" "")) 
				    for(i 1 2 
					(cell = (axlFormGridNewCell)) 
					(cell->col = i)
					(cell->row = 1) 
					(cell->value = nth((i - 1) tmp_list)) 
					(axlFormSetField fh "grid" cell)
				    )
				) 
				(axlFormGridUpdate fh "grid")
			    )
			) 
			(axlFormGridUpdate fh "grid")
		    ) 
		    (change 
			when(onep((fh->col)) 
			    (cell = (axlFormGridNewCell)) 
			    (cell->col = 1) 
			    (cell->row = (fh->row)) 
			    (var_name = ((axlFormGridGetCell fh "grid" cell)->value))
			    (var_name = TBX_MFGCOLLECT_Validate_Input(var_name "string" "upperCaseNoSpace")) 
			    (cell = (axlFormGridNewCell)) 
			    (cell->col = 2) 
			    (cell->row = (fh->row)) 
			    if((tbx_mfgcollect_data->customvarDef)[var_name] then 
				(cell->backColor = 'button) 
				(cell->value = (tbx_mfgcollect_data->customvarDef)[var_name]) 
				(cell->noEdit = t)
				else 
				(cell->backColor = 'white) 
				(cell->value = "") 
				(cell->noEdit = nil)
			    )
			    (axlFormSetField fh "grid" cell) 
			    (axlFormGridUpdate fh "grid")
			)
		    )
		)
	    ) 
	    ("cv_source_cpm" 
		(tbx_mfgcollect_data->variables = TBX_MFGCOLLECT_VDEF_Extract_Grid_Data(t)) 
		if((fh->curValue) then 
		    ((tbx_mfgcollect_data->options)->customvarSourceCpm = t) else 
		    ((tbx_mfgcollect_data->options)->customvarSourceCpm = nil)
		) 
		(tbx_mfgcollect_data->customvarDef = TBX_MFGCOLLECT_Get_Custom_Variables((tbx_mfgcollect_data->options))) 
		(axlFormGridReset fh "grid")
		TBX_MFGCOLLECT_VDEF_Init_Grid_Cols() 
		TBX_MFGCOLLECT_VDEF_Init_Grid_Rows() 
		(axlFormGridUpdate fh "grid") 
		(axlFormGridEvents fh "grid" 
		    list('cellselect 
			'change 
			'rightpopup
		    )
		)
	    ) 
	    ("cv_source_local" 
		(tbx_mfgcollect_data->variables = TBX_MFGCOLLECT_VDEF_Extract_Grid_Data(t)) 
		if((fh->curValue) then 
		    ((tbx_mfgcollect_data->options)->customvarSourceLocal = t) else 
		    ((tbx_mfgcollect_data->options)->customvarSourceLocal = nil)
		) 
		(tbx_mfgcollect_data->customvarDef = TBX_MFGCOLLECT_Get_Custom_Variables((tbx_mfgcollect_data->options))) 
		(axlFormGridReset fh "grid")
		TBX_MFGCOLLECT_VDEF_Init_Grid_Cols() 
		TBX_MFGCOLLECT_VDEF_Init_Grid_Rows() 
		(axlFormGridUpdate fh "grid") 
		(axlFormGridEvents fh "grid" 
		    list('cellselect 
			'change 
			'rightpopup
		    )
		)
	    ) 
	    ("done" 
		(tbx_mfgcollect_data->variables = TBX_MFGCOLLECT_VDEF_Extract_Grid_Data(t)) 
		if((axlFormGetField fh "cv_source_cpm") then 
		    ((tbx_mfgcollect_data->options)->customvarSourceCpm = t) else 
		    ((tbx_mfgcollect_data->options)->customvarSourceCpm = nil)
		) 
		if((axlFormGetField fh "cv_source_local") then 
		    ((tbx_mfgcollect_data->options)->customvarSourceLocal = t) else 
		    ((tbx_mfgcollect_data->options)->customvarSourceLocal = nil)
		) 
		TBX_FORM_Done(fh nil)
		((tbx_mfgcollect_data->formHandle)->vardef = nil)
	    )
	    ("cancel" 
		TBX_FORM_Cancel(fh nil) 
		((tbx_mfgcollect_data->formHandle)->vardef = nil)
	    ) 
	    ("my_help" 
		(axlShell "tbx help postproc")
	    )
	)
    )
)
procedure(TBX_MFGCOLLECT_VDEF_Init_Grid_Cols() 
    let((p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 6) 
	(p->fieldLength = 20)
	(p->headText = "Name") 
	(p->scriptLabel = "grid_var_name") 
	(axlFormGridInsertCol 
	    ((tbx_mfgcollect_data->formHandle)->vardef) "grid" p
	) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING)
	(p->colWidth = 4) 
	(p->fieldLength = 1024) 
	(p->headText = "Value") 
	(p->scriptLabel = "grid_file_extension") 
	(axlFormGridInsertCol 
	    ((tbx_mfgcollect_data->formHandle)->vardef) "grid" p
	)
    )
)
procedure(TBX_MFGCOLLECT_VDEF_Init_Grid_Rows() 
    if(zerop(((tbx_mfgcollect_data->gridRows)->vardef)) then 
	(axlFormGridInsertRows 
	    ((tbx_mfgcollect_data->formHandle)->vardef) "grid" 0 1
	) 
	((tbx_mfgcollect_data->gridRows)->vardef = 1) else
	(axlFormGridInsertRows 
	    ((tbx_mfgcollect_data->formHandle)->vardef) "grid" 0 
	    ((tbx_mfgcollect_data->gridRows)->vardef)
	)
    ) 
    (axlFormGridSetBatch 
	((tbx_mfgcollect_data->formHandle)->vardef) "grid" 
	'TBX_MFGCOLLECT_VDEF_Init_Grid_Rows_Callback nil
    )
)
procedure(TBX_MFGCOLLECT_VDEF_Init_Grid_Rows_Callback(pvt_data) 
    let((cell row_num var_info var_name var_value) 
	(pvt_data = pvt_data) 
	(row_num = 1) 
	if((length((tbx_mfgcollect_data->variables)) >= 1) then 
	    (var_info = (tbx_mfgcollect_data->variables)) else 
	    (var_info = list(list("" "")))
	) 
	foreach(entry var_info 
	    (var_name = car(entry)) 
	    (var_value = cadr(entry)) 
	    (cell = (axlFormGridNewCell))
	    (cell->col = 1) 
	    (cell->row = row_num) 
	    (cell->value = var_name) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell))
	    (cell->col = 2) 
	    (cell->row = row_num) 
	    if((tbx_mfgcollect_data->customvarDef)[var_name] then 
		(cell->backColor = 'button) 
		(cell->value = (tbx_mfgcollect_data->customvarDef)[var_name]) 
		(cell->noEdit = t)
		else 
		(cell->backColor = 'white) 
		(cell->value = var_value) 
		(cell->noEdit = nil)
	    ) 
	    (axlFormGridBatch cell) 
	    ++row_num
	)
	t
    )
)
procedure((TBX_MFGCOLLECT_Validate_Input value type_required \@optional mode) 
    let((new_value) 
	case(type_required 
	    ("string" 
		when((value && (type(value) == 'string)) 
		    (new_value = value) 
		    rexCompile("^ *") 
		    (new_value = rexReplace(new_value "" 0)) 
		    rexCompile(" *$")
		    (new_value = rexReplace(new_value "" 0)) 
		    when(mode 
			case(mode 
			    ("lowerCaseNoSpace" 
				rexCompile(" ") 
				(new_value = rexReplace(new_value "" 0)) 
				(new_value = lowerCase(new_value))
			    ) 
			    ("upperCaseNoSpace" 
				rexCompile(" ") 
				(new_value = rexReplace(new_value "" 0)) 
				(new_value = upperCase(new_value))
			    ) 
			    ("asIs" t)
			)
		    )
		)
	    ) 
	    ("float" 
		cond(((value && (type(value) == 'string)) 
			when(atof(value) 
			    (new_value = atof(value))
			)
		    ) 
		    ((value && (type(value) == 'flonum)) 
			(new_value = value)
		    ) 
		    ((value && (type(value) == 'fixnum)) 
			(new_value = (value * 1.0))
		    )
		)
	    ) 
	    ("integer" 
		cond(((value && (type(value) == 'string)) 
			when(atoi(value) 
			    (new_value = atoi(value))
			)
		    ) 
		    ((value && (type(value) == 'flonum)) 
			(new_value = round(value))
		    ) 
		    ((value && (type(value) == 'fixnum)) 
			(new_value = value)
		    )
		)
	    )
	) new_value
    )
)
procedure(TBX_NETCOLORVIEW_Callback(form_handle) 
    let((view_name view_file color_list) 
	case((form_handle->curField) 
	    ("done" 
		(axlFinishEnterFun) 
		(axlUIPopupSet nil) 
		(axlClearDynamics) 
		(axlFormClose form_handle)
		(axlDBTransactionCommit 
		    (tbx_netcolorview_global->transMark)
		) 
		(axlVisibleUpdate t)
	    ) 
	    ("save_view" 
		(view_name = (axlStringRemoveSpaces 
			(axlFormGetField form_handle "color_view")
		    )) 
		if((view_name != "") then 
		    TBX_NETCOLORVIEW_Save_View(form_handle) 
		    (tbx_netcolorview_global->viewPath = TBX_NETCOLORVIEW_Update_Views(form_handle)) else
		    printf("Warning: Please specify a valid view name first\n")
		)
	    ) 
	    ("restore_view" 
		(view_name = (axlStringRemoveSpaces 
			(form_handle->curValue)
		    )) 
		if((view_name != "") then 
		    TBX_NETCOLORVIEW_Restore_View(form_handle 
			(tbx_netcolorview_global->viewPath)
		    ) else 
		    printf("Warning: Please specify a valid view name first\n")
		)
	    ) 
	    ("misc_action" 
		case((form_handle->curValue) 
		    ("show_contents" 
			(view_name = (axlStringRemoveSpaces 
				(axlFormGetField form_handle "color_view")
			    )) 
			(view_file = (tbx_netcolorview_global->viewPath)[view_name]) 
			when(view_file 
			    (axlUIViewFileCreate view_file 
				sprintf(nil "File: %s.ncolor" view_name) nil
			    )
			)
		    ) 
		    ("file_manager" 
			(axlShell "filemgr")
		    )
		)
	    )
	    ("global_rats" 
		(axlDBTransactionMark 
		    (tbx_netcolorview_global->transMark)
		) 
		TBX_NETCOLORVIEW_Global_Rats((form_handle->curValue))
	    ) 
	    ("global_blank" 
		(axlDBTransactionMark 
		    (tbx_netcolorview_global->transMark)
		) 
		TBX_NETCOLORVIEW_Global_Blank((form_handle->curValue))
	    ) 
	    ("global_highlight" 
		(axlDBTransactionMark 
		    (tbx_netcolorview_global->transMark)
		) 
		TBX_NETCOLORVIEW_Global_Highlight((form_handle->curValue) 
		    (tbx_netcolorview_global->colorId)
		)
	    ) 
	    ("global_dehighlight" 
		(axlDBTransactionMark 
		    (tbx_netcolorview_global->transMark)
		) 
		TBX_NETCOLORVIEW_Global_Dehighlight((form_handle->curValue))
	    ) 
	    ("highlight_color" 
		(color_list = (axlCVFColorChooserDlg 0)) 
		when(color_list 
		    (tbx_netcolorview_global->colorId = car(color_list)) 
		    (axlFormSetField form_handle "highlight_color" 
			car(color_list)
		    ) 
		    (axlVisibleUpdate t)
		)
	    )
	    ("clear_all" 
		(axlDBTransactionMark 
		    (tbx_netcolorview_global->transMark)
		) 
		TBX_NETCOLORVIEW_Visible_Rats(((axlDBGetDesign)->nets) nil) 
		TBX_DBDISPLAY_Dehighlight_By_Type(list("groups" "symbols" "nets" "pins" "vias"
			"drcs"
		    )
		) 
		(axlClearSelSet)
		(axlVisibleUpdate t)
	    ) 
	    ("myhelp" 
		TBX_HELP_Launch("netcolorview")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_NETCOLORVIEW_Global_Blank(t_mode) 
    let((net_list) 
	case(t_mode 
	    ("blank_all" 
		(net_list = ((axlDBGetDesign)->nets))
	    ) 
	    ("blank_selected" 
		if((tbx_netcolorview_global->selSet) then 
		    (net_list = (tbx_netcolorview_global->selSet)) 
		    (tbx_netcolorview_global->selSet = nil) else
		    printf("Warning: No nets selected\n")
		)
	    ) 
	    ("blank_highlighted" 
		(net_list = setof(x 
			((axlDBGetDesign)->nets) 
			(axlIsCustomColored x)
		    ))
	    ) 
	    ("blank_non_highlighted" 
		(net_list = setof(x 
			((axlDBGetDesign)->nets) 
			!(axlIsCustomColored x)
		    ))
	    )
	    ("blank_fixed" 
		(net_list = setof(x 
			((axlDBGetDesign)->nets) 
			((x->prop)->FIXED)
		    ))
	    ) 
	    ("blank_voltage" 
		(net_list = setof(x 
			((axlDBGetDesign)->nets) 
			((x->prop)->VOLTAGE)
		    ))
	    )
	) 
	when(net_list 
	    TBX_NETCOLORVIEW_Visible_Rats(net_list nil)
	) 
	(axlClearSelSet) 
	(axlDBRefreshId nil)
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_NETCOLORVIEW_Global_Dehighlight(t_mode) 
    let((net_list) 
	case(t_mode 
	    ("dehighlight_all" 
		(net_list = ((axlDBGetDesign)->nets))
	    ) 
	    ("dehighlight_selected" 
		if((tbx_netcolorview_global->selSet) then 
		    (net_list = (tbx_netcolorview_global->selSet)) 
		    (tbx_netcolorview_global->selSet = nil) else
		    printf("Warning: No nets selected\n")
		)
	    ) 
	    ("dehighlight_fixed" 
		(net_list = setof(x 
			((axlDBGetDesign)->nets) 
			((x->prop)->FIXED)
		    ))
	    ) 
	    ("dehighlight_voltage" 
		(net_list = setof(x 
			((axlDBGetDesign)->nets) 
			((x->prop)->VOLTAGE)
		    ))
	    )
	    ("dehighlight_dummy" 
		(axlClearSelSet) 
		(axlSetFindFilter ?enabled 
		    list("noall" "nets" "invisible") ?onButtons 
		    list("all")
		) 
		(axlAddSelectAll) 
		(net_list = setof(x 
			(axlGetSelSet) 
			((x->name) == "")
		    ))
	    )
	) 
	when(net_list 
	    (axlClearObjectCustomColor net_list)
	) 
	(axlClearSelSet) 
	(axlDBRefreshId nil)
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_NETCOLORVIEW_Global_Highlight(t_mode color_id) 
    let((net_list ff_en_orig ff_on_orig) 
	(ff_en_orig = cons("noall" 
		(axlGetFindFilter nil)
	    )) 
	(ff_on_orig = (axlGetFindFilter t)) 
	case(t_mode 
	    ("highlight_all" 
		(net_list = ((axlDBGetDesign)->nets))
	    ) 
	    ("highlight_selected" 
		if((tbx_netcolorview_global->selSet) then 
		    (net_list = (tbx_netcolorview_global->selSet)) 
		    (tbx_netcolorview_global->selSet = nil) else
		    printf("Warning: No nets selected\n")
		)
	    ) 
	    ("highlight_fixed" 
		(net_list = setof(x 
			((axlDBGetDesign)->nets) 
			((x->prop)->FIXED)
		    ))
	    ) 
	    ("highlight_voltage" 
		(net_list = setof(x 
			((axlDBGetDesign)->nets) 
			((x->prop)->VOLTAGE)
		    ))
	    )
	    ("highlight_dummy" 
		(axlClearSelSet) 
		(axlSetFindFilter ?enabled 
		    list("noall" "nets" "invisible") ?onButtons 
		    list("all")
		) 
		(axlAddSelectAll) 
		(net_list = setof(x 
			(axlGetSelSet) 
			((x->name) == "")
		    ))
	    )
	) 
	when(net_list 
	    (axlCustomColorObject net_list color_id)
	)
	(axlSetFindFilter ?enabled ff_en_orig ?onButtons ff_on_orig) 
	(axlClearSelSet) 
	(axlDBRefreshId nil) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_NETCOLORVIEW_Global_Rats(t_mode) 
    let((net_list) 
	case(t_mode 
	    ("rats_all" 
		(net_list = ((axlDBGetDesign)->nets))
	    ) 
	    ("rats_selected" 
		if((tbx_netcolorview_global->selSet) then 
		    (net_list = (tbx_netcolorview_global->selSet)) 
		    (tbx_netcolorview_global->selSet = nil) else
		    printf("Warning: No nets selected\n")
		)
	    ) 
	    ("rats_highlighted" 
		(net_list = setof(x 
			((axlDBGetDesign)->nets) 
			(axlIsCustomColored x)
		    ))
	    ) 
	    ("rats_fixed" 
		(net_list = setof(x 
			((axlDBGetDesign)->nets) 
			((x->prop)->FIXED)
		    ))
	    )
	    ("rats_voltage" 
		(net_list = setof(x 
			((axlDBGetDesign)->nets) 
			((x->prop)->VOLTAGE)
		    ))
	    )
	) 
	when(net_list 
	    TBX_NETCOLORVIEW_Visible_Rats(net_list t)
	) 
	(axlClearSelSet) 
	(axlDBRefreshId nil)
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_NETCOLORVIEW_Init() 
    (axlDBDisplayControl 
	'customColorEnabled t
    ) 
    (axlVisibleUpdate t) 
    unless(boundp('tbx_netcolorview_global) 
	iliDefstruct('defstruct(tbx_netcolorview_global_struct formId viewPath colorId transMark)) 
	defvar(tbx_netcolorview_global nil)
    ) 
    if(!tbx_netcolorview_global then 
	(tbx_netcolorview_global = (make_tbx_netcolorview_global_struct ?colorId nil ?formId nil
		?viewPath nil ?transMark nil
	    )) else 
	(tbx_netcolorview_global->colorId = nil)
	(tbx_netcolorview_global->formId = nil) 
	(tbx_netcolorview_global->viewPath = nil) 
	(tbx_netcolorview_global->transMark = nil)
    )
)
procedure((TBX_NETCOLORVIEW_Main \@optional arg) 
    let((lic_check_result FORM_FILE fid FC_VERSION FC_FEATURE
	    SUB_VERSION VERSION_STR info_file port rats_items
	    blank_items highlight_items dehighlight_items color_id_start ok_start_app
	) 
	(FC_FEATURE = "NETCOLORVIEW") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Net Color View %s (C)2017" FC_VERSION))
	(ok_start_app = t) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./netcolorview_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Net color view nformation:\n") 
		fprintf(port "====================================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Net Color View: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION) 
		(ok_start_app = nil)
	    )
	) 
	when(ok_start_app 
	    (lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
	    when(lic_check_result 
		(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "netcolorview_main")) 
		unless(boundp('tbxNetcolorviewMainHandle) 
		    defvar(tbxNetcolorviewMainHandle nil)
		) 
		(fid = (axlFormCreate 
			'tbxNetcolorviewMainHandle FORM_FILE 
			'(e outer) 
			'TBX_NETCOLORVIEW_Callback
			t nil
		    )) 
		when((fid && (axlOKToProceed)) 
		    TBX_NETCOLORVIEW_Init() 
		    (tbx_netcolorview_global->formId = fid) 
		    (tbx_netcolorview_global->licCheck = lic_check_result) 
		    TBX_FORM_Init_Header(fid "" lic_check_result VERSION_STR)
		    (axlFormSetField fid "include_rats" t) 
		    (axlFormSetField fid "include_colors" t) 
		    (axlFormSetField fid "mode_complete" t) 
		    (color_id_start = 1) 
		    (axlFormSetField fid "highlight_color" color_id_start)
		    (tbx_netcolorview_global->colorId = color_id_start) 
		    (rats_items = list(list("All" "rats_all") 
			    list("Selected" "rats_selected") 
			    list("Highlighted Nets" "rats_highlighted") 
			    list("Fixed Nets" "rats_fixed") 
			    list("Voltage Nets" "rats_voltage")
			)) 
		    (blank_items = list(list("All" "blank_all") 
			    list("Selected" "blank_selected") 
			    list("Highlighted Nets" "blank_highlighted") 
			    list("Non-Highlighted Nets" "blank_non_highlighted") 
			    list("Fixed Nets" "blank_fixed")
			    list("Voltage Nets" "blank_voltage")
			)) 
		    (highlight_items = list(list("All" "highlight_all") 
			    list("Selected" "highlight_selected") 
			    list("Fixed Nets" "highlight_fixed") 
			    list("Voltage Nets" "highlight_voltage") 
			    list("Dummy Nets" "highlight_dummy")
			)) 
		    (dehighlight_items = list(list("All" "dehighlight_all") 
			    list("Selected" "dehighlight_selected") 
			    list("Fixed Nets" "dehighlight_fixed") 
			    list("Voltage Nets" "dehighlight_voltage") 
			    list("Dummy Nets" "dehighlight_dummy")
			))
		    (axlFormBuildPopup fid "global_rats" rats_items) 
		    (axlFormBuildPopup fid "global_blank" blank_items) 
		    (axlFormBuildPopup fid "global_highlight" highlight_items) 
		    (axlFormBuildPopup fid "global_dehighlight" dehighlight_items) 
		    (axlFormDisplay fid)
		    (tbx_netcolorview_global->viewPath = TBX_NETCOLORVIEW_Update_Views(fid)) 
		    TBX_NETCOLORVIEW_Start() 
		    when((!(fid->doneState) || zerop((fid->doneState))) 
			(axlDBTransactionCommit 
			    (tbx_netcolorview_global->transMark)
			) 
			(axlFormClose fid)
		    ) 
		    TBX_FORM_Delete(lic_check_result FORM_FILE)
		)
	    )
	)
    )
)
procedure(TBX_NETCOLORVIEW_Popup_Cancel() 
    (axlDBTransactionOops 
	(tbx_netcolorview_global->transMark)
    ) 
    (axlDBTransactionCommit 
	(tbx_netcolorview_global->transMark)
    ) 
    (axlUIPopupSet nil) 
    (axlClearDynamics)
    (axlFormClose 
	(tbx_netcolorview_global->formId)
    )
)
procedure(TBX_NETCOLORVIEW_Popup_Clear_Selection() 
    (axlClearSelSet) 
    (tbx_netcolorview_global->selSet = nil)
)
procedure(TBX_NETCOLORVIEW_Popup_Done() 
    (axlDBTransactionCommit 
	(tbx_netcolorview_global->transMark)
    ) 
    (axlFinishEnterFun) 
    (axlUIPopupSet nil) 
    (axlClearDynamics)
    (axlFormClose 
	(tbx_netcolorview_global->formId)
    )
)
procedure(TBX_NETCOLORVIEW_Popup_Oops() 
    (axlDBTransactionOops 
	(tbx_netcolorview_global->transMark)
    )
)
procedure(TBX_NETCOLORVIEW_Restore_View(form_handle viewPath) 
    let((view_name view_file port line arr
	    net net_name rat_state color_id regular_mode
	) 
	(view_name = lowerCase((axlFormGetField form_handle "color_view"))) 
	(view_file = viewPath[view_name]) 
	if((view_file && isReadable(view_file)) then 
	    printf("Note: Restoring net color visibility from %L ...\n" view_file) 
	    when((axlFormGetField form_handle "mode_complete") 
		TBX_NETCOLORVIEW_Visible_Rats(((axlDBGetDesign)->nets) nil) 
		TBX_DBDISPLAY_Dehighlight_By_Type(list("groups" "functions" "symbols" "nets" "pins"
			"vias" "drcs"
		    )
		)
	    ) 
	    if(((axlFormGetField form_handle "mode_complete") || 
		    (axlFormGetField form_handle "mode_incremental")) then 
		(regular_mode = t) else 
		(regular_mode = nil)
	    )
	    (port = infile(view_file)) 
	    while((line = _gets(port)) 
		cond((rexMatchp("^[ \t]*#" line) t) 
		    (t 
			(arr = parseString(line)) 
			when((length(arr) >= 3) 
			    (net_name = car(arr)) 
			    (rat_state = lowerCase(cadr(arr))) 
			    (color_id = atoi(caddr(arr))) 
			    (net = car((axlSelectByName "NET" net_name)))
			    when(net 
				if(regular_mode then 
				    when((rat_state == "on") 
					(axlRatsnestDisplay net)
				    ) 
				    when((color_id && (color_id > -1)) 
					(axlCustomColorObject net color_id)
				    ) else
				    when((rat_state == "on") 
					if((net->ratsnestOn) then 
					    (axlRatsnestBlank net) else 
					    (axlRatsnestDisplay net)
					)
				    ) 
				    when((color_id > -1) 
					if((axlIsCustomColored net) then 
					    (axlClearObjectCustomColor net) else 
					    (axlCustomColorObject net color_id)
					)
				    )
				)
			    )
			)
		    )
		)
	    ) 
	    close(port) else 
	    printf("Warning: Cannot find ncolor file for view %L\n" view_name)
	) 
	(axlClearSelSet)
	(axlDBRefreshId nil) 
	(axlVisibleUpdate t)
    )
)
procedure(TBX_NETCOLORVIEW_Save_View(form_handle) 
    let((view_name view_file port include_rats include_colors
	    net_info rat_state color_id result
	) 
	(view_name = lowerCase((axlFormGetField form_handle "color_view"))) 
	(view_file = strcat(getWorkingDir() "/" view_name ".ncolor")) 
	(include_rats = (axlFormGetField form_handle "include_rats")) 
	(include_colors = (axlFormGetField form_handle "include_colors"))
	foreach(net 
	    ((axlDBGetDesign)->nets) 
	    (rat_state = "OFF") 
	    when((include_rats && (net->ratsnestOn)) 
		(rat_state = "ON")
	    ) 
	    (color_id = "-1")
	    when(include_colors 
		(result = (axlIsCustomColored net)) 
		when(result 
		    (color_id = sprintf(nil "%d" result))
		)
	    ) 
	    when(((rat_state == "ON") || (color_id != "-1")) 
		(net_info = cons(list((net->name) rat_state color_id) net_info))
	    )
	) 
	(net_info = sortcar(net_info nil)) 
	(port = outfile(view_file "w")) 
	fprintf(port "# ===========================================\n") 
	fprintf(port "# %-29s  %-3s  %-2s\n" "Net" "Rat" "Color")
	fprintf(port "# ===========================================\n") 
	foreach(entry net_info 
	    fprintf(port "%-31s  %-3s  %-2s\n" 
		car(entry) 
		cadr(entry) 
		caddr(entry)
	    )
	) 
	close(port) 
	printf("Note: File %L  has been written\n" view_file) t
    )
)
procedure(TBX_NETCOLORVIEW_Start() 
    let((mypopup msg) 
	(mypopup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_NETCOLORVIEW_Popup_Done
		    ) 
		    list("Oops" 
			'TBX_NETCOLORVIEW_Popup_Oops
		    ) 
		    list("Cancel" 
			'TBX_NETCOLORVIEW_Popup_Cancel
		    ) 
		    list("Clear Selection" 
			'TBX_NETCOLORVIEW_Popup_Clear_Selection
		    )
		)
	    )) 
	(axlUIPopupSet mypopup) 
	(tbx_netcolorview_global->transMark = (axlDBTransactionStart)) 
	(axlClearSelSet)
	(axlSetFindFilter ?enabled 
	    list("noall" "nameform" "nets") ?onButtons 
	    list("all")
	) 
	while((axlSelect ?prompt msg) 
	    when((axlGetSelSet) 
		(tbx_netcolorview_global->selSet = setof(x 
			(axlGetSelSet) 
			((x->name) != "")
		    ))
	    )
	) 
	(axlUIPopupSet nil)
    )
)
procedure(TBX_NETCOLORVIEW_Update_Views(form_handle) 
    let((file_list search_dir view_items view_path base_name) 
	(view_path = makeTable("view_path_data" nil)) 
	(search_dir = getWorkingDir()) 
	(file_list = rexMatchList("[.][nN][cC][oO][lL][oO][rR]$" 
		getDirFiles(search_dir)
	    )) 
	foreach(fn file_list 
	    (base_name = lowerCase(cadr((axlDMFileParts fn)))) 
	    when(base_name 
		(view_path[base_name] = strcat(search_dir "/" fn))
	    )
	)
	foreach(key view_path 
	    (view_items = cons(key view_items))
	) 
	(view_items = sort(view_items nil)) 
	if(view_items then 
	    (axlFormBuildPopup form_handle "color_view" view_items) else 
	    (axlFormBuildPopup form_handle "color_view" 
		list("")
	    )
	) view_path
    )
)
procedure(TBX_NETCOLORVIEW_Visible_Rats(net_list make_vis) 
    foreach(net net_list 
	if(make_vis then 
	    (axlRatsnestDisplay net) else 
	    (axlRatsnestBlank net)
	)
    ) t
)
procedure(TBX_PADUSAGE_Cache_Param(form_handle) 
    let((rec session_param) 
	(rec = "padusage") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "single_dir_mode") 
	    stringToSymbol("single_dir_mode")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "psm_dir_mode") 
	    stringToSymbol("psm_dir_mode")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "dir_path") 
	    stringToSymbol("dir_path")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "report_type") 
	    stringToSymbol("report_type")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "report_format") 
	    stringToSymbol("report_format")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "report_units") 
	    stringToSymbol("report_units")
	)
	t
    )
)
procedure(TBX_PADUSAGE_Callback(form_handle) 
    let((dir_path) 
	case((form_handle->curField) 
	    ("done" 
		TBX_PADUSAGE_Cache_Param(form_handle) 
		(axlFormClose form_handle) 
		(axlVisibleUpdate t)
	    ) 
	    ("single_dir_mode" 
		when((form_handle->curValue) 
		    (axlFormSetFieldEditable form_handle "dir_path" t) 
		    (axlFormSetFieldEditable form_handle "browse_dir" t)
		)
	    ) 
	    ("browse_dir" 
		(dir_path = (axlDMDirectoryBrowse "." nil ?title "Pick a directory")) 
		when(dir_path 
		    (axlFormSetField form_handle "dir_path" dir_path)
		)
	    ) 
	    ("psm_dir_mode" 
		when((form_handle->curValue) 
		    (axlFormSetFieldEditable form_handle "dir_path" nil) 
		    (axlFormSetFieldEditable form_handle "browse_dir" nil)
		)
	    )
	    ("report_type" 
		if(((form_handle->curValue) == "detailed_report") then 
		    (axlFormSetFieldEditable form_handle "report_units" t) else 
		    (axlFormSetFieldEditable form_handle "report_units" nil)
		)
	    ) 
	    ("apply" 
		TBX_PADUSAGE_Run(form_handle)
	    ) 
	    ("myhelp" 
		TBX_HELP_Launch("padusage")
	    )
	)
    )
)
procedure(TBX_PADUSAGE_Cleanup_Local_Data(run_dir) 
    let((df_list df_path) 
	(df_list = rexMatchList("tmp_[0-9]" 
		getDirFiles(run_dir)
	    )) 
	foreach(df df_list 
	    (df_path = strcat(run_dir "/" df)) 
	    when(isDir(df_path) 
		printf("Cleaning up directory %L ...\n" df_path) 
		TBX_UTIL_Clear_Directory(df_path) 
		deleteDir(df_path)
	    )
	)
    )
)
procedure(TBX_PADUSAGE_Compare_Config(cur_config last_config) 
    let((ret_value match_cnt) 
	(match_cnt = 0) 
	when((length(cur_config) == length(last_config)) 
	    foreach(ce cur_config 
		foreach(le last_config 
		    when(((car(ce) == car(le)) && (cadr(ce) == cadr(le)) && isDir(cadr(ce))) 
			++match_cnt
		    )
		)
	    ) 
	    when((match_cnt == length(cur_config)) 
		(ret_value = t)
	    )
	) ret_value
    )
)
procedure(TBX_PADUSAGE_Extract_Data(dir_config view_file) 
    let((dra_dir_path tmp_dir_path cur_dra dra_list dra_cnt
	    cur_id info_1 info_2 cur_dra_file out_file
	    cmd
	) 
	foreach(entry dir_config 
	    (dra_dir_path = car(entry)) 
	    (tmp_dir_path = cadr(entry)) 
	    unless(isDir(tmp_dir_path) 
		createDir(tmp_dir_path)
	    )
	    (dra_list = rexMatchList("[.][dD][rR][aA]$" 
		    getDirFiles(dra_dir_path)
		)) 
	    (dra_cnt = length(dra_list)) 
	    (cur_id = 0) 
	    when((dra_cnt > 0) 
		(axlMeterCreate 
		    sprintf(nil "Extract data from %s" 
			cadr((axlDMFileParts dra_dir_path))
		    ) "" t
		) 
		printf("Extracting dra from %L ...\n" dra_dir_path) 
		while((dra_list && !(axlMeterIsCancelled)) 
		    (cur_dra = car(dra_list)) 
		    ++cur_id 
		    (info_1 = sprintf(nil "File %s" cur_dra)) 
		    (info_2 = sprintf(nil "%d of %d" cur_id dra_cnt))
		    (axlMeterUpdate 
			((100 * cur_id) / dra_cnt) info_1 info_2
		    ) 
		    (cur_dra_file = strcat(dra_dir_path "/" cur_dra)) 
		    (out_file = strcat(tmp_dir_path "/" 
			    cadr((axlDMFileParts cur_dra)) ".txt"
			)) 
		    (cmd = sprintf(nil "extracta -m %s %s %s" cur_dra_file view_file out_file)) 
		    (axlRunBatchDBProgram "extracta" cmd ?silent t)
		    (dra_list = cdr(dra_list))
		)
	    ) 
	    (axlMeterDestroy)
	) t
    )
)
procedure(TBX_PADUSAGE_Init() 
    let((run_dir run_dir_path) 
	(run_dir = "toolbox.run") 
	(run_dir_path = strcat(getWorkingDir() "/" run_dir)) 
	unless(isDir(run_dir_path) 
	    createDir(run_dir_path)
	) 
	unless(boundp('tbx_padusage_global) 
	    iliDefstruct('defstruct(tbx_padusage_global_struct formId licCheck runDir)) 
	    defvar(tbx_padusage_global nil)
	)
	if(!tbx_padusage_global then 
	    (tbx_padusage_global = (make_tbx_padusage_global_struct ?formId nil ?licCheck nil
		    ?runDir run_dir_path
		)) else 
	    (tbx_padusage_global->formId = nil)
	    (tbx_padusage_global->licCheck = nil) 
	    (tbx_padusage_global->runDir = run_dir_path)
	)
    )
)
procedure((TBX_PADUSAGE_Main \@optional arg) 
    let((lic_check_result info_file FC_FEATURE FC_VERSION SUB_VERSION
	    VERSION_STR port fid FORM_FILE record
	) 
	(FC_FEATURE = "PADUSAGE") 
	(FC_VERSION = "17.1") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Padstack Report %s (C)2017" FC_VERSION))
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./padusage_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Padstack Report information:\n") 
		fprintf(port "=======================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Padstack Report: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    TBX_PADUSAGE_Init() 
		    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "padusage_main")) 
		    unless(boundp('tbxPadUsageMainHandle) 
			defvar(tbxPadUsageMainHandle nil)
		    ) 
		    (fid = (axlFormCreate 
			    'tbxPadUsageMainHandle FORM_FILE 
			    '(e outer) 
			    'TBX_PADUSAGE_Callback
			    t
			))
		    when(fid 
			(tbx_padusage_global->formId = fid) 
			(tbx_padusage_global->licCheck = lic_check_result) 
			(record = "padusage") 
			TBX_FORM_Init_Header(fid nil lic_check_result VERSION_STR)
			(axlFormSetField fid "single_dir_mode" 
			    TBX_SESSION_Get_Param(record "single_dir_mode" t)
			) 
			(axlFormSetField fid "psm_dir_mode" 
			    TBX_SESSION_Get_Param(record "psm_dir_mode" nil)
			) 
			(axlFormSetField fid "dir_path" 
			    TBX_SESSION_Get_Param(record "dir_path" "")
			) 
			(axlFormSetField fid "report_type" 
			    TBX_SESSION_Get_Param(record "report_type" "where_used_report")
			) 
			(axlFormSetField fid "report_format" 
			    TBX_SESSION_Get_Param(record "report_format" "html")
			)
			(axlFormSetField fid "report_units" 
			    TBX_SESSION_Get_Param(record "report_units" "mm")
			) 
			if((axlFormGetField fid "single_dir_mode") then 
			    (axlFormSetFieldEditable fid "dir_path" t) 
			    (axlFormSetFieldEditable fid "browse_dir" t) else
			    (axlFormSetFieldEditable fid "dir_path" nil) 
			    (axlFormSetFieldEditable fid "browse_dir" nil)
			) 
			if(((axlFormGetField fid "report_type") == "detailed_report") then 
			    (axlFormSetFieldEditable fid "report_units" t) else 
			    (axlFormSetFieldEditable fid "report_units" nil)
			) 
			(axlFormDisplay fid) 
			TBX_FORM_Delete(lic_check_result FORM_FILE)
		    )
		)
	    )
	)
    )
)
procedure(TBX_PADUSAGE_Parse_Output(dir_config mode format report_units) 
    let((cur_dra tmp_dir txt_file port line
	    padstack_name padstack_type pin_number arr cur_paddef
	    cur_details via_cnt mech_cnt pin_cnt padref
	    padstack_x padstack_y sortkey ret_data key_list
	    ref_cnt tmp_list pvminfo dra_units
	) 
	(padref = makeTable("padref_data_table" nil)) 
	(pvminfo = makeTable("pvminfo_data_table" nil)) 
	foreach(entry dir_config 
	    (tmp_dir = cadr(entry)) 
	    printf("Parsing data from %L ...\n" tmp_dir) 
	    foreach(fn 
		rexMatchList("[.][tT][xX][tT]$" 
		    getDirFiles(tmp_dir)
		) 
		(txt_file = strcat(tmp_dir "/" fn)) 
		(port = infile(txt_file)) 
		(cur_dra = nil)
		(cur_paddef = list()) 
		(cur_details = list()) 
		(via_cnt = 0) 
		(pin_cnt = 0) 
		(mech_cnt = 0)
		while((line = _gets(port)) 
		    rexCompile("!!") 
		    (line = rexReplace(line "! !" 0)) 
		    (line = rexReplace(line "! !" 0)) 
		    (arr = parseString(line "!"))
		    when((length(arr) >= 9) 
			case(car(arr) 
			    ("A" t) 
			    ("J" 
				(cur_dra = lowerCase(cadr((axlDMFileParts 
						cadr(arr)
					    )
					)
				    )) 
				(dra_units = nth(8 arr))
			    ) 
			    ("S" 
				when(((cadr(arr) == "PIN") || (cadr(arr) == "VIA CLASS")) 
				    (padstack_name = lowerCase(caddr(arr))) 
				    when(cur_dra 
					unless(exists(x cur_paddef 
						(x == padstack_name)
					    ) 
					    (cur_paddef = cons(padstack_name cur_paddef))
					) 
					cond(((cadr(arr) == "VIA CLASS") 
						(padstack_type = "Via") 
						(padstack_x = nth(9 arr)) 
						(padstack_y = nth(10 arr)) 
						(pin_number = "-")
						++via_cnt
					    ) 
					    ((cadr(arr) == "PIN") 
						(pin_number = nth(6 arr)) 
						if((pin_number == " ") then 
						    (pin_number = "-") 
						    (padstack_type = "Mech") 
						    ++mech_cnt
						    else 
						    (padstack_type = "Pin") 
						    ++pin_cnt
						) 
						(padstack_x = nth(7 arr)) 
						(padstack_y = nth(8 arr))
					    )
					) 
					case(padstack_type 
					    ("Pin" 
						(sortkey = strcat("SORTA" pin_number))
					    ) 
					    ("Via" 
						(sortkey = strcat("SORTB" pin_number))
					    ) 
					    ("Mech" 
						(sortkey = strcat("SORTC" pin_number))
					    )
					) 
					(pin_number = lowerCase(pin_number))
					(padstack_x = sprintf(nil "%.3f" 
						(axlMKSConvert 
						    strcat(padstack_x " " dra_units) report_units
						)
					    )) 
					(padstack_y = sprintf(nil "%.3f" 
						(axlMKSConvert 
						    strcat(padstack_y " " dra_units) report_units
						)
					    )) 
					(cur_details = cons(list(sortkey padstack_type pin_number padstack_name padstack_x
						    padstack_y
						) cur_details
					    ))
				    )
				)
			    )
			)
		    )
		) 
		close(port) 
		when((cur_dra && (length(cur_paddef) > 0)) 
		    case(mode 
			("where_used_report" 
			    foreach(p cur_paddef 
				unless(exists(x 
					padref[p] 
					(x == cur_dra)
				    ) 
				    (padref[p] = cons(cur_dra 
					    padref[p]
					))
				)
			    )
			) 
			("standard_report" 
			    (padref[cur_dra] = cur_paddef)
			) 
			("detailed_report" 
			    (padref[cur_dra] = cur_details) 
			    (pvminfo[cur_dra] = sprintf(nil "%d/%d/%d" pin_cnt via_cnt mech_cnt))
			)
		    )
		)
	    )
	) 
	foreach(key padref 
	    (key_list = cons(key key_list))
	)
	(key_list = sort(key_list nil)) 
	(ret_data = tconc(nil nil)) 
	case(mode 
	    ("where_used_report" 
		foreach(key key_list 
		    (padref[key] = sort(padref[key] nil)) 
		    (ref_cnt = length(padref[key])) 
		    tconc(ret_data 
			list(key 
			    sprintf(nil "%d" ref_cnt) 
			    padref[key]
			)
		    )
		)
	    ) 
	    ("standard_report" 
		foreach(key key_list 
		    (padref[key] = sort(padref[key] nil)) 
		    (ref_cnt = length(padref[key])) 
		    tconc(ret_data 
			list(key 
			    sprintf(nil "%d" ref_cnt) 
			    padref[key]
			)
		    )
		)
	    ) 
	    ("detailed_report" 
		foreach(key key_list 
		    (padref[key] = sortcar(padref[key] 
			    'axlStrcmpAlpNum
			)) 
		    (tmp_list = cdar(padref[key])) 
		    (tmp_list = cons(pvminfo[key] tmp_list))
		    (tmp_list = cons(key tmp_list)) 
		    tconc(ret_data tmp_list) 
		    foreach(tmpl 
			cdr(padref[key]) 
			(tmpl = cdr(tmpl)) 
			if(((format == "html") || (format == "text")) then 
			    (tmpl = cons(" " tmpl)) 
			    (tmpl = cons(" " tmpl)) else
			    (tmpl = cons(pvminfo[key] tmpl)) 
			    (tmpl = cons(key tmpl))
			) 
			tconc(ret_data tmpl)
		    ) 
		    case(format 
			("html" 
			    tconc(ret_data 
				list("&nbsp;" " " " " " " " "
				    " " " "
				)
			    )
			) 
			("text" 
			    tconc(ret_data 
				list("" "" "" "" ""
				    "" ""
				)
			    )
			) 
			("excel" 
			    tconc(ret_data 
				list("" "" "" "" ""
				    "" ""
				)
			    )
			)
		    )
		)
	    )
	) 
	(ret_data = cdar(ret_data)) ret_data
    )
)
procedure(TBX_PADUSAGE_Run(form_handle) 
    let((data single_dir_path dra_dir_list view_file report_type
	    report_format text_report html_report xml_report report_units
	    dir_cnt dir_config tmp_dir_path skip_extracta msg
	    last_config config_file inport outport continue
	) 
	(data = makeTable("data_table_data" nil)) 
	if((axlFormGetField form_handle "psm_dir_mode") then 
	    (dra_dir_list = (parseQuotedString 
		    axlGetVariable("psmpath")
		)) 
	    (dra_dir_list = setof(x dra_dir_list 
		    isDir(x)
		)) else
	    (single_dir_path = (axlFormGetField form_handle "dir_path")) 
	    when((single_dir_path && (type(single_dir_path) == 'string) && isDir(single_dir_path)) 
		(dra_dir_list = list(single_dir_path))
	    )
	) 
	(report_type = (axlFormGetField form_handle "report_type")) 
	(report_format = (axlFormGetField form_handle "report_format"))
	(report_units = (axlFormGetField form_handle "report_units")) 
	(dir_cnt = 0) 
	foreach(dp dra_dir_list 
	    ++dir_cnt 
	    (tmp_dir_path = sprintf(nil "%s/padusage_tmp_%d" 
		    (tbx_padusage_global->runDir) dir_cnt
		)) 
	    (dir_config = cons(list(dp tmp_dir_path) dir_config))
	) 
	(dir_config = reverse(dir_config)) 
	(continue = t)
	when(((report_type == "detailed_report") && (axlFormGetField form_handle "psm_dir_mode") && 
		((axlFormGetField form_handle "report_format") == "excel")) 
	    (msg = "XML file size will increase dramatically in case of large libraries with many footprints. Also operation might take a long time. During this time PCB Editor might not repsond.\n") 
	    (msg = strcat(msg "Do you want to continue?")) 
	    unless((axlUIYesNo msg nil 
		    'no
		) 
		(continue = nil)
	    )
	) 
	when((dir_config && continue) 
	    (skip_extracta = nil) 
	    (config_file = strcat((tbx_padusage_global->runDir) "/padusage_dirmap.cfg")) 
	    when(isFile(config_file) 
		(inport = infile(config_file)) 
		(last_config = car(lineread(inport))) 
		close(inport)
	    ) 
	    when(TBX_PADUSAGE_Compare_Config(dir_config last_config) 
		(msg = "Extracta output exists from previous run. If library data has not changed, you can skip running extracta and directly parse its output.\n") 
		(msg = strcat(msg "Skip extracta?")) 
		when((axlUIYesNo msg nil 
			'yes
		    ) 
		    (skip_extracta = t)
		)
	    )
	    unless(skip_extracta 
		(view_file = strcat((tbx_padusage_global->runDir) "/padusage_view.txt")) 
		TBX_PADUSAGE_Write_View(view_file) 
		TBX_PADUSAGE_Cleanup_Local_Data((tbx_padusage_global->runDir)) 
		TBX_PADUSAGE_Extract_Data(dir_config view_file)
	    ) 
	    (outport = outfile(config_file "w")) 
	    pprint(dir_config outport) 
	    close(outport) 
	    (data = TBX_PADUSAGE_Parse_Output(dir_config report_type report_format report_units))
	    if((length(data) > 0) then 
		case(report_format 
		    ("html" 
			(html_report = strcat(getWorkingDir() "/pad_usage.html")) 
			TBX_PADUSAGE_Write_HTML_Report(data report_type html_report) 
			when((isFile(html_report) && isReadable(html_report) && !axlGetVariable("TBX_PV_REGRESSION")) 
			    (axlShell 
				sprintf(nil "http %L" html_report)
			    )
			)
		    ) 
		    ("text" 
			(text_report = strcat(getWorkingDir() "/pad_usage.txt")) 
			TBX_PADUSAGE_Write_Text_Report(data report_type text_report) 
			when((isFile(text_report) && isReadable(text_report)) 
			    (axlUIViewFileCreate text_report "Padstack Usage Report" nil)
			)
		    ) 
		    ("excel" 
			(xml_report = strcat(getWorkingDir() "/pad_usage.xml")) 
			TBX_PADUSAGE_Write_XML(data report_type xml_report)
		    )
		) else 
		printf("Warning: Nothing to report.\n")
	    )
	)
    )
)
procedure(TBX_PADUSAGE_Write_HTML_Report(data mode html_file) 
    let((port report_mode stringToHTML) 
	(stringToHTML = lambda((str_l) 
		let((html_str_l) 
		    (html_str_l = str_l) 
		    rexCompile("<") 
		    (html_str_l = rexReplace(html_str_l "\\&lt;" 0)) 
		    rexCompile(">")
		    (html_str_l = rexReplace(html_str_l "\\&gt;" 0)) 
		    rexCompile("\n") 
		    (html_str_l = rexReplace(html_str_l "<br>" 0)) html_str_l
		)
	    )) 
	(port = outfile(html_file "w")) 
	fprintf(port "<!DOCTYPE html>\n<!--This is a report generated by Productivity Toolbox Padstack Usage application-->\n<html>\n") 
	fprintf(port "<head>\n<title>PCB Editor Pad Usage Report</title>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=yes\">\n<meta name=\"author\" content=\"FlowCAD\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n<style>\nbody {background-color: #FFFFFF;display: block;font-family:Calibri,Candara,Segoe,Segoe UI,Optima,Arial,sans-serif;\n  font-size: 0.95em;margin: 0.2em 0.2em 0.2em;\n  position: absolute;text-align: left: 800px;\n  font-family:Calibri,Candara,Segoe,Segoe UI,Optima,Arial,sans-serif;font-size: 1em;line-height: 1.4em;\n  width:800px;\n}\narticle {display: inline;float: left;margin-left: 10px;margin-right: 5px;\n  margin-top: 0.5em;overflow: visible;text-align: left;width: 800px;padding-left:0px;\n}\nh1 { color: #3366CC;font-size: 1.7em;margin-bottom: 0.5em;margin-top: 0.4em;}\nh2 {color:  #CC0000;font-size: 1.5em;margin-bottom: 0.35em;margin-top: 0.4em;}\nh3 { color: #666666;font-size: 1.2em;margin-bottom: 0.35em;margin-left:10px;}\nh2:hover{background-color:#e0e0e0;}\nh3:hover{background-color:#e0e0e0;}\ntable, th, td {\n  font-family:Calibri,Candara,Segoe,Segoe UI,Optima,Arial,sans-serif; font-size: 1.0em;\n  border: 1px solid black;\n  border-collapse: collapse;\n  line-height: 1.2em;\n  background-color: #f4f4f4;\n  margin-left:15px;\n  }\nth, td {\n  padding: 5px 5px 5px 5px;\n  text-align: left;\n  vertical-align: top;\n  word-wrap: break-word;\n  max-width: 35em;\n}\nsvg{margin-right:5px;\n}\n.dielec {background-color:#93B63A;}\n.conduc {background-color:#E87C1E;}\n.plane  {background-color:#CC0000;color:#ffffff;}\n.topline {text-align:right}\n.collapse-open-icon {\n    float:left;\n    margin: -3px 2px 0 0;\n}\n</style>\n</head>\n")
	fprintf(port "<body>\n") 
	(report_mode = "cadence") 
	if((report_mode == "cadence") then 
	    fprintf(port "<header><!-- Cadence logo and headline-->\n") 
	    fprintf(port "<p class=\"topline\"><svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n") 
	    fprintf(port "   viewBox=\"0 0 218.5 51.5\" style=\"enable-background:new 0 0 218.5 51.5;\" xml:space=\"preserve\" preserveAspectRatio=\"xMidYMid\" width=\"166\" height=\"40\" viewBox=\"0 0 166 40\">\n")
	    fprintf(port "<style type=\"text/css\">\n") 
	    fprintf(port "  .st0{fill:#DD052B;}\n") 
	    fprintf(port "</style>\n") 
	    fprintf(port "<g>\n") 
	    fprintf(port "  <g>\n")
	    fprintf(port "    <polyline class=\"st0\" points=\"55.7,8.5 55.7,4.3 40.3,4.3 40.3,8.5 55.7,8.5     \"/>\n") 
	    fprintf(port "    <path d=\"M27.5,41.4c-0.8,0.4-2.3,0.9-4.2,0.9c-6.3,0-10.5-4.7-10.5-13.4c0-7.9,4.4-13.9,11.4-13.9c1.6,0,2.6,0.4,3.3,0.8v4.6\n") 
	    fprintf(port "      c-0.6-0.2-1.9-0.6-3.2-0.6c-3.8,0-5.7,4.1-5.7,9c0,5.4,2.2,8.7,5.7,8.7c1.1,0,2.3-0.2,3.2-0.6V41.4\"/>\n") 
	    fprintf(port "    <path d=\"M50,37.6l0-9.3c-2.3,0-6.4,0.7-6.4,5.3c0,3,1.6,4.1,2.9,4.1L50,37.6L50,37.6z M55.7,35.5c0,2.1,0.1,4.7,0.4,6.4\n") 
	    fprintf(port "      c0,0-9,0-11.4,0c-3.8,0-6.7-3.1-6.7-7.8c0-6.8,5.7-9.7,11.7-9.7v-0.5c0-2.8-1.1-4.7-4-4.7c-1.9,0-4.1,0.6-5.5,1.5v-4\n")
	    fprintf(port "      c1.3-0.8,3.5-1.9,6.8-1.9c6.8,0,8.6,4.4,8.6,10.1V35.5\"/>\n") 
	    fprintf(port "    <path d=\"M81.2,37.6h-3.4c-2.4,0-3.8-3.7-3.8-9c0-4.7,1.1-8.9,4-8.9c1.7,0,2.9,1.9,3.2,4c0.1,0.5,0.1,1.1,0.1,1.6V37.6L81.2,37.6z\n") 
	    fprintf(port "       M87,35.5L87,7h-5.8v10.6h-0.1c-0.8-1.8-2.4-2.9-4.6-2.9c-4.3,0-8.3,4.5-8.3,13.8c0,8,2.9,13.4,8,13.4l11.2,0\n") 
	    fprintf(port "      C87.1,40.2,87,37.5,87,35.5\"/>\n") 
	    fprintf(port "    <path d=\"M112.3,26.1c0-4.2-1.4-6.8-3.4-6.8c-2.5,0-3.7,3.7-3.8,6.8H112.3L112.3,26.1z M105.1,30.2c0.1,5.9,2.8,7.5,5.9,7.5\n")
	    fprintf(port "      c1.9,0,4-0.4,5.2-0.9v4.2c-1.7,0.8-3.8,1.2-6.2,1.2c-6.8,0-10.5-5-10.5-13.1c0-8.8,4.2-14.1,9.9-14.1c5.6,0,8.4,5,8.4,12.1\n") 
	    fprintf(port "      c0,1.5-0.1,2.4-0.2,3.1L105.1,30.2\"/>\n") 
	    fprintf(port "    <path d=\"M136.1,19.9v22h-5.8v-19c0-3-0.2-5.3-0.2-7.7h11.4c4.4,0,7,3.2,7,9.4v17.3h-5.8V25.1c0-2.6-0.6-5.2-3.1-5.2L136.1,19.9\"/>\n") 
	    fprintf(port "    <path d=\"M175.6,41.4c-0.8,0.4-2.3,0.9-4.2,0.9c-6.3,0-10.5-4.7-10.5-13.4c0-7.9,4.4-13.9,11.4-13.9c1.6,0,2.6,0.4,3.3,0.8v4.6\n") 
	    fprintf(port "      c-0.6-0.2-1.9-0.6-3.2-0.6c-3.8,0-5.7,4.1-5.7,9c0,5.4,2.2,8.7,5.7,8.7c1.1,0,2.3-0.2,3.2-0.6V41.4\"/>\n")
	    fprintf(port "    <path d=\"M191.5,26.1c0.1-3.1,1.3-6.8,3.8-6.8c2.1,0,3.5,2.5,3.4,6.8H191.5L191.5,26.1z M204.1,27.1c0-7.1-2.8-12.1-8.4-12.1\n") 
	    fprintf(port "      c-5.7,0-9.9,5.3-9.9,14.1c0,8.2,3.7,13.1,10.5,13.1c2.4,0,4.6-0.5,6.2-1.2v-4.2c-1.2,0.5-3.2,0.9-5.2,0.9c-3.1,0-5.8-1.6-5.9-7.5\n") 
	    fprintf(port "      l12.4,0C204,29.4,204.1,28.6,204.1,27.1\"/>\n") 
	    fprintf(port "  </g>\n") 
	    fprintf(port "</g>\n")
	    fprintf(port "<g>\n") 
	    fprintf(port "  <path d=\"M206.9,8.3c0-2.1,1.7-3.7,3.7-3.7c2.1,0,3.7,1.7,3.7,3.7c0,2-1.7,3.7-3.7,3.7C208.5,12,206.9,10.3,206.9,8.3z M213.4,8.3\n") 
	    fprintf(port "    c0-1.7-1.3-3-2.8-3c-1.6,0-2.8,1.3-2.8,3c0,1.7,1.3,3,2.8,3C212.1,11.3,213.4,10,213.4,8.3z M209.1,6.1h1.6c1,0,1.6,0.3,1.6,1.2\n") 
	    fprintf(port "    c0,0.7-0.4,1.1-1.1,1.1l1.1,1.8h-0.8l-1.1-1.8h-0.5v1.8h-0.8V6.1z M209.9,7.9h0.7c0.5,0,0.9-0.1,0.9-0.6c0-0.5-0.5-0.6-0.9-0.6\n") 
	    fprintf(port "    h-0.7V7.9z\"/>\n")
	    fprintf(port "</g>\n") 
	    fprintf(port "</svg>\n") 
	    fprintf(port "</p>\n") 
	    fprintf(port "<hr>\n") 
	    fprintf(port "<h1>PCB Editor Padstack Usage Report</h1>\n")
	    fprintf(port "</header>\n") else 
	    fprintf(port "<header><!-- FlowCAD logo and headline-->\n<p class=\"topline\"><svg preserveAspectRatio=\"xMidYMid\" width=\"83\" height=\"20\" viewBox=\"0 0 83 20\">\n  <image xlink:href=\"data:img/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFMAAAAUCAMAAADGMfHmAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAaVBMVEUAAAD///9AQED87+/539+AgIC/v7/pj4/SICDMAADPEBDicHDsn5/vr6/mgIDcUFD1z8/WMDCvr6/f39/Pz8/v7+/pz8/ZQEBgYGAgICCfn5/cj4/yv78QEBCPj49QUFBwcHDfYGAwMDDVsfIlAAAAAWJLR0QAiAUdSAAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAVFJREFUOMvd1Y1ugyAQAODjROrhX60yhBVt9/4PuTvt1izZXLesSbOLESHmk+MgAtwj1F8H/lMz0z8283WJDV+fvb0riGwpTxVRzU1DHLbd/94siYqOSFBu2jeT1WzTzJd2MQ95blRvBuUM94x5ItrxXIm00iJpMb1Se7t85mtzNIYVNh3KjMcBgooAvQN4JivvHDOZcdsJtJh8777NHcXMIcUJICboR24izCuwhKW6ki+sQzXRphkQ8SQmyjKcYBxhCgnmGeLV5AodGapuNN/XEyFKHw8QYE4pgWOJ09bFWfu1NP5iltcEts0R0LkAk0oAE2c/q8zSOcs8Wa5Q2TS8C7SYWW2puc0cEvDkglPsDVyluKQsUZVrTQo6X/ZSt7WXIsZ1GAc1zCGMjjcRzqpHdFLy1tq2Vq2vllX1beUldh/IhzjvD27y6bw9Xu7x53gFYBMW2DKy/54AAAAASUVORK5CYII=\" width=\"83\" height=\"20\"/></svg>\n</p>\n<hr>\n<h1>PCB Editor Padstack Usage Report</h1>\n</header>\n")
	) 
	fprintf(port "<article id=\"%s\">\n" "pad_data") 
	fprintf(port "  <section class=\"inneraccordion\">\n")
	fprintf(port "    <div>\n") 
	fprintf(port "      <table>\n") 
	case(mode 
	    ("where_used_report" 
		fprintf(port "      <tr><th><b>Padstack</b></th><th><b>References</b></th><th><b>Footprint(s)</b></th></tr>\n") 
		foreach(entry data 
		    fprintf(port "      <tr><td>%s</td><td>%s</td><td>%s</td></tr>\n" 
			car(entry) 
			cadr(entry) 
			funcall(stringToHTML 
			    buildString(caddr(entry) "\n")
			)
		    )
		)
	    ) 
	    ("standard_report" 
		fprintf(port "      <tr><th><b>Footprint</b></th><th><b>Definitions</b></th><th><b>Padstacks(s)</b></th></tr>\n") 
		foreach(entry data 
		    fprintf(port "      <tr><td>%s</td><td>%s</td><td>%s</td></tr>\n" 
			car(entry) 
			cadr(entry) 
			funcall(stringToHTML 
			    buildString(caddr(entry) "\n")
			)
		    )
		)
	    ) 
	    ("detailed_report" 
		fprintf(port "      <tr><th><b>Footprint</b></th><th><b>Pins/Vias/Mech</b></th><th><b>Type</b></th><th><b>Number</b></th><th><b>Padstack</b></th><th><b>X</b></th><th><b>Y</b></th></tr>\n") 
		foreach(entry data 
		    fprintf(port "      <tr>") 
		    for(i 0 6 
			fprintf(port "<td>%s</td>" 
			    nth(i entry)
			)
		    ) 
		    fprintf(port "      </tr>\n")
		)
	    )
	) 
	fprintf(port "      </table>\n") 
	fprintf(port "    </div>\n")
	fprintf(port "  </section>\n") 
	fprintf(port "</article>\n") 
	fprintf(port "</body>\n") 
	fprintf(port "</html>\n") 
	close(port)
	printf("Note: File %L has been written\n" html_file)
    )
)
procedure(TBX_PADUSAGE_Write_Text_Report(data mode text_file) 
    let((port item_list) 
	(port = outfile(text_file "w")) 
	case(mode 
	    ("where_used_report" 
		fprintf(port "========================================================================================\n") 
		fprintf(port "%-35s %-10s %s\n" "Padstack" "References" "Footprint(s)") 
		fprintf(port "========================================================================================\n") 
		foreach(entry data 
		    (item_list = caddr(entry)) 
		    fprintf(port "%-35s %-10s %s\n" 
			car(entry) 
			cadr(entry) 
			car(item_list)
		    ) 
		    when((length(item_list) > 1) 
			foreach(dra 
			    cdr(item_list) 
			    fprintf(port "%-46s %s\n" " " dra)
			)
		    )
		)
	    ) 
	    ("standard_report" 
		fprintf(port "========================================================================================\n") 
		fprintf(port "%-30s %-12s %s\n" "Footprint" "Definitions" "Padstacks(s)") 
		fprintf(port "========================================================================================\n") 
		foreach(entry data 
		    (item_list = caddr(entry)) 
		    fprintf(port "%-30s %-12s %s\n" 
			car(entry) 
			cadr(entry) 
			car(item_list)
		    ) 
		    when((length(item_list) > 1) 
			foreach(pad 
			    cdr(item_list) 
			    fprintf(port "%-43s %s\n" " " pad)
			)
		    )
		)
	    ) 
	    ("detailed_report" 
		fprintf(port "============================================================================================================\n") 
		fprintf(port "%-30s %-15s %-5s %-5s %-20s %-10s %-10s\n" "Footprint" "Pins/Vias/Mech" "Type"
		    "Number" "Padstack" "X" "Y"
		) 
		fprintf(port "============================================================================================================\n") 
		foreach(entry data 
		    fprintf(port "%-30s %-15s %-5s %-6s %-20s %-10s %-10s\n" 
			car(entry) 
			cadr(entry) 
			caddr(entry)
			nth(3 entry) 
			nth(4 entry) 
			nth(5 entry) 
			nth(6 entry)
		    )
		)
	    )
	) 
	fprintf(port "\n") 
	close(port)
	printf("Note: File %L has been written\n" text_file)
    )
)
procedure(TBX_PADUSAGE_Write_View(view_file) 
    let((port result) 
	(port = outfile(view_file "w")) 
	fprintf(port "COMPOSITE_PAD\n") 
	fprintf(port "  CLASS\n") 
	fprintf(port "  PAD_STACK_NAME\n")
	fprintf(port "  PAD_STACK_TYPE\n") 
	fprintf(port "  START_LAYER_NAME\n") 
	fprintf(port "  END_LAYER_NAME\n") 
	fprintf(port "  PIN_NUMBER\n") 
	fprintf(port "  PIN_X\n")
	fprintf(port "  PIN_Y\n") 
	fprintf(port "  VIA_X\n") 
	fprintf(port "  VIA_Y\n") 
	fprintf(port "END\n") 
	close(port)
	when(isFile(view_file) 
	    (result = t)
	) result
    )
)
procedure(TBX_PADUSAGE_Write_XML(data mode xml_file) 
    let((row pad_name dra_name ref_cnt item_list) 
	(axlSpreadsheetInit) 
	(axlSpreadsheetSetStyle "Default" nil) 
	(axlSpreadsheetSetStyleProp "Alignment" "Vertical" "Top") 
	(axlSpreadsheetSetStyleProp "Alignment" "Horizontal" "Left")
	(axlSpreadsheetSetStyleProp "Alignment" "WrapText" "1") 
	(axlSpreadsheetSetStyle "Header" "Bold style") 
	(axlSpreadsheetSetStyleParent "Default") 
	(axlSpreadsheetSetStyleProp "Font" "Bold" "1") 
	(axlSpreadsheetSetWorksheet "Padstack Usage Report")
	case(mode 
	    ("where_used_report" 
		(axlSpreadsheetSetColumnProp 1 "Width" "150") 
		(axlSpreadsheetSetColumnProp 2 "Width" "70") 
		(axlSpreadsheetSetColumnProp 3 "Width" "150") 
		(row = 1)
		(axlSpreadsheetDefineCell row 1 "Header" "String"
		    "Padstack"
		) 
		(axlSpreadsheetDefineCell row 2 "Header" "String"
		    "References"
		) 
		(axlSpreadsheetDefineCell row 3 "Header" "String"
		    "Footprint(s)"
		) 
		foreach(entry data 
		    ++row 
		    (pad_name = car(entry)) 
		    (ref_cnt = cadr(entry))
		    (item_list = caddr(entry)) 
		    (axlSpreadsheetDefineCell row 1 "Default" "String"
			pad_name
		    ) 
		    (axlSpreadsheetDefineCell row 2 "Default" "Number"
			ref_cnt
		    ) 
		    (axlSpreadsheetDefineCell row 3 "Default" "String"
			car(item_list)
		    ) 
		    when((length(item_list) > 1) 
			foreach(dra 
			    cdr(item_list) 
			    ++row 
			    (axlSpreadsheetDefineCell row 1 "Default" "String"
				""
			    ) 
			    (axlSpreadsheetDefineCell row 2 "Default" "String"
				""
			    )
			    (axlSpreadsheetDefineCell row 3 "Default" "String"
				dra
			    )
			)
		    )
		)
	    ) 
	    ("standard_report" 
		(axlSpreadsheetSetColumnProp 1 "Width" "150") 
		(axlSpreadsheetSetColumnProp 2 "Width" "70") 
		(axlSpreadsheetSetColumnProp 3 "Width" "150") 
		(row = 1)
		(axlSpreadsheetDefineCell row 1 "Header" "String"
		    "Footprint"
		) 
		(axlSpreadsheetDefineCell row 2 "Header" "String"
		    "Definitions"
		) 
		(axlSpreadsheetDefineCell row 3 "Header" "String"
		    "Padstack(s)"
		) 
		foreach(entry data 
		    ++row 
		    (dra_name = car(entry)) 
		    (ref_cnt = cadr(entry))
		    (item_list = caddr(entry)) 
		    (axlSpreadsheetDefineCell row 1 "Default" "String"
			dra_name
		    ) 
		    (axlSpreadsheetDefineCell row 2 "Default" "Number"
			ref_cnt
		    ) 
		    (axlSpreadsheetDefineCell row 3 "Default" "String"
			car(item_list)
		    ) 
		    when((length(item_list) > 1) 
			foreach(pad 
			    cdr(item_list) 
			    ++row 
			    (axlSpreadsheetDefineCell row 1 "Default" "String"
				""
			    ) 
			    (axlSpreadsheetDefineCell row 2 "Default" "String"
				""
			    )
			    (axlSpreadsheetDefineCell row 3 "Default" "String"
				pad
			    )
			)
		    )
		)
	    ) 
	    ("detailed_report" 
		(axlSpreadsheetSetColumnProp 1 "Width" "150") 
		(axlSpreadsheetSetColumnProp 2 "Width" "100") 
		(axlSpreadsheetSetColumnProp 3 "Width" "70") 
		(axlSpreadsheetSetColumnProp 4 "Width" "100")
		(axlSpreadsheetSetColumnProp 5 "Width" "150") 
		(axlSpreadsheetSetColumnProp 6 "Width" "150") 
		(axlSpreadsheetSetColumnProp 7 "Width" "150") 
		(row = 1) 
		(axlSpreadsheetDefineCell row 1 "Header" "String"
		    "Footprint"
		)
		(axlSpreadsheetDefineCell row 2 "Header" "String"
		    "Pins/Vias/Mech"
		) 
		(axlSpreadsheetDefineCell row 3 "Header" "String"
		    "Type"
		) 
		(axlSpreadsheetDefineCell row 4 "Header" "String"
		    "Number"
		) 
		(axlSpreadsheetDefineCell row 5 "Header" "String"
		    "Padstack"
		) 
		(axlSpreadsheetDefineCell row 6 "Header" "String"
		    "X"
		)
		(axlSpreadsheetDefineCell row 7 "Header" "String"
		    "Y"
		) 
		foreach(entry data 
		    ++row 
		    when(entry 
			(axlSpreadsheetDefineCell row 1 "Default" "String"
			    car(entry)
			) 
			(axlSpreadsheetDefineCell row 2 "Default" "String"
			    cadr(entry)
			) 
			(axlSpreadsheetDefineCell row 3 "Default" "String"
			    caddr(entry)
			) 
			(axlSpreadsheetDefineCell row 4 "Default" "String"
			    nth(3 entry)
			)
			(axlSpreadsheetDefineCell row 5 "Default" "String"
			    nth(4 entry)
			) 
			if(atof(nth(5 entry)) then 
			    (axlSpreadsheetDefineCell row 6 "Default" "Number"
				nth(5 entry)
			    ) else 
			    (axlSpreadsheetDefineCell row 6 "Default" "String"
				nth(5 entry)
			    )
			) 
			if(atof(nth(6 entry)) then 
			    (axlSpreadsheetDefineCell row 7 "Default" "Number"
				nth(6 entry)
			    ) else 
			    (axlSpreadsheetDefineCell row 7 "Default" "String"
				nth(6 entry)
			    )
			)
		    )
		)
	    )
	) 
	(axlSpreadsheetWrite xml_file) 
	(axlSpreadsheetClose) 
	printf("Note: File %L has been written\n" xml_file) t
    )
)
procedure(TBX_PANELIZE_Autosilk_Backup() 
    let((mfg_class config auto_silk_top auto_silk_bottom pnl_silk_top
	    pnl_silk_bottom auto_silk_layer pnl_silk_layer
	) 
	(mfg_class = (axlMapClassName "MANUFACTURING")) 
	(auto_silk_top = strcat(mfg_class "/AUTOSILK_TOP")) 
	(auto_silk_bottom = strcat(mfg_class "/AUTOSILK_BOTTOM")) 
	(pnl_silk_top = strcat(mfg_class "/PNL_AUTOSILK_TOP"))
	(pnl_silk_bottom = strcat(mfg_class "/PNL_AUTOSILK_BOTTOM")) 
	unless((axlIsLayer pnl_silk_top) 
	    (axlLayerCreateNonConductor pnl_silk_top)
	) 
	unless((axlIsLayer pnl_silk_bottom) 
	    (axlLayerCreateNonConductor pnl_silk_bottom)
	) 
	(config = list(list(auto_silk_top pnl_silk_top) 
		list(auto_silk_bottom pnl_silk_bottom)
	    )) 
	foreach(entry config 
	    (auto_silk_layer = car(entry)) 
	    (pnl_silk_layer = cadr(entry)) 
	    (axlDBControl 
		'activeLayer auto_silk_layer
	    )
	    (axlVisibleDesign nil) 
	    (axlVisibleLayer auto_silk_layer t) 
	    (axlVisibleUpdate t) 
	    (axlSetFindFilter ?enabled 
		list("noall" "boundary_shapes" "text" "lines" "shapes") ?onButtons 
		list("all")
	    ) 
	    (axlClearSelSet)
	    (axlAddSelectAll) 
	    when((axlGetSelSet) 
		TBX_UTIL_Copy_To_Layer((axlGetSelSet) pnl_silk_layer nil) 
		(axlClearSelSet)
	    )
	)
	(axlClearSelSet) t
    )
)
procedure(TBX_PANELIZE_Batch_Update(ctrl_file) 
    let((cmd result id_list mdd_list update_time
	    panel_design_fullpath panel_stackup port line arr
	    ini_file design_to_sync design_list instance_list design_info
	    instance_info data design_nick_name design_path design_path_abs
	    design_path_rel rel_dir design_dir design_name panel_id
	    definition loc_x loc_y rotation mirror
	    plc_info delete_list mod_list ok_cleanup
	) 
	when((ctrl_file && isFile(ctrl_file)) 
	    (port = infile(ctrl_file)) 
	    while((line = _gets(port)) 
		(arr = (parseQuotedString line)) 
		rexCompile("#.*$") 
		(line = rexReplace(line "" 0)) 
		when((length(arr) > 0) 
		    case(upperCase(car(arr)) 
			("CONFIG" t 
			    (ini_file = cadr(arr))
			) 
			("DELETE" 
			    (delete_list = cdr(arr))
			) 
			("DESIGN" 
			    (design_nick_name = cadr(arr)) 
			    (design_path = caddr(arr)) 
			    (design_list = cons(list(design_nick_name design_path) design_list))
			) 
			("SYNCHRONIZE" 
			    (design_to_sync = cadr(arr))
			)
			("INSTANCE" 
			    (instance_list = cons(cdr(arr) instance_list))
			) 
			("CLEANUP" 
			    (ok_cleanup = t)
			)
		    )
		)
	    ) 
	    close(port)
	) 
	when((ini_file && isFile(ini_file)) 
	    printf("Panelize Batch: Reading form settings from %L...\n" ini_file) 
	    (data = TBX_UTIL_File_Lineread(ini_file)) 
	    foreach(entry data 
		putprop((tbx_panelize_global->cfg) 
		    cadr(entry) 
		    car(entry)
		)
	    )
	) 
	when(delete_list 
	    if((upperCase(car(delete_list)) == "ALL") then 
		(mod_list = (axlSelectByName "GROUP" "*" t)) 
		(id_list = mapcar(lambda((x) 
			    (x->name)
			) mod_list
		    )) else
		(id_list = delete_list)
	    ) 
	    when(id_list 
		(axlDBCloak 
		    'TBX_PANELIZE_Delete_Modules(id_list) 
		    'shape
		)
	    ) 
	    (tbx_panelize_global->panelInfo = TBX_PANELIZE_Get_Panel_Info())
	) 
	when(design_list 
	    foreach(entry design_list 
		(design_nick_name = upperCase(car(entry))) 
		(design_path = cadr(entry)) 
		(design_path_abs = simplifyFilename(design_path))
		(design_path_abs = (axlOSSlash design_path_abs)) 
		(design_dir = car((axlDMFileParts design_path_abs))) 
		(design_name = caddr((axlDMFileParts design_path_abs))) 
		(rel_dir = TBX_UTIL_Get_Relative_Path(design_dir 
			(tbx_panelize_global->panelDir)
		    )) 
		when(rel_dir 
		    (design_path_rel = strcat(rel_dir "/" design_name))
		)
		when((design_nick_name && design_path_abs && design_path_rel) 
		    (design_info = cons(list(design_nick_name design_path_abs design_path_rel) design_info))
		)
	    ) 
	    when(design_info 
		printf("Panelize Batch: Reading design configuration...\n") 
		((tbx_panelize_global->cfg)->designInfo = design_info) 
		((tbx_panelize_global->cfg)->mddSizeInfo = nil) 
		((tbx_panelize_global->cfg)->timeStamp = ncons(nil))
	    )
	)
	when(design_to_sync 
	    printf("Panelize Batch: Synchronize layer stackup with %L...\n" design_to_sync) 
	    (design_path_abs = TBX_PANELIZE_Get_Design_Path(design_to_sync 
		    ((tbx_panelize_global->cfg)->designInfo) "absolute"
		)) 
	    case((tbx_panelize_global->panelType) 
		("BRD" 
		    TBX_PANELIZE_Sync_Stackup_PCB_Mode(design_path_abs 
			((tbx_panelize_global->cfg)->unifyLayerNames)
		    )
		) 
		("MCM/SIP" 
		    TBX_PANELIZE_Sync_Stackup_MCM_Mode(design_path_abs 
			((tbx_panelize_global->cfg)->unifyLayerNames)
		    )
		) 
		(t t)
	    )
	) 
	when(instance_list 
	    foreach(entry instance_list 
		when((length(entry) >= 6) 
		    rexMatchp("^P" 
			upperCase(car(entry))
		    ) 
		    (panel_id = car(entry)) 
		    (definition = cadr(entry)) 
		    (loc_x = atof(caddr(entry)))
		    (loc_y = atof(nth(3 entry))) 
		    (rotation = atof(nth(4 entry))) 
		    (mirror = nth(5 entry)) 
		    when((panel_id && definition && loc_x && loc_y && rotation && mirror) 
			(plc_info = ncons(nil)) 
			(plc_info->definition = definition) 
			(plc_info->originX = loc_x) 
			(plc_info->originY = loc_y)
			(plc_info->rotation = rotation) 
			(plc_info->isMirror = mirror) t 
			(instance_info = cons(list(panel_id plc_info) instance_info))
		    )
		)
	    ) 
	    when(instance_info 
		printf("Panelize Batch: Reading instance configuration...\n") 
		(tbx_panelize_global->panelInfo = instance_info)
	    )
	) 
	(panel_stackup = TBX_PANELIZE_Get_Conductor_Layer_Info()) 
	(panel_design_fullpath = (axlGetDrawingName)) 
	(axlSaveDesign ?noConfirm t)
	(result = TBX_PANELIZE_Create_Modules(panel_stackup 
		(tbx_panelize_global->sysLayers) 
		(tbx_panelize_global->cfg)
	    )) 
	((tbx_panelize_global->cfg)->mddSizeInfo = car(result)) 
	TBX_PANELIZE_Open(panel_design_fullpath) 
	unless(axlGetVariable("FLW_DEBUG") 
	    foreach(db 
		cadr(result) 
		deleteFile(db)
	    )
	) 
	when((tbx_panelize_global->panelInfo) 
	    (id_list = mapcar(lambda((x) 
			car(x)
		    ) 
		    (tbx_panelize_global->panelInfo)
		)) 
	    (id_list = id_list) 
	    (axlDBCloak 
		'TBX_PANELIZE_Delete_Modules(id_list) 
		'shape
	    ) 
	    (axlPurgePadstacks 
		'padstacks nil
	    )
	    (axlPurgePadstacks 
		'via t
	    ) 
	    (axlDBRefreshId nil) 
	    (axlShell "save") 
	    (cmd = sprintf(nil "opencd %L" panel_design_fullpath)) 
	    (axlShell cmd)
	    (update_time = stringToTime(getCurrentTime())) 
	    TBX_PANELIZE_Update_All_Instances((tbx_panelize_global->panelInfo)) 
	    (mdd_list = (axlSelectByName "MODULE" "*" t)) 
	    when(mdd_list 
		when(((tbx_panelize_global->panelType) == "MCM/SIP") 
		    TBX_PANELIZE_Set_Die_Properties(mdd_list)
		) 
		TBX_PANELIZE_Update_Panel_Id(mdd_list) 
		foreach(mdd mdd_list 
		    putprop(((tbx_panelize_global->cfg)->timeStamp) update_time 
			stringToSymbol((mdd->name))
		    )
		) 
		when(((tbx_panelize_global->cfg)->clearNets) 
		    TBX_PANELIZE_Clear_Nets(id_list)
		)
		(axlDBAddProp mdd_list 
		    list("FIXED" t)
		)
	    ) 
	    (axlClearSelSet)
	    (axlSaveDesign) 
	    TBX_PANELIZE_Change_Env("reset") 
	    TBX_PANELIZE_Save_Config_To_Database() 
	    when((tbx_panelize_global->envVar) 
		TBX_UTIL_Restore_Session_Variables((tbx_panelize_global->envVar) 
		    list("padpath" "psmpath") t
		)
	    ) 
	    (tbx_panelize_global = nil)
	    TBX_PANELIZE_Cleanup_Local_Library_Data(getWorkingDir()) 
	    printf("Info: Due to performance reasons, On-Line DRC had been disabled. Please run DRC Update.\n")
	)
	when(ok_cleanup 
	    TBX_PANELIZE_Cleanup_Local_Library_Data(getWorkingDir())
	) t
    )
)
procedure(TBX_PANELIZE_Build_Definition_Popup(form_handle form_type) 
    let((popup_list) 
	foreach(entry 
	    ((tbx_panelize_global->cfg)->designInfo) 
	    (popup_list = cons(car(entry) popup_list))
	) 
	(popup_list = sort(popup_list nil)) 
	(axlFormBuildPopup form_handle "board_name" popup_list) 
	when((form_type == "main") 
	    (axlFormBuildPopup form_handle "grid_board_name_popup" popup_list)
	)
    )
)
procedure(TBX_PANELIZE_Callback(form_handle) 
    let((cell tmp_list board_fullpath board_name panel_id
	    mdd_inst cur_name pt_x pt_y rot
	    mirror mdd_info mdd_xy mdd_rot mdd_mirror
	    delta_x delta_y delta_rot mirror_flag panel_grid_info
	    design_grid_info popup_list ok_delete panel_stackup panel_design_fullpath
	    cmd FORM_FILE fid wb_xml_file tech_file
	    id_list board_path board_dir brd_file msg
	    result grid_info config_file update_time mdd_list
	    unify_names instance_info design_path_abs
	) 
	case((form_handle->curField) 
	    ("update_panel" 
		(panel_grid_info = TBX_PANELIZE_Extract_Panel_Grid()) 
		(panel_stackup = TBX_PANELIZE_Get_Conductor_Layer_Info()) 
		(panel_design_fullpath = (axlGetDrawingName)) 
		(design_grid_info = TBX_PANELIZE_Extract_Design_Grid(t))
		((tbx_panelize_global->cfg)->designInfo = TBX_PANELIZE_Validate_Design_Info((tbx_panelize_global->panelDir) design_grid_info)) 
		(tbx_panelize_global->cfg = TBX_PANELIZE_Update_Config(form_handle 
			(tbx_panelize_global->cfg)
		    )) 
		(axlSaveDesign ?noConfirm t) 
		(result = TBX_PANELIZE_Create_Modules(panel_stackup 
			(tbx_panelize_global->sysLayers) 
			(tbx_panelize_global->cfg)
		    )) 
		((tbx_panelize_global->cfg)->mddSizeInfo = car(result))
		TBX_PANELIZE_Open(panel_design_fullpath) 
		unless(axlGetVariable("FLW_DEBUG") 
		    foreach(db 
			cadr(result) 
			deleteFile(db)
		    )
		) 
		when(panel_grid_info 
		    (id_list = mapcar(lambda((x) 
				car(x)
			    ) panel_grid_info
			)) 
		    (id_list = id_list) 
		    (axlDBCloak 
			'TBX_PANELIZE_Delete_Modules(id_list) 
			'shape
		    ) 
		    (axlPurgePadstacks 
			'padstacks nil
		    )
		    (axlPurgePadstacks 
			'via t
		    ) 
		    (axlDBRefreshId nil) 
		    (axlShell "save") 
		    (cmd = sprintf(nil "opencd %L" panel_design_fullpath)) 
		    (axlShell cmd)
		    (update_time = stringToTime(getCurrentTime())) 
		    TBX_PANELIZE_Update_All_Instances(panel_grid_info) 
		    (mdd_list = (axlSelectByName "MODULE" "*" t)) 
		    when(mdd_list 
			when(((tbx_panelize_global->panelType) == "MCM/SIP") 
			    TBX_PANELIZE_Set_Die_Properties(mdd_list)
			) 
			TBX_PANELIZE_Update_Panel_Id(mdd_list) 
			foreach(mdd mdd_list 
			    putprop(((tbx_panelize_global->cfg)->timeStamp) update_time 
				stringToSymbol((mdd->name))
			    )
			) 
			(axlDBAddProp mdd_list 
			    list("FIXED" t)
			)
		    ) 
		    (axlClearSelSet)
		)
	    ) 
	    ("init_modules" 
		tconc((tbx_panelize_global->viewlog) 
		    sprintf(nil "Creating Modules")
		) 
		(panel_stackup = TBX_PANELIZE_Get_Conductor_Layer_Info()) 
		(tbx_panelize_global->panelDesign = (axlGetDrawingName)) 
		(design_grid_info = TBX_PANELIZE_Extract_Design_Grid(t))
		((tbx_panelize_global->cfg)->designInfo = TBX_PANELIZE_Validate_Design_Info((tbx_panelize_global->panelDir) design_grid_info)) 
		(tbx_panelize_global->cfg = TBX_PANELIZE_Update_Config(form_handle 
			(tbx_panelize_global->cfg)
		    )) 
		(axlSaveDesign ?noConfirm t) 
		(result = TBX_PANELIZE_Create_Modules(panel_stackup 
			(tbx_panelize_global->sysLayers) 
			(tbx_panelize_global->cfg)
		    )) 
		((tbx_panelize_global->cfg)->mddSizeInfo = car(result))
		TBX_PANELIZE_Open((tbx_panelize_global->panelDesign)) 
		unless(axlGetVariable("FLW_DEBUG") 
		    foreach(db 
			cadr(result) 
			deleteFile(db)
		    )
		)
	    ) 
	    ("sync_stackup" 
		if((length(((tbx_panelize_global->cfg)->designInfo)) > 0) then 
		    tconc((tbx_panelize_global->viewlog) 
			sprintf(nil "Synchronize stackup")
		    ) 
		    (board_name = (axlFormGetField form_handle "board_name")) 
		    (unify_names = (axlFormGetField form_handle "unify_names"))
		    (design_grid_info = TBX_PANELIZE_Extract_Design_Grid(t)) 
		    ((tbx_panelize_global->cfg)->designInfo = TBX_PANELIZE_Validate_Design_Info((tbx_panelize_global->panelDir) design_grid_info)) 
		    (design_path_abs = TBX_PANELIZE_Get_Design_Path(board_name 
			    ((tbx_panelize_global->cfg)->designInfo) "absolute"
			)) 
		    case((tbx_panelize_global->panelType) 
			("BRD" 
			    TBX_PANELIZE_Sync_Stackup_PCB_Mode(design_path_abs unify_names)
			) 
			("MCM/SIP" 
			    TBX_PANELIZE_Sync_Stackup_MCM_Mode(design_path_abs unify_names)
			) 
			(t t)
		    ) else
		    printf("Warning: No designs have been defined.\n")
		)
	    ) 
	    ("import_techfile" 
		(tech_file = (axlDMFileBrowse nil nil ?optFilters "Technology file (*.tcf)|*.tcf")) 
		when((tech_file && isFile(tech_file)) 
		    TBX_UTIL_Import_Techfile(tech_file)
		)
	    )
	    ("import_wirebond_profiles" 
		(wb_xml_file = (axlDMFileBrowse nil nil ?optFilters "Wirebond profile definition (*.xml)|*.xml")) 
		when((wb_xml_file && isFile(wb_xml_file)) 
		    (axlFinishEnterFun) 
		    (axlImportWireProfileDefinitions wb_xml_file t) 
		    (axlDBRefreshId nil)
		)
	    ) 
	    ("include_all_layers" 
		when((form_handle->curValue) 
		    (axlFormSetField form_handle "include_artwork_layers" nil)
		) 
		if(((form_handle->curValue) || (axlFormGetField form_handle "include_artwork_layers")) then 
		    (axlFormSetFieldEditable form_handle "specify_layers" nil) else 
		    (axlFormSetFieldEditable form_handle "specify_layers" t)
		)
	    ) 
	    ("include_artwork_layers" 
		when((form_handle->curValue) 
		    (axlFormSetField form_handle "include_all_layers" nil)
		) 
		if(((form_handle->curValue) || (axlFormGetField form_handle "include_all_layers")) then 
		    (axlFormSetFieldEditable form_handle "specify_layers" nil) else 
		    (axlFormSetFieldEditable form_handle "specify_layers" t)
		)
	    ) 
	    ("specify_layers" 
		(FORM_FILE = TBX_FORM_Get_Name((tbx_panelize_global->licCheck) "panelize_layers")) 
		unless(boundp('tbxPanelizeLayersHandle) 
		    defvar(tbxPanelizeLayersHandle nil)
		) 
		(fid = (axlFormCreate 
			'tbxPanelizeLayersHandle FORM_FILE 
			'(e outer) 
			'TBX_PANELIZE_INCLUDE_Callback
			t nil
		    )) 
		when(fid 
		    TBX_FORM_Init_Header(fid "Licensed for " 
			(tbx_panelize_global->licCheck) 
			(tbx_panelize_global->version)
		    ) 
		    (axlFormSetField fid "available_layers" 
			(tbx_panelize_global->availableLayers)
		    ) 
		    (tbx_panelize_global->tmpSelection = ((tbx_panelize_global->cfg)->userLayers)) 
		    (axlFormSetField fid "selected_layers" 
			(tbx_panelize_global->tmpSelection)
		    )
		    (axlFormBuildPopup fid "class_name" 
			list((axlMapClassName "BOARD GEOMETRY") 
			    (axlMapClassName "MANUFACTURING") 
			    (axlMapClassName "DRAWING FORMAT")
			)
		    ) 
		    (axlFormSetField fid "class_name" 
			(axlMapClassName "BOARD GEOMETRY")
		    ) 
		    (axlFormDisplay fid) 
		    TBX_FORM_Delete((tbx_panelize_global->licCheck) FORM_FILE)
		)
	    ) 
	    ("design_grid" 
		caseq((form_handle->event) 
		    (rightpopup 
			case((form_handle->curValue) 
			    ("add_row" 
				(tbx_panelize_global->designGridRowCnt = ((tbx_panelize_global->designGridRowCnt) + 1)) 
				(axlFormGridInsertRows form_handle "design_grid" 
				    (tbx_panelize_global->designGridRowCnt) 1
				) 
				(tmp_list = list(nil nil "...")) 
				for(i 1 3 
				    (cell = (axlFormGridNewCell)) 
				    (cell->col = i)
				    (cell->row = (tbx_panelize_global->designGridRowCnt)) 
				    (cell->value = nth((i - 1) tmp_list)) 
				    when((i == 3) 
					(cell->noEdit = t)
				    ) 
				    (axlFormSetField form_handle "design_grid" cell)
				)
			    ) 
			    ("delete_row" 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 1) 
				(cell->row = (form_handle->row)) 
				(board_name = ((axlFormGridGetCell form_handle "design_grid" cell)->value))
				(board_name = TBX_PANELIZE_Validate_Input(board_name "string" "upperCaseNoSpace")) 
				(ok_delete = t) 
				foreach(p 
				    (tbx_panelize_global->panelInfo) 
				    when(((cadr(p)->definition) == board_name) 
					(ok_delete = nil) 
					printf("Warning: Row cannot be deleted, as board is already in use.\n")
				    )
				) 
				when(ok_delete 
				    if(((tbx_panelize_global->designGridRowCnt) >= 2) then 
					(axlFormGridDeleteRows form_handle "design_grid" 
					    (form_handle->row) 1
					) 
					(tbx_panelize_global->designGridRowCnt = ((tbx_panelize_global->designGridRowCnt) - 1)) else
					(tmp_list = list("" "" "...")) 
					for(i 1 3 
					    (cell = (axlFormGridNewCell)) 
					    (cell->col = i)
					    (cell->row = 1) 
					    (cell->value = nth((i - 1) tmp_list)) 
					    when((i == 3) 
						(cell->noEdit = t)
					    ) 
					    (axlFormSetField form_handle "design_grid" cell)
					)
				    ) 
				    (axlFormGridUpdate form_handle "design_grid")
				)
			    )
			) 
			(axlFormGridUpdate form_handle "design_grid")
		    ) 
		    (cellselect 
			when(((form_handle->col) == 3) 
			    (board_fullpath = (axlDMFileBrowse nil nil ?optFilters 
				    TBX_PANELIZE_Get_Filter_String()
				)) 
			    when(board_fullpath 
				(board_name = upperCase(cadr((axlDMFileParts board_fullpath)))) 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 1) 
				(cell->row = (form_handle->row))
				(cur_name = ((axlFormGridGetCell form_handle "design_grid" cell)->value)) 
				when((!cur_name || rexMatchp("^ *$" cur_name)) 
				    (cell = (axlFormGridNewCell)) 
				    (cell->col = 1) 
				    (cell->row = (form_handle->row)) 
				    (cell->value = board_name)
				    (cell->noEdit = nil) 
				    (cell->backColor = 'white) 
				    (axlFormSetField form_handle "design_grid" cell)
				) 
				if(((tbx_panelize_global->cfg)->useRelativePath) then 
				    (board_dir = car((axlDMFileParts board_fullpath))) 
				    (brd_file = caddr((axlDMFileParts board_fullpath))) 
				    when(TBX_UTIL_Get_Relative_Path(board_dir 
					    (tbx_panelize_global->panelDir)
					) 
					(board_path = strcat(TBX_UTIL_Get_Relative_Path(board_dir 
						    (tbx_panelize_global->panelDir)
						) "/" brd_file
					    ))
				    )
				    else 
				    (board_path = board_fullpath)
				) 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 2)
				(cell->row = (form_handle->row)) 
				(cell->value = board_path) 
				(cell->noEdit = t) 
				(cell->backColor = 'white) 
				(axlFormSetField form_handle "design_grid" cell)
				(axlFormGridUpdate form_handle "design_grid")
			    )
			)
		    ) 
		    (change 
			when(onep((form_handle->col)) 
			    (cell = (axlFormGridNewCell)) 
			    (cell->col = 1) 
			    (cell->row = (form_handle->row)) 
			    (board_name = ((axlFormGridGetCell form_handle "design_grid" cell)->value))
			    (board_name = TBX_PANELIZE_Validate_Input(board_name "string" "upperCaseNoSpace")) 
			    when((board_name && (board_name != "")) 
				foreach(entry 
				    ((tbx_panelize_global->cfg)->designInfo) 
				    when((car(entry) == board_name) 
					printf("Warning: Board name aleady in use.\n") 
					(cell = (axlFormGridNewCell)) 
					(cell->col = 1) 
					(cell->row = (form_handle->row))
					(cell->value = strcat(board_name "_1")) 
					(cell->backColor = 'white) 
					(axlFormSetField form_handle "design_grid" cell) 
					(axlFormGridUpdate form_handle "design_grid")
				    )
				)
			    )
			)
		    )
		) 
		(design_grid_info = TBX_PANELIZE_Extract_Design_Grid(t)) 
		((tbx_panelize_global->cfg)->designInfo = TBX_PANELIZE_Validate_Design_Info((tbx_panelize_global->panelDir) design_grid_info)) 
		foreach(entry 
		    ((tbx_panelize_global->cfg)->designInfo) 
		    (popup_list = cons(car(entry) popup_list))
		)
		(popup_list = sort(popup_list nil)) 
		(axlFormBuildPopup 
		    ((tbx_panelize_global->formHandle)->main) "grid_board_name_popup" popup_list
		) 
		(axlFormBuildPopup 
		    ((tbx_panelize_global->formHandle)->main) "board_name" popup_list
		) 
		(axlFormSetField 
		    ((tbx_panelize_global->formHandle)->main) "board_name" 
		    car(popup_list)
		)
	    )
	    ("use_relative_path" 
		((tbx_panelize_global->cfg)->useRelativePath = (form_handle->curValue)) 
		(design_grid_info = TBX_PANELIZE_Extract_Design_Grid(t)) 
		((tbx_panelize_global->cfg)->designInfo = TBX_PANELIZE_Validate_Design_Info((tbx_panelize_global->panelDir) design_grid_info)) 
		TBX_PANELIZE_Init_Grid(form_handle "design")
	    ) 
	    ("panel_grid" 
		caseq((form_handle->event) 
		    (rightpopup 
			case((form_handle->curValue) 
			    ("delete_item" 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 1) 
				(cell->row = (form_handle->row)) 
				(panel_id = ((axlFormGridGetCell form_handle "panel_grid" cell)->value))
				if(((tbx_panelize_global->panelGridRowCnt) >= 2) then 
				    (axlFormGridDeleteRows form_handle "panel_grid" 
					(form_handle->row) 1
				    ) 
				    (tbx_panelize_global->panelGridRowCnt = ((tbx_panelize_global->panelGridRowCnt) - 1)) else
				    (tmp_list = list("" "" "" "" ""
					    ""
					)) 
				    for(i 1 6 
					(cell = (axlFormGridNewCell)) 
					(cell->col = i)
					(cell->row = 1) 
					(cell->value = nth((i - 1) tmp_list)) 
					(axlFormSetField form_handle "panel_grid" cell)
				    )
				) 
				TBX_PANELIZE_Delete_Modules(list(panel_id)) 
				(axlDBRefreshId nil)
			    ) 
			    ("delete_all" 
				(panel_grid_info = TBX_PANELIZE_Extract_Panel_Grid()) 
				when(panel_grid_info 
				    (id_list = mapcar(lambda((x) 
						car(x)
					    ) panel_grid_info
					)) 
				    (id_list = id_list) 
				    (axlDBCloak 
					'TBX_PANELIZE_Delete_Modules(id_list) 
					'shape
				    ) 
				    (axlPurgePadstacks 
					'padstacks nil
				    )
				    (axlPurgePadstacks 
					'via t
				    ) 
				    (axlDBRefreshId nil) 
				    (tbx_panelize_global->panelInfo = TBX_PANELIZE_Get_Panel_Info()) 
				    TBX_PANELIZE_Init_Grid(form_handle "panel")
				)
			    ) 
			    ("highlight_instance" 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 1) 
				(cell->row = (form_handle->row)) 
				(panel_id = ((axlFormGridGetCell form_handle "panel_grid" cell)->value))
				(mdd_inst = car((axlSelectByName "MODULE" panel_id))) 
				(axlZoomToDbid mdd_inst t) 
				(axlHighlightObject mdd_inst)
			    ) 
			    ("dehighlight_instance" 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 1) 
				(cell->row = (form_handle->row)) 
				(panel_id = ((axlFormGridGetCell form_handle "panel_grid" cell)->value))
				(mdd_inst = car((axlSelectByName "MODULE" panel_id))) 
				(axlZoomToDbid mdd_inst t) 
				(axlDehighlightObject mdd_inst)
			    )
			    ("dehighlight_all" 
				(tmp_list = (axlSelectByName "MODULE" "*" t)) 
				(axlDehighlightObject tmp_list)
			    ) 
			    ("update_changes" 
				TBX_PANELIZE_Protection_Mode("unfix") 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 1) 
				(cell->row = (form_handle->row))
				(panel_id = ((axlFormGridGetCell form_handle "panel_grid" cell)->value)) 
				(cell->noEdit = t) 
				(cell->backColor = 'button) 
				(axlFormSetField form_handle "panel_grid" cell) 
				(cell = (axlFormGridNewCell))
				(cell->col = 2) 
				(cell->row = (form_handle->row)) 
				(board_name = ((axlFormGridGetCell form_handle "panel_grid" cell)->value)) 
				(cell->noEdit = t) 
				(cell->backColor = 'button)
				(axlFormSetField form_handle "panel_grid" cell) 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 3) 
				(cell->row = (form_handle->row)) 
				(pt_x = ((axlFormGridGetCell form_handle "panel_grid" cell)->value))
				(cell->noEdit = nil) 
				(cell->backColor = 'white) 
				(axlFormSetField form_handle "panel_grid" cell) 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 4)
				(cell->row = (form_handle->row)) 
				(pt_y = ((axlFormGridGetCell form_handle "panel_grid" cell)->value)) 
				(cell->noEdit = nil) 
				(cell->backColor = 'white) 
				(axlFormSetField form_handle "panel_grid" cell)
				(cell = (axlFormGridNewCell)) 
				(cell->col = 5) 
				(cell->row = (form_handle->row)) 
				(rot = ((axlFormGridGetCell form_handle "panel_grid" cell)->value)) 
				(cell->noEdit = nil)
				(cell->backColor = 'white) 
				(axlFormSetField form_handle "panel_grid" cell) 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 6) 
				(cell->row = (form_handle->row))
				(mirror = ((axlFormGridGetCell form_handle "panel_grid" cell)->value)) 
				(cell->noEdit = nil) 
				(cell->backColor = 'white) 
				(axlFormSetField form_handle "panel_grid" cell) 
				(panel_id = TBX_PANELIZE_Validate_Input(panel_id "string" "upperCaseNoSpace"))
				(board_name = TBX_PANELIZE_Validate_Input(board_name "string" "upperCaseNoSpace")) 
				(pt_x = TBX_PANELIZE_Validate_Input(pt_x "float")) 
				(pt_y = TBX_PANELIZE_Validate_Input(pt_y "float")) 
				(rot = TBX_PANELIZE_Validate_Input(rot "float")) 
				(mirror = TBX_PANELIZE_Validate_Input(mirror "string" "lowerCaseNoSpace"))
				if((panel_id && board_name && pt_x && pt_y && rot && mirror) then 
				    (mdd_inst = car((axlSelectByName "MODULE" panel_id))) 
				    when(mdd_inst 
					(mdd_info = (axlGetModuleInstanceLocation mdd_inst)) 
					cond(((length(mdd_info) == 2) 
						(mdd_mirror = nil)
					    ) 
					    ((length(mdd_info) == 3) 
						(mdd_mirror = t)
					    ) 
					    (t 
						(mdd_mirror = nil)
					    )
					) 
					if((((mirror == "yes") && mdd_mirror) || ((mirror == "no") && !mdd_mirror)) then 
					    (mirror_flag = nil) else 
					    (mirror_flag = t)
					) 
					(mdd_xy = car(mdd_info))
					(mdd_rot = (cadr(mdd_info) * 1.0)) 
					(delta_x = (pt_x - car(mdd_xy))) 
					(delta_y = (pt_y - cadr(mdd_xy))) 
					(delta_rot = (rot - mdd_rot)) 
					unless(mdd_mirror 
					    (mdd_rot = (- mdd_rot))
					)
					if(TBX_PANELIZE_Fit_To_Canvas(mdd_inst 
						(delta_x:delta_y) delta_rot mirror_flag 
						(pt_x:pt_y)
					    ) then 
					    (axlTransformObject mdd_inst ?move 
						(delta_x:delta_y) ?mirror
						mirror_flag ?angle delta_rot ?origin 
						(pt_x:pt_y)
						?allOrNone t
					    ) else 
					    printf("Warning: Out of extents, cannot transform module.\n")
					    (cell = (axlFormGridNewCell)) 
					    (cell->col = 3) 
					    (cell->row = (form_handle->row)) 
					    (cell->value = car(mdd_xy)) 
					    (cell->backColor = 'white)
					    (axlFormSetField form_handle "panel_grid" cell) 
					    (cell = (axlFormGridNewCell)) 
					    (cell->col = 4) 
					    (cell->row = (form_handle->row)) 
					    (cell->value = cadr(mdd_xy))
					    (cell->backColor = 'white) 
					    (axlFormSetField form_handle "panel_grid" cell) 
					    (cell = (axlFormGridNewCell)) 
					    (cell->col = 5) 
					    (cell->row = (form_handle->row))
					    (cell->value = mdd_rot) 
					    (cell->backColor = 'white) 
					    (axlFormSetField form_handle "panel_grid" cell) 
					    (cell = (axlFormGridNewCell)) 
					    (cell->col = 6)
					    (cell->row = (form_handle->row)) 
					    if(mdd_mirror then 
						(cell->value = "yes") else 
						(cell->value = "no")
					    ) 
					    (cell->backColor = 'white) 
					    (axlFormSetField form_handle "panel_grid" cell)
					)
				    ) else
				    printf("Warning: Incomplete data in row %L, cannot modify item.\n" 
					(form_handle->row)
				    )
				) 
				TBX_PANELIZE_Protection_Mode("fix")
			    )
			) 
			(axlFormGridUpdate form_handle "panel_grid")
		    ) 
		    (change 
			when(((form_handle->col) != 1) 
			    (cell = (axlFormGridNewCell)) 
			    (cell->col = (form_handle->col)) 
			    (cell->row = (form_handle->row)) 
			    (cell->noEdit = nil)
			    (cell->backColor = 'yellow) 
			    (axlFormSetField form_handle "panel_grid" cell)
			) 
			(axlFormGridUpdate form_handle "panel_grid")
		    )
		)
	    ) 
	    ("save_to_file" 
		(grid_info = TBX_PANELIZE_Extract_Panel_Grid()) 
		(instance_info = sortcar(grid_info 
			'axlStrcmpAlpNum
		    )) 
		(config_file = (axlDMFileBrowse "ALLEGRO_TEXT" t)) 
		when(config_file 
		    TBX_PANELIZE_Save_to_File(config_file instance_info)
		)
	    ) 
	    ("load_from_file" 
		(config_file = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
		when(config_file 
		    (instance_info = TBX_PANELIZE_Load_from_File(config_file)) 
		    when(instance_info 
			(tbx_panelize_global->panelInfo = instance_info) 
			TBX_PANELIZE_Init_Grid(form_handle "panel") 
			(axlUIConfirm "Choose Update panel in order to commit changes to database")
		    )
		)
	    ) 
	    ("place_mode" 
		(grid_info = TBX_PANELIZE_Extract_Design_Grid(t)) 
		((tbx_panelize_global->cfg)->designInfo = TBX_PANELIZE_Validate_Design_Info((tbx_panelize_global->panelDir) grid_info)) 
		if(((tbx_panelize_global->cfg)->designInfo) then 
		    if(TBX_PANELIZE_Validate_Size_Info(((tbx_panelize_global->cfg)->mddSizeInfo)) then 
			(axlShell "tbx panelize place") else 
			(axlUIConfirm "Info: Size data for dynamic preview not complete.\nRun Create Modules first.")
		    ) else 
		    printf("Warning: No design specified. Cannot proceed.\n")
		)
	    )
	    ("done" 
		TBX_PANELIZE_Change_Env("reset") 
		(tbx_panelize_global->cfg = TBX_PANELIZE_Update_Config(form_handle 
			(tbx_panelize_global->cfg)
		    )) 
		TBX_PANELIZE_Save_Config_To_Database() 
		TBX_FORM_Done(form_handle nil)
		when((tbx_panelize_global->envVar) 
		    TBX_UTIL_Restore_Session_Variables((tbx_panelize_global->envVar) 
			list("padpath" "psmpath") t
		    )
		) 
		(tbx_panelize_global = nil) 
		printf("Info: Due to performance reasons, On-Line DRC had been disabled. Please run DRC Update.\n")
	    ) 
	    ("status" 
		TBX_PANELIZE_Check_Status((tbx_panelize_global->panelInfo) 
		    ((tbx_panelize_global->cfg)->timeStamp) 
		    ((tbx_panelize_global->cfg)->designInfo)
		)
	    ) 
	    ("cleanup_local_dir" 
		(msg = sprintf(nil "This process will cleanup local libraries (*.pad, *.dra, *.psm etc.) in directory %s\nDo you want to continue?" 
			getWorkingDir()
		    )) 
		when((axlUIYesNo msg nil 
			'no
		    ) 
		    TBX_PANELIZE_Cleanup_Local_Library_Data(getWorkingDir())
		)
	    ) 
	    ("my_help" 
		(axlShell "tbx help panelize")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_PANELIZE_Change_Env(mode) 
    let((var_list) 
	(var_list = var_list) 
	case(mode 
	    ("set" 
		unless(axlGetVariable("NOCONFIRM_SAVEDB") 
		    (axlSetVariable "NOCONFIRM_SAVEDB" t) 
		    ((tbx_panelize_global->envSettings)->noConfirmSaveOrig = nil)
		) 
		unless(axlGetVariable("DB_TIER_NOMSG") 
		    (axlSetVariable "DB_TIER_NOMSG" t) 
		    ((tbx_panelize_global->envSettings)->noTierMessageOrig = nil)
		) 
		unless(axlGetVariable("NOCONFIRM_UPREV") 
		    (axlSetVariable "NOCONFIRM_UPREV" t) 
		    ((tbx_panelize_global->envSettings)->noConfirmUprevOrig = nil)
		) 
		((tbx_panelize_global->envSettings)->mddpathOrig = axlGetVariable("MODULEPATH"))
		(axlSetVariable "MODULEPATH" ".")
	    ) 
	    ("reset" 
		unless(((tbx_panelize_global->envSettings)->noConfirmSaveOrig) 
		    (axlUnsetVariable "NOCONFIRM_SAVEDB")
		) 
		unless(((tbx_panelize_global->envSettings)->noTierMessageOrig) 
		    (axlUnsetVariable "DB_TIER_NOMSG")
		) 
		unless(((tbx_panelize_global->envSettings)->noConfirmUprevOrig) 
		    (axlUnsetVariable "NOCONFIRM_UPREV")
		) 
		(axlSetVariable "MODULEPATH" 
		    ((tbx_panelize_global->envSettings)->mddpathOrig)
		)
	    ) 
	    (t t)
	) t
    )
)
procedure(TBX_PANELIZE_Check_Library_Path() 
    let((padpath psmpath ok_library_path) 
	(padpath = axlGetVariable("padpath")) 
	(psmpath = axlGetVariable("psmpath")) 
	when(((car(parseString(padpath)) == ".") && (car(parseString(psmpath)) == ".")) 
	    (ok_library_path = t)
	) ok_library_path
    )
)
procedure(TBX_PANELIZE_Check_Status(panelInfo timeStamp designInfo) 
    let((port log_file board_name board_path panel_id
	    attr last_update
	) 
	(log_file = strcat(getWorkingDir() "/panelize_status.txt")) 
	(port = outfile(log_file "w")) 
	fprintf(port "================================================\n") 
	fprintf(port "Instance    Design         Last Update/Create\n")
	fprintf(port "================================================\n") 
	foreach(entry panelInfo 
	    (panel_id = upperCase(car(entry))) 
	    (attr = cadr(entry)) 
	    (board_name = (attr->definition))
	    if(get(timeStamp 
		    stringToSymbol(panel_id)
		) then 
		(last_update = timeToString(get(timeStamp 
			    stringToSymbol(panel_id)
			)
		    )) else 
		(last_update = "NA")
	    ) 
	    fprintf(port "%-10s  %-13s  %-22s\n" panel_id board_name last_update)
	) 
	fprintf(port "\n\n") 
	fprintf(port "================================================\n") 
	fprintf(port "Design      Last Modified         Path\n")
	fprintf(port "================================================\n") 
	foreach(entry designInfo 
	    (board_name = upperCase(car(entry))) 
	    if(((tbx_panelize_global->cfg)->useRelativePath) then 
		(board_path = caddr(entry)) else 
		(board_path = cadr(entry))
	    ) 
	    if(isFile(board_path) then 
		fprintf(port "%-10s  %-13s  %-s\n" board_name 
		    timeToString(fileTimeModified(board_path)) board_path
		) else 
		fprintf(port "Warning: Cannot access file %L\n" board_path)
	    )
	) 
	close(port) 
	(axlUIViewFileCreate log_file "Panelization: Status" nil) 
	when(isFile(log_file) 
	    deleteFile(log_file)
	)
    )
)
procedure(TBX_PANELIZE_Cleanup_Local_Library_Data(dir_name) 
    let((dir_data dra_list psm_list bsm_list osm_list
	    fsm_list ssm_list pad_list log_list lib_list
	    view_list
	) 
	(dir_data = getDirFiles(dir_name)) 
	(view_list = rexMatchList("[.][cC][oO][lL][oO][rR]$" dir_data)) 
	(dra_list = rexMatchList("[.][dD][rR][aA]$" dir_data)) 
	(psm_list = rexMatchList("[.][pP][sS][mM]$" dir_data))
	(bsm_list = rexMatchList("[.][bB][sS][mM]$" dir_data)) 
	(osm_list = rexMatchList("[.][oO][sS][mM]$" dir_data)) 
	(fsm_list = rexMatchList("[.][fF][sS][mM]$" dir_data)) 
	(ssm_list = rexMatchList("[.][sS][sS][mM]$" dir_data)) 
	(pad_list = rexMatchList("[.][pP][aA][dD]$" dir_data))
	(log_list = rexMatchList("[.][lL][oO][gG],*[123]*$" dir_data)) 
	(log_list = remove("signoise.log" log_list)) 
	(lib_list = nconc(view_list dra_list psm_list bsm_list osm_list
		fsm_list ssm_list pad_list log_list
	    )) 
	when(lib_list 
	    (lib_list = mapcar(lambda((x) 
			strcat(getWorkingDir() "/" x)
		    ) lib_list
		)) 
	    printf("Cleaning up current working directory...\n") 
	    foreach(fn lib_list 
		when((isReadable(fn) && isWritable(fn)) 
		    deleteFile(fn)
		)
	    )
	) t
    )
)
procedure(TBX_PANELIZE_Clear_Nets(id_list) 
    let((net_prefix net_list) 
	foreach(pid id_list 
	    (net_prefix = strcat("^" pid "_")) 
	    (net_list = setof(x 
		    ((axlDBGetDesign)->nets) 
		    rexMatchp(net_prefix 
			upperCase((x->name))
		    )
		)) 
	    foreach(net net_list 
		(axlRemoveNet net)
	    )
	) 
	foreach(net 
	    ((axlDBGetDesign)->nets) 
	    unless((axlPinsOfNet net 
		    'pin
		) 
		(axlRemoveNet net)
	    )
	) 
	(axlDBRefreshId nil) t
    )
)
procedure(TBX_PANELIZE_Convert_Fillets() 
    let((fillet_list) 
	(axlVisibleDesign nil) 
	(axlVisibleLayer 
	    (axlMapClassName "ETCH") t
	) 
	(axlVisibleLayer 
	    (axlMapClassName "BOUNDARY") t
	) 
	(axlSetFindFilter ?enabled 
	    list("noall" "dynthemals" "shapes") ?onButtons 
	    list("all")
	)
	(axlClearSelSet) 
	(axlAddSelectAll) 
	(fillet_list = setof(x 
		(axlGetSelSet) 
		(x->fillet)
	    )) 
	when(fillet_list 
	    (axlDBCloak 
		TBX_PANELIZE_Convert_Fillets_Cloak(fillet_list) 
		'shape
	    )
	) t
    )
)
procedure(TBX_PANELIZE_Convert_Fillets_Cloak(fillet_list) 
    foreach(flt fillet_list 
	(axlFilletConvert flt)
    )
)
procedure(TBX_PANELIZE_Copy_Refdes(cfg mode) 
    let((continue refdes_source refdes_source_layers refdes_docu_layers layer_map) 
	(continue = t) 
	when((mode == "alt") 
	    cond((((cfg->refdesAlt) == "none") 
		    (continue = nil)
		) 
		(((cfg->refdesAlt) == (cfg->refdesMaster)) 
		    printf("Skipping redfes copy in alt mode, since value is identical to master\n") 
		    (continue = nil)
		)
	    )
	) 
	when(continue 
	    if((mode == "master") then 
		(refdes_source = (cfg->refdesMaster)) else 
		(refdes_source = (cfg->refdesAlt))
	    ) 
	    case(refdes_source 
		("refdes_assembly" 
		    (refdes_source_layers = list(upperCase(strcat((axlMapClassName "REF DES") "/ASSEMBLY_TOP")) 
			    upperCase(strcat((axlMapClassName "REF DES") "/ASSEMBLY_BOTTOM"))
			))
		) 
		("refdes_silkscreen" 
		    (refdes_source_layers = list(upperCase(strcat((axlMapClassName "REF DES") "/SILKSCREEN_TOP")) 
			    upperCase(strcat((axlMapClassName "REF DES") "/SILKSCREEN_BOTTOM"))
			))
		) 
		("refdes_display" 
		    (refdes_source_layers = list(upperCase(strcat((axlMapClassName "REF DES") "/DISPLAY_TOP")) 
			    upperCase(strcat((axlMapClassName "REF DES") "/DISPLAY_BOTTOM"))
			))
		) 
		(t t)
	    ) 
	    tconc((tbx_panelize_global->viewlog) 
		sprintf(nil "   Copying refdes labels in %L mode" mode)
	    ) 
	    tconc((tbx_panelize_global->viewlog) 
		sprintf(nil "      Source layers: %L" refdes_source_layers)
	    )
	    if((mode == "master") then 
		(refdes_docu_layers = list(upperCase(strcat((axlMapClassName "PACKAGE GEOMETRY") "/PNL_REFDES_TOP")) 
			upperCase(strcat((axlMapClassName "PACKAGE GEOMETRY") "/PNL_REFDES_BOTTOM"))
		    )) else 
		(refdes_docu_layers = list(upperCase(strcat((axlMapClassName "PACKAGE GEOMETRY") "/PNL_REFDES_ALT_TOP")) 
			upperCase(strcat((axlMapClassName "PACKAGE GEOMETRY") "/PNL_REFDES_ALT_BOTTOM"))
		    ))
	    ) 
	    tconc((tbx_panelize_global->viewlog) 
		sprintf(nil "      Panel docu layers: %L" refdes_docu_layers)
	    ) 
	    (layer_map = makeTable("layer_map_table" nil)) 
	    (layer_map[car(refdes_source_layers)] = car(refdes_docu_layers)) 
	    (layer_map[cadr(refdes_source_layers)] = cadr(refdes_docu_layers))
	    foreach(lyr refdes_docu_layers 
		unless((axlLayerGet lyr) 
		    (axlLayerCreateNonConductor lyr)
		)
	    ) 
	    (axlVisibleDesign nil) 
	    foreach(lyr refdes_source_layers 
		(axlVisibleLayer lyr t)
	    ) 
	    (axlSetFindFilter ?enabled 
		list("noall" "text") ?onButtons 
		list("all")
	    ) 
	    (axlClearSelSet)
	    (axlAddSelectAll) 
	    tconc((tbx_panelize_global->viewlog) 
		sprintf(nil "      Number of refdes labels to copy: %L" 
		    length((axlGetSelSet))
		)
	    ) 
	    TBX_PANELIZE_Copy_Text((axlGetSelSet) layer_map) 
	    (axlClearSelSet)
	) t
    )
)
procedure(TBX_PANELIZE_Copy_Text(text_list layer_map) 
    let((text_str text_block text_rotation text_mirrored text_justify
	    myorient text_xy destination_layer
	) 
	foreach(text_dbid text_list 
	    (text_str = (text_dbid->text)) 
	    (text_block = (text_dbid->textBlock)) 
	    (text_xy = (text_dbid->xy))
	    (text_rotation = (text_dbid->rotation)) 
	    (text_mirrored = (text_dbid->isMirrored)) 
	    (text_justify = (text_dbid->justify)) 
	    (destination_layer = layer_map[upperCase((text_dbid->layer))]) 
	    (myorient = (make_axlTextOrientation ?textBlock text_block ?rotation text_rotation
		    ?mirrored text_mirrored ?justify text_justify
		))
	    (axlDBCreateText text_str text_xy myorient destination_layer
		nil
	    )
	)
    )
)
procedure(TBX_PANELIZE_Create_Artwork() 
    let((port script_file) 
	(script_file = strcat(getWorkingDir() "/tbx_panelize_create_art.scr")) 
	(port = outfile(script_file "w")) 
	fprintf(port "scriptmode +i\n") 
	fprintf(port "setwindow pcb\n")
	fprintf(port "generaledit\n") 
	fprintf(port "echo Create conductor artwork...\n") 
	fprintf(port "artwork \n") 
	fprintf(port "setwindow form.film_control\n") 
	fprintf(port "FORM film_control select_all  \n")
	fprintf(port "FORM film_control create  \n") 
	fprintf(port "FORM film_control ok  \n") 
	fprintf(port "setwindow pcb\n") 
	close(port) 
	(axlShell 
	    strcat("replay " 
		sprintf(nil "%L" script_file)
	    )
	)
	(axlVisibleUpdate t) 
	unless(axlGetVariable("FLW_DEBUG") 
	    when(isFile(script_file) 
		deleteFile(script_file)
	    )
	) t
    )
)
procedure(TBX_PANELIZE_Create_Modules(panel_stackup sys_layers cfg) 
    let((mdd_definition database_fullpath tmp_database arr sym_def
	    class_name subclass_name database_lyr panel_lyr find_filter
	    current_size_info mdd_size_info msg design_outline_lyr sym_inst
	    layer_info layer_cnt change_list ok_continue ok_database
	    mdd_list sym_list die_info tmp_database_list result
	) 
	tconc((tbx_panelize_global->viewlog) 
	    sprintf(nil "  Status NOCONFIRM_SAVEDB: %L" 
		axlGetVariable("NOCONFIRM_SAVEDB")
	    )
	) 
	tconc((tbx_panelize_global->viewlog) 
	    sprintf(nil "  Creating Mdd files: Refdes Primary: %L  Routing: %L Artwork: %L  Nets: %L" 
		(cfg->refdesMaster) 
		(cfg->excludeRouting) 
		(cfg->loadArtwork)
		(cfg->clearNets)
	    )
	) 
	(find_filter = list("noall" "symbols" "vias" "clines" "lines"
		"shapes" "boundary_shapes" "figures" "text"
	    )) 
	(mdd_size_info = list())
	(tbx_panelize_global->dieInfo = makeTable("die_info_table" nil)) 
	foreach(entry 
	    (cfg->designInfo) 
	    (ok_database = t) 
	    (ok_continue = t) 
	    (mdd_definition = car(entry))
	    (database_fullpath = cadr(entry)) 
	    (arr = (axlDMFileParts database_fullpath)) 
	    (tmp_database = strcat((tbx_panelize_global->panelDir) "/" 
		    lowerCase(cadr(arr)) "_tbxtmp" "."
		    lowerCase(nth(3 arr))
		)) 
	    unless((axlOSFileCopy database_fullpath tmp_database nil) 
		(axlUIConfirm "Copy operation FAILED") 
		(ok_database = nil)
	    ) 
	    if(ok_database then 
		TBX_PANELIZE_Open(tmp_database) 
		tconc((tbx_panelize_global->viewlog) 
		    sprintf(nil "   Processing database: %L" tmp_database)
		) 
		TBX_PANELIZE_Protection_Mode("unfix")
		(mdd_list = (axlSelectByName "MODULE" "*" t)) 
		when(mdd_list 
		    (axlDBDeleteProp mdd_list 
			list("LOCKED")
		    )
		) 
		(sym_list = ((axlDBGetDesign)->symbols)) 
		when(sym_list 
		    (axlDBDeleteProp sym_list 
			list("LOCKED")
		    )
		) 
		(axlDBRefreshId nil)
		(layer_info = TBX_PANELIZE_Get_Conductor_Layer_Info()) 
		when((length(layer_info) != length(panel_stackup)) 
		    (ok_continue = nil) 
		    (msg = sprintf(nil "Number of physical (etch) layers from panel design and %L do not match." database_fullpath)) 
		    (msg = sprintf(nil "%s\nStackup must have been synchronized before." msg)) 
		    (axlUIConfirm msg)
		) 
		if(ok_continue then 
		    (layer_cnt = length(layer_info)) 
		    for(i 0 
			(layer_cnt - 1) 
			(panel_lyr = nth(i panel_stackup)) 
			(database_lyr = nth(i layer_info))
			when((cadr(panel_lyr) != cadr(database_lyr)) 
			    (change_list = cons(list(list(car(database_lyr) 
					    cadr(database_lyr)
					) 
					cadr(panel_lyr) nil nil
				    ) change_list
				))
			)
		    ) 
		    when(change_list 
			(change_list = reverse(change_list)) 
			tconc((tbx_panelize_global->viewlog) 
			    sprintf(nil "   Renaming layers: %L" change_list)
			) 
			TBX_PANELIZE_Rename_Layers(change_list)
		    )
		    (axlRunBatchDBProgram "dump_libraries" "dump_libraries -pamsfcx %s") 
		    TBX_PANELIZE_Copy_Refdes(cfg "master") 
		    TBX_PANELIZE_Copy_Refdes(cfg "alt") 
		    tconc((tbx_panelize_global->viewlog) 
			sprintf(nil "   Changing dynamic shapes to static")
		    ) 
		    (axlVisibleDesign nil)
		    (axlVisibleLayer 
			(axlMapClassName "ETCH") t
		    ) 
		    (axlVisibleLayer 
			(axlMapClassName "BOUNDARY") t
		    ) 
		    (axlSetFindFilter ?enabled 
			list("noall" "shapes" "boundary_shapes") ?onButtons 
			list("all")
		    ) 
		    (axlClearSelSet) 
		    (axlAddSelectAll)
		    (axlDBCloak 
			'TBX_PANELIZE_Make_Static((axlGetSelSet)) 
			'shape
		    ) 
		    when(isCallable('axlFilletConvert) 
			tconc((tbx_panelize_global->viewlog) 
			    sprintf(nil "   Convert fillets to static shapes")
			) 
			TBX_PANELIZE_Convert_Fillets()
		    ) 
		    tconc((tbx_panelize_global->viewlog) 
			sprintf(nil "   Checking Package and Route Keepins")
		    ) 
		    (axlVisibleDesign nil) 
		    (axlVisibleLayer 
			strcat((axlMapClassName "ROUTE KEEPIN") "/ALL") t
		    )
		    (axlVisibleLayer 
			strcat((axlMapClassName "PACKAGE KEEPIN") "/ALL") t
		    ) 
		    (axlSetFindFilter ?enabled 
			list("noall" "shapes" "boundary_shapes") ?onButtons 
			list("all")
		    ) 
		    (axlClearSelSet) 
		    (axlAddSelectAll) 
		    foreach(shp 
			(axlGetSelSet) 
			(arr = parseString((shp->layer) "/")) 
			(class_name = upperCase((axlMapClassName 
				    car(arr) t
				)
			    )) 
			(subclass_name = upperCase(cadr(arr)))
			(sym_inst = (shp->parent)) 
			when(((class_name == (axlMapClassName "PACKAGE KEEPIN")) || 
				(class_name == (axlMapClassName "ROUTE KEEPIN"))) 
			    tconc((tbx_panelize_global->viewlog) 
				sprintf(nil "      Delete shape instance on %L" class_name)
			    ) 
			    (axlDeleteObject shp)
			) 
			when(sym_inst 
			    (sym_def = (sym_inst->definition)) 
			    foreach(ch 
				(sym_def->children) 
				when((((ch->objType) == "shape") || ((ch->objType) == "polygon")) 
				    (arr = parseString((ch->layer) "/")) 
				    (class_name = upperCase((axlMapClassName 
						car(arr) t
					    )
					)) 
				    (subclass_name = upperCase(cadr(arr))) 
				    when(((class_name == (axlMapClassName "PACKAGE KEEPIN")) || 
					    (class_name == (axlMapClassName "ROUTE KEEPIN"))) 
					(subclass_name = subclass_name) 
					tconc((tbx_panelize_global->viewlog) 
					    sprintf(nil "      Delete data from %L in symbol definition %L" class_name 
						(sym_inst->name)
					    )
					) 
					(axlDeleteObject ch)
				    )
				)
			    )
			)
		    )
		    (axlDBRefreshId nil) 
		    when(((axlVersion 
				'version
			    ) >= 17.2) 
			TBX_PANELIZE_Outline_Backup()
		    ) 
		    tconc((tbx_panelize_global->viewlog) 
			sprintf(nil "   Extracting mdd size")
		    ) 
		    (current_size_info = TBX_PANELIZE_Get_Design_Size()) 
		    TBX_PANELIZE_Autosilk_Backup()
		    when(((tbx_panelize_global->panelType) == "MCM/SIP") 
			(die_info = TBX_PANELIZE_Get_Die_Properties()) 
			((tbx_panelize_global->dieInfo)[mdd_definition] = die_info)
		    ) 
		    when(((tbx_panelize_global->panelType) == "MCM/SIP") 
			TBX_PANELIZE_Process_Bond_Pads()
		    ) 
		    when(axlGetVariable("TBX_PANELIZE_ENABLE_TOUCH_CONNECT") 
			TBX_PANELIZE_Safe_Connect()
		    ) 
		    when((cfg->clearNets) t) 
		    TBX_PANELIZE_Strip_Constraints()
		    when((cfg->loadArtwork) 
			(axlDBDeleteProp 
			    (axlDBGetDesign) 
			    list("ARTWORK_SUFFIX" "ARTWORK_PREFIX")
			) 
			(axlDBRefreshId nil) 
			(axlDeleteObject 
			    (axlGetParam "artwork")
			) 
			TBX_PANELIZE_Create_Artwork()
			(axlShell "tbx panelize loadartwork")
		    ) 
		    tconc((tbx_panelize_global->viewlog) 
			sprintf(nil "   Generating mdd files")
		    ) 
		    TBX_PANELIZE_Set_Visible_Layers(sys_layers cfg) 
		    when((cfg->excludeRouting) 
			(axlVisibleLayer 
			    (axlMapClassName "ETCH") nil
			) 
			(axlVisibleLayer 
			    (axlMapClassName "VIA CLASS") nil
			) 
			(find_filter = list("noall" "symbols" "lines" "shapes" "boundary_shapes"
				"figures" "text"
			    ))
		    ) 
		    (design_outline_lyr = strcat((axlMapClassName "BOARD GEOMETRY") "/DESIGN_OUTLINE"))
		    when(((axlIsLayer design_outline_lyr) && 
			    (axlIsVisibleLayer design_outline_lyr)) 
			(axlVisibleLayer design_outline_lyr nil)
		    ) 
		    (axlVisibleUpdate t) 
		    (axlSetFindFilter ?enabled find_filter ?onButtons 
			list("all")
		    ) 
		    (axlClearSelSet) 
		    (axlAddSelectAll)
		    putprop(current_size_info 
			(axlDBGetExtents 
			    (axlGetSelSet) nil
			) 
			'extents
		    ) 
		    (axlDBCreateModuleDef mdd_definition 
			(0.0:0.0) 
			(axlGetSelSet)
		    ) 
		    (axlClearSelSet) 
		    (axlSaveDesign ?noConfirm t) 
		    (mdd_size_info = cons(list(mdd_definition current_size_info) mdd_size_info))
		    (tmp_database_list = cons(tmp_database tmp_database_list)) else 
		    (axlSaveDesign ?noConfirm t)
		) else 
		tconc((tbx_panelize_global->viewlog) 
		    sprintf(nil " Failed to open database: %L" tmp_database)
		)
	    )
	) 
	(mdd_size_info = sortcar(mdd_size_info nil)) 
	(result = list(mdd_size_info tmp_database_list)) result
    )
)
procedure(TBX_PANELIZE_Delete_Modules(id_list) 
    let((mdd_inst) 
	TBX_PANELIZE_Protection_Mode("unfix") 
	foreach(id id_list 
	    (mdd_inst = car((axlSelectByName "MODULE" id))) 
	    (axlDeleteObject mdd_inst)
	) 
	TBX_PANELIZE_Protection_Mode("fix") t
    )
)
procedure(TBX_PANELIZE_Extract_Design_Grid(valid_rows_only) 
    let((grid_info cell mdd_definition board_path) 
	(grid_info = list()) 
	for(i 1 
	    (tbx_panelize_global->designGridRowCnt) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 1) 
	    (mdd_definition = ((axlFormGridGetCell 
			((tbx_panelize_global->formHandle)->main) "design_grid" cell
		    )->value)) 
	    (mdd_definition = TBX_PANELIZE_Validate_Input(mdd_definition "string" "upperCaseNoSpace")) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 2) 
	    (board_path = ((axlFormGridGetCell 
			((tbx_panelize_global->formHandle)->main) "design_grid" cell
		    )->value)) 
	    (board_path = TBX_PANELIZE_Validate_Input(board_path "string" "asIs")) 
	    if(valid_rows_only then 
		when((mdd_definition && (mdd_definition != "") && board_path && (board_path != "")) 
		    (grid_info = cons(list(mdd_definition board_path) grid_info))
		) else 
		(grid_info = cons(list(mdd_definition board_path) grid_info))
	    )
	) 
	(grid_info = reverse(grid_info)) grid_info
    )
)
procedure(TBX_PANELIZE_Extract_Panel_Grid() 
    let((cell panel_id panel_design pt_x pt_y
	    rot mirror prop_list grid_info
	) 
	(grid_info = list()) 
	for(i 1 
	    (tbx_panelize_global->panelGridRowCnt) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 1) 
	    (panel_id = ((axlFormGridGetCell 
			((tbx_panelize_global->formHandle)->main) "panel_grid" cell
		    )->value)) 
	    (panel_id = TBX_PANELIZE_Validate_Input(panel_id "string" "upperCaseNoSpace")) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 2) 
	    (panel_design = ((axlFormGridGetCell 
			((tbx_panelize_global->formHandle)->main) "panel_grid" cell
		    )->value)) 
	    (panel_design = TBX_PANELIZE_Validate_Input(panel_design "string" "upperCaseNoSpace")) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 3) 
	    (pt_x = ((axlFormGridGetCell 
			((tbx_panelize_global->formHandle)->main) "panel_grid" cell
		    )->value)) 
	    (pt_x = TBX_PANELIZE_Validate_Input(pt_x "float")) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 4) 
	    (pt_y = ((axlFormGridGetCell 
			((tbx_panelize_global->formHandle)->main) "panel_grid" cell
		    )->value)) 
	    (pt_y = TBX_PANELIZE_Validate_Input(pt_y "float")) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 5) 
	    (rot = ((axlFormGridGetCell 
			((tbx_panelize_global->formHandle)->main) "panel_grid" cell
		    )->value)) 
	    (rot = TBX_PANELIZE_Validate_Input(rot "float")) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 6) 
	    (mirror = ((axlFormGridGetCell 
			((tbx_panelize_global->formHandle)->main) "panel_grid" cell
		    )->value)) 
	    (mirror = TBX_PANELIZE_Validate_Input(mirror "string" "lowerCaseNoSpace")) 
	    (prop_list = ncons(nil)) 
	    (prop_list->definition = panel_design)
	    (prop_list->originX = pt_x) 
	    (prop_list->originY = pt_y) 
	    (prop_list->rotation = rot) 
	    (prop_list->isMirror = mirror) 
	    when((panel_id && panel_design) 
		(grid_info = cons(list(panel_id prop_list) grid_info))
	    )
	) grid_info
    )
)
procedure(TBX_PANELIZE_Fit_To_Canvas(mdd_inst delta_xy delta_rot mirror_flag origin) 
    let((rpath result ok_fit) 
	foreach(mem 
	    (mdd_inst->groupMembers) 
	    when((((mem->objType) == "polygon") && ((mem->layer) == strcat((axlMapClassName "PACKAGE GEOMETRY") "/MODULES"))) 
		(rpath = (axlDB2Path mem))
	    )
	) 
	when(rpath 
	    (rpath = (axlPathOffset rpath delta_xy)) 
	    (rpath = TBX_DBCORE_Rotate_Rpath(rpath delta_rot origin mirror_flag)) 
	    (result = (axlPolyFromDB rpath)) 
	    when(result 
		(ok_fit = t)
	    )
	) ok_fit
    )
)
procedure((TBX_PANELIZE_Get_Conductor_Layer_Info \@optional board_path) 
    let((xsection output_file cmd_str view_file port
	    conductor_cnt diestack_cnt layer_id layer_name layer_type
	    layer_is_negative arr line design_type cur_cond
	    cur_diestack map_name ok_cond tmp_entry layer_info
	) 
	if(board_path then 
	    case(lowerCase(nth(3 
			(axlDMFileParts board_path)
		    )
		) 
		("brd" 
		    (design_type = "BOARD")
		) 
		("mcm" 
		    (design_type = "MCM")
		) 
		("sip" 
		    (design_type = "SIP")
		) 
		(t 
		    (design_type = "BOARD")
		)
	    ) 
	    (output_file = strcat(getWorkingDir() "/tbxextract.txt")) 
	    (view_file = "layer_bv")
	    (view_file = strcat(getWorkingDir() "/tbxcmd.txt")) 
	    (port = outfile(view_file "w")) 
	    fprintf(port "LAYER\n") 
	    fprintf(port "  LAYER_SORT\n") 
	    fprintf(port "  LAYER_SUBCLASS\n")
	    fprintf(port "  LAYER_TYPE\n") 
	    fprintf(port "  LAYER_ARTWORK\n") 
	    fprintf(port "END") 
	    close(port) 
	    (cmd_str = sprintf(nil "extracta -m %s %s %s" board_path view_file output_file))
	    (axlRunBatchDBProgram "extracta" cmd_str ?silent t) 
	    when(isFile(output_file) 
		(conductor_cnt = 0) 
		(diestack_cnt = 0) 
		(port = infile(output_file)) 
		while((line = _gets(port)) 
		    rexCompile("!!") 
		    (line = upperCase(rexReplace(line "! !" 0))) 
		    (arr = parseString(line "!")) 
		    when((car(arr) == "S") 
			(arr = cdr(arr)) 
			(layer_type = caddr(arr)) 
			cond((((layer_type == "CONDUCTOR") || (layer_type == "PLANE")) 
				++conductor_cnt
			    ) 
			    ((layer_type == "DIESTACK") 
				++diestack_cnt
			    )
			) 
			rexCompile("^ *$")
			(arr = mapcar(lambda((x) 
				    rexReplace(x "" 0)
				) arr
			    )) 
			(layer_id = atoi(car(arr))) 
			(layer_name = cadr(arr)) 
			(layer_type = caddr(arr)) 
			case(nth(3 arr) 
			    ("POSITIVE" 
				(layer_is_negative = nil)
			    ) 
			    ("NEGATIVE" 
				(layer_is_negative = t)
			    ) 
			    (t 
				(layer_is_negative = nil)
			    )
			)
			(xsection = cons(list(layer_id layer_name layer_type layer_is_negative) xsection))
		    )
		)
		close(port)
	    ) else 
	    (design_type = (axlDesignType t)) 
	    (layer_id = 0)
	    (conductor_cnt = 0) 
	    (diestack_cnt = 0) 
	    foreach(entry 
		(axlGetXSection) 
		++layer_id 
		(layer_name = car(entry)) 
		(layer_type = upperCase(cadr(entry)))
		(layer_is_negative = nth(7 entry)) 
		cond((((layer_type == "CONDUCTOR") || (layer_type == "PLANE")) 
			++conductor_cnt
		    ) 
		    ((layer_type == "DIESTACK") 
			++diestack_cnt
		    )
		) 
		(xsection = cons(list(layer_id layer_name layer_type layer_is_negative) xsection))
	    )
	) 
	(xsection = reverse(xsection)) 
	(cur_cond = 0) 
	(cur_diestack = 0)
	foreach(entry xsection 
	    (ok_cond = nil) 
	    (layer_type = caddr(entry)) 
	    cond((((layer_type == "CONDUCTOR") || (layer_type == "PLANE")) 
		    ++cur_cond 
		    (ok_cond = t) 
		    cond((onep(cur_cond) 
			    if((design_type == "BOARD") then 
				(map_name = "TOP") else 
				(map_name = sprintf(nil "L%02d" cur_cond))
			    )
			) 
			((cur_cond == conductor_cnt) 
			    if((design_type == "BOARD") then 
				(map_name = "BOTTOM") else 
				(map_name = sprintf(nil "L%02d" cur_cond))
			    )
			) 
			(t 
			    (map_name = sprintf(nil "L%02d" cur_cond))
			)
		    )
		) 
		((layer_type == "DIESTACK") 
		    ++cur_diestack 
		    (ok_cond = t) 
		    (map_name = sprintf(nil "WB%02d" cur_diestack))
		)
	    )
	    when(ok_cond 
		(layer_id = car(entry)) 
		(layer_name = cadr(entry)) 
		(tmp_entry = cddr(entry)) 
		(tmp_entry = cons(map_name tmp_entry))
		(tmp_entry = cons(layer_name tmp_entry)) 
		(tmp_entry = cons(layer_id tmp_entry)) 
		(layer_info = cons(tmp_entry layer_info))
	    )
	) 
	(layer_info = reverse(layer_info)) layer_info
    )
)
procedure(TBX_PANELIZE_Get_Design_Path(design_name designInfo path_type) 
    let((design_path) 
	foreach(entry designInfo 
	    when((lowerCase(car(entry)) == lowerCase(design_name)) 
		case(path_type 
		    ("absolute" 
			(design_path = cadr(entry))
		    ) 
		    ("relative" 
			(design_path = caddr(entry))
		    ) 
		    (t 
			(design_path = cadr(entry))
		    )
		)
	    )
	) design_path
    )
)
procedure(TBX_PANELIZE_Get_Design_Size() 
    let((attr bbox bbox_ll_x bbox_ll_y bbox_ur_x
	    bbox_ur_y rpath_data ndbid seg_list
	) 
	(attr = ncons(nil)) 
	(axlVisibleDesign nil) 
	(axlVisibleLayer 
	    strcat((axlMapClassName "BOARD GEOMETRY") "/OUTLINE") t
	) 
	(axlVisibleUpdate nil)
	(axlSetFindFilter ?enabled 
	    list("noall" "lines" "shapes" "boundary_shapes") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	(bbox = (axlDBGetExtents 
		(axlGetSelSet) t
	    )) 
	(attr->units = car((axlDBGetDesignUnits)))
	if(bbox then 
	    (bbox_ll_x = car((lowerLeft bbox))) 
	    (bbox_ll_y = cadr((lowerLeft bbox))) 
	    (bbox_ur_x = car((upperRight bbox)))
	    (bbox_ur_y = cadr((upperRight bbox))) 
	    (attr->width = (bbox_ur_x - bbox_ll_x)) 
	    (attr->height = (bbox_ur_y - bbox_ll_y)) 
	    (attr->lowerLeft = (bbox_ll_x:bbox_ll_y)) 
	    foreach(dbid 
		(axlGetSelSet) 
		case((dbid->objType) 
		    ("polygon" 
			(rpath_data = cons((axlDB2Path dbid) rpath_data))
		    ) 
		    ("path" 
			(seg_list = setof(x 
				(dbid->segments) 
				((x->width) && ((x->width) > 0.0))
			    )) 
			if(seg_list then 
			    (ndbid = (axlChangeWidth dbid 0.0)) else 
			    (ndbid = dbid)
			) 
			(rpath_data = cons((axlDB2Path ndbid) rpath_data))
		    )
		)
	    )
	    (attr->outlineDetail = rpath_data) else 
	    (attr->width = (axlMKSConvert "1.0 MM" 
		    car((axlDBGetDesignUnits))
		)) 
	    (attr->height = (axlMKSConvert "1.0 MM" 
		    car((axlDBGetDesignUnits))
		)) 
	    (attr->lowerLeft = (0.0:0.0))
	    (attr->outlineDetail = nil)
	) attr
    )
)
procedure(TBX_PANELIZE_Get_Die_Properties() 
    let((design_type die_info refdes) 
	(design_type = upperCase((axlDesignType t))) 
	when(((design_type == "MCM") || (design_type == "SIP")) 
	    foreach(cmp 
		((axlDBGetDesign)->components) 
		when((axlGetDieType cmp) 
		    (refdes = upperCase((cmp->name))) 
		    (die_info = cons(list(refdes 
				(axlGetDieType cmp)
			    ) die_info
			))
		)
	    )
	) die_info die_info
    )
)
procedure(TBX_PANELIZE_Get_Filter_String() 
    let((filter_string brd_filter mcm_filter sip_filter) 
	(brd_filter = "Board files(*.brd)|*.brd|MCM files(*.mcm)|*.mcm|SIP files(*.sip)|*.sip|") 
	(mcm_filter = "MCM files(*.mcm)|*.mcm|SIP files(*.sip)|*.sip|Board files(*.brd)|*.brd|") 
	(sip_filter = "SIP files(*.sip)|*.sip|MCM files(*.mcm)|*.mcm|Board files(*.brd)|*.brd|") 
	case(upperCase((axlDesignType t)) 
	    ("BOARD" 
		(filter_string = brd_filter)
	    ) 
	    ("MCM" 
		(filter_string = mcm_filter)
	    ) 
	    ("SIP" 
		(filter_string = sip_filter)
	    ) 
	    (t 
		(filter_string = brd_filter)
	    )
	)
	filter_string
    )
)
procedure(TBX_PANELIZE_Get_Last_Panel_Id() 
    let((grid_info last_instance num) 
	(grid_info = TBX_PANELIZE_Extract_Panel_Grid()) 
	(grid_info = sortcar(grid_info 
		'axlStrcmpAlpNum
	    )) 
	(last_instance = car((lastelem grid_info))) 
	if(last_instance then 
	    (num = (atoi(substring(last_instance 2)) + 1)) else 
	    (num = 1)
	)
	num
    )
)
procedure(TBX_PANELIZE_Get_Panel_Info() 
    let((module_list panel_info prop_list) 
	(panel_info = list()) 
	(module_list = (axlSelectByName "MODULE" "*" t)) 
	foreach(md module_list 
	    (prop_list = ncons(nil)) 
	    (prop_list->definition = ((md->prop)->MODULE_DEFINITION)) 
	    (prop_list->originX = (axlMKSConvert 
		    ((md->prop)->MODULE_ORIGIN_X) 
		    car((axlDBGetDesignUnits))
		))
	    (prop_list->originY = (axlMKSConvert 
		    ((md->prop)->MODULE_ORIGIN_Y) 
		    car((axlDBGetDesignUnits))
		)) 
	    (prop_list->rotation = (atof(((md->prop)->MODULE_ROTATION)) / 1000.0)) 
	    if(((md->prop)->TILE_MIRRORED) then 
		(prop_list->isMirror = "yes") else 
		(prop_list->isMirror = "no")
	    ) 
	    (panel_info = cons(list((md->name) prop_list) panel_info))
	) 
	(panel_info = sortcar(panel_info 
		'axlStrcmpAlpNum
	    ))
	panel_info
    )
)
procedure(TBX_PANELIZE_INCLUDE_Callback(form_handle) 
    let((layer_name available_layers) 
	case((form_handle->curField) 
	    ("add_selected" 
		foreach(lyr 
		    (axlFormListGetSelItems form_handle "available_layers") 
		    unless(exists(x 
			    (tbx_panelize_global->tmpSelection) 
			    (x == lyr)
			) 
			if(exists(x 
				(tbx_panelize_global->sysLayers) 
				(x == lyr)
			    ) then 
			    printf("Info: %L is a system layer which is included by default. Ignoring selection.\n" lyr) else 
			    (tbx_panelize_global->tmpSelection = cons(lyr 
				    (tbx_panelize_global->tmpSelection)
				))
			)
		    )
		) 
		(axlFormListDeleteAll form_handle "selected_layers") 
		(axlFormSetField form_handle "selected_layers" 
		    (tbx_panelize_global->tmpSelection)
		)
	    ) 
	    ("remove_selected" 
		foreach(lyr 
		    (axlFormListGetSelItems form_handle "selected_layers") 
		    (tbx_panelize_global->tmpSelection = remove(lyr 
			    (tbx_panelize_global->tmpSelection)
			))
		) 
		(axlFormListDeleteAll form_handle "selected_layers") 
		(axlFormSetField form_handle "selected_layers" 
		    (tbx_panelize_global->tmpSelection)
		)
	    ) 
	    ("add_layer" 
		(layer_name = (axlFormGetField form_handle "new_layer_name")) 
		when(layer_name 
		    rexCompile(" ") 
		    (layer_name = upperCase(rexReplace(layer_name "" 0))) 
		    when((layer_name != "") 
			(layer_name = strcat((axlFormGetField form_handle "class_name") "/" layer_name)) 
			unless(exists(x 
				(tbx_panelize_global->tmpSelection) 
				(x == layer_name)
			    ) 
			    (tbx_panelize_global->tmpSelection = cons(layer_name 
				    (tbx_panelize_global->tmpSelection)
				))
			) 
			(axlFormListDeleteAll form_handle "selected_layers") 
			(axlFormSetField form_handle "selected_layers" 
			    (tbx_panelize_global->tmpSelection)
			)
		    )
		)
	    ) 
	    ("cancel" 
		(axlFormClose form_handle) 
		(axlFinishEnterFun)
	    )
	    ("done" 
		((tbx_panelize_global->cfg)->userLayers = (tbx_panelize_global->tmpSelection)) 
		(axlFormClose form_handle) 
		(axlFinishEnterFun) 
		foreach(lyr 
		    ((tbx_panelize_global->cfg)->userLayers) 
		    unless((axlIsLayer lyr) 
			(axlLayerCreateNonConductor lyr)
		    )
		)
		(available_layers = list()) 
		foreach(cls 
		    list("BOARD GEOMETRY" "MANUFACTURING" "DRAWING FORMAT") 
		    foreach(lyr 
			(axlSubclasses 
			    (axlMapClassName cls)
			) 
			(available_layers = cons(strcat((axlMapClassName cls) "/" lyr) available_layers))
		    )
		) 
		(tbx_panelize_global->availableLayers = available_layers)
	    )
	)
    )
)
procedure(TBX_PANELIZE_Init() 
    let((sys_layers port assy_top_color_file assy_bot_color_file available_layers
	    msg
	) 
	(sys_layers = list(strcat((axlMapClassName "BOARD GEOMETRY") "/OUTLINE") 
		strcat((axlMapClassName "BOARD GEOMETRY") "/DESIGN_OUTLINE") 
		strcat((axlMapClassName "BOARD GEOMETRY") "/CUTOUT") 
		strcat((axlMapClassName "BOARD GEOMETRY") "/SOLDERMASK_TOP") 
		strcat((axlMapClassName "BOARD GEOMETRY") "/SOLDERMASK_BOTTOM")
		strcat((axlMapClassName "BOARD GEOMETRY") "/PASTEMASK_TOP") 
		strcat((axlMapClassName "BOARD GEOMETRY") "/PASTEMASK_BOTTOM") 
		strcat((axlMapClassName "BOARD GEOMETRY") "/NCROUTE_PATH") 
		strcat((axlMapClassName "BOARD GEOMETRY") "/PLATING_BAR") 
		strcat((axlMapClassName "BOARD GEOMETRY") "/SILKSCREEN_TOP")
		strcat((axlMapClassName "BOARD GEOMETRY") "/SILKSCREEN_BOTTOM") 
		strcat((axlMapClassName "MANUFACTURING") "/FIXTURE_TOP") 
		strcat((axlMapClassName "MANUFACTURING") "/FIXTURE_BOTTOM") 
		strcat((axlMapClassName "MANUFACTURING") "/PROBE_TOP") 
		strcat((axlMapClassName "MANUFACTURING") "/PROBE_BOTTOM")
		strcat((axlMapClassName "MANUFACTURING") "/AUTOSILK_TOP") 
		strcat((axlMapClassName "MANUFACTURING") "/AUTOSILK_BOTTOM") 
		strcat((axlMapClassName "MANUFACTURING") "/PNL_AUTOSILK_TOP") 
		strcat((axlMapClassName "MANUFACTURING") "/PNL_AUTOSILK_BOTTOM")
	    )) 
	when(axlGetVariable("FLW_PANELIZE_ADD_USER_LAYER") 
	    (msg = "Warning: Variable FLW_PANELIZE_ADD_USER_LAYER will be ignored starting from version 1.60\nUse GUI to specify layers instead.") 
	    (axlUIConfirm msg)
	) 
	(available_layers = list()) 
	foreach(cls 
	    list("BOARD GEOMETRY" "MANUFACTURING" "DRAWING FORMAT") 
	    foreach(lyr 
		(axlSubclasses 
		    (axlMapClassName cls)
		) 
		(available_layers = cons(strcat((axlMapClassName cls) "/" lyr) available_layers))
	    )
	)
	(assy_top_color_file = strcat(getWorkingDir() "/pnl_assy_top.color")) 
	(port = outfile(assy_top_color_file "w")) 
	fprintf(port "color -globvis off\n") 
	fprintf(port "color -vis \"%s/OUTLINE\"\n" 
	    (axlMapClassName "BOARD GEOMETRY")
	) 
	fprintf(port "color -vis \"%s/ASSEMBLY_TOP\"\n" 
	    (axlMapClassName "PACKAGE GEOMETRY")
	)
	fprintf(port "color -vis \"%s/PNL_REFDES_TOP\"\n" 
	    (axlMapClassName "PACKAGE GEOMETRY")
	) 
	fprintf(port "color -vis \"%s/TOP\"\n" 
	    (axlMapClassName "PIN")
	) 
	close(port) 
	(assy_bot_color_file = strcat(getWorkingDir() "/pnl_assy_bottom.color")) 
	(port = outfile(assy_bot_color_file "w"))
	fprintf(port "color -globvis off\n") 
	fprintf(port "color -vis \"%s/OUTLINE\"\n" 
	    (axlMapClassName "BOARD GEOMETRY")
	) 
	fprintf(port "color -vis \"%s/ASSEMBLY_BOTTOM\"\n" 
	    (axlMapClassName "PACKAGE GEOMETRY")
	) 
	fprintf(port "color -vis \"%s/PNL_REFDES_BOTTOM\"\n" 
	    (axlMapClassName "PACKAGE GEOMETRY")
	) 
	fprintf(port "color -vis \"%s/BOTTOM\"\n" 
	    (axlMapClassName "PIN")
	)
	close(port) 
	(axlDBControl 
	    'maxNameLength 255
	) 
	unless(boundp('tbx_panelize_global) 
	    iliDefstruct('defstruct(tbx_panelize_global_struct cfg formHandle version viewlog
			panelInfo referenceStackup sysLayers envSettings availableLayers
			tmpSelection dieInfo panelDir panelDesign panelType
			envVar runtime licCheck
		    )
	    ) 
	    defvar(tbx_panelize_global nil)
	) 
	if(!tbx_panelize_global then 
	    (tbx_panelize_global = (make_tbx_panelize_global_struct ?cfg 
		    ncons(nil) ?formHandle 
		    ncons(nil)
		    ?dieInfo nil ?panelType nil ?panelInfo
		    nil ?panelDesign nil ?panelDir nil
		    ?referenceStackup nil ?sysLayers sys_layers ?availableLayers
		    available_layers ?tmpSelection nil ?version nil
		    ?viewlog 
		    tconc(nil nil) ?envSettings 
		    ncons(nil) ?envVar
		    nil ?runtime nil ?licCheck nil
		)) else 
	    (tbx_panelize_global->cfg = ncons(nil))
	    (tbx_panelize_global->formHandle = ncons(nil)) 
	    (tbx_panelize_global->panelInfo = nil) 
	    (tbx_panelize_global->panelDesign = nil) 
	    (tbx_panelize_global->referenceStackup = nil) 
	    (tbx_panelize_global->sysLayers = sys_layers)
	    (tbx_panelize_global->availableLayers = available_layers) 
	    (tbx_panelize_global->tmpSelection = nil) 
	    (tbx_panelize_global->version = nil) 
	    (tbx_panelize_global->runtime = nil) 
	    (tbx_panelize_global->licCheck = nil)
	) t
    )
)
procedure(TBX_PANELIZE_Init_Design_Grid_Cols() 
    let((p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 5) 
	(p->fieldLength = 10)
	(p->headText = "Name") 
	(p->scriptLabel = "grid_design_name") 
	(axlFormGridInsertCol 
	    ((tbx_panelize_global->formHandle)->main) "design_grid" p
	) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING)
	(p->colWidth = 15) 
	(p->fieldLength = 1024) 
	(p->headText = "Design location") 
	(p->scriptLabel = "grid_design_location") 
	(axlFormGridInsertCol 
	    ((tbx_panelize_global->formHandle)->main) "design_grid" p
	)
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 2) 
	(p->fieldLength = 1024) 
	(p->headText = "")
	(p->scriptLabel = "grid_design_browse") 
	(axlFormGridInsertCol 
	    ((tbx_panelize_global->formHandle)->main) "design_grid" p
	)
    )
)
procedure(TBX_PANELIZE_Init_Design_Grid_Rows() 
    if(zerop((tbx_panelize_global->designGridRowCnt)) then 
	(axlFormGridInsertRows 
	    ((tbx_panelize_global->formHandle)->main) "design_grid" 0 1
	) 
	(tbx_panelize_global->designGridRowCnt = 1) else
	(axlFormGridInsertRows 
	    ((tbx_panelize_global->formHandle)->main) "design_grid" 0 
	    (tbx_panelize_global->designGridRowCnt)
	)
    ) 
    (axlFormGridSetBatch 
	((tbx_panelize_global->formHandle)->main) "design_grid" 
	'TBX_PANELIZE_Init_Design_Grid_Rows_Callback nil
    )
)
procedure(TBX_PANELIZE_Init_Design_Grid_Rows_Callback(pvt_data) 
    let((cell readonly_flag bg_color row_num design_info
	    board_name design_path
	) 
	(pvt_data = pvt_data) 
	(row_num = 1) 
	if((length(((tbx_panelize_global->cfg)->designInfo)) >= 1) then 
	    (design_info = ((tbx_panelize_global->cfg)->designInfo)) else 
	    (design_info = list(list("" "" "" "...")))
	) 
	foreach(entry design_info 
	    (board_name = upperCase(car(entry))) 
	    foreach(p 
		(tbx_panelize_global->panelInfo) 
		when(((cadr(p)->definition) == board_name) 
		    (readonly_flag = t) 
		    (bg_color = 'button)
		)
	    ) 
	    (cell = (axlFormGridNewCell))
	    (cell->col = 1) 
	    (cell->row = row_num) 
	    (cell->value = board_name) 
	    (cell->backColor = bg_color) 
	    (cell->noEdit = readonly_flag)
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 2) 
	    (cell->row = row_num) 
	    if(((tbx_panelize_global->cfg)->useRelativePath) then 
		(design_path = caddr(entry)) else 
		(design_path = cadr(entry))
	    )
	    if((!design_path || (design_path == "") || (design_path && isFile(design_path))) then 
		(cell->backColor = 'white) else 
		(cell->backColor = 'red)
	    ) 
	    (cell->value = design_path) 
	    (cell->noEdit = t) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell))
	    (cell->col = 3) 
	    (cell->row = row_num) 
	    (cell->value = "...") 
	    (cell->backColor = 'button) 
	    (cell->noEdit = t)
	    (axlFormGridBatch cell) 
	    ++row_num
	)
	t
    )
)
procedure(TBX_PANELIZE_Init_Form(form_handle) 
    let((board_name) 
	TBX_PANELIZE_Init_Grid(form_handle "panel") 
	TBX_PANELIZE_Build_Definition_Popup(form_handle "main") 
	TBX_PANELIZE_Init_Grid(form_handle "design") 
	(board_name = "")
	when((length(((tbx_panelize_global->cfg)->designInfo)) >= 1) 
	    (board_name = caar(((tbx_panelize_global->cfg)->designInfo)))
	) 
	(axlFormSetField form_handle "board_name" board_name) 
	TBX_PANELIZE_Update_Size_String(form_handle 
	    ((tbx_panelize_global->cfg)->mddSizeInfo)
	) 
	(axlFormSetField form_handle "board_rotation" 0.0) 
	(axlFormSetField form_handle "board_mirror" "no")
	(axlFormSetField form_handle "columns" 1) 
	(axlFormSetField form_handle "rows" 1) 
	(axlFormSetField form_handle "offset_x" 0.0) 
	(axlFormSetField form_handle "offset_y" 0.0) 
	if(((tbx_panelize_global->panelType) == "MCM/SIP") then 
	    (axlFormSetFieldEditable form_handle "import_wirebond_profiles" t) else 
	    (axlFormSetFieldEditable form_handle "import_wirebond_profiles" nil)
	)
	(axlFormSetField form_handle "refdes_master" 
	    ((tbx_panelize_global->cfg)->refdesMaster)
	) 
	(axlFormSetField form_handle "refdes_alt" 
	    ((tbx_panelize_global->cfg)->refdesAlt)
	) 
	(axlFormSetField form_handle "exclude_routing" 
	    ((tbx_panelize_global->cfg)->excludeRouting)
	) 
	(axlFormSetField form_handle "load_artwork" 
	    ((tbx_panelize_global->cfg)->loadArtwork)
	) 
	(axlFormSetField form_handle "clear_nets" 
	    ((tbx_panelize_global->cfg)->clearNets)
	)
	(axlFormSetField form_handle "use_relative_path" 
	    ((tbx_panelize_global->cfg)->useRelativePath)
	) 
	(axlFormSetField form_handle "include_all_layers" 
	    ((tbx_panelize_global->cfg)->includeAllLayers)
	) 
	(axlFormSetField form_handle "include_artwork_layers" 
	    ((tbx_panelize_global->cfg)->includeArtworkLayers)
	) 
	(axlFormSetField form_handle "unify_names" 
	    ((tbx_panelize_global->cfg)->unifyLayerNames)
	) 
	if((((tbx_panelize_global->cfg)->includeAllLayers) || ((tbx_panelize_global->cfg)->includeArtworkLayers)) then 
	    (axlFormSetFieldEditable form_handle "specify_layers" nil) else 
	    (axlFormSetFieldEditable form_handle "specify_layers" t)
	)
	t
    )
)
procedure(TBX_PANELIZE_Init_Grid(form_handle grid_name) 
    case(grid_name 
	("panel" 
	    if(zerop(length((tbx_panelize_global->panelInfo))) then 
		(tbx_panelize_global->panelGridRowCnt = 1) else 
		(tbx_panelize_global->panelGridRowCnt = length((tbx_panelize_global->panelInfo)))
	    ) 
	    (axlFormGridReset form_handle "panel_grid") 
	    TBX_PANELIZE_Init_Panel_Grid_Cols() 
	    TBX_PANELIZE_Init_Panel_Grid_Rows()
	    (axlFormGridUpdate form_handle "panel_grid") 
	    (axlFormGridEvents form_handle "panel_grid" 
		list('cellselect 
		    'change 
		    'rightpopup
		)
	    )
	) 
	("design" 
	    if(zerop(length(((tbx_panelize_global->cfg)->designInfo))) then 
		(tbx_panelize_global->designGridRowCnt = 1) else 
		(tbx_panelize_global->designGridRowCnt = length(((tbx_panelize_global->cfg)->designInfo)))
	    ) 
	    (axlFormGridReset form_handle "design_grid") 
	    TBX_PANELIZE_Init_Design_Grid_Cols() 
	    TBX_PANELIZE_Init_Design_Grid_Rows()
	    (axlFormGridUpdate form_handle "design_grid") 
	    (axlFormGridEvents form_handle "design_grid" 
		list('cellselect 
		    'change 
		    'rightpopup
		)
	    )
	)
    )
)
procedure(TBX_PANELIZE_Init_Panel_Grid_Cols() 
    let((p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 2) 
	(p->fieldLength = 50)
	(p->headText = "Id") 
	(p->scriptLabel = "grid_panel_id") 
	(axlFormGridInsertCol 
	    ((tbx_panelize_global->formHandle)->main) "panel_grid" p
	) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'ENUMSET)
	(p->colWidth = 4) 
	(p->fieldLength = 50) 
	(p->align = 'left) 
	(p->popup = "grid_board_name_popup") 
	(p->headText = "Design")
	(p->scriptLabel = "grid_design_name") 
	(axlFormGridInsertCol 
	    ((tbx_panelize_global->formHandle)->main) "panel_grid" p
	) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'REAL) 
	(p->colWidth = 4)
	(p->fieldLength = 50) 
	(p->decimals = 3) 
	(p->headText = "X") 
	(p->scriptLabel = "grid_x_value") 
	(axlFormGridInsertCol 
	    ((tbx_panelize_global->formHandle)->main) "panel_grid" p
	)
	(p = (make_formGridCol)) 
	(p->fieldType = 'REAL) 
	(p->colWidth = 4) 
	(p->fieldLength = 50) 
	(p->decimals = 3)
	(p->headText = "Y") 
	(p->scriptLabel = "grid_y_value") 
	(axlFormGridInsertCol 
	    ((tbx_panelize_global->formHandle)->main) "panel_grid" p
	) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'REAL)
	(p->colWidth = 4) 
	(p->fieldLength = 50) 
	(p->min = 0.0) 
	(p->max = 360.0) 
	(p->decimals = 3)
	(p->headText = "Rotation") 
	(p->scriptLabel = "grid_rotation") 
	(axlFormGridInsertCol 
	    ((tbx_panelize_global->formHandle)->main) "panel_grid" p
	) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'ENUMSET)
	(p->colWidth = 3) 
	(p->align = 'left) 
	(p->popup = "mirror_popup") 
	(p->headText = "Mirror") 
	(p->scriptLabel = "grid_mirror")
	(axlFormGridInsertCol 
	    ((tbx_panelize_global->formHandle)->main) "panel_grid" p
	)
    )
)
procedure(TBX_PANELIZE_Init_Panel_Grid_Rows() 
    if(zerop((tbx_panelize_global->panelGridRowCnt)) then 
	(axlFormGridInsertRows 
	    ((tbx_panelize_global->formHandle)->main) "panel_grid" 0 1
	) 
	(tbx_panelize_global->panelGridRowCnt = 1) else
	(axlFormGridInsertRows 
	    ((tbx_panelize_global->formHandle)->main) "panel_grid" 0 
	    (tbx_panelize_global->panelGridRowCnt)
	)
    ) 
    (axlFormGridSetBatch 
	((tbx_panelize_global->formHandle)->main) "panel_grid" 
	'TBX_PANELIZE_Init_Panel_Grid_Rows_Callback nil
    )
)
procedure(TBX_PANELIZE_Init_Panel_Grid_Rows_Callback(pvt_data) 
    let((cell prop_list panel_inst_id panel_inst_name panel_inst_x
	    panel_inst_y panel_inst_rotation panel_inst_mirror row_num
	) 
	(pvt_data = pvt_data) 
	(row_num = 1) 
	foreach(entry 
	    (tbx_panelize_global->panelInfo) 
	    (panel_inst_id = car(entry)) 
	    (prop_list = cadr(entry)) 
	    (panel_inst_name = (prop_list->definition))
	    (panel_inst_x = (prop_list->originX)) 
	    (panel_inst_y = (prop_list->originY)) 
	    (panel_inst_rotation = (prop_list->rotation)) 
	    (panel_inst_mirror = (prop_list->isMirror)) 
	    (cell = (axlFormGridNewCell))
	    (cell->col = 1) 
	    (cell->row = row_num) 
	    (cell->value = panel_inst_id) 
	    (cell->backColor = 'button) 
	    (cell->noEdit = t)
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 2) 
	    (cell->row = row_num) 
	    (cell->value = panel_inst_name)
	    (cell->backColor = 'button) 
	    (cell->noEdit = t) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 3)
	    (cell->row = row_num) 
	    (cell->value = panel_inst_x) 
	    (cell->backColor = 'white) 
	    (cell->noEdit = nil) 
	    (axlFormGridBatch cell)
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 4) 
	    (cell->row = row_num) 
	    (cell->value = panel_inst_y) 
	    (cell->backColor = 'white)
	    (cell->noEdit = nil) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 5) 
	    (cell->row = row_num)
	    (cell->value = panel_inst_rotation) 
	    (cell->backColor = 'white) 
	    (cell->noEdit = nil) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell))
	    (cell->col = 6) 
	    (cell->row = row_num) 
	    (cell->value = panel_inst_mirror) 
	    (cell->backColor = 'white) 
	    (cell->noEdit = nil)
	    (axlFormGridBatch cell) 
	    ++row_num
	)
    )
)
procedure(TBX_PANELIZE_Load_Artwork() 
    let((port script_file mfg_layer layer_list config
	    artwork_file arr class_name subclass_name
	) 
	foreach(lyr 
	    (axlSubclassRoute) 
	    (mfg_layer = strcat((axlMapClassName "MANUFACTURING") "/PNL_" lyr)) 
	    unless((axlIsLayer mfg_layer) 
		(axlLayerCreateNonConductor mfg_layer)
	    ) 
	    (layer_list = cons(mfg_layer layer_list))
	    (config = cons(list(strcat(lyr ".art") mfg_layer) config))
	) 
	(script_file = strcat(getWorkingDir() "/tbx_panelize_import_art.scr")) 
	(port = outfile(script_file "w")) 
	fprintf(port "scriptmode +i\n")
	fprintf(port "setwindow pcb\n") 
	fprintf(port "generaledit\n") 
	fprintf(port "load photoplot\n") 
	foreach(entry config 
	    (artwork_file = car(entry)) 
	    (arr = parseString(cadr(entry) "/")) 
	    (class_name = car(arr))
	    (subclass_name = cadr(arr)) 
	    fprintf(port "setwindow form.load_photoplot\n") 
	    fprintf(port "FORM load_photoplot browse\n") 
	    fprintf(port "fillin \"%s\"\n" artwork_file) 
	    fprintf(port "FORM load_photoplot forceformattype 'Gerber RS274X' \n")
	    fprintf(port "FORM load_photoplot classname %s\n" class_name) 
	    fprintf(port "FORM load_photoplot subclassname %s\n" subclass_name) 
	    fprintf(port "FORM load_photoplot loadfile\n") 
	    fprintf(port "setwindow pcb\n") 
	    fprintf(port "pick 0 0\n")
	) 
	fprintf(port "FORM load_photoplot done\n")
	fprintf(port "setwindow pcb\n") 
	fprintf(port "generaledit\n") 
	close(port) 
	(axlShell 
	    strcat("replay " 
		sprintf(nil "%L" script_file)
	    )
	) 
	(axlVisibleUpdate t)
	unless(axlGetVariable("FLW_DEBUG") 
	    when(isFile(script_file) t)
	) t
    )
)
procedure(TBX_PANELIZE_Load_from_File(file_name) 
    let((port instance_config arr plc_info line
	    panel_id definition loc_x loc_y rotation
	    mirror
	) 
	if((file_name && isFile(file_name)) then 
	    (port = infile(file_name)) 
	    while((line = _gets(port)) 
		if(rexMatchp("^ *#" line) then t else 
		    (arr = parseString(line))
		    if((length(arr) >= 6) then 
			rexMatchp("^P" 
			    upperCase(car(arr))
			) 
			(panel_id = car(arr)) 
			(definition = cadr(arr))
			(loc_x = atof(caddr(arr))) 
			(loc_y = atof(nth(3 arr))) 
			(rotation = atof(nth(4 arr))) 
			(mirror = nth(5 arr)) 
			when((panel_id && definition && loc_x && loc_y && rotation && mirror) 
			    (plc_info = ncons(nil)) 
			    (plc_info->definition = definition) 
			    (plc_info->originX = loc_x) 
			    (plc_info->originY = loc_y)
			    (plc_info->rotation = rotation) 
			    (plc_info->isMirror = mirror) 
			    (instance_config = cons(list(panel_id plc_info) instance_config))
			)
			else 
			printf("Warning: Invalid data in: %L, skipping line...\n" line)
		    )
		)
	    ) 
	    close(port)
	    if(instance_config then 
		(instance_config = sortcar(instance_config nil)) else 
		printf("Warning: Nothing to import.\n")
	    ) else 
	    printf("Warning: Cannot acces file %L.\n" file_name)
	) instance_config
    )
)
procedure((TBX_PANELIZE_Main \@optional arg ctrl_file) 
    let((lic_check_result fid FC_FEATURE FORM_FILE VERSION_STR
	    FC_VERSION SUB_VERSION info_file port need_update
	    design_type var_list att att_data
	) 
	(FC_FEATURE = "PANELIZE") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Panelization %s (C)2017" FC_VERSION))
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./panelize_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Panelization information:\n") 
		fprintf(port "===============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version      : Prints the current version of the module\n") 
		fprintf(port "  viewlog      : Shows log file\n") 
		fprintf(port "  reset        : Removes configuration from database\n") 
		fprintf(port "  save_ini     : Saves panelize ini to disk\n")
		fprintf(port "  batch        : Panel update in batch mode: Two modes are supported:\n") 
		fprintf(port "                 tbx panelize batch               : Updates an existing panel database completely in batch\n") 
		fprintf(port "                 tbx panelize batch  control_file : Panel setup and update based on directives from control file\n") 
		fprintf(port "                 Control file syntax is:\n") 
		fprintf(port "                    CONFIG   ./panelize.ini   \n")
		fprintf(port "\n") 
		fprintf(port "                    DELETE    P1 P2 ...   # You may also use pseudo id ALL in order to delete all modules\n") 
		fprintf(port "\n") 
		fprintf(port "                    DESIGN    AMP  ./brd/amp.brd\n") 
		fprintf(port "                    DESIGN    SEN  ./brd/sen.brd\n")
		fprintf(port "\n") 
		fprintf(port "                    SYNCHRONIZE AMP\n") 
		fprintf(port "\n") 
		fprintf(port "                    INSTANCE  P1    AMP    39.0000    291.0000   0.0000   no\n") 
		fprintf(port "                    INSTANCE  P2    AMP   226.0000    290.0000   0.0000   no\n")
		fprintf(port "                    INSTANCE  P3    AMP    41.0000    173.0000   0.0000   no\n") 
		fprintf(port "                    INSTANCE  P4    SEN    55.0000    122.0000   0.0000   no\n") 
		fprintf(port "                    INSTANCE  P5    SEN   149.0000    125.0000   0.0000   no\n") 
		fprintf(port "                    INSTANCE  P6    SEN    54.0000    69.0000    0.0000   no\n") 
		fprintf(port "                    INSTANCE  P7    SEN   160.0000    73.0000    0.0000   no\n")
		fprintf(port "\n") 
		fprintf(port "                    CLEANUP\n") 
		fprintf(port "                 Note: Directives are optional, comments are starting with #\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Panelization: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    ((arg && (lowerCase(arg) == "viewlog")) 
		TBX_PANELIZE_Showlog(cdar((tbx_panelize_global->viewlog)))
	    ) 
	    ((arg && (lowerCase(arg) == "reset")) 
		(axlDeleteAttachment "tbx_panelize") 
		printf("Deleting configuration from database...\n") t
	    ) 
	    ((arg && (lowerCase(arg) == "save_ini")) 
		(att = (axlGetAttachment "tbx_panelize" 
			'string
		    )) 
		if(att then 
		    (att_data = car(linereadstring((att->data)))) 
		    TBX_PANELIZE_Save_Ini(att_data) 
		    TBX_UTIL_Form_Ini_Message("panelize")
		    else 
		    printf("No configuration found in database\n")
		)
	    )
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    TBX_PANELIZE_Init() 
		    TBX_UTIL_Migrate("flw_panelize" "tbx_panelize") 
		    (axlCmdRegister "tbx panelize place" 
			'TBX_PANELIZE_Place ?cmdType "interactive"
		    ) 
		    (axlCmdRegister "tbx panelize loadartwork" 
			'TBX_PANELIZE_Load_Artwork ?cmdType "general"
		    )
		    TBX_PANELIZE_Change_Env("set") 
		    (tbx_panelize_global->envVar = nil) 
		    unless(TBX_PANELIZE_Check_Library_Path() 
			printf("Warning: Environment variables padpath and psmpath do not have \".\" at first position. Application will modify local env file, original settings will be restored once application is closed.\n") 
			(var_list = list(list("set" "padpath" ".") 
				list("set" "psmpath" ".")
			    )) 
			(tbx_panelize_global->envVar = TBX_UTIL_Define_Session_Variables(var_list t))
		    ) 
		    when((axlDBControl 
			    'dynamicFilletsOn
			) 
			printf("Info: Dynamic fillets will be disabled.\n") 
			(axlDBControl 
			    'dynamicFilletsOn nil
			)
		    ) 
		    when((axlDBControl 
			    'drcEnable
			) 
			printf("Info: For performance reasons On-Line DRC will be disabled.\n") 
			(axlDBControl 
			    'drcEnable nil
			)
		    )
		    (tbx_panelize_global->version = VERSION_STR) 
		    (tbx_panelize_global->panelInfo = TBX_PANELIZE_Get_Panel_Info()) 
		    TBX_UTIL_Change_Working_Dir() 
		    (tbx_panelize_global->panelDir = getWorkingDir()) 
		    (tbx_panelize_global->cfg = TBX_PANELIZE_Read_Config())
		    unless(((tbx_panelize_global->cfg)->timeStamp) 
			((tbx_panelize_global->cfg)->timeStamp = ncons(nil))
		    ) 
		    (design_type = upperCase((axlDesignType t))) 
		    if(((design_type == "MCM") || (design_type == "SIP")) then 
			(tbx_panelize_global->panelType = "MCM/SIP") else 
			(tbx_panelize_global->panelType = "BRD")
		    ) 
		    cond(((arg && (arg == "batch")) 
			    TBX_PANELIZE_Batch_Update(ctrl_file)
			) 
			(t 
			    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "panelize_main")) 
			    unless(boundp('tbxPanelizeMainHandle) 
				defvar(tbxPanelizeMainHandle nil)
			    ) 
			    (fid = (axlFormCreate 
				    'tbxPanelizeMainHandle FORM_FILE 
				    '(e outer) 
				    'TBX_PANELIZE_Callback
				    t nil
				)) 
			    when(fid 
				(axlUIWPerm fid t) 
				TBX_FORM_Init_Header(fid "Licensed for " lic_check_result VERSION_STR) 
				((tbx_panelize_global->formHandle)->main = fid) 
				(tbx_panelize_global->licCheck = lic_check_result)
				(axlFormDisplay fid) 
				TBX_PANELIZE_Init_Form(fid) 
				(need_update = TBX_PANELIZE_Revision_Check((tbx_panelize_global->panelInfo) 
					((tbx_panelize_global->cfg)->timeStamp) 
					((tbx_panelize_global->cfg)->designInfo)
				    )) 
				when(need_update 
				    (axlUIConfirm "Warning: Referenced database has been modified in the meantime. Check status for details\nUpdate panel for synchronization.")
				) 
				TBX_FORM_Delete(lic_check_result FORM_FILE)
			    )
			)
		    )
		)
	    )
	)
    )
)
procedure(TBX_PANELIZE_Make_Static(shape_list) 
    let((arr class_name) 
	foreach(shp shape_list 
	    (arr = parseString((shp->layer) "/")) 
	    (class_name = car(arr)) 
	    when((upperCase((axlMapClassName class_name t)) == "BOUNDARY") 
		(axlShapeChangeDynamicType shp nil nil)
	    )
	) t
    )
)
procedure(TBX_PANELIZE_Open(dsn) 
    let((cmd mode) 
	(mode = "skill") 
	when(axlGetVariable("TBX_PANELIZE_SHELL_MODE") 
	    (mode = "shell")
	) 
	if((mode == "shell") then 
	    (cmd = sprintf(nil "opencd %L" dsn)) 
	    (axlShell cmd) else
	    (axlOpenDesignForBatch dsn "wf")
	) t
    )
)
procedure(TBX_PANELIZE_Outline_Backup() 
    let((brd_geo design_outline_lyr design_cutout_lyr legacy_outline_lyr legacy_data
	    new_data
	) 
	(brd_geo = (axlMapClassName "BOARD GEOMETRY")) 
	(design_outline_lyr = strcat(brd_geo "/DESIGN_OUTLINE")) 
	(design_cutout_lyr = strcat(brd_geo "/DESIGN_OUTLINE")) 
	(legacy_outline_lyr = strcat(brd_geo "/OUTLINE"))
	(axlVisibleDesign nil) 
	(axlVisibleLayer design_outline_lyr t) 
	(axlVisibleLayer design_cutout_lyr t) 
	(axlVisibleLayer legacy_outline_lyr t) 
	(axlVisibleUpdate nil)
	(axlSetFindFilter ?enabled 
	    list("noall" "boundary_shapes" "shapes" "lines") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	(legacy_data = setof(x 
		(axlGetSelSet) 
		((x->layer) == legacy_outline_lyr)
	    )) 
	(new_data = setof(x 
		(axlGetSelSet) 
		((x->layer) != legacy_outline_lyr)
	    ))
	(axlClearSelSet) 
	when((new_data && !legacy_data) 
	    TBX_UTIL_Copy_To_Layer(new_data legacy_outline_lyr)
	) t
    )
)
procedure(TBX_PANELIZE_PLC_Build_Dynamics(form_handle mddSizeInfo) 
    let((board_name angle col_cnt row_cnt off_x
	    off_y rpath_data rpath_data_m rpath_offset origin
	    spacing_x spacing_y dyn_origin cur_mdd_info mirror_flag
	    ret
	) 
	(board_name = (axlFormGetField form_handle "board_name")) 
	(angle = (axlFormGetField form_handle "board_rotation")) 
	foreach(entry mddSizeInfo 
	    when((car(entry) == board_name) 
		(cur_mdd_info = cadr(entry))
	    )
	) 
	if(cur_mdd_info then 
	    (dyn_origin = (0.0:0.0)) 
	    if((axlFormGetField form_handle "display_real_outline") then 
		(rpath_data = TBX_PANELIZE_PLC_Build_Path(cur_mdd_info "outline")) else 
		(rpath_data = TBX_PANELIZE_PLC_Build_Path(cur_mdd_info "box"))
	    ) 
	    when((axlFormGetField form_handle "display_module_extents") 
		(rpath_data = nconc(TBX_PANELIZE_PLC_Build_Path(cur_mdd_info "extents") rpath_data))
	    )
	    when((lowerCase((axlFormGetField form_handle "board_mirror")) == "yes") 
		(mirror_flag = t)
	    ) 
	    if(((angle != 0.0) || mirror_flag) then 
		foreach(rp rpath_data 
		    (rpath_data_m = cons(TBX_DBCORE_Rotate_Rpath(rp angle origin mirror_flag) rpath_data_m))
		) else 
		(rpath_data_m = rpath_data)
	    ) 
	    (col_cnt = (axlFormGetField form_handle "columns")) 
	    (row_cnt = (axlFormGetField form_handle "rows")) 
	    (spacing_x = (axlFormGetField form_handle "offset_x"))
	    (spacing_y = (axlFormGetField form_handle "offset_y")) 
	    (axlClearDynamics) 
	    if((axlFormGetField form_handle "place_single") then 
		foreach(rp rpath_data_m 
		    (axlAddSimpleMoveDynamics dyn_origin rp "path") t
		) else 
		for(c 1 col_cnt 
		    (off_x = ((c - 1) * spacing_x)) 
		    for(r 1 row_cnt 
			(off_y = ((r - 1) * spacing_y)) 
			foreach(rp rpath_data_m 
			    (rpath_offset = (axlPathOffset rp 
				    (off_x:off_y)
				)) 
			    (axlAddSimpleMoveDynamics dyn_origin rpath_offset "path")
			)
		    )
		)
	    ) 
	    (ret = t) else
	    printf("No size information available for design %L. Run Create Modules before." board_name) 
	    (axlClearDynamics) 
	    (ret = nil)
	)
	ret
    )
)
procedure(TBX_PANELIZE_PLC_Build_Path(cur_mdd_info mode) 
    let((line_width rpath rpath_data box_width box_height
	    box_ll_x box_ll_y grid box_ll box_ur
	    box_ur_x box_ur_y
	) 
	(line_width = (axlMKSConvert 0.05 "millimeters" 
		car((axlDBGetDesignUnits))
	    )) 
	(line_width = line_width) 
	case(mode 
	    ("box" 
		when(cur_mdd_info 
		    (box_width = (axlMKSConvert 
			    (cur_mdd_info->width) 
			    (cur_mdd_info->units) 
			    car((axlDBGetDesignUnits))
			)) 
		    (box_height = (axlMKSConvert 
			    (cur_mdd_info->height) 
			    (cur_mdd_info->units) 
			    car((axlDBGetDesignUnits))
			)) 
		    (box_ll_x = (axlMKSConvert 
			    car((cur_mdd_info->lowerLeft)) 
			    (cur_mdd_info->units) 
			    car((axlDBGetDesignUnits))
			)) 
		    (box_ll_y = (axlMKSConvert 
			    cadr((cur_mdd_info->lowerLeft)) 
			    (cur_mdd_info->units) 
			    car((axlDBGetDesignUnits))
			))
		    (rpath = (axlPathStart 
			    list(list(box_ll_x box_ll_y) 
				list((box_ll_x + box_width) box_ll_y) 
				list((box_ll_x + box_width) 
				    (box_ll_y + box_height)
				) 
				list(box_ll_x 
				    (box_ll_y + box_height)
				) 
				list(box_ll_x box_ll_y)
			    ) 0.0
			)) 
		    (rpath_data = cons(rpath rpath_data)) 
		    if((box_height < box_width) then 
			(grid = (0.1 * box_height)) else 
			(grid = (0.1 * box_width))
		    ) 
		    (rpath = (axlPathStart 
			    list(list(((1.0 * grid) + box_ll_x) 
				    ((1.0 * grid) + box_ll_y)
				) 
				list(((1.0 * grid) + box_ll_x) 
				    ((3.0 * grid) + box_ll_y)
				) 
				list(((1.5 * grid) + box_ll_x) 
				    ((3.0 * grid) + box_ll_y)
				)
			    ) 0.0
			)) 
		    (rpath = (axlPathArcAngle rpath 0.0 
			    (((1.5 * grid) + box_ll_x):((2.0 * grid) + box_ll_y)) t
			    180.0
			))
		    (rpath = (axlPathLine rpath 0.0 
			    (((1.0 * grid) + box_ll_x):((2.0 * grid) + box_ll_y))
			)) 
		    (rpath_data = cons(rpath rpath_data))
		)
	    ) 
	    ("outline" 
		when(cur_mdd_info 
		    if((car((axlDBGetDesignUnits)) != (cur_mdd_info->units)) then 
			foreach(rp 
			    (cur_mdd_info->outlineDetail) 
			    (rpath_data = cons(TBX_DBCORE_Change_Rpath_Units(rp 
					(cur_mdd_info->units) 
					car((axlDBGetDesignUnits))
				    ) rpath_data
				))
			) else 
			(rpath_data = (cur_mdd_info->outlineDetail))
		    )
		)
	    ) 
	    ("extents" 
		(box_ll = car((cur_mdd_info->extents))) 
		(box_ur = cadr((cur_mdd_info->extents))) 
		(box_ll_x = (axlMKSConvert 
			car(box_ll) 
			(cur_mdd_info->units) 
			car((axlDBGetDesignUnits))
		    )) 
		(box_ll_y = (axlMKSConvert 
			cadr(box_ll) 
			(cur_mdd_info->units) 
			car((axlDBGetDesignUnits))
		    ))
		(box_ur_x = (axlMKSConvert 
			car(box_ur) 
			(cur_mdd_info->units) 
			car((axlDBGetDesignUnits))
		    )) 
		(box_ur_y = (axlMKSConvert 
			cadr(box_ur) 
			(cur_mdd_info->units) 
			car((axlDBGetDesignUnits))
		    )) 
		(rpath = (axlPathStart 
			list((box_ll_x:box_ll_y) 
			    (box_ur_x:box_ll_y) 
			    (box_ur_x:box_ur_y) 
			    (box_ll_x:box_ur_y) 
			    (box_ll_x:box_ll_y)
			) 0.0
		    )) 
		(rpath_data = list(rpath))
	    )
	) rpath_data
    )
)
procedure(TBX_PANELIZE_PLC_Callback(form_handle) 
    let((msg) 
	case((form_handle->curField) 
	    ("board_name" 
		TBX_PANELIZE_Update_Size_String(form_handle 
		    ((tbx_panelize_global->cfg)->mddSizeInfo)
		) 
		TBX_PANELIZE_PLC_Build_Dynamics(form_handle 
		    ((tbx_panelize_global->cfg)->mddSizeInfo)
		)
	    ) 
	    ("board_rotation" 
		TBX_PANELIZE_PLC_Build_Dynamics(form_handle 
		    ((tbx_panelize_global->cfg)->mddSizeInfo)
		)
	    ) 
	    ("rotation_mini_help" 
		(msg = "For arbitrary angles panel accuracy (design parameters) should be at least one greater than single layout database accuracy.") 
		(axlUIConfirm msg)
	    ) 
	    ("board_mirror" 
		TBX_PANELIZE_PLC_Build_Dynamics(form_handle 
		    ((tbx_panelize_global->cfg)->mddSizeInfo)
		)
	    )
	    ("columns" 
		TBX_PANELIZE_PLC_Build_Dynamics(form_handle 
		    ((tbx_panelize_global->cfg)->mddSizeInfo)
		)
	    ) 
	    ("rows" 
		TBX_PANELIZE_PLC_Build_Dynamics(form_handle 
		    ((tbx_panelize_global->cfg)->mddSizeInfo)
		)
	    ) 
	    ("offset_x" 
		TBX_PANELIZE_PLC_Build_Dynamics(form_handle 
		    ((tbx_panelize_global->cfg)->mddSizeInfo)
		)
	    ) 
	    ("offset_y" 
		TBX_PANELIZE_PLC_Build_Dynamics(form_handle 
		    ((tbx_panelize_global->cfg)->mddSizeInfo)
		)
	    ) 
	    ("place_single" 
		TBX_PANELIZE_PLC_Build_Dynamics(form_handle 
		    ((tbx_panelize_global->cfg)->mddSizeInfo)
		)
	    )
	    ("place_array" 
		TBX_PANELIZE_PLC_Build_Dynamics(form_handle 
		    ((tbx_panelize_global->cfg)->mddSizeInfo)
		)
	    ) 
	    ("display_real_outline" 
		TBX_PANELIZE_PLC_Build_Dynamics(form_handle 
		    ((tbx_panelize_global->cfg)->mddSizeInfo)
		)
	    ) 
	    ("display_module_extents" 
		TBX_PANELIZE_PLC_Build_Dynamics(form_handle 
		    ((tbx_panelize_global->cfg)->mddSizeInfo)
		)
	    ) 
	    ("snap_to_grid" 
		if((form_handle->curValue) then 
		    ((tbx_panelize_global->runtime)->snapGrid = t) else 
		    ((tbx_panelize_global->runtime)->snapGrid = nil)
		) 
		((tbx_panelize_global->runtime)->dummyNextPick = t) 
		(axlShell "pick 0 0") 
		TBX_PANELIZE_PLC_Build_Dynamics(form_handle 
		    ((tbx_panelize_global->cfg)->mddSizeInfo)
		)
	    ) 
	    ("done" 
		(axlFinishEnterFun) 
		(axlFormClose form_handle) 
		(axlUIWShow 
		    ((tbx_panelize_global->formHandle)->main) 
		    'show
		)
	    )
	    (t t)
	)
    )
)
procedure(TBX_PANELIZE_PLC_Event_Loop(form_handle) 
    let((eventMask loop event pt_xy) 
	(axlEventSetStartPopup 
	    'TBX_PANELIZE_PLC_Popup
	) 
	(eventMask = list('PICK)) 
	(loop = t) 
	while(loop 
	    TBX_PANELIZE_PLC_Build_Dynamics(form_handle 
		((tbx_panelize_global->cfg)->mddSizeInfo)
	    ) 
	    (event = (axlEnterEvent eventMask nil 
		    ((tbx_panelize_global->runtime)->snapGrid)
		)) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(PICK 
		    if(((tbx_panelize_global->runtime)->dummyNextPick) then 
			((tbx_panelize_global->runtime)->dummyNextPick = nil) else 
			if(((tbx_panelize_global->runtime)->snapGrid) then 
			    (pt_xy = (event->xySnap)) else 
			    (pt_xy = (event->xy))
			)
			TBX_PANELIZE_PLC_Place_Modules(form_handle pt_xy) 
			(tbx_panelize_global->panelInfo = TBX_PANELIZE_Get_Panel_Info()) 
			TBX_PANELIZE_Init_Grid(((tbx_panelize_global->formHandle)->main) "panel")
		    )
		) 
		(DONE 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    (loop = nil) 
		    (axlFormClose form_handle)
		    (axlUIWShow 
			((tbx_panelize_global->formHandle)->main) 
			'show
		    )
		) 
		(CANCEL 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    (loop = nil)
		)
	    )
	)
	(axlEventSetStartPopup)
    )
)
procedure(TBX_PANELIZE_PLC_Init_Form(form_handle) 
    let((board_name) 
	TBX_PANELIZE_Build_Definition_Popup(form_handle "place") 
	(board_name = "") 
	when((length(((tbx_panelize_global->cfg)->designInfo)) >= 1) 
	    (board_name = caar(((tbx_panelize_global->cfg)->designInfo)))
	) 
	(axlFormSetField form_handle "board_name" board_name)
	TBX_PANELIZE_Update_Size_String(form_handle 
	    ((tbx_panelize_global->cfg)->mddSizeInfo)
	) 
	(axlFormSetField form_handle "board_rotation" 0.0) 
	(axlFormSetField form_handle "board_mirror" "no") 
	(axlFormSetField form_handle "columns" 1) 
	(axlFormSetField form_handle "rows" 1)
	(axlFormSetField form_handle "offset_x" 0.0) 
	(axlFormSetField form_handle "offset_y" 0.0) 
	(axlFormSetField form_handle "place_single" t) 
	(axlFormSetField form_handle "display_real_outline" nil) 
	(axlFormSetField form_handle "snap_to_grid" t)
    )
)
procedure(TBX_PANELIZE_PLC_Place_Modules(form_handle dest_xy) 
    let((board_name board_rotation board_mirror num start_num
	    mirror_flag modinst col_cnt row_cnt spacing_x
	    spacing_y mdd_x mdd_y clear_nets panel_id
	    id_list
	) 
	(board_name = (axlFormGetField 
		((tbx_panelize_global->formHandle)->place) "board_name"
	    )) 
	(board_rotation = (axlFormGetField 
		((tbx_panelize_global->formHandle)->place) "board_rotation"
	    )) 
	(board_mirror = (axlFormGetField 
		((tbx_panelize_global->formHandle)->place) "board_mirror"
	    )) 
	(clear_nets = ((tbx_panelize_global->cfg)->clearNets))
	if((lowerCase(board_mirror) == "yes") then 
	    (mirror_flag = t) else 
	    (mirror_flag = nil)
	) 
	when((board_name && (board_name != "")) 
	    (num = TBX_PANELIZE_Get_Last_Panel_Id()) 
	    (axlClearDynamics) 
	    cond(((axlFormGetField form_handle "place_single") 
		    (axlClearDynamics) 
		    (panel_id = sprintf(nil "P%d" num)) 
		    (modinst = (axlDBCreateModuleInstance panel_id board_name dest_xy board_rotation
			    2 nil mirror_flag
			)) 
		    when(modinst 
			when((tbx_panelize_global->isMcmSipPanel) 
			    TBX_PANELIZE_Set_Die_Properties(list(modinst))
			) 
			TBX_PANELIZE_Update_Panel_Id(list(modinst)) 
			when(clear_nets 
			    TBX_PANELIZE_Clear_Nets(list(panel_id))
			) 
			(axlDBAddProp modinst 
			    list("FIXED" t)
			)
			putprop(((tbx_panelize_global->cfg)->timeStamp) 
			    stringToTime(getCurrentTime()) 
			    stringToSymbol(sprintf(nil "P%d" num))
			)
		    )
		) 
		((axlFormGetField form_handle "place_array") 
		    (col_cnt = (axlFormGetField form_handle "columns")) 
		    (row_cnt = (axlFormGetField form_handle "rows")) 
		    (spacing_x = (axlFormGetField form_handle "offset_x")) 
		    (spacing_y = (axlFormGetField form_handle "offset_y"))
		    (start_num = num) 
		    if((col_cnt < row_cnt) then 
			for(c 1 col_cnt 
			    (id_list = nil) 
			    for(r 0 
				(row_cnt - 1) 
				(id_list = cons(sprintf(nil "P%d" 
					    (num + row_cnt)
					) id_list
				    ))
			    )
			    (id_list = reverse(id_list)) 
			    (mdd_x = (car(dest_xy) + ((c - 1) * spacing_x))) 
			    (mdd_y = cadr(dest_xy)) 
			    (modinst = (axlDBCreateManyModuleInstances "P" board_name num 
				    (mdd_x:mdd_y)
				    (0.0:spacing_y) row_cnt board_rotation 2 nil
				    mirror_flag
				)) 
			    (num = (num + row_cnt))
			    when(modinst 
				when((tbx_panelize_global->isMcmSipPanel) 
				    TBX_PANELIZE_Set_Die_Properties(modinst)
				) 
				TBX_PANELIZE_Update_Panel_Id(modinst) 
				when(clear_nets 
				    TBX_PANELIZE_Clear_Nets(id_list)
				) 
				(axlDBAddProp modinst 
				    list("FIXED" t)
				)
			    )
			) else 
			for(r 1 row_cnt 
			    (id_list = nil) 
			    for(c 0 
				(col_cnt - 1) 
				(id_list = cons(sprintf(nil "P%d" 
					    (num + col_cnt)
					) id_list
				    ))
			    )
			    (id_list = reverse(id_list)) 
			    (mdd_x = car(dest_xy)) 
			    (mdd_y = (cadr(dest_xy) + ((r - 1) * spacing_y))) 
			    (modinst = (axlDBCreateManyModuleInstances "P" board_name num 
				    (mdd_x:mdd_y)
				    (spacing_x:0.0) col_cnt board_rotation 2 nil
				    mirror_flag
				)) 
			    (num = (num + col_cnt))
			    when(modinst 
				when((tbx_panelize_global->isMcmSipPanel) 
				    TBX_PANELIZE_Set_Die_Properties(modinst)
				) 
				TBX_PANELIZE_Update_Panel_Id(modinst) 
				when(clear_nets 
				    TBX_PANELIZE_Clear_Nets(id_list)
				) 
				(axlDBAddProp modinst 
				    list("FIXED" t)
				)
			    )
			)
		    ) 
		    for(n start_num 
			((start_num + (row_cnt * col_cnt)) - 1) 
			putprop(((tbx_panelize_global->cfg)->timeStamp) 
			    stringToTime(getCurrentTime()) 
			    stringToSymbol(sprintf(nil "P%d" n))
			)
		    )
		)
	    )
	) 
	(axlDBRefreshId nil) t
    )
)
procedure(TBX_PANELIZE_PLC_Popup(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_PANELIZE_PLC_Popup_Done
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_PANELIZE_PLC_Popup_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_PANELIZE_Place() 
    let((FORM_FILE fid) 
	(axlUIWShow 
	    ((tbx_panelize_global->formHandle)->main) 
	    'hide
	) 
	(FORM_FILE = TBX_FORM_Get_Name((tbx_panelize_global->licCheck) "panelize_place")) 
	unless(boundp('tbxPanelizePlaceHandle) 
	    defvar(tbxPanelizePlaceHandle nil)
	) 
	(fid = (axlFormCreate 
		'tbxPanelizePlaceHandle FORM_FILE 
		'(e outer) 
		'TBX_PANELIZE_PLC_Callback
		t nil
	    ))
	when(fid 
	    TBX_FORM_Init_Header(fid nil nil 
		(tbx_panelize_global->version)
	    ) 
	    ((tbx_panelize_global->formHandle)->place = fid) 
	    (axlFormDisplay fid) 
	    TBX_PANELIZE_PLC_Init_Form(fid)
	    (tbx_panelize_global->runtime = ncons(nil)) 
	    ((tbx_panelize_global->runtime)->snapGrid = t) 
	    TBX_PANELIZE_PLC_Event_Loop(fid) 
	    TBX_FORM_Delete((tbx_panelize_global->licCheck) FORM_FILE)
	)
    )
)
procedure(TBX_PANELIZE_Process_Bond_Pads() 
    let((top_cond_layer bottom_cond_layer top_via_layer bottom_via_layer net_dbid
	    outer_layers rpath radius
	) 
	(top_cond_layer = strcat((axlMapClassName "ETCH") "/" 
		(axlConductorTopLayer)
	    )) 
	(bottom_cond_layer = strcat((axlMapClassName "ETCH") "/" 
		(axlConductorBottomLayer)
	    )) 
	(top_via_layer = strcat("VIA CLASS/" 
		(axlConductorTopLayer)
	    )) 
	(bottom_via_layer = strcat("VIA CLASS/" 
		(axlConductorBottomLayer)
	    ))
	(radius = (axlMKSConvert "10 UM" 
		car((axlDBGetDesignUnits))
	    )) 
	(axlVisibleDesign nil) 
	(axlVisibleLayer top_via_layer t) 
	(axlVisibleLayer bottom_via_layer t) 
	(axlVisibleUpdate t)
	(axlSetFindFilter ?enabled 
	    list("noall" "fingers") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	foreach(bp 
	    (axlGetSelSet) 
	    (net_dbid = (bp->net)) 
	    (outer_layers = nil) 
	    when(net_dbid 
		when((car((bp->startEnd)) == top_cond_layer) 
		    (outer_layers = cons(car((bp->startEnd)) outer_layers))
		) 
		when((cadr((bp->startEnd)) == bottom_cond_layer) 
		    (outer_layers = cons(cadr((bp->startEnd)) outer_layers))
		)
	    )
	    foreach(lyr outer_layers 
		(rpath = (axlPathStartCircle 
			list((bp->xy) radius) 0.0
		    )) 
		(axlDBCreateShape rpath t lyr 
		    (net_dbid->name)
		)
	    )
	) 
	(axlClearSelSet)
	(axlDBRefreshId nil) t
    )
)
procedure(TBX_PANELIZE_Protection_Mode(mode) 
    let((module_list) 
	case(lowerCase(mode) 
	    ("unfix" 
		(axlShell "unfix; prepopup; pop unfixall; prepopup; done")
	    ) 
	    ("fix" 
		(axlClearSelSet) 
		(module_list = (axlSelectByName "MODULE" "*" t)) 
		(axlDBAddProp module_list 
		    list("FIXED" t)
		)
	    )
	) 
	(axlDBRefreshId nil) t
    )
)
procedure(TBX_PANELIZE_Read_Config() 
    let((att att_data cfg config_path data) 
	(att = (axlGetAttachment "tbx_panelize" 
		'string
	    )) 
	if(att then 
	    (att_data = car(linereadstring((att->data)))) else 
	    (att_data = ncons(nil))
	    (config_path = car(TBX_UTIL_Search_Config("panelize.ini" nil nil))) 
	    when(config_path 
		printf("Reading form settings from %L\n" config_path) 
		(data = TBX_UTIL_File_Lineread(config_path)) 
		foreach(entry data 
		    putprop(att_data 
			cadr(entry) 
			car(entry)
		    )
		)
	    )
	) 
	(cfg = ncons(nil)) 
	(cfg->designInfo = TBX_PANELIZE_Validate_Design_Info((tbx_panelize_global->panelDir) 
		(att_data->designInfo)
	    ))
	(cfg->timeStamp = (att_data->timeStamp)) 
	(cfg->userLayers = (att_data->userLayers)) 
	(cfg->mddSizeInfo = (att_data->mddSizeInfo)) 
	(cfg->includeAllLayers = t) 
	when(memq('includeAllLayers 
		(att_data->?)
	    ) 
	    (cfg->includeAllLayers = (att_data->includeAllLayers))
	)
	(cfg->includeArtworkLayers = nil) 
	when(memq('includeArtworkLayers 
		(att_data->?)
	    ) 
	    (cfg->includeArtworkLayers = (att_data->includeArtworkLayers))
	) 
	(cfg->refdesMaster = "refdes_assembly") 
	when(memq('refdesMaster 
		(att_data->?)
	    ) 
	    (cfg->refdesMaster = (att_data->refdesMaster))
	) 
	(cfg->refdesAlt = "none")
	when(memq('refdesAlt 
		(att_data->?)
	    ) 
	    (cfg->refdesAlt = (att_data->refdesAlt))
	) 
	(cfg->excludeRouting = nil) 
	when(memq('excludeRouting 
		(att_data->?)
	    ) 
	    (cfg->excludeRouting = (att_data->excludeRouting))
	) 
	(cfg->loadArtwork = nil) 
	when(memq('loadArtwork 
		(att_data->?)
	    ) 
	    (cfg->loadArtwork = (att_data->loadArtwork))
	)
	(cfg->clearNets = nil) 
	when(memq('clearNets 
		(att_data->?)
	    ) 
	    (cfg->clearNets = (att_data->clearNets))
	) 
	(cfg->useRelativePath = nil) 
	when(memq('useRelativePath 
		(att_data->?)
	    ) 
	    (cfg->useRelativePath = (att_data->useRelativePath))
	) 
	(cfg->unifyLayerNames = nil)
	when(memq('unifyLayerNames 
		(att_data->?)
	    ) 
	    (cfg->unifyLayerNames = (att_data->unifyLayerNames))
	) cfg
    )
)
procedure(TBX_PANELIZE_Rename_Layers(change_list) 
    let((script_file cur_name layer_name layer_type layer_material
	    layer_is_negative row_nr port xs ds
	) 
	if(isCallable('axlXSectionModify) then 
	    foreach(entry change_list 
		(cur_name = cadar(entry)) 
		(xs = (axlXSectionGet nil cur_name)) 
		(layer_name = 'none)
		(layer_type = 'none) 
		(layer_material = 'none) 
		(layer_is_negative = nil) 
		when(cadr(entry) 
		    (layer_name = cadr(entry))
		) 
		when(caddr(entry) 
		    (layer_type = caddr(entry)) 
		    (layer_material = "COPPER")
		)
		when((nth(3 entry) && 
			(lowerCase(nth(3 entry)) == "yes")) 
		    (layer_is_negative = t)
		) 
		(ds = (axlXSectionModify ?name layer_name ?layerType layer_type
			?material layer_material ?negativeArtwork layer_is_negative
		    )) 
		(axlXSectionSet xs ds)
	    ) else 
	    (script_file = strcat(getWorkingDir() "/tbx_rename_layers.scr"))
	    (port = outfile(script_file)) 
	    if(port then 
		fprintf(port "scriptmode +i +n\n") 
		fprintf(port "version 16.3\n") 
		fprintf(port "setwindow pcb\n")
		fprintf(port "trapsize 893\n") 
		fprintf(port "generaledit\n") 
		fprintf(port "xsection\n") 
		fprintf(port "setwindow form.fplyrstack\n") 
		foreach(entry change_list 
		    (row_nr = caar(entry)) 
		    (layer_name = cadr(entry)) 
		    (layer_type = caddr(entry))
		    (layer_is_negative = cadddr(entry)) 
		    when(layer_name 
			fprintf(port "FORM fplyrstack lsgrid cell %d,name\n" row_nr) 
			fprintf(port "FORM fplyrstack lsgrid change %d,name %s\n" row_nr layer_name)
		    ) 
		    when(layer_type 
			fprintf(port "FORM fplyrstack lsgrid lprepopup %d,type\n" row_nr) 
			fprintf(port "FORM fplyrstack lsgrid cell %d,type\n" row_nr) 
			fprintf(port "FORM fplyrstack lsgrid change %d,type %s\n" row_nr layer_type)
		    ) 
		    when(layer_is_negative 
			fprintf(port "FORM fplyrstack lsgrid cell %d,neg\n" row_nr) 
			fprintf(port "FORM fplyrstack lsgrid change %d,neg %s\n" row_nr layer_is_negative)
		    )
		)
		fprintf(port "FORM fplyrstack done\n") 
		fprintf(port "setwindow pcb\n") 
		fprintf(port "generaledit\n") 
		close(port) 
		(axlShell 
		    strcat("replay " "\"" script_file "\"")
		)
		deleteFile(script_file) else 
		printf("Warning: Could not open file %L for write access.\n" script_file)
	    )
	) t
    )
)
procedure(TBX_PANELIZE_Revision_Check(panelInfo timeStamp designInfo) 
    let((board_name board_path lastModBoard panel_id_time_created user_notification
	    panel_id attr
	) 
	(lastModBoard = makeTable("last_mod_board_table" nil)) 
	foreach(entry designInfo 
	    (board_name = upperCase(car(entry))) 
	    (board_path = cadr(entry)) 
	    when(isFile(board_path) 
		(lastModBoard[board_name] = fileTimeModified(board_path))
	    )
	) 
	foreach(entry panelInfo 
	    (panel_id = upperCase(car(entry))) 
	    (attr = cadr(entry)) 
	    (board_name = (attr->definition))
	    (panel_id_time_created = get(timeStamp 
		    stringToSymbol(panel_id)
		)) 
	    when((panel_id_time_created && lastModBoard[board_name] && (lastModBoard[board_name] > panel_id_time_created)) 
		(user_notification = t)
	    )
	) user_notification
    )
)
procedure(TBX_PANELIZE_Safe_Connect() 
    let((xyLoc rect_size cur_clines cur_pinvias seg_list
	    start_xy end_xy net_name pt_str etch_layer
	    pin_layer via_layer pt_xy
	) 
	(rect_size = (axlMKSConvert "20 UM" 
		car((axlDBGetDesignUnits))
	    )) 
	when(((tbx_panelize_global->panelType) == "MCM/SIP") 
	    (rect_size = (axlMKSConvert "10 UM" 
		    car((axlDBGetDesignUnits))
		))
	) 
	(axlSetFindFilter ?enabled 
	    list("noall" "clines" "pins" "vias") ?onButtons 
	    list("all")
	) 
	foreach(lyr 
	    (axlSubclassRoute) 
	    (etch_layer = strcat((axlMapClassName "ETCH") "/" lyr)) 
	    (pin_layer = strcat((axlMapClassName "PIN") "/" lyr)) 
	    (via_layer = strcat((axlMapClassName "VIA CLASS") "/" lyr))
	    (xyLoc = makeTable("xy_loc_data" nil)) 
	    (axlVisibleDesign nil) 
	    (axlVisibleLayer etch_layer t) 
	    (axlVisibleLayer pin_layer t) 
	    (axlVisibleLayer via_layer t)
	    (axlVisibleUpdate nil) 
	    (axlClearSelSet) 
	    (axlAddSelectAll) 
	    (cur_clines = setof(x 
		    (axlGetSelSet) 
		    ((x->objType) == "path")
		)) 
	    (cur_pinvias = setof(x 
		    (axlGetSelSet) 
		    ((x->objType) != "path")
		))
	    (axlClearSelSet) 
	    foreach(cl cur_clines 
		(net_name = ((cl->net)->name)) 
		(seg_list = (cl->segments)) 
		(start_xy = car((car(seg_list)->startEnd)))
		(end_xy = cadr(((lastelem seg_list)->startEnd))) 
		foreach(pt 
		    list(start_xy end_xy) 
		    (pt_str = (axlGeo2Str pt)) 
		    unless(xyLoc[pt_str] 
			(xyLoc[pt_str] = list(pt net_name))
		    )
		)
	    ) 
	    foreach(pv cur_pinvias 
		(pt_str = (axlGeo2Str 
			(pv->xy)
		    )) 
		unless(xyLoc[pt_str] 
		    (xyLoc[pt_str] = list((pv->xy) 
			    ((pv->net)->name)
			))
		)
	    ) 
	    foreach(key xyLoc 
		(pt_xy = car(xyLoc[key])) 
		(net_name = cadr(xyLoc[key])) 
		when((net_name && (net_name != "")) 
		    (axlDBCreateRectangle 
			list(((car(pt_xy) - rect_size):(cadr(pt_xy) - rect_size)) 
			    ((car(pt_xy) + rect_size):(cadr(pt_xy) + rect_size))
			) t etch_layer net_name
		    )
		)
	    )
	)
	t
    )
)
procedure(TBX_PANELIZE_Save_Config_To_Database() 
    let((data_str setup_info match panel_id att_design_info
	    cur_mdd
	) 
	(axlDeleteAttachment "tbx_panelize") 
	foreach(pid 
	    (((tbx_panelize_global->cfg)->timeStamp)->?) 
	    (match = nil) 
	    (panel_id = upperCase(symbolToString(pid))) 
	    foreach(entry 
		(tbx_panelize_global->panelInfo) 
		when((panel_id == upperCase(car(entry))) 
		    (match = t)
		)
	    )
	    unless(match 
		remprop(((tbx_panelize_global->cfg)->timeStamp) pid)
	    )
	) 
	foreach(entry 
	    ((tbx_panelize_global->cfg)->designInfo) 
	    if(((tbx_panelize_global->cfg)->useRelativePath) then 
		(att_design_info = cons(list(car(entry) 
			    caddr(entry)
			) att_design_info
		    )) else 
		(att_design_info = cons(list(car(entry) 
			    cadr(entry)
			) att_design_info
		    ))
	    )
	) 
	(att_design_info = sortcar(att_design_info nil))
	foreach(entry 
	    ((tbx_panelize_global->cfg)->mddSizeInfo) 
	    (cur_mdd = cadr(entry)) 
	    (cur_mdd->outlineDetail = nil)
	) 
	(setup_info = list(nil 
		'designInfo att_design_info 
		'mddSizeInfo 
		((tbx_panelize_global->cfg)->mddSizeInfo)
		'timeStamp 
		((tbx_panelize_global->cfg)->timeStamp) 
		'includeAllLayers 
		((tbx_panelize_global->cfg)->includeAllLayers) 
		'includeArtworkLayers
		((tbx_panelize_global->cfg)->includeArtworkLayers) 
		'userLayers 
		((tbx_panelize_global->cfg)->userLayers) 
		'refdesMaster 
		((tbx_panelize_global->cfg)->refdesMaster)
		'refdesAlt 
		((tbx_panelize_global->cfg)->refdesAlt) 
		'excludeRouting 
		((tbx_panelize_global->cfg)->excludeRouting) 
		'loadArtwork
		((tbx_panelize_global->cfg)->loadArtwork) 
		'clearNets 
		((tbx_panelize_global->cfg)->clearNets) 
		'useRelativePath 
		((tbx_panelize_global->cfg)->useRelativePath)
		'unifyLayerNames 
		((tbx_panelize_global->cfg)->unifyLayerNames)
	    )) 
	(data_str = sprintf(nil "%L" setup_info)) 
	(axlCreateAttachment "tbx_panelize" nil 1 
	    'string
	    data_str
	) t
    )
)
procedure(TBX_PANELIZE_Save_Ini(att_data_dpl) 
    let((port file_name) 
	(file_name = strcat(getWorkingDir() "/panelize.ini")) 
	(port = outfile(file_name "w")) 
	fprintf(port "(\n") 
	fprintf(port "   (refdesMaster          %L)\n" 
	    (att_data_dpl->refdesMaster)
	)
	fprintf(port "   (refdesAlt             %L)\n" 
	    (att_data_dpl->refdesAlt)
	) 
	fprintf(port "   (excludeRouting        %L)\n" 
	    (att_data_dpl->excludeRouting)
	) 
	fprintf(port "   (loadArtwork           %L)\n" 
	    (att_data_dpl->loadArtwork)
	) 
	fprintf(port "   (clearNets             %L)\n" 
	    (att_data_dpl->clearNets)
	) 
	fprintf(port "   (useRelativePath       %L)\n" 
	    (att_data_dpl->useRelativePath)
	)
	fprintf(port "   (includeAllLayers      %L)\n" 
	    (att_data_dpl->includeAllLayers)
	) 
	fprintf(port "   (includeArtworkLayers  %L)\n" 
	    (att_data_dpl->includeArtworkLayers)
	) 
	fprintf(port "   (userLayers            %L)\n" 
	    (att_data_dpl->userLayers)
	) 
	fprintf(port "   (unifyLayerNames       %L)\n" 
	    (att_data_dpl->unifyLayerNames)
	) 
	fprintf(port "   ; =========\n")
	fprintf(port "   ; Note:\n") 
	fprintf(port "   ; =========\n") 
	fprintf(port "   ; Use t to enable and nil to disable a setting\n") 
	fprintf(port "   ; If necessary specify user layers as list, line wrapping allowed for improved readability\n") 
	fprintf(port "   ; e.g.\n")
	fprintf(port "   ;   (userLayers    ( \"MANUFACTURING/MY_LAYER_1\" \"MANUFACTURING/MY_LAYER_2\" .... ) )\n") 
	fprintf(port "   ; or\n") 
	fprintf(port "   ;   (userLayers    ( \"MANUFACTURING/MY_LAYER_1\"\n") 
	fprintf(port "   ;                    \"MANUFACTURING/MY_LAYER_2\"\n") 
	fprintf(port "   ;                     ....\n")
	fprintf(port "   ;                  ) \n") 
	fprintf(port "   ;   )\n") 
	fprintf(port "   ; You may also use command tbx panelize save_ini to generate a panelize.ini from an existing panel database\n") 
	fprintf(port ")\n") 
	close(port)
	printf("Note File %L has been written\n" file_name)
    )
)
procedure(TBX_PANELIZE_Save_to_File(file_name panel_info) 
    let((port plc_info loc_x_str loc_y_str rotation_str) 
	(port = outfile(file_name "w")) 
	fprintf(port "#%-4s %-15s %-10s %-10s %-10s %-3s\n" "Id" "Definition" "X"
	    "Y" "Rotation" "Mirror"
	) 
	foreach(entry panel_info 
	    (plc_info = cadr(entry)) 
	    (loc_x_str = sprintf(nil "%.4f" 
		    (plc_info->originX)
		)) 
	    (loc_y_str = sprintf(nil "%.4f" 
		    (plc_info->originY)
		))
	    (rotation_str = sprintf(nil "%.4f" 
		    (plc_info->rotation)
		)) 
	    fprintf(port "%-5s %-15s %-10s %-10s %-10s %-3s\n" 
		car(entry) 
		(plc_info->definition) loc_x_str
		loc_y_str rotation_str 
		(plc_info->isMirror)
	    )
	) 
	close(port)
    )
)
procedure(TBX_PANELIZE_Set_Die_Properties(module_list) 
    let((sym_list mdd_definition panel_id tmp_table refdes
	    die_type pattern comp_dbid refdes_base
	) 
	foreach(mdl module_list 
	    (mdd_definition = ((mdl->prop)->MODULE_DEFINITION)) 
	    (panel_id = (mdl->name)) 
	    (sym_list = setof(x 
		    (mdl->groupMembers) 
		    ((x->objType) == "symbol")
		))
	    (pattern = strcat(panel_id "_")) 
	    rexCompile(pattern) 
	    when((tbx_panelize_global->dieInfo)[mdd_definition] 
		(tmp_table = makeTable("tmp_table_data" nil)) 
		foreach(entry 
		    (tbx_panelize_global->dieInfo)[mdd_definition] 
		    (refdes_base = car(entry)) 
		    (die_type = cadr(entry)) 
		    (tmp_table[refdes_base] = die_type)
		) 
		foreach(sym sym_list 
		    (comp_dbid = (sym->component)) 
		    if(comp_dbid then 
			(refdes = upperCase((comp_dbid->name))) 
			(refdes_base = rexReplace(refdes "" 0)) 
			when(tmp_table[refdes_base] 
			    (axlSetDieType comp_dbid 
				tmp_table[refdes_base]
			    )
			)
			else t
		    )
		)
	    )
	) t
    )
)
procedure(TBX_PANELIZE_Set_Visible_Layers(sys_layers cfg) 
    let((art_info artwork_layers art_layer) 
	cond(((cfg->includeAllLayers) 
		(axlVisibleDesign t)
	    ) 
	    ((cfg->includeArtworkLayers) 
		foreach(ad 
		    ((axlGetParam "artwork")->groupMembers) 
		    (art_info = (axlGetParam 
			    strcat("artwork:" ad)
			)) 
		    foreach(lyr 
			(art_info->groupMembers) 
			unless(exists(x artwork_layers 
				(x == lyr)
			    ) 
			    (artwork_layers = cons(lyr artwork_layers))
			)
		    )
		) 
		(artwork_layers = sort(artwork_layers nil)) 
		(axlVisibleDesign nil) 
		foreach(lyr artwork_layers 
		    (axlVisibleLayer lyr t)
		)
	    ) 
	    (t 
		(axlVisibleDesign t) 
		(axlVisibleLayer 
		    (axlMapClassName "DRC ERROR CLASS") nil
		) 
		(axlVisibleLayer 
		    (axlMapClassName "DRAWING FORMAT") nil
		) 
		(axlVisibleLayer 
		    (axlMapClassName "ANALYSIS") nil
		)
		(axlVisibleLayer 
		    (axlMapClassName "BOARD GEOMETRY") nil
		) 
		(axlVisibleLayer 
		    (axlMapClassName "MANUFACTURING") nil
		) 
		foreach(lyr sys_layers 
		    when((axlIsLayer lyr) 
			(axlVisibleLayer lyr t)
		    )
		) 
		when((cfg->loadArtwork) 
		    foreach(lyr 
			(axlSubclassRoute) 
			(art_layer = strcat((axlMapClassName "MANUFACTURING") "/PNL_" lyr)) 
			(axlVisibleLayer art_layer t)
		    )
		) 
		foreach(lyr 
		    (cfg->userLayers) 
		    when((axlLayerGet lyr) 
			(axlVisibleLayer lyr t)
		    )
		)
	    )
	)
    )
)
procedure(TBX_PANELIZE_Showlog(message_list) 
    let((out_f log_file) 
	(log_file = strcat(getWorkingDir() "/tbxpanelize.log")) 
	(out_f = outfile(log_file "w")) 
	foreach(item message_list 
	    fprintf(out_f "%s\n" item)
	) 
	close(out_f)
	if(!isFile(log_file) then 
	    (axlUIConfirm "Unable to open log file, Check Permissions!") else 
	    (axlUIViewFileCreate log_file "Panelization - Log" nil)
	)
    )
)
procedure(TBX_PANELIZE_Strip_Constraints() 
    let((a) 
	(a = a) 
	foreach(rg 
	    (axlSelectByName "REGION" "*" t) 
	    (axlRegionDelete rg)
	) 
	foreach(cs 
	    setof(x 
		(axlCnsList 
		    'spacing
		) 
		(upperCase(x) != "DEFAULT")
	    ) 
	    (axlCNSDelete 
		'spacing cs
	    )
	) 
	foreach(cs 
	    setof(x 
		(axlCnsList 
		    'physical
		) 
		(upperCase(x) != "DEFAULT")
	    ) 
	    (axlCNSDelete 
		'physical cs
	    )
	)
	foreach(cs 
	    setof(x 
		(axlCnsList 
		    'sameNet
		) 
		(upperCase(x) != "DEFAULT")
	    ) 
	    (axlCNSDelete 
		'sameNet cs
	    )
	)
    )
)
procedure(TBX_PANELIZE_Sync_Stackup_MCM_Mode(design_path unify_names) 
    let((layer_info layer_cnt ok_continue change_list panel_entry
	    reference_entry row_nr cur_name new_name name_index
	    tech_file cond_cnt diestack_cnt ok_layer_stack
	) 
	tconc((tbx_panelize_global->viewlog) 
	    sprintf(nil "   Reading data from panel database")
	) 
	(cond_cnt = 0) 
	(diestack_cnt = 0) 
	foreach(entry 
	    TBX_PANELIZE_Get_Conductor_Layer_Info() 
	    case(nth(3 entry) 
		("DIESTACK" 
		    ++diestack_cnt
		) 
		("CONDUCTOR" 
		    ++cond_cnt
		) 
		("PLANE" 
		    ++cond_cnt
		)
	    )
	)
	(ok_layer_stack = t) 
	when(((diestack_cnt > 0) || (cond_cnt > 2)) 
	    (axlUIConfirm "Warning: At the moment importing cross section by reading techfile only works when original panel database is a 2 layer substrate without any diestack layer") 
	    (ok_layer_stack = nil)
	) 
	when(ok_layer_stack 
	    if((design_path && isFile(design_path)) then 
		tconc((tbx_panelize_global->viewlog) 
		    sprintf(nil "   Extracting conductor layers from reference board: %L" design_path)
		) 
		(tbx_panelize_global->referenceStackup = TBX_PANELIZE_Get_Conductor_Layer_Info(design_path)) 
		(tech_file = TBX_UTIL_Export_XSection(design_path))
		(ok_continue = t) else 
		tconc((tbx_panelize_global->viewlog) 
		    sprintf(nil "   Error: Could not open database: %L" design_path)
		) 
		(axlUIConfirm 
		    sprintf(nil "Error: Could not open database: %L" design_path)
		) 
		(ok_continue = nil)
	    ) 
	    when(ok_continue 
		TBX_UTIL_Import_Techfile(tech_file) 
		when(unify_names 
		    (layer_info = TBX_PANELIZE_Get_Conductor_Layer_Info()) 
		    tconc((tbx_panelize_global->viewlog) 
			sprintf(nil "   Updated layer info panel: %L" layer_info)
		    ) 
		    (name_index = 2) 
		    (layer_cnt = length(layer_info))
		    for(i 0 
			(layer_cnt - 1) 
			(panel_entry = nth(i layer_info)) 
			(reference_entry = nth(i 
				(tbx_panelize_global->referenceStackup)
			    ))
			(row_nr = car(panel_entry)) 
			(cur_name = cadr(panel_entry)) 
			(new_name = nil) 
			when((cadr(panel_entry) != nth(name_index reference_entry)) 
			    (new_name = nth(name_index reference_entry)) 
			    (change_list = cons(list(list(row_nr cur_name) new_name nil nil) change_list))
			)
		    ) 
		    tconc((tbx_panelize_global->viewlog) 
			sprintf(nil "   Layer data to change: %L" change_list)
		    ) 
		    when(change_list 
			tconc((tbx_panelize_global->viewlog) 
			    sprintf(nil "   Changing layer attributes")
			) 
			TBX_PANELIZE_Rename_Layers(change_list)
		    )
		)
	    )
	)
    )
)
procedure(TBX_PANELIZE_Sync_Stackup_PCB_Mode(design_path unify_names) 
    let((delete_cnt layer_info layer_name layer_cnt diff
	    inner_layers ok_continue class_subclass change_list panel_entry
	    reference_entry row_nr cur_name new_name new_type
	    neg_flag name_index result
	) 
	if((design_path && isFile(design_path)) then 
	    tconc((tbx_panelize_global->viewlog) 
		sprintf(nil "   Extracting conductor layers from reference board: %L" design_path)
	    ) 
	    (tbx_panelize_global->referenceStackup = TBX_PANELIZE_Get_Conductor_Layer_Info(design_path)) 
	    (ok_continue = t)
	    else 
	    tconc((tbx_panelize_global->viewlog) 
		sprintf(nil "   Error: Reference board not specified")
	    ) 
	    (axlUIConfirm 
		sprintf(nil "Error: Reference board not specified")
	    ) 
	    (ok_continue = nil)
	) 
	tconc((tbx_panelize_global->viewlog) 
	    sprintf(nil "   Reference stackup: %L" 
		(tbx_panelize_global->referenceStackup)
	    )
	) 
	when(ok_continue 
	    (layer_info = TBX_PANELIZE_Get_Conductor_Layer_Info()) 
	    (diff = (length(layer_info) - length((tbx_panelize_global->referenceStackup)))) 
	    (ok_continue = t) 
	    tconc((tbx_panelize_global->viewlog) 
		sprintf(nil "   Layer difference is: %L" diff)
	    )
	    cond(((diff > 0) 
		    tconc((tbx_panelize_global->viewlog) 
			sprintf(nil "   Removing first %L layers below TOP from database" 
			    abs(diff)
			)
		    ) 
		    (inner_layers = cdr(layer_info)) 
		    (inner_layers = reverse(inner_layers)) 
		    (inner_layers = cdr(inner_layers))
		    (inner_layers = reverse(inner_layers)) 
		    (delete_cnt = 0) 
		    (layer_cnt = 0) 
		    while(((delete_cnt < diff) && (layer_cnt < length(inner_layers))) 
			(class_subclass = strcat((axlMapClassName "ETCH") "/" 
				cadr(nth(layer_cnt inner_layers))
			    )) 
			++layer_cnt 
			when((axlDeleteObject 
				(axlLayerGet class_subclass)
			    ) 
			    ++delete_cnt 
			    tconc((tbx_panelize_global->viewlog) 
				sprintf(nil "      Remove %L" class_subclass)
			    )
			)
		    ) 
		    when((delete_cnt < diff) 
			(ok_continue = nil) 
			tconc((tbx_panelize_global->viewlog) 
			    sprintf(nil "   Error: Cannot reduce number of etch layers to %d, data may exist on these layers" 
				length((tbx_panelize_global->referenceStackup))
			    )
			) 
			(axlUIConfirm 
			    sprintf(nil "Error: Cannot reduce number of etch layers to %d, data may exist on these layers" 
				length((tbx_panelize_global->referenceStackup))
			    )
			)
		    )
		) 
		((diff < 0) 
		    tconc((tbx_panelize_global->viewlog) 
			sprintf(nil "   Adding %L layers to database" 
			    abs(diff)
			)
		    ) 
		    for(i 1 
			abs(diff) 
			(layer_name = sprintf(nil "NEW_LAYER_%d" i)) 
			(result = (axlLayerCreateCrossSection "BOTTOM" "Conductor" "Copper" layer_name
				"Positive"
			    ))
			unless(result 
			    tconc((tbx_panelize_global->viewlog) 
				sprintf(nil "   Error: Cannot add layer %L to stackup" layer_name)
			    ) 
			    (axlUIConfirm 
				sprintf(nil "   Error: Cannot add layer %L to stackup" layer_name)
			    ) 
			    (ok_continue = nil)
			) 
			(axlLayerCreateCrossSection "BOTTOM" "Dielectric" "FR-4") 
			tconc((tbx_panelize_global->viewlog) 
			    sprintf(nil "      Adding %L above BOTTOM" layer_name)
			)
		    )
		)
	    ) 
	    (axlDBRefreshId nil) 
	    when(ok_continue 
		(layer_info = TBX_PANELIZE_Get_Conductor_Layer_Info()) 
		tconc((tbx_panelize_global->viewlog) 
		    sprintf(nil "   Updated layer info panel: %L" layer_info)
		) 
		(layer_cnt = length(layer_info)) 
		if(unify_names then 
		    (name_index = 2) else 
		    (name_index = 1)
		)
		for(i 0 
		    (layer_cnt - 1) 
		    (panel_entry = nth(i layer_info)) 
		    (reference_entry = nth(i 
			    (tbx_panelize_global->referenceStackup)
			))
		    (row_nr = car(panel_entry)) 
		    (cur_name = cadr(panel_entry)) 
		    (new_name = nil) 
		    (new_type = nil) 
		    (neg_flag = nil)
		    when((cadr(panel_entry) != nth(name_index reference_entry)) 
			(new_name = nth(name_index reference_entry))
		    ) 
		    when((nth(3 panel_entry) != 
			    nth(3 reference_entry)) 
			(new_type = nth(3 reference_entry))
		    ) 
		    when((nth(4 panel_entry) != 
			    nth(4 reference_entry)) 
			if(nth(4 reference_entry) then 
			    (neg_flag = "yes") else 
			    (neg_flag = "no")
			)
		    ) 
		    (change_list = cons(list(list(row_nr cur_name) new_name new_type neg_flag) change_list))
		) 
		tconc((tbx_panelize_global->viewlog) 
		    sprintf(nil "   Layer data to change: %L" change_list)
		) 
		when(change_list 
		    tconc((tbx_panelize_global->viewlog) 
			sprintf(nil "   Changing layer attributes")
		    ) 
		    TBX_PANELIZE_Rename_Layers(change_list)
		)
	    )
	)
    )
)
procedure(TBX_PANELIZE_Update_All_Instances(panel_grid_info) 
    let((panel_id attr mdd_name pt_x pt_y
	    rot mirror_flag
	) 
	foreach(entry panel_grid_info 
	    (panel_id = car(entry)) 
	    (attr = cadr(entry)) 
	    (mdd_name = (attr->definition))
	    (pt_x = (attr->originX)) 
	    (pt_y = (attr->originY)) 
	    (rot = (attr->rotation)) 
	    if((lowerCase((attr->isMirror)) == "yes") then 
		(mirror_flag = t) else 
		(mirror_flag = nil)
	    ) 
	    (axlDBCreateModuleInstance panel_id mdd_name 
		(pt_x:pt_y) rot
		2 nil mirror_flag
	    )
	) t
    )
)
procedure(TBX_PANELIZE_Update_Config(form_handle cfg) 
    (cfg->refdesMaster = (axlFormGetField form_handle "refdes_master")) 
    (cfg->refdesAlt = (axlFormGetField form_handle "refdes_alt")) 
    (cfg->excludeRouting = (axlFormGetField form_handle "exclude_routing")) 
    (cfg->loadArtwork = (axlFormGetField form_handle "load_artwork"))
    (cfg->clearNets = (axlFormGetField form_handle "clear_nets")) 
    (cfg->useRelativePath = (axlFormGetField form_handle "use_relative_path")) 
    (cfg->includeAllLayers = (axlFormGetField form_handle "include_all_layers")) 
    (cfg->includeArtworkLayers = (axlFormGetField form_handle "include_artwork_layers")) 
    (cfg->unifyLayerNames = (axlFormGetField form_handle "unify_names"))
    cfg
)
procedure(TBX_PANELIZE_Update_Panel_Id(module_list) 
    let((pid_list modinst id_value txt_orient) 
	(axlClearSelSet) 
	(pid_list = (axlSelectByName "SYMTYPE" "PANEL_ID")) 
	foreach(pid pid_list 
	    (modinst = car((pid->parentGroups))) 
	    when((modinst && (upperCase((modinst->type)) == "MODULE") && memq(modinst module_list)) 
		(id_value = (modinst->name)) 
		foreach(txt 
		    (axlDBGetAttachedText pid) 
		    when((upperCase((txt->text)) == "ID") 
			(txt_orient = (axlTextOrientationCopy txt)) 
			(axlDBChangeText txt id_value txt_orient)
		    )
		)
	    )
	) 
	(axlClearSelSet)
	t
    )
)
procedure(TBX_PANELIZE_Update_Size_String(form_handle mdd_size_info) 
    let((size_string width height) 
	(size_string = "NA") 
	foreach(entry mdd_size_info 
	    when((car(entry) == (axlFormGetField form_handle "board_name")) 
		(width = (axlMKSConvert 
			(cadr(entry)->width) 
			(cadr(entry)->units) 
			car((axlDBGetDesignUnits))
		    )) 
		(height = (axlMKSConvert 
			(cadr(entry)->height) 
			(cadr(entry)->units) 
			car((axlDBGetDesignUnits))
		    )) 
		(size_string = sprintf(nil "%.2fx%.2f" width height))
	    )
	) 
	(axlFormSetField form_handle "extents" size_string)
    )
)
procedure(TBX_PANELIZE_Validate_Design_Info(panel_dir grid_info) 
    let((mdd_name board_path board_path_abs board_path_rel board_dir
	    rel_dir brd_file design_info
	) 
	foreach(entry grid_info 
	    (mdd_name = car(entry)) 
	    (board_path = cadr(entry)) 
	    (board_path_abs = simplifyFilename(board_path))
	    (board_path_abs = (axlOSSlash board_path_abs)) 
	    (board_dir = car((axlDMFileParts board_path_abs))) 
	    (brd_file = caddr((axlDMFileParts board_path_abs))) 
	    (rel_dir = TBX_UTIL_Get_Relative_Path(board_dir panel_dir)) 
	    when(rel_dir 
		(board_path_rel = strcat(rel_dir "/" brd_file))
	    )
	    when((mdd_name && board_path_abs && board_path_rel) 
		(design_info = cons(list(mdd_name board_path_abs board_path_rel) design_info))
	    )
	) 
	(design_info = sortcar(design_info nil)) design_info
    )
)
procedure((TBX_PANELIZE_Validate_Input value type_required \@optional mode) 
    let((new_value) 
	case(type_required 
	    ("string" 
		when((value && (type(value) == 'string)) 
		    (new_value = value) 
		    rexCompile("^ *") 
		    (new_value = rexReplace(new_value "" 0)) 
		    rexCompile(" *$")
		    (new_value = rexReplace(new_value "" 0)) 
		    when(mode 
			case(mode 
			    ("lowerCaseNoSpace" 
				rexCompile(" ") 
				(new_value = rexReplace(new_value "" 0)) 
				(new_value = lowerCase(new_value))
			    ) 
			    ("upperCaseNoSpace" 
				rexCompile(" ") 
				(new_value = rexReplace(new_value "" 0)) 
				(new_value = upperCase(new_value))
			    ) 
			    ("asIs" t)
			)
		    )
		)
	    ) 
	    ("float" 
		cond(((value && (type(value) == 'string)) 
			when(atof(value) 
			    (new_value = atof(value))
			)
		    ) 
		    ((value && (type(value) == 'flonum)) 
			(new_value = value)
		    ) 
		    ((value && (type(value) == 'fixnum)) 
			(new_value = (value * 1.0))
		    )
		)
	    ) 
	    ("integer" 
		cond(((value && (type(value) == 'string)) 
			when(atoi(value) 
			    (new_value = atoi(value))
			)
		    ) 
		    ((value && (type(value) == 'flonum)) 
			(new_value = round(value))
		    ) 
		    ((value && (type(value) == 'fixnum)) 
			(new_value = value)
		    )
		)
	    )
	) new_value
    )
)
procedure(TBX_PANELIZE_Validate_Size_Info(mddSizeInfo) 
    let((ok_size_info cur_mdd_info) 
	(ok_size_info = t) 
	foreach(entry mddSizeInfo 
	    (cur_mdd_info = cadr(entry)) 
	    when((!(cur_mdd_info->units) || !(cur_mdd_info->width) || !(cur_mdd_info->height) || !(cur_mdd_info->lowerLeft) || !(cur_mdd_info->outlineDetail)) 
		(ok_size_info = nil)
	    )
	) ok_size_info
    )
)
procedure(TBX_PCBLIBPLOT_Calculate_Param(sym_box cv_box plot_mode) 
    let((sym_ll sym_ur sym_width sym_height cv_ll
	    cv_ur cv_width cv_height cv_center_x cv_center_y
	    cv_ll_x cv_ll_y cv_ur_x cv_ur_y offset_y
	    delta_x delta_y dest_x dest_y result
	    scale_exact scale_final scale_x scale_y char_height_small
	    char_height_regular char_height_large
	) 
	(sym_ll = car(sym_box)) 
	(sym_ur = cadr(sym_box)) 
	(sym_width = (car(sym_ur) - car(sym_ll))) 
	(sym_height = (cadr(sym_ur) - cadr(sym_ll)))
	(cv_ll = car(cv_box)) 
	(cv_ur = cadr(cv_box)) 
	(cv_ll_x = car(cv_ll)) 
	(cv_ll_y = cadr(cv_ll)) 
	(cv_ur_x = car(cv_ur))
	(cv_ur_y = cadr(cv_ur)) 
	(char_height_small = ((axlGetParam 
		    sprintf(nil "paramTextBlock:%s" 
			(tbx_pcblibplot_global->labelBlockSmall)
		    )
		)->height)) 
	(offset_y = (char_height_small + (tbx_pcblibplot_global->lineSpace))) 
	(cv_ll_y = (cv_ll_y + offset_y)) 
	(cv_ll = (cv_ll_x:cv_ll_y))
	(char_height_large = ((axlGetParam 
		    sprintf(nil "paramTextBlock:%s" 
			(tbx_pcblibplot_global->labelBlockLarge)
		    )
		)->height)) 
	(char_height_regular = ((axlGetParam 
		    sprintf(nil "paramTextBlock:%s" 
			(tbx_pcblibplot_global->labelBlockRegular)
		    )
		)->height)) 
	if((plot_mode == "long") then 
	    (offset_y = (char_height_large + (tbx_pcblibplot_global->lineSpace))) else 
	    (offset_y = ((2 * char_height_regular) + char_height_large + (3 * (tbx_pcblibplot_global->lineSpace))))
	) 
	(cv_ur_y = (cv_ur_y - offset_y)) 
	(cv_ur = (cv_ur_x:cv_ur_y))
	(cv_width = (car(cv_ur) - car(cv_ll))) 
	(cv_height = (cadr(cv_ur) - cadr(cv_ll))) 
	(cv_center_x = (car(cv_ll) + (cv_width / 2.0))) 
	(cv_center_y = (cadr(cv_ll) + (cv_height / 2.0))) 
	(scale_x = (cv_width / (sym_width * 1.0)))
	(scale_y = (cv_height / (sym_height * 1.0))) 
	if((scale_x < scale_y) then 
	    (scale_exact = scale_x) else 
	    (scale_exact = scale_y)
	) 
	foreach(val 
	    (tbx_pcblibplot_global->scaleValues) 
	    when((scale_exact > val) 
		(scale_final = val)
	    )
	) 
	unless(scale_final 
	    (scale_final = car((tbx_pcblibplot_global->scaleValues)))
	) 
	when((scale_final > (tbx_pcblibplot_global->maxScale)) 
	    (scale_final = (tbx_pcblibplot_global->maxScale))
	)
	(delta_x = ((sym_width / 2.0) * scale_final)) 
	(delta_y = ((sym_height / 2.0) * scale_final)) 
	(dest_x = (cv_center_x - delta_x)) 
	(dest_y = (cv_center_y - delta_y)) 
	(result = list((dest_x:dest_y) scale_final))
	result
    )
)
procedure(TBX_PCBLIBPLOT_Change_Env(mode) 
    case(mode 
	("set" 
	    unless(axlGetVariable("NOCONFIRM_SAVEDB") 
		(axlSetVariable "NOCONFIRM_SAVEDB" t) 
		((tbx_pcblibplot_global->envSettings)->noconfirmOrig = nil)
	    ) 
	    unless(axlGetVariable("NOCONFIRM_UPREV") 
		(axlSetVariable "NOCONFIRM_UPREV" t) 
		((tbx_pcblibplot_global->envSettings)->noconfirmUprev = nil)
	    ) 
	    unless(axlGetVariable("DB_TIER_NOMSG") 
		(axlSetVariable "DB_TIER_NOMSG" t) 
		((tbx_pcblibplot_global->envSettings)->noTierMessageOrig = nil)
	    )
	) 
	("reset" 
	    unless(((tbx_pcblibplot_global->envSettings)->noconfirmOrig) 
		(axlUnsetVariable "NOCONFIRM_SAVEDB")
	    ) 
	    unless(((tbx_pcblibplot_global->envSettings)->noconfirmUprev) 
		(axlUnsetVariable "NOCONFIRM_UPREV")
	    ) 
	    unless(((tbx_pcblibplot_global->envSettings)->noTierMessageOrig) 
		(axlUnsetVariable "DB_TIER_NOMSG")
	    )
	) 
	(t t)
    )
)
procedure(TBX_PCBLIBPLOT_Cleanup() 
    let((tmp_layer_list param) 
	(tmp_layer_list = list(((tbx_pcblibplot_global->tmpLayer)->shape) 
		((tbx_pcblibplot_global->tmpLayer)->pad) 
		((tbx_pcblibplot_global->tmpLayer)->hole)
	    )) 
	(axlVisibleDesign nil) 
	foreach(lyr tmp_layer_list 
	    (axlVisibleLayer lyr t)
	) 
	(axlVisibleUpdate nil)
	(axlClearSelSet) 
	if(isCallable('axlDeleteByLayer) then 
	    (axlDeleteByLayer tmp_layer_list 
		'fixed
	    ) else 
	    TBX_UTIL_Clean_Layer(tmp_layer_list)
	) 
	foreach(lyr tmp_layer_list 
	    (param = (axlLayerGet lyr)) 
	    (axlDeleteObject param)
	) t
    )
)
procedure(TBX_PCBLIBPLOT_Copy_Examples() 
    let((examples_dir brd_list source destination) 
	(examples_dir = strcat(axlGetVariable("allegro_install_root") "/share/pcb/toolbox/getting_started/pcblibplot")) 
	foreach(brd 
	    rexMatchList("[.][bB][rR][dD]$" 
		getDirFiles(examples_dir)
	    ) 
	    (source = strcat(examples_dir "/" brd)) 
	    (destination = strcat(getWorkingDir() "/" brd)) 
	    (axlOSFileCopy source destination nil)
	    (brd_list = cons(destination brd_list))
	) 
	(brd_list = reverse(brd_list)) brd_list
    )
)
procedure(TBX_PCBLIBPLOT_Create_Text(text_list corner mode cv_box align_column) 
    let((line_space txt_xy txt_y txt_orient cv_ll
	    cv_ur txt_block txt_layer txt_justify txt_x1
	    txt_x2 two_columns_exist first_text y_offset max_len_col1
	    max_len_col2 max_char_space max_char_width char_space char_width
	    char_height
	) 
	(txt_layer = (tbx_pcblibplot_global->notesLayer)) 
	(max_len_col1 = 0) 
	(max_len_col2 = 0) 
	(max_char_space = 0)
	(max_char_width = 0) 
	foreach(entry text_list 
	    (txt_block = caddr(entry)) 
	    when((cadr(entry) != " ") 
		(two_columns_exist = t) 
		when((strlen(car(entry)) > max_len_col1) 
		    (max_len_col1 = strlen(car(entry)))
		) 
		when((strlen(cadr(entry)) > max_len_col2) 
		    (max_len_col2 = strlen(cadr(entry)))
		) 
		(char_space = ((axlGetParam 
			    sprintf(nil "paramTextBlock:%s" txt_block)
			)->charSpace))
		(char_width = ((axlGetParam 
			    sprintf(nil "paramTextBlock:%s" txt_block)
			)->width)) 
		when((char_space > max_char_space) 
		    (max_char_space = char_space)
		) 
		when((char_width > max_char_width) 
		    (max_char_width = char_width)
		)
	    )
	) 
	(cv_ll = car(cv_box)) 
	(cv_ur = cadr(cv_box)) 
	case(lowerCase(corner) 
	    ("upper_left" 
		(txt_justify = "left") 
		(txt_xy = (car(cv_ll):cadr(cv_ur))) 
		(txt_x1 = car(txt_xy)) 
		when(two_columns_exist 
		    (txt_x2 = (txt_x1 + (max_len_col1 * max_char_width) + ((max_len_col1 + 4) * max_char_space)))
		)
		(txt_y = cadr(txt_xy))
	    ) 
	    ("lower_left" 
		(txt_justify = "left") 
		(txt_xy = (car(cv_ll):cadr(cv_ll))) 
		(txt_x1 = car(txt_xy)) 
		when(two_columns_exist 
		    (txt_x2 = (txt_x1 + (max_len_col1 * max_char_width) + ((max_len_col1 + 4) * max_char_space)))
		)
		(txt_y = cadr(txt_xy))
	    ) 
	    ("upper_right" 
		(txt_justify = "right") 
		(txt_xy = (car(cv_ur):cadr(cv_ur))) 
		(txt_x2 = car(txt_xy)) 
		when(two_columns_exist 
		    (txt_x1 = (txt_x2 - (max_len_col2 * max_char_width) - ((max_len_col2 + 4) * max_char_space)))
		)
		(txt_y = cadr(txt_xy))
	    ) 
	    ("lower_right" 
		(txt_justify = "right") 
		(txt_xy = (car(cv_ur):cadr(cv_ll))) 
		(txt_x2 = car(txt_xy)) 
		when(two_columns_exist 
		    (txt_x1 = (txt_x2 - (max_len_col2 * max_char_width) - ((max_len_col2 + 4) * max_char_space)))
		)
		(txt_y = cadr(txt_xy))
	    )
	)
	foreach(entry text_list 
	    (txt_block = caddr(entry)) 
	    (char_height = ((axlGetParam 
			sprintf(nil "paramTextBlock:%s" txt_block)
		    )->height)) 
	    (line_space = (tbx_pcblibplot_global->lineSpace))
	    unless(first_text 
		(first_text = t) 
		case(lowerCase(mode) 
		    ("outside" 
			if(((corner == "upper_left") || (corner == "upper_right")) then 
			    (y_offset = (char_height + line_space)) else 
			    (txt_y = (txt_y - char_height))
			    (y_offset = (- (char_height + line_space)))
			)
		    ) 
		    ("inside" 
			if(((corner == "upper_left") || (corner == "upper_right")) then 
			    (txt_y = (txt_y - char_height)) 
			    (y_offset = (- (char_height + line_space))) else
			    (y_offset = (char_height + line_space))
			)
		    ) 
		    (t t)
		)
	    ) 
	    (txt_orient = (make_axlTextOrientation ?textBlock txt_block ?rotation 0.0
		    ?mirrored nil ?justify txt_justify
		)) 
	    if((align_column && two_columns_exist) then 
		(axlDBCreateText 
		    car(entry) 
		    (txt_x1:txt_y) txt_orient txt_layer
		    nil
		) 
		if((cadr(entry) != " ") then 
		    (axlDBCreateText 
			cadr(entry) 
			(txt_x2:txt_y) txt_orient txt_layer
			nil
		    ) else
		) 
		(txt_y = (txt_y + y_offset))
		else 
		(axlDBCreateText 
		    strcat(car(entry) " " 
			cadr(entry)
		    ) 
		    (txt_x1:txt_y) txt_orient txt_layer
		    nil
		) 
		(txt_y = (txt_y + y_offset))
	    )
	) t
    )
)
procedure(TBX_PCBLIBPLOT_Generate_Text_Info(sym_info cv_box_list plot_mode) 
    let((attr_value graphics_ul_text graphics_ll_text info_text arr
	    pin_cnt
	) 
	(graphics_ul_text = list()) 
	(graphics_ll_text = list()) 
	(info_text = list()) 
	(graphics_ll_text = cons(list("Scale" 
		    get(sym_info 
			'SCALE
		    ) 
		    (tbx_pcblibplot_global->labelBlockSmall)
		) graphics_ll_text
	    ))
	if((plot_mode == "long") then 
	    (graphics_ul_text = cons(list(get(sym_info 
			    'NAME
			) " " 
			(tbx_pcblibplot_global->labelBlockLarge)
		    ) graphics_ul_text
		)) 
	    (info_text = cons(list("Attributes:" " " 
			(tbx_pcblibplot_global->labelBlockRegular)
		    ) info_text
		)) 
	    (info_text = cons(list("-----------" " " 
			(tbx_pcblibplot_global->labelBlockRegular)
		    ) info_text
		))
	    (info_text = cons(list("Size" 
			get(sym_info 
			    'SIZE
			) 
			(tbx_pcblibplot_global->labelBlockRegular)
		    ) info_text
		)) 
	    (info_text = cons(list(" " 
			get(sym_info 
			    'PLACEBOUND_SIZE
			) 
			(tbx_pcblibplot_global->labelBlockRegular)
		    ) info_text
		)) 
	    (info_text = cons(list("Height" 
			get(sym_info 
			    'HEIGHT
			) 
			(tbx_pcblibplot_global->labelBlockRegular)
		    ) info_text
		)) 
	    (info_text = cons(list("PitchX" 
			get(sym_info 
			    'XPITCH
			) 
			(tbx_pcblibplot_global->labelBlockRegular)
		    ) info_text
		)) 
	    (info_text = cons(list("PitchY" 
			get(sym_info 
			    'YPITCH
			) 
			(tbx_pcblibplot_global->labelBlockRegular)
		    ) info_text
		))
	    (info_text = cons(list("ConnPinCnt" 
			get(sym_info 
			    'CONNECT_PINS
			) 
			(tbx_pcblibplot_global->labelBlockRegular)
		    ) info_text
		)) 
	    (attr_value = get(sym_info 
		    'CONNECT_PADS
		)) 
	    (arr = parseString(attr_value "|")) 
	    if((length(arr) > 1) then 
		(info_text = cons(list("ConnPads" 
			    car(arr) 
			    (tbx_pcblibplot_global->labelBlockRegular)
			) info_text
		    )) 
		foreach(pad 
		    cdr(arr) 
		    (info_text = cons(list(" " pad 
				(tbx_pcblibplot_global->labelBlockRegular)
			    ) info_text
			))
		) else
		(info_text = cons(list("ConnPads" attr_value 
			    (tbx_pcblibplot_global->labelBlockRegular)
			) info_text
		    ))
	    ) 
	    (info_text = cons(list("MechPinCnt" 
			get(sym_info 
			    'MECH_PINS
			) 
			(tbx_pcblibplot_global->labelBlockRegular)
		    ) info_text
		))
	    (attr_value = get(sym_info 
		    'MECH_PADS
		)) 
	    (arr = parseString(attr_value "|")) 
	    if((length(arr) > 1) then 
		(info_text = cons(list("MechPads" 
			    car(arr) 
			    (tbx_pcblibplot_global->labelBlockRegular)
			) info_text
		    )) 
		foreach(pad 
		    cdr(arr) 
		    (info_text = cons(list(" " pad 
				(tbx_pcblibplot_global->labelBlockRegular)
			    ) info_text
			))
		) else
		(info_text = cons(list("MechPads" attr_value 
			    (tbx_pcblibplot_global->labelBlockRegular)
			) info_text
		    ))
	    ) 
	    (graphics_ul_text = reverse(graphics_ul_text)) 
	    TBX_PCBLIBPLOT_Create_Text(graphics_ul_text "upper_left" "inside" 
		car(cv_box_list) nil
	    )
	    (info_text = reverse(info_text)) 
	    TBX_PCBLIBPLOT_Create_Text(info_text "upper_left" "inside" 
		cadr(cv_box_list) t
	    ) else 
	    (pin_cnt = (atoi(get(sym_info 
			    'CONNECT_PINS
			)
		    ) + atoi(get(sym_info 
			    'MECH_PINS
			)
		    ))) 
	    (graphics_ul_text = cons(list(get(sym_info 
			    'NAME
			) " " 
			(tbx_pcblibplot_global->labelBlockLarge)
		    ) graphics_ul_text
		))
	    (graphics_ul_text = cons(list("Pins" 
			sprintf(nil "%d" pin_cnt) 
			(tbx_pcblibplot_global->labelBlockRegular)
		    ) graphics_ul_text
		)) 
	    (graphics_ul_text = cons(list("Size" 
			get(sym_info 
			    'SIZE
			) 
			(tbx_pcblibplot_global->labelBlockRegular)
		    ) graphics_ul_text
		)) 
	    (graphics_ul_text = reverse(graphics_ul_text)) 
	    TBX_PCBLIBPLOT_Create_Text(graphics_ul_text "upper_left" "inside" 
		car(cv_box_list) nil
	    )
	) 
	(graphics_ll_text = reverse(graphics_ll_text)) 
	TBX_PCBLIBPLOT_Create_Text(graphics_ll_text "lower_left" "inside" 
	    car(cv_box_list) nil
	) t
    )
)
procedure(TBX_PCBLIBPLOT_Get_Canvas_Areas(plot_mode) 
    let((canvas_list tmp_data cv_ll cv_ll_x cv_ll_y
	    master_list y_sorted x_sorted cv_sorted cv_ll_a
	    cv_ur_a cv_ll_b cv_ur_b width result
	    cv_ur
	) 
	(tmp_data = makeTable("tmp_data_table" nil)) 
	TBX_PCBLIBPLOT_Vis_Mode("canvas_boundary") 
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    list("noall" "shapes") ?onButtons 
	    list("all")
	)
	(axlAddSelectAll) 
	(canvas_list = list()) 
	foreach(shape 
	    (axlGetSelSet) 
	    (canvas_list = cons((shape->bBox) canvas_list))
	) 
	(axlClearSelSet) 
	foreach(cv canvas_list 
	    (cv_ll = car(cv)) 
	    (cv_ll_x = (axlGeo2Str 
		    car(cv_ll)
		)) 
	    (cv_ll_y = (axlGeo2Str 
		    cadr(cv_ll)
		))
	    (tmp_data[cv_ll_y] = cons(list(atof(cv_ll_x) cv) 
		    tmp_data[cv_ll_y]
		))
	)
	(master_list = list()) 
	foreach(key tmp_data 
	    (master_list = cons(cons(atof(key) 
			tmp_data[key]
		    ) master_list
		))
	) 
	(y_sorted = sortcar(master_list 
		'lessp
	    )) 
	(y_sorted = reverse(y_sorted)) 
	foreach(entry y_sorted 
	    (x_sorted = sortcar(cdr(entry) 
		    'lessp
		)) 
	    foreach(cv x_sorted 
		(cv_sorted = cons(cadr(cv) cv_sorted))
	    )
	)
	(cv_sorted = reverse(cv_sorted)) 
	(result = list()) 
	if((plot_mode == "long") then 
	    foreach(cv cv_sorted 
		(cv_ll = car(cv)) 
		(cv_ur = cadr(cv)) 
		(width = (car(cv_ur) - car(cv_ll)))
		(width = (width / 2.0)) 
		(cv_ll_a = cv_ll) 
		(cv_ur_a = ((car(cv_ll) + width):cadr(cv_ur))) 
		(cv_ll_b = ((car(cv_ll) + width):cadr(cv_ll))) 
		(cv_ur_b = cv_ur)
		(result = cons(list(list(cv_ll_a cv_ur_a) 
			    list(cv_ll_b cv_ur_b)
			) result
		    ))
	    ) 
	    (result = reverse(result)) else
	    foreach(cv cv_sorted 
		(result = cons(list(cv nil) result))
	    ) 
	    (result = reverse(result))
	) result
    )
)
procedure(TBX_PCBLIBPLOT_Get_Fill_Style(style_info scale) 
    let((fill_style hatch_1 hatch_2 hwidth hspacing
	    design_units resolution
	) 
	(design_units = car((axlDBGetDesignUnits))) 
	(resolution = (1.0 / (10**cadr((axlDBGetDesignUnits))))) 
	(fill_style = "NA") 
	when(style_info 
	    when(rexMatchp("^HATCH" 
		    upperCase(car(style_info))
		) 
		(hwidth = (axlMKSConvert 
			cadr(style_info) design_units
		    )) 
		(hspacing = (axlMKSConvert 
			caddr(style_info) design_units
		    )) 
		when((scale > 1.0) 
		    (hwidth = (hwidth / scale)) 
		    (hspacing = (hspacing / scale))
		) 
		when((hwidth < resolution) 
		    (hwidth = (2 * resolution))
		)
		when((hspacing < resolution) 
		    (hspacing = (2 * resolution))
		)
	    ) 
	    case(upperCase(car(style_info)) 
		("FILL" 
		    (fill_style = t)
		) 
		("UNFILL" 
		    (fill_style = nil)
		) 
		("HATCH_VERTICAL" 
		    (hatch_1 = (make_axlFill)) 
		    (hatch_1->width = hwidth) 
		    (hatch_1->spacing = hspacing) 
		    (hatch_1->angle = 90.0)
		    (fill_style = list(hatch_1))
		) 
		("HATCH_HORIZONTAL" 
		    (hatch_1 = (make_axlFill)) 
		    (hatch_1->width = hwidth) 
		    (hatch_1->spacing = hspacing) 
		    (hatch_1->angle = 0.0)
		    (fill_style = list(hatch_1))
		)
		("HATCH_HORI_VERT" 
		    (hatch_1 = (make_axlFill)) 
		    (hatch_1->width = hwidth) 
		    (hatch_1->spacing = hspacing) 
		    (hatch_1->angle = 0.0)
		    (hatch_2 = (make_axlFill)) 
		    (hatch_2->width = hwidth) 
		    (hatch_2->spacing = hspacing) 
		    (hatch_2->angle = 0.0) 
		    (fill_style = list(hatch_1 hatch_2))
		) 
		("HATCH_DIAG_POS" 
		    (hatch_1 = (make_axlFill)) 
		    (hatch_1->width = hwidth) 
		    (hatch_1->spacing = hspacing) 
		    (hatch_1->angle = 45.0)
		    (fill_style = list(hatch_1))
		) 
		("HATCH_DIAG_NEG" 
		    (hatch_1 = (make_axlFill)) 
		    (hatch_1->width = hwidth) 
		    (hatch_1->spacing = hspacing) 
		    (hatch_1->angle = 135.0)
		    (fill_style = list(hatch_1))
		) 
		("HATCH_DIAG_BOTH" 
		    (hatch_1 = (make_axlFill)) 
		    (hatch_1->width = hwidth) 
		    (hatch_1->spacing = hspacing) 
		    (hatch_1->angle = 45.0)
		    (hatch_2 = (make_axlFill)) 
		    (hatch_2->width = hwidth) 
		    (hatch_2->spacing = hspacing) 
		    (hatch_2->angle = 135.0) 
		    (fill_style = list(hatch_1 hatch_2))
		) 
		(t 
		    (fill_style = "NA")
		)
	    )
	)
	fill_style
    )
)
procedure(TBX_PCBLIBPLOT_Get_Frame_Info() 
    let((month_nr tmp_list mm dd yy
	    user_name date frame_info tmp_data
	) 
	if(axlGetVariable("username") then 
	    (user_name = upperCase(axlGetVariable("username"))) else 
	    (user_name = (tbx_pcblibplot_global->naValue))
	) 
	(month_nr = makeTable("month_nr_table" nil)) 
	(month_nr["JAN"] = 1) 
	(month_nr["FEB"] = 2)
	(month_nr["MAR"] = 3) 
	(month_nr["APR"] = 4) 
	(month_nr["MAY"] = 5) 
	(month_nr["JUN"] = 6) 
	(month_nr["JUL"] = 7)
	(month_nr["AUG"] = 8) 
	(month_nr["SEP"] = 9) 
	(month_nr["OCT"] = 10) 
	(month_nr["NOV"] = 11) 
	(month_nr["DEC"] = 12)
	(tmp_list = parseString(upperCase(getCurrentTime()))) 
	(mm = sprintf(nil "%02d" 
		month_nr[car(tmp_list)]
	    )) 
	(dd = sprintf(nil "%02d" 
		atoi(cadr(tmp_list))
	    )) 
	(yy = substring(nth(3 tmp_list) 3)) 
	(date = strcat(dd "." mm "." yy))
	(frame_info = makeTable("frame_info_table" nil)) 
	TBX_PCBLIBPLOT_Vis_Mode("frame_info") 
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    list("noall" "text") ?onButtons 
	    list("all")
	) 
	(axlAddSelectAll)
	foreach(txt 
	    (axlGetSelSet) 
	    (tmp_data = ncons(nil)) 
	    putprop(tmp_data 
		(txt->xy) 
		'XY
	    ) 
	    putprop(tmp_data 
		(txt->rotation) 
		'ROTATION
	    )
	    putprop(tmp_data 
		(txt->textBlock) 
		'BLOCK
	    ) 
	    putprop(tmp_data 
		(txt->isMirrored) 
		'MIRROR
	    ) 
	    putprop(tmp_data 
		(txt->justify) 
		'JUSTIFY
	    ) 
	    (frame_info[upperCase((txt->text))] = tmp_data)
	) 
	putprop(frame_info["DATE"] date 
	    'VALUE
	) 
	putprop(frame_info["USER"] user_name 
	    'VALUE
	) frame_info
    )
)
procedure(TBX_PCBLIBPLOT_Get_Styles() 
    let((style_loc file_list style_name) 
	(style_loc = makeTable("style_loc_table" nil)) 
	(file_list = TBX_UTIL_Search_Config("*.style" "pcblibplot" t ?includeWorkDir t)) 
	when(file_list 
	    foreach(fn file_list 
		(style_name = cadr((axlDMFileParts fn))) 
		(style_loc[lowerCase(style_name)] = fn)
	    )
	) style_loc
    )
)
procedure(TBX_PCBLIBPLOT_Get_Symbol_Info(dra_name) 
    let((sym_extents size_x size_y master_unit master_unit_str
	    xy_ll xy_ur data mech_pads conn_pads
	    mech_pin_cnt conn_pin_cnt place_bound_layer y_data_by_x x_data_by_y
	    pin_x pin_y pin_x_str pin_y_str distance
	    distance_str pitch_y pitch_x pitch_y_values pitch_x_values
	    oversize x_ll_ov y_ll_ov x_ur_ov y_ur_ov
	    x_list x_list_len y_list y_list_len pack_height
	    na_value sym
	) 
	(na_value = (tbx_pcblibplot_global->naValue)) 
	(mech_pads = list()) 
	(conn_pads = list()) 
	(y_data_by_x = makeTable("y_data_by_x_table" nil))
	(x_data_by_y = makeTable("x_data_by_y_table" nil)) 
	(pitch_x = makeTable("pitch_x_table" nil)) 
	(pitch_y = makeTable("pitch_y_table" nil)) 
	(data = ncons(nil)) 
	(master_unit = car((tbx_pcblibplot_global->masterUnits)))
	(master_unit_str = cadr((tbx_pcblibplot_global->masterUnits))) 
	TBX_PCBLIBPLOT_Vis_Mode("sym_info") 
	(axlSetFindFilter ?enabled 
	    (tbx_pcblibplot_global->findFilterMerge) ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll)
	(sym_extents = (axlDBGetExtents 
		(axlGetSelSet) t
	    )) 
	(oversize = (axlMKSConvert "0.15 MM" 
		car((axlDBGetDesignUnits))
	    )) 
	if(sym_extents then 
	    putprop(data sym_extents 
		'BBOX
	    ) 
	    (xy_ll = car(sym_extents)) 
	    (xy_ur = cadr(sym_extents))
	    (x_ll_ov = (car(xy_ll) - oversize)) 
	    (y_ll_ov = (cadr(xy_ll) - oversize)) 
	    (x_ur_ov = (car(xy_ur) + oversize)) 
	    (y_ur_ov = (cadr(xy_ur) + oversize)) 
	    putprop(data 
		list((x_ll_ov:y_ll_ov) 
		    (x_ur_ov:y_ur_ov)
		) 
		'SELWINDOW
	    )
	    (size_x = (car(xy_ur) - car(xy_ll))) 
	    (size_y = (cadr(xy_ur) - cadr(xy_ll))) 
	    (size_x = (axlMKSConvert size_x master_unit)) 
	    (size_y = (axlMKSConvert size_y master_unit)) 
	    putprop(data 
		sprintf(nil "%.3f x %.3f %s (visible)" size_x size_y master_unit_str) 
		'SIZE
	    )
	    else 
	    putprop(data na_value 
		'SIZE
	    )
	) 
	(sym = car((axlSelectByName "SYMTYPE" dra_name))) 
	putprop(data 
	    (sym->name) 
	    'NAME
	)
	(mech_pin_cnt = 0) 
	(conn_pin_cnt = 0) 
	when((sym->pins) 
	    foreach(pin 
		(sym->pins) 
		if((pin->isMech) then 
		    ++mech_pin_cnt 
		    unless(member((pin->name) mech_pads) 
			(mech_pads = cons((pin->name) mech_pads))
		    ) else
		    ++conn_pin_cnt 
		    (pin_x = car((pin->xy))) 
		    (pin_x_str = (axlGeo2Str pin_x)) 
		    (pin_y = cadr((pin->xy))) 
		    (pin_y_str = (axlGeo2Str pin_y))
		    (y_data_by_x[pin_x_str] = cons(pin_y 
			    y_data_by_x[pin_x_str]
			)) 
		    (x_data_by_y[pin_y_str] = cons(pin_x 
			    x_data_by_y[pin_y_str]
			)) 
		    unless(member((pin->name) conn_pads) 
			(conn_pads = cons((pin->name) conn_pads))
		    )
		)
	    )
	) 
	(conn_pads = sort(conn_pads nil)) 
	(mech_pads = sort(mech_pads nil))
	if((length(conn_pads) > 0) then 
	    putprop(data 
		buildString(conn_pads "|") 
		'CONNECT_PADS
	    ) else 
	    putprop(data na_value 
		'CONNECT_PADS
	    )
	) 
	if((length(mech_pads) > 0) then 
	    putprop(data 
		buildString(mech_pads "|") 
		'MECH_PADS
	    ) else 
	    putprop(data na_value 
		'MECH_PADS
	    )
	) 
	putprop(data 
	    sprintf(nil "%d" conn_pin_cnt) 
	    'CONNECT_PINS
	) 
	putprop(data 
	    sprintf(nil "%d" mech_pin_cnt) 
	    'MECH_PINS
	) 
	foreach(xstr y_data_by_x 
	    (y_list = sort(y_data_by_x[xstr] 
		    'lessp
		)) 
	    (y_list_len = length(y_list)) 
	    cond(((y_list_len > 2) 
		    for(i 0 
			(y_list_len - 2) 
			(distance = (nth((i + 1) y_list) - 
				nth(i y_list))) 
			(distance_str = (axlGeo2Str distance))
			(pitch_y[distance_str] = t)
		    )
		) 
		((y_list_len == 2) 
		    (distance = (cadr(y_list) - car(y_list))) 
		    (distance_str = (axlGeo2Str distance)) 
		    (pitch_y[distance_str] = t)
		) 
		(t t)
	    )
	)
	(pitch_y_values = list()) 
	foreach(key pitch_y 
	    (pitch_y_values = cons(atof(key) pitch_y_values))
	) 
	(pitch_y_values = sort(pitch_y_values 
		'lessp
	    )) 
	cond(((length(pitch_y_values) >= 1) 
		putprop(data 
		    sprintf(nil "%.3f %s" 
			(axlMKSConvert 
			    car(pitch_y_values) master_unit
			) master_unit_str
		    ) 
		    'YPITCH
		)
	    ) 
	    (t 
		putprop(data na_value 
		    'YPITCH
		)
	    )
	) 
	foreach(ystr x_data_by_y 
	    (x_list = sort(x_data_by_y[ystr] 
		    'lessp
		)) 
	    (x_list_len = length(x_list)) 
	    cond(((x_list_len > 2) 
		    for(i 0 
			(x_list_len - 2) 
			(distance = (nth((i + 1) x_list) - 
				nth(i x_list))) 
			(distance_str = (axlGeo2Str distance))
			(pitch_x[distance_str] = t)
		    )
		) 
		((x_list_len == 2) 
		    (distance = (cadr(x_list) - car(x_list))) 
		    (distance_str = (axlGeo2Str distance)) 
		    (pitch_x[distance_str] = t)
		) 
		(t t)
	    )
	)
	(pitch_x_values = list()) 
	foreach(key pitch_x 
	    (pitch_x_values = cons(atof(key) pitch_x_values))
	) 
	(pitch_x_values = sort(pitch_x_values 
		'lessp
	    )) 
	cond(((length(pitch_x_values) >= 1) 
		putprop(data 
		    sprintf(nil "%.3f %s" 
			(axlMKSConvert 
			    car(pitch_x_values) master_unit
			) master_unit_str
		    ) 
		    'XPITCH
		)
	    ) 
	    (t 
		putprop(data na_value 
		    'XPITCH
		)
	    )
	) 
	(pack_height = na_value)
	(place_bound_layer = strcat((axlMapClassName "PACKAGE GEOMETRY") "/PLACE_BOUND_TOP")) 
	foreach(ch 
	    (sym->children) 
	    when((((ch->objType) == "shape") && ((ch->layer) == place_bound_layer)) 
		(xy_ll = car((ch->bBox))) 
		(xy_ur = cadr((ch->bBox))) 
		(size_x = (car(xy_ur) - car(xy_ll))) 
		(size_y = (cadr(xy_ur) - cadr(xy_ll)))
		(size_x = (axlMKSConvert size_x master_unit)) 
		(size_y = (axlMKSConvert size_y master_unit)) 
		putprop(data 
		    sprintf(nil "%.3f x %.3f %s (PlaceBound)" size_x size_y master_unit_str) 
		    'PLACEBOUND_SIZE
		) 
		if(((ch->prop)->PACKAGE_HEIGHT_MAX) then 
		    (pack_height = ((ch->prop)->PACKAGE_HEIGHT_MAX)) else 
		    (pack_height = na_value)
		)
	    )
	) 
	unless(get(data 
		'PLACEBOUND_SIZE
	    ) 
	    putprop(data na_value 
		'PLACEBOUND_SIZE
	    )
	) 
	putprop(data pack_height 
	    'HEIGHT
	) data
    )
)
procedure(TBX_PCBLIBPLOT_Init() 
    let((notes_layer tmp_layer_shape tmp_layer_pad tmp_layer_hole na_value
	    units units_str plot_dir orgvis run_dir
	) 
	TBX_UTIL_Change_Working_Dir() 
	(orgvis = (axlVisibleGet)) 
	(run_dir = strcat(getWorkingDir() "/toolbox.run")) 
	unless(isDir(run_dir) 
	    createDir(run_dir)
	)
	when(axlGetVariable("ads_sdplot") 
	    (plot_dir = axlGetVariable("ads_sdplot")) 
	    unless(isDir(plot_dir) 
		printf("Info: Creating directory %L\n" plot_dir) 
		createDir(plot_dir)
	    )
	) 
	(notes_layer = "MANUFACTURING/DOC_NOTES") 
	(tmp_layer_shape = "MANUFACTURING/TBX_TMP_SHAPE") 
	(tmp_layer_pad = "MANUFACTURING/TBX_TMP_PAD") 
	(tmp_layer_hole = "MANUFACTURING/TBX_TMP_HOLE")
	(na_value = "NA") 
	foreach(lyr 
	    list(notes_layer tmp_layer_shape tmp_layer_pad tmp_layer_hole) 
	    unless((axlIsLayer lyr) 
		(axlLayerCreateNonConductor lyr)
	    )
	) 
	TBX_PCBLIBPLOT_Set_Default_Color(notes_layer) 
	(units = lowerCase(car((axlDBGetDesignUnits)))) 
	case(units 
	    ("millimeters" 
		(units_str = "MM")
	    ) 
	    ("mils" 
		(units_str = "MIL")
	    ) 
	    ("microns" 
		(units_str = "UM")
	    ) 
	    ("inches" 
		(units_str = "IN")
	    )
	    ("centimeters" 
		(units_str = "CM")
	    ) 
	    (t 
		(units_str = car((axlDBGetDesignUnits)))
	    )
	)
	unless(boundp('tbx_pcblibplot_global) 
	    iliDefstruct('defstruct(tbx_pcblibplot_global_struct labelBlockSmall labelBlockRegular labelBlockLarge notesLayer
			printLayers symbolView lineSpace tmpLayer maxScale
			scaleValues findFilterMerge sourceLayersMerge docLayersMerge issuesFound
			naValue version orgVis envSettings masterUnits
			styleLoc licCheck printerParam runDir
		    )
	    ) 
	    defvar(tbx_pcblibplot_global nil)
	) 
	if(!tbx_pcblibplot_global then 
	    (tbx_pcblibplot_global = (make_tbx_pcblibplot_global_struct ?labelBlockSmall nil ?labelBlockRegular nil
		    ?labelBlockLarge nil ?lineSpace nil ?maxScale
		    nil ?scaleValues nil ?notesLayer notes_layer
		    ?tmpLayer 
		    list(nil 
			'shape tmp_layer_shape 
			'pad tmp_layer_pad
			'hole tmp_layer_hole
		    ) ?printLayers nil ?symbolView
		    nil ?findFilterMerge nil ?sourceLayersMerge nil
		    ?docLayersMerge nil ?naValue na_value ?styleLoc
		    nil ?issuesFound 
		    list(nil nil) ?version nil
		    ?orgVis orgvis ?envSettings 
		    ncons(nil) ?masterUnits
		    list(units units_str) ?licCheck nil ?printerParam nil
		    ?runDir run_dir
		)) else 
	    (tbx_pcblibplot_global->labelBlockSmall = nil)
	    (tbx_pcblibplot_global->labelBlockRegular = nil) 
	    (tbx_pcblibplot_global->labelBlockLarge = nil) 
	    (tbx_pcblibplot_global->lineSpace = nil) 
	    (tbx_pcblibplot_global->maxScale = nil) 
	    (tbx_pcblibplot_global->scaleValues = nil)
	    (tbx_pcblibplot_global->notesLayer = notes_layer) 
	    (tbx_pcblibplot_global->tmpLayer = list(nil 
		    'shape tmp_layer_shape 
		    'pad tmp_layer_pad
		    'hole tmp_layer_hole
		)) 
	    (tbx_pcblibplot_global->printLayers = nil) 
	    (tbx_pcblibplot_global->symbolView = nil) 
	    (tbx_pcblibplot_global->findFilterMerge = nil)
	    (tbx_pcblibplot_global->sourceLayersMerge = nil) 
	    (tbx_pcblibplot_global->docLayersMerge = nil) 
	    (tbx_pcblibplot_global->naValue = na_value) 
	    (tbx_pcblibplot_global->styleLoc = nil) 
	    (tbx_pcblibplot_global->issuesFound = list(nil nil))
	    (tbx_pcblibplot_global->version = nil) 
	    (tbx_pcblibplot_global->orgVis = orgvis) 
	    (tbx_pcblibplot_global->envSettings = ncons(nil)) 
	    (tbx_pcblibplot_global->masterUnits = list(units units_str)) 
	    (tbx_pcblibplot_global->licCheck = nil)
	    (tbx_pcblibplot_global->printerParam = nil) 
	    (tbx_pcblibplot_global->runDir = run_dir)
	)
    )
)
procedure((TBX_PCBLIBPLOT_Main \@optional arg) 
    let((lic_check_result FORM_FILE VERSION_STR FC_FEATURE FC_VERSION
	    SUB_VERSION fid msg_str brd_list cmd
	    style_list printer_param
	) 
	(FC_FEATURE = "PCBLIBPLOT") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "PCB Library Plot %s (C)2017" FC_VERSION))
	(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
	cond(((arg && (lowerCase(arg) == "info")) 
		printf("PCB Library Plot information:\n") 
		printf("Command line arguments:\n") 
		printf("  version : Prints the current version of the module\n")
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (lic_check_result 
		TBX_PCBLIBPLOT_Init() 
		(tbx_pcblibplot_global->version = VERSION_STR) 
		(printer_param = TBX_PLOTBASE_Check_System_Environment()) 
		when((((printer_param->platform) == "wint") && (printer_param->driver) && (printer_param->command)) 
		    if(TBX_PCBLIBPLOT_Get_Canvas_Areas("default") then 
			(tbx_pcblibplot_global->printerParam = printer_param) 
			(tbx_pcblibplot_global->styleLoc = TBX_PCBLIBPLOT_Get_Styles()) 
			(axlVisibleSet 
			    (tbx_pcblibplot_global->orgVis)
			)
			(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "pcblibplot_main")) 
			(fid = (axlFormCreate 
				gensym("tbxpcblibplotmain") FORM_FILE 
				'(e outer) 
				'TBX_PCBLIBPLOT_Main_Callback
				t
			    )) 
			TBX_FORM_Init_Header(fid nil lic_check_result VERSION_STR) 
			(axlFormSetField fid "info_default" t) 
			(axlFormSetField fid "printer_name" 
			    ((tbx_pcblibplot_global->printerParam)->driver)
			)
			(style_list = TBX_UTIL_Get_Hash_Keys((tbx_pcblibplot_global->styleLoc) t)) 
			(axlFormBuildPopup fid "style" style_list) 
			(axlFormSetField fid "style" 
			    car(style_list)
			) 
			(axlFormDisplay fid) 
			TBX_FORM_Delete(lic_check_result FORM_FILE)
			else 
			(axlVisibleSet 
			    (tbx_pcblibplot_global->orgVis)
			) 
			(axlVisibleUpdate t) 
			(msg_str = "Error: No template information found in this database.") 
			(msg_str = strcat(msg_str "Must have polygons defined on DRAWING FORMAT/PCBLIBPLOT_SYS\n"))
			(msg_str = strcat(msg_str "Do you want to open an example database from getting_started instead?\n\n")) 
			(msg_str = strcat(msg_str "(Data will be copied to your working dir)\n")) 
			when((axlUIYesNo msg_str nil 
				'no
			    ) 
			    (brd_list = TBX_PCBLIBPLOT_Copy_Examples()) 
			    when(brd_list 
				(axlSaveDesign) 
				(cmd = sprintf(nil "opencd %L" 
					car(brd_list)
				    )) 
				(axlShell cmd)
			    )
			)
		    )
		)
	    )
	)
    )
)
procedure(TBX_PCBLIBPLOT_Main_Callback(form_handle) 
    let((mode pdf_file canvas_areas dra_dir style_name
	    plot_profile_data file_name
	) 
	case((form_handle->curField) 
	    ("done" 
		(axlFormClose form_handle) 
		TBX_PCBLIBPLOT_Cleanup() 
		(axlVisibleSet 
		    (tbx_pcblibplot_global->orgVis)
		) 
		(axlVisibleUpdate t)
	    ) 
	    ("plot_setup" 
		TBX_PLOTBASE_Print_Setup_Main((tbx_pcblibplot_global->licCheck) 
		    (tbx_pcblibplot_global->version) "pcblibplot"
		)
	    ) 
	    ("run" 
		if((axlOKToProceed) then 
		    (file_name = strcat((tbx_pcblibplot_global->runDir) "/pcblibplot.profile")) 
		    (plot_profile_data = TBX_PLOTBASE_Read_Profile(file_name)) 
		    if(plot_profile_data then 
			(dra_dir = (axlDMDirectoryBrowse "." t ?title "Pick a symbol library")) 
			when(dra_dir 
			    if((axlFormGetField form_handle "info_detailed") then 
				(mode = "long") else 
				(mode = "default")
			    ) 
			    (canvas_areas = TBX_PCBLIBPLOT_Get_Canvas_Areas(mode)) 
			    TBX_PCBLIBPLOT_Change_Env("set") 
			    (style_name = (axlFormGetField form_handle "style"))
			    TBX_PCBLIBPLOT_Read_Config((tbx_pcblibplot_global->styleLoc)[style_name]) 
			    (pdf_file = TBX_PCBLIBPLOT_Run(dra_dir mode canvas_areas 
				    (tbx_pcblibplot_global->printerParam) plot_profile_data
				)) 
			    TBX_PCBLIBPLOT_Change_Env("reset") 
			    TBX_PCBLIBPLOT_Show_Issues() 
			    when((isFile(pdf_file) && !axlGetVariable("TBX_PV_REGRESSION")) 
				(axlPdfView pdf_file)
			    )
			) else
			(axlUIConfirm "Specify plot settings first!")
		    )
		    else 
		    (axlUIWPrint form_handle "E - Finish current command first!")
		)
	    ) 
	    ("myhelp" 
		(axlShell "tbx help pcblibplot")
	    )
	)
    )
)
procedure(TBX_PCBLIBPLOT_Process_Footprint(dra_name dra_type cv_area_list plot_mode) 
    let((origin result sym_info param_list dest_xy
	    scale pass scale_info syms_no_instance syms_no_data
	) 
	(syms_no_instance = car((tbx_pcblibplot_global->issuesFound))) 
	(syms_no_data = cadr((tbx_pcblibplot_global->issuesFound))) 
	(origin = (0:0)) 
	(axlPurgePadstacks 
	    'padstacks nil
	)
	(axlPurgePadstacks 
	    'via t
	) 
	(result = (axlDBCreateSymbol 
		list(dra_name dra_type) origin
	    )) 
	if(result then 
	    (pass = t) 
	    (sym_info = TBX_PCBLIBPLOT_Get_Symbol_Info(dra_name)) 
	    if(((sym_info->BBOX) && !(axlGeoPointsEqual 
			    car((sym_info->BBOX)) 
			    cadr((sym_info->BBOX))
			)) then 
		(param_list = TBX_PCBLIBPLOT_Calculate_Param((sym_info->BBOX) 
			car(cv_area_list) plot_mode
		    )) 
		(dest_xy = car(param_list)) 
		(scale = cadr(param_list))
		if((scale >= 1.0) then 
		    (scale_info = sprintf(nil "%d:1" 
			    round(scale)
			)) else 
		    (scale_info = sprintf(nil "1:%d" 
			    round((1 / scale))
			))
		) 
		(sym_info->SCALE = scale_info) 
		TBX_PCBLIBPLOT_Generate_Text_Info(sym_info cv_area_list plot_mode) 
		TBX_PCBLIBPLOT_Process_Footprint_Views(sym_info 
		    (tbx_pcblibplot_global->symbolView) dest_xy scale
		) else
		(pass = nil) 
		(syms_no_data = cons(dra_name syms_no_data))
	    )
	    (axlDeleteObject 
		(axlSelectByName "SYMTYPE" dra_name)
	    ) 
	    (axlDBRefreshId nil) else 
	    (pass = nil) 
	    (syms_no_instance = cons(dra_name syms_no_instance))
	) 
	(tbx_pcblibplot_global->issuesFound = list(syms_no_instance syms_no_data)) pass
    )
)
procedure(TBX_PCBLIBPLOT_Process_Footprint_Views(symInfo config dest_xy scale) 
    let((shape_list shape_poly_data pad_list pad_poly_data hole_poly_data
	    combi_data tmp_data other_list viewConfig shape_style
	    pad_style hole_style plt_file
	) 
	foreach(vn config 
	    (viewConfig = config[vn]) 
	    (axlVisibleUpdate t) 
	    (axlClearSelSet)
	    if(isCallable('axlDeleteByLayer) then 
		(axlDeleteByLayer 
		    list(((tbx_pcblibplot_global->tmpLayer)->shape) 
			((tbx_pcblibplot_global->tmpLayer)->pad) 
			((tbx_pcblibplot_global->tmpLayer)->hole)
		    ) 
		    'fixed
		) else 
		TBX_UTIL_Clean_Layer(list(((tbx_pcblibplot_global->tmpLayer)->shape) 
			((tbx_pcblibplot_global->tmpLayer)->pad) 
			((tbx_pcblibplot_global->tmpLayer)->hole)
		    )
		)
	    ) 
	    (axlVisibleDesign nil) 
	    foreach(lyr 
		(viewConfig->sourceLayers) 
		(axlVisibleLayer lyr t)
	    ) 
	    (shape_style = TBX_PCBLIBPLOT_Get_Fill_Style((viewConfig->shapeStyle) scale)) 
	    (pad_style = TBX_PCBLIBPLOT_Get_Fill_Style((viewConfig->padStyle) scale))
	    (hole_style = TBX_PCBLIBPLOT_Get_Fill_Style((viewConfig->holeStyle) scale)) 
	    (axlClearSelSet) 
	    (axlDBControl 
		'activeLayer 
		(viewConfig->docLayer)
	    ) 
	    (axlSetFindFilter ?enabled 
		(viewConfig->findFilter) ?onButtons 
		list("all")
	    ) 
	    (axlSingleSelectBox 
		(symInfo->SELWINDOW)
	    )
	    (shape_list = setof(x 
		    (axlGetSelSet) 
		    (((x->objType) == "shape") || ((x->objType) == "polygon"))
		)) 
	    (pad_list = setof(x 
		    (axlGetSelSet) 
		    (((x->objType) == "pin") || ((x->objType) == "via"))
		)) 
	    when((shape_list && (shape_style != "NA") && member("SHAPES" 
			(viewConfig->findFilter)
		    )) 
		(axlSubSelectObject shape_list) 
		(shape_poly_data = tconc(nil nil)) 
		foreach(shp shape_list 
		    lconc(shape_poly_data 
			(axlPolyFromDB shp ?holes t)
		    )
		) 
		(shape_poly_data = cdar(shape_poly_data))
		foreach(pl shape_poly_data 
		    (axlDBCreateShape pl shape_style 
			((tbx_pcblibplot_global->tmpLayer)->shape)
		    )
		)
	    ) 
	    when((pad_list && (pad_style != "NA") && (member("PINS" 
			    (viewConfig->findFilter)
			) || member("VIAS" 
			    (viewConfig->findFilter)
			))) 
		when((hole_style == "NA") 
		    (axlSubSelectObject pad_list)
		) 
		(pad_poly_data = tconc(nil nil)) 
		foreach(pd pad_list 
		    lconc(pad_poly_data 
			TBX_DBCORE_Poly_From_Padstack(pd)
		    )
		) 
		(pad_poly_data = cdar(pad_poly_data))
		foreach(pl pad_poly_data 
		    (axlDBCreateShape pl pad_style 
			((tbx_pcblibplot_global->tmpLayer)->pad)
		    )
		)
	    ) 
	    when((pad_list && (hole_style != "NA") && (member("PINS" 
			    (viewConfig->findFilter)
			) || member("VIAS" 
			    (viewConfig->findFilter)
			))) 
		(axlSubSelectObject pad_list) 
		(hole_poly_data = tconc(nil nil)) 
		foreach(pd pad_list 
		    lconc(hole_poly_data 
			TBX_DBCORE_Poly_From_Drill(pd)
		    )
		) 
		(hole_poly_data = cdar(hole_poly_data))
		foreach(pl hole_poly_data 
		    (axlDBCreateShape pl hole_style 
			((tbx_pcblibplot_global->tmpLayer)->hole)
		    )
		)
	    )
	    (other_list = (axlGetSelSet)) 
	    (axlVisibleDesign nil) 
	    (axlVisibleLayer 
		((tbx_pcblibplot_global->tmpLayer)->shape) t
	    ) 
	    (axlVisibleLayer 
		((tbx_pcblibplot_global->tmpLayer)->pad) t
	    ) 
	    (axlVisibleLayer 
		((tbx_pcblibplot_global->tmpLayer)->hole) t
	    )
	    (axlClearSelSet) 
	    (axlSetFindFilter ?enabled 
		list("noall" "boundary_shapes" "shapes" "lines" "clines") ?onButtons 
		list("all")
	    ) 
	    (axlSingleSelectBox 
		(symInfo->SELWINDOW)
	    ) 
	    (tmp_data = (axlGetSelSet)) 
	    (combi_data = nconc(other_list tmp_data))
	    foreach(lyr 
		(viewConfig->sourceLayers) 
		(axlVisibleLayer lyr t)
	    ) 
	    (axlVisibleUpdate t) 
	    when(combi_data 
		(plt_file = strcat((tbx_pcblibplot_global->runDir) "/tmp.plt")) 
		(axlDBControl 
		    'activeLayer 
		    (viewConfig->docLayer)
		) 
		(axlDetailSave plt_file 
		    (symInfo->BBOX) combi_data
		) 
		(axlDetailLoad plt_file dest_xy scale 0
		    nil
		)
	    ) t
	)
    )
)
procedure(TBX_PCBLIBPLOT_Read_Config(config_file) 
    let((port data new_config view_name valid_filter_objects
	    pad_style_type hole_style_type
	) 
	(tbx_pcblibplot_global->labelBlockSmall = "3") 
	(tbx_pcblibplot_global->labelBlockRegular = "6") 
	(tbx_pcblibplot_global->labelBlockLarge = "9") 
	(tbx_pcblibplot_global->lineSpace = (axlMKSConvert "1.0 MM" 
		car((axlDBGetDesignUnits))
	    ))
	(tbx_pcblibplot_global->maxScale = 5) 
	(tbx_pcblibplot_global->scaleValues = list(0.001 0.002 0.005 0.01 0.02
		0.05 0.1 0.2 0.5 1.0
		2.0 5.0 10.0 20.0 50.0
		100.0
	    )) 
	(tbx_pcblibplot_global->printLayers = list("MANUFACTURING/DOC_LABEL" "MANUFACTURING/DOC_HOLES" 
		(tbx_pcblibplot_global->notesLayer) "MANUFACTURING/DOC_GEOM" "MANUFACTURING/DOC_ETCH"
		"DRAWING FORMAT/OUTLINE" "DRAWING FORMAT/TITLE_BLOCK"
	    )) 
	(tbx_pcblibplot_global->symbolView = makeTable("symbol_view_table" nil)) 
	((tbx_pcblibplot_global->symbolView)["HOLES"] = list(nil 
		'findFilter 
		list("PINS" "VIAS") 
		'docLayer "MANUFACTURING/DOC_HOLES"
		'sourceLayers 
		list("PIN/TOP" "VIA CLASS/TOP") 
		'shapeStyle "NA" 
		'padStyle
		"IGNORE" 
		'holeStyle "FILL"
	    ))
	((tbx_pcblibplot_global->symbolView)["ETCH"] = list(nil 
		'findFilter 
		list("PINS" "VIAS" "CLINES" "LINES" "SHAPES"
		    "TEXT"
		) 
		'docLayer "MANUFACTURING/DOC_ETCH"
		'sourceLayers 
		list("ETCH/TOP" "PIN/TOP" "VIA CLASS/TOP" "ETCH/BOTTOM" "PIN/BOTTOM"
		    "VIA CLASS/BOTTOM"
		) 
		'shapeStyle "FILL" 
		'padStyle
		"FILL" 
		'holeStyle "NA"
	    )) 
	((tbx_pcblibplot_global->symbolView)["GEOM"] = list(nil 
		'findFilter 
		list("LINES" "SHAPES" "TEXT") 
		'docLayer "MANUFACTURING/DOC_GEOM"
		'sourceLayers 
		list("PACKAGE GEOMETRY/ASSEMBLY_TOP" "PACKAGE GEOMETRY/ASSEMBLY_BOTTOM") 
		'shapeStyle "NA" 
		'padStyle
		"FILL" 
		'holeStyle "NA"
	    )) 
	((tbx_pcblibplot_global->symbolView)["LABEL"] = list(nil 
		'findFilter 
		list("TEXT") 
		'docLayer "MANUFACTURING/DOC_LABEL"
		'sourceLayers 
		list("REF DES/ASSEMBLY_TOP" "REF DES/ASSEMBLY_BOTTOM") 
		'shapeStyle "NA" 
		'padStyle
		"NA" 
		'holeStyle "NA"
	    )) 
	if(((type(config_file) == 'string) && isFile(config_file)) then 
	    (port = infile(config_file)) 
	    (data = car(lineread(port))) 
	    close(port)
	    else 
	    printf("Warning: Configuration file %L does not exist.\n" config_file)
	) 
	if(data then 
	    foreach(entry data 
		caseq(car(entry) 
		    (labelBlockSmall 
			(tbx_pcblibplot_global->labelBlockSmall = sprintf(nil "%d" 
				cadr(entry)
			    ))
		    ) 
		    (labelBlockRegular 
			(tbx_pcblibplot_global->labelBlockRegular = sprintf(nil "%d" 
				cadr(entry)
			    ))
		    ) 
		    (labelBlockLarge 
			(tbx_pcblibplot_global->labelBlockLarge = sprintf(nil "%d" 
				cadr(entry)
			    ))
		    ) 
		    (lineSpace 
			(tbx_pcblibplot_global->lineSpace = (axlMKSConvert 
				cadr(entry) 
				car((axlDBGetDesignUnits))
			    ))
		    )
		    (maxScale 
			(tbx_pcblibplot_global->maxScale = cadr(entry))
		    ) 
		    (scaleValues 
			(tbx_pcblibplot_global->scaleValues = cdr(entry))
		    ) 
		    (printLayers 
			(tbx_pcblibplot_global->printLayers = cdr(entry))
		    ) 
		    (symbolView 
			unless(new_config 
			    (tbx_pcblibplot_global->symbolView = makeTable("symbol_view_table" nil)) 
			    (new_config = t)
			) 
			(view_name = upperCase(cadr(entry))) 
			((tbx_pcblibplot_global->symbolView)[view_name] = ncons(nil)) 
			foreach(itm 
			    cddr(entry) 
			    caseq(car(itm) 
				(findFilter 
				    (valid_filter_objects = setof(x 
					    cdr(itm) 
					    member(upperCase(x) 
						list("PINS" "VIAS" "CLINES" "LINES" "SHAPES"
						    "TEXT"
						)
					    )
					)) 
				    (valid_filter_objects = cons("DYNTHEMALS" valid_filter_objects)) 
				    (valid_filter_objects = cons("BOUNDARY_SHAPES" valid_filter_objects)) 
				    (valid_filter_objects = cons("NOALL" valid_filter_objects))
				    ((tbx_pcblibplot_global->symbolView)[view_name]->findFilter = valid_filter_objects)
				) 
				(docLayer 
				    ((tbx_pcblibplot_global->symbolView)[view_name]->docLayer = cadr(itm))
				) 
				(sourceLayers 
				    ((tbx_pcblibplot_global->symbolView)[view_name]->sourceLayers = cdr(itm))
				) 
				(drawStyle 
				    foreach(dsr 
					cdr(itm) 
					caseq(car(dsr) 
					    (shapes 
						((tbx_pcblibplot_global->symbolView)[view_name]->shapeStyle = cdr(dsr))
					    ) 
					    (pads 
						((tbx_pcblibplot_global->symbolView)[view_name]->padStyle = cdr(dsr))
					    ) 
					    (holes 
						((tbx_pcblibplot_global->symbolView)[view_name]->holeStyle = cdr(dsr))
					    )
					)
				    )
				)
			    )
			)
			(hole_style_type = car(((tbx_pcblibplot_global->symbolView)[view_name]->holeStyle))) 
			when(hole_style_type 
			    (hole_style_type = upperCase(hole_style_type))
			) 
			when((hole_style_type && ((hole_style_type == "FILL") || (hole_style_type == "UNFILL") || rexMatchp("^HATCH" hole_style_type))) 
			    (pad_style_type = car(((tbx_pcblibplot_global->symbolView)[view_name]->padStyle))) 
			    when(pad_style_type 
				(pad_style_type = upperCase(pad_style_type))
			    ) 
			    when((pad_style_type && ((pad_style_type == "FILL") || rexMatchp("^HATCH" pad_style_type))) 
				printf("Warning: Symbol view %s, if hole style is defined, pad style can be only \"ignore\"  or \"unfill\" within the same view. You can define a separate view for pad  display. Setting pad style to \"unfill\"\n" view_name) 
				((tbx_pcblibplot_global->symbolView)[view_name]->padStyle = list("UNFILL"))
			    )
			)
		    )
		)
	    ) 
	    foreach(vn 
		(tbx_pcblibplot_global->symbolView) 
		unless((axlIsLayer 
			((tbx_pcblibplot_global->symbolView)[vn]->docLayer)
		    ) 
		    (axlLayerCreateNonConductor 
			((tbx_pcblibplot_global->symbolView)[vn]->docLayer)
		    ) 
		    TBX_PCBLIBPLOT_Set_Default_Color(((tbx_pcblibplot_global->symbolView)[vn]->docLayer))
		)
	    ) 
	    (tbx_pcblibplot_global->findFilterMerge = nil)
	    foreach(vn 
		(tbx_pcblibplot_global->symbolView) 
		foreach(ffo 
		    ((tbx_pcblibplot_global->symbolView)[vn]->findFilter) 
		    when(member(upperCase(ffo) 
			    list("PINS" "VIAS" "CLINES" "LINES" "SHAPES"
				"TEXT"
			    )
			) 
			unless(member(upperCase(ffo) 
				(tbx_pcblibplot_global->findFilterMerge)
			    ) 
			    (tbx_pcblibplot_global->findFilterMerge = cons(upperCase(ffo) 
				    (tbx_pcblibplot_global->findFilterMerge)
				))
			)
		    )
		)
	    ) 
	    (tbx_pcblibplot_global->findFilterMerge = nconc(list("NOALL" "DYNTHEMALS" "BOUNDARY_SHAPES") 
		    (tbx_pcblibplot_global->findFilterMerge)
		)) 
	    (tbx_pcblibplot_global->sourceLayersMerge = nil) 
	    foreach(vn 
		(tbx_pcblibplot_global->symbolView) 
		foreach(lyr 
		    ((tbx_pcblibplot_global->symbolView)[vn]->sourceLayers) 
		    unless(member(lyr 
			    (tbx_pcblibplot_global->sourceLayersMerge)
			) 
			(tbx_pcblibplot_global->sourceLayersMerge = cons(lyr 
				(tbx_pcblibplot_global->sourceLayersMerge)
			    ))
		    )
		)
	    ) 
	    (tbx_pcblibplot_global->docLayersMerge = nil)
	    foreach(vn 
		(tbx_pcblibplot_global->symbolView) 
		unless(member(((tbx_pcblibplot_global->symbolView)[vn]->docLayer) 
			(tbx_pcblibplot_global->docLayersMerge)
		    ) 
		    (tbx_pcblibplot_global->docLayersMerge = cons(((tbx_pcblibplot_global->symbolView)[vn]->docLayer) 
			    (tbx_pcblibplot_global->docLayersMerge)
			))
		)
	    ) 
	    foreach(lyr 
		(tbx_pcblibplot_global->docLayersMerge) 
		unless(member(lyr 
			(tbx_pcblibplot_global->printLayers)
		    ) 
		    (tbx_pcblibplot_global->printLayers = cons(lyr 
			    (tbx_pcblibplot_global->printLayers)
			))
		)
	    ) 
	    unless(member((tbx_pcblibplot_global->notesLayer) 
		    (tbx_pcblibplot_global->printLayers)
		) 
		(tbx_pcblibplot_global->printLayers = cons((tbx_pcblibplot_global->notesLayer) 
			(tbx_pcblibplot_global->printLayers)
		    ))
	    ) else 
	    (axlUIConfirm 
		sprintf(nil "Warning:  Cannot read data from %L\nContinue with tool defaults\n" config_file)
	    )
	)
	t
    )
)
procedure(TBX_PCBLIBPLOT_Run(symbol_dir plot_mode canvas_areas printer_param plot_profile_data) 
    let((footprint_type arr ps_index ps_file ps_list
	    pdf_file footprint_name fp_id canvas_cnt mod_value
	    max_valid_cnt result lib_name frame_info file_list
	    psm_list bsm_list script_file
	) 
	(frame_info = TBX_PCBLIBPLOT_Get_Frame_Info()) 
	TBX_PCBLIBPLOT_Vis_Mode("print") 
	(ps_index = 0) 
	(ps_list = list())
	(symbol_dir = (axlOSSlash symbol_dir)) 
	(lib_name = car(reverse(parseString(symbol_dir "/")))) 
	when(frame_info["LIBNAME"] 
	    putprop(frame_info["LIBNAME"] lib_name 
		'VALUE
	    )
	) 
	(pdf_file = strcat("./" lib_name ".pdf")) 
	(psm_list = rexMatchList("[.][pP][sS][mM]$" 
		getDirFiles(symbol_dir)
	    ))
	(bsm_list = rexMatchList("[.][bB][sS][mM]$" 
		getDirFiles(symbol_dir)
	    )) 
	(file_list = nconc(psm_list bsm_list)) 
	(file_list = sort(file_list nil)) 
	foreach(lyr 
	    (tbx_pcblibplot_global->printLayers) 
	    unless((axlIsLayer lyr) 
		(axlLayerCreateNonConductor lyr)
	    )
	) 
	(canvas_cnt = length(canvas_areas))
	(fp_id = 0) 
	TBX_UTIL_Set_Layer_Priority((tbx_pcblibplot_global->printLayers) t) 
	(script_file = strcat((tbx_pcblibplot_global->runDir) "/pcblibplot_setup.scr")) 
	TBX_PLOTBASE_Print_Setup_Execute(plot_profile_data script_file) 
	unless(axlGetVariable("FLW_DEBUG") 
	    deleteFile(script_file)
	)
	(max_valid_cnt = length(file_list)) 
	foreach(fn file_list 
	    ++fp_id 
	    (arr = (axlDMFileParts fn)) 
	    (footprint_name = cadr(arr))
	    case(lowerCase(nth(3 arr)) 
		("psm" 
		    (footprint_type = "package")
		) 
		("bsm" 
		    (footprint_type = "mechanical")
		) 
		(t 
		    (footprint_type = "package")
		)
	    ) 
	    (mod_value = mod(fp_id canvas_cnt)) 
	    (result = TBX_PCBLIBPLOT_Process_Footprint(footprint_name footprint_type 
		    nth(mod((fp_id - 1) canvas_cnt) canvas_areas) plot_mode
		)) 
	    if(result then 
		when((zerop(mod_value) || (!zerop(mod_value) && (fp_id == max_valid_cnt))) 
		    ++ps_index 
		    when(frame_info["PGNR"] 
			putprop(frame_info["PGNR"] 
			    sprintf(nil "%d" ps_index) 
			    'VALUE
			)
		    ) 
		    TBX_PCBLIBPLOT_Write_Frame_Text(frame_info) 
		    TBX_PCBLIBPLOT_Vis_Mode("print")
		    (axlDBControl 
			'activeLayer 
			car((tbx_pcblibplot_global->printLayers))
		    ) 
		    (axlVisibleUpdate t) 
		    (axlDBRefreshId nil) 
		    (ps_file = sprintf(nil "plot%03d.ps" ps_index)) 
		    (script_file = strcat((tbx_pcblibplot_global->runDir) "/pcblibplot_run.scr"))
		    TBX_PLOTBASE_Generate_Postscript(nil ps_file 
			(printer_param->driver) plot_profile_data script_file
		    ) 
		    unless(axlGetVariable("FLW_DEBUG") 
			deleteFile(script_file)
		    ) 
		    if(axlGetVariable("ads_sdplot") then 
			(ps_list = cons(strcat(axlGetVariable("ads_sdplot") "/" ps_file) ps_list)) else 
			(ps_list = cons(ps_file ps_list))
		    ) 
		    (axlClearSelSet) 
		    (axlVisibleUpdate t)
		    if(isCallable('axlDeleteByLayer) then 
			(axlDeleteByLayer 
			    cons((tbx_pcblibplot_global->notesLayer) 
				(tbx_pcblibplot_global->docLayersMerge)
			    ) 
			    'fixed
			) else 
			TBX_UTIL_Clean_Layer(cons((tbx_pcblibplot_global->notesLayer) 
				(tbx_pcblibplot_global->docLayersMerge)
			    )
			)
		    )
		) else 
		--fp_id
		--max_valid_cnt
	    )
	) 
	(axlVisibleUpdate t) 
	(ps_list = reverse(ps_list)) 
	when((length(ps_list) > 0) 
	    if(axlGetVariable("FLW_DEBUG") then 
		TBX_PLOTBASE_Generate_PDF(ps_list pdf_file printer_param t t) else 
		TBX_PLOTBASE_Generate_PDF(ps_list pdf_file printer_param t nil)
	    )
	)
	unless(axlGetVariable("FLW_DEBUG") 
	    foreach(fn ps_list 
		deleteFile(fn)
	    )
	) pdf_file
    )
)
procedure(TBX_PCBLIBPLOT_Set_Default_Color(layer_name) 
    let((bg_color default_color color_id color_rgb color_param
	    prm
	) 
	(bg_color = (axlColorGet 
		'background
	    )) 
	cond(((zerop(car(bg_color)) && zerop(cadr(bg_color)) && zerop(caddr(bg_color))) 
		(default_color = list(0 0 255))
	    ) 
	    (((car(bg_color) == 255) && (cadr(bg_color) == 255) && (caddr(bg_color) == 255)) 
		(default_color = list(0 0 0))
	    ) 
	    (t 
		(default_color = list(255 0 0))
	    )
	) 
	(color_param = makeTable("color_param_table_data" nil)) 
	(color_param["MANUFACTURING/DOC_ETCH"] = list(160 
		list(255 0 0)
	    ))
	(color_param["MANUFACTURING/DOC_GEOM"] = list(161 
		list(88 88 88)
	    )) 
	(color_param["MANUFACTURING/DOC_LABEL"] = list(162 
		list(0 0 255)
	    )) 
	(color_param["MANUFACTURING/DOC_HOLES"] = list(163 
		list(0 255 0)
	    )) 
	(color_param["MANUFACTURING/DOC_MASK"] = list(164 
		list(255 0 255)
	    )) 
	(color_param["MANUFACTURING/DOC_PASTE"] = list(165 
		list(90 0 138)
	    ))
	(color_param["MANUFACTURING/DOC_NOTES"] = list(166 default_color)) 
	(layer_name = upperCase(layer_name)) 
	if(color_param[layer_name] then 
	    (color_id = car(color_param[layer_name])) 
	    (color_rgb = cadr(color_param[layer_name])) else
	    (color_id = 166) 
	    (color_rgb = default_color)
	) 
	(axlColorSet color_id color_rgb) 
	(prm = (axlLayerGet layer_name))
	(prm->color = color_id) 
	(axlLayerSet prm) t
    )
)
procedure(TBX_PCBLIBPLOT_Show_Issues() 
    let((port log_file syms_no_instance syms_no_data) 
	(syms_no_instance = car((tbx_pcblibplot_global->issuesFound))) 
	(syms_no_data = cadr((tbx_pcblibplot_global->issuesFound))) 
	if(((length(syms_no_instance) > 0) || (length(syms_no_data) > 0)) then 
	    (log_file = strcat((tbx_pcblibplot_global->runDir) "/pcblibplot_issues.txt")) 
	    (port = outfile(log_file "w")) 
	    when((length(syms_no_instance) > 0) 
		fprintf(port "Symbols which could no be placed into the layout:\n") 
		fprintf(port "-------------------------------------------------\n") 
		foreach(dra syms_no_instance 
		    fprintf(port "   %s\n" dra)
		) 
		fprintf(port "\n")
		fprintf(port "   Possible reasons:\n") 
		fprintf(port "      - Symbol does not fit into drawing extents.\n") 
		fprintf(port "      - Padstacks could not be resolved.\n")
	    )
	    when((length(syms_no_data) > 0) 
		fprintf(port "\n") 
		fprintf(port "\n") 
		fprintf(port "Symbols without data on visible layers:\n") 
		fprintf(port "-------------------------------------------------\n")
		foreach(dra syms_no_data 
		    fprintf(port "   %s\n" dra)
		)
	    ) 
	    close(port) 
	    if(!isFile(log_file) then 
		(axlUIConfirm 
		    sprintf(nil "Unable to open file %L" log_file)
		) else 
		(axlUIViewFileCreate log_file " PCB Library Plot Issues - Log" nil)
	    ) else 
	    printf("PCB Library Plot finished. No problems occurred\n")
	) t
    )
)
procedure(TBX_PCBLIBPLOT_Vis_Mode(view) 
    let((vis_layers) 
	case(lowerCase(view) 
	    ("all_on" 
		(axlVisibleDesign t)
	    ) 
	    ("all_off" 
		(axlVisibleDesign nil)
	    ) 
	    ("print" 
		(axlVisibleDesign nil) 
		(vis_layers = (tbx_pcblibplot_global->printLayers))
	    ) 
	    ("sym_info" 
		(axlVisibleDesign nil) 
		(vis_layers = (tbx_pcblibplot_global->sourceLayersMerge))
	    )
	    ("canvas_boundary" 
		(vis_layers = list("DRAWING FORMAT/PCBLIBPLOT_SYS")) 
		(axlVisibleDesign nil)
	    ) 
	    ("frame_info" 
		(vis_layers = list("DRAWING FORMAT/PCBLIBPLOT_SYS")) 
		(axlVisibleDesign nil)
	    ) 
	    (t 
		printf("Unknown visibility mode: %L\n" view)
	    )
	) 
	foreach(lyr vis_layers 
	    when((axlIsLayer lyr) 
		(axlVisibleLayer lyr t)
	    )
	) 
	(axlVisibleUpdate nil)
    )
)
procedure(TBX_PCBLIBPLOT_Write_Frame_Text(info) 
    let((txt_layer txt_orient) 
	(txt_layer = (tbx_pcblibplot_global->notesLayer)) 
	foreach(key info 
	    when(get(info[key] 
		    'VALUE
		) 
		(txt_orient = (make_axlTextOrientation ?textBlock 
			get(info[key] 
			    'BLOCK
			) ?rotation 
			get(info[key] 
			    'ROTATION
			)
			?mirrored 
			get(info[key] 
			    'MIRROR
			) ?justify 
			get(info[key] 
			    'JUSTIFY
			)
		    )) 
		(axlDBCreateText 
		    get(info[key] 
			'VALUE
		    ) 
		    get(info[key] 
			'XY
		    ) txt_orient txt_layer
		    nil
		)
	    )
	)
    )
)
procedure(TBX_PLOTBASE_Check_System_Environment(\@optional 
	(verbose 
	    't
	)
    ) 
    let((result printer_param command_exe msg cfg_file
	    platform
	) 
	(result = t) 
	(cfg_file = car(TBX_UTIL_Search_Config("pdfprint.cfg" nil nil))) 
	(platform = lowerCase(cdsPlat())) 
	(result = ncons(nil))
	if(((platform != "wint") || axlGetVariable("FLW_EMULATE_LINUX")) then 
	    when(verbose 
		(axlUIConfirm "Warning: PDF generation currently supported only on Windows.")
	    ) 
	    when(axlGetVariable("FLW_EMULATE_LINUX") 
		(platform = "lnx86") 
		printf("**** Message driven by debug environment variable FLW_EMULATE_LINUX ****\n")
	    ) else
	    (printer_param = TBX_PLOTBASE_Get_Printer_Info()) 
	    when((printer_param->command) 
		(command_exe = car((parseQuotedString 
			    (printer_param->command)
			)
		    )) 
		if(isFile(command_exe) then 
		    (result = printer_param) else 
		    (msg = sprintf(nil "Warning: Executable %L does not exist. Please check configuration in %L\nOpen user guide?" command_exe cfg_file))
		    when((verbose && (axlUIYesNo msg nil 
				'no
			    )) 
			(axlShell "tbx help batchplot")
		    )
		)
	    )
	) 
	(result->platform = platform) result
    )
)
procedure(TBX_PLOTBASE_Check_View_Data(view_name) 
    let((run_dir script_file port ok_data) 
	(run_dir = strcat(getWorkingDir() "/toolbox.run")) 
	unless(isDir(run_dir) 
	    (run_dir = getWorkingDir())
	) 
	(ok_data = t) 
	(script_file = strcat(run_dir "/plotbase_view.scr"))
	(port = outfile(script_file "w")) 
	fprintf(port "scriptmode +i +n\n") 
	fprintf(port "setwindow pcb\n") 
	fprintf(port "trapsize 0\n") 
	fprintf(port "setwindow form.vf_vis\n")
	fprintf(port "FORM vf_vis colorview_list %s\n" view_name) 
	fprintf(port "setwindow pcb\n") 
	close(port) 
	(axlShell 
	    sprintf(nil "replay %L" script_file)
	) 
	(axlVisibleUpdate t)
	(axlSetFindFilter ?enabled 
	    list("noall" "clines" "lines" "shapes" "pins"
		"vias" "text" "figures"
	    ) ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	unless((axlGetSelSet) 
	    (ok_data = nil)
	) 
	(axlClearSelSet)
	ok_data
    )
)
procedure((TBX_PLOTBASE_Generate_PDF ps_list pdf_file printer_param \@optional
	ipc verbose
    ) 
    let((cmd_str port source_list_file dist_control_file file_list
	    abs_path batch_file cid line log_file
	    run_dir pdf_name ps_error
	) 
	(run_dir = strcat(getWorkingDir() "/toolbox.run")) 
	unless(isDir(run_dir) 
	    (run_dir = getWorkingDir())
	) 
	foreach(fn ps_list 
	    cond((!isFile(fn) 
		    printf("Error: File %L does not exist.\n" fn) 
		    (ps_error = t)
		) 
		(zerop(fileLength(fn)) 
		    printf("Error: File %L has zero bytes.\n" fn) 
		    (ps_error = t)
		) 
		(!isReadable(fn) 
		    printf("Error: Cannot read/access file %L.\n" fn) 
		    (ps_error = t)
		)
	    )
	) 
	if(ps_error then 
	    (axlUIConfirm "Errors occurred. For more details refer to messages in command window." 
		'error
	    ) else 
	    when(isFile(pdf_file) 
		deleteFile(pdf_file)
	    )
	    (pdf_file = (axlOSSlash 
		    simplifyFilename(pdf_file)
		)) 
	    (pdf_name = lowerCase(cadr((axlDMFileParts pdf_file)))) 
	    if(((printer_param->configName) == "ACROBAT") then 
		(dist_control_file = strcat(run_dir "/pdf_dist_control" pdf_name ".txt")) 
		(port = outfile(dist_control_file "w")) 
		fprintf(port "/prun { /mysave save def   %% Performs a save before running the PS file\n")
		fprintf(port "       dup = flush            %% Shows name of PS file being run\n") 
		fprintf(port "       RunFile                %% Calls built in Distiller procedure\n") 
		fprintf(port "       clear cleardictstack   %% Cleans up after PS file\n") 
		fprintf(port "       mysave restore         %% Restores save level\n") 
		fprintf(port "} def\n")
		foreach(fn ps_list 
		    (abs_path = (axlOSSlash 
			    simplifyFilename(fn)
			)) 
		    fprintf(port "(%s)  prun\n" abs_path)
		) 
		close(port) 
		(cmd_str = (printer_param->command)) 
		(cmd_str = sprintf(nil "%s  %L  %L" cmd_str pdf_file dist_control_file)) 
		(file_list = cons(dist_control_file ps_list))
		else 
		(source_list_file = strcat(run_dir "/pdf_gs_control_" pdf_name ".txt")) 
		(port = outfile(source_list_file "w")) 
		foreach(fn ps_list 
		    (abs_path = (axlOSSlash 
			    simplifyFilename(fn)
			)) 
		    (abs_path = sprintf(nil "%L" abs_path)) 
		    fprintf(port "%s\n" abs_path)
		) 
		close(port)
		(cmd_str = (printer_param->command)) 
		(cmd_str = sprintf(nil "%s -sOutputFile=%L @%L" cmd_str pdf_file source_list_file)) 
		(file_list = cons(source_list_file ps_list))
	    ) 
	    when(axlGetVariable("FLW_DEBUG") 
		printf("PDF system command is: %s\n" cmd_str)
	    ) 
	    if(ipc then 
		(batch_file = strcat(run_dir "/pdf_gen_" pdf_name ".bat")) 
		(log_file = strcat(run_dir "/pdf_gen_" pdf_name ".log")) 
		(port = outfile(batch_file "w"))
		fprintf(port "cd /D %L\n" 
		    getWorkingDir()
		) 
		fprintf(port "%s\n" cmd_str) 
		close(port) 
		(file_list = cons(batch_file file_list)) 
		when(batch_file 
		    (cid = ipcBeginProcess(sprintf(nil "%L" batch_file))) 
		    ipcWaitForProcess(cid) 
		    (line = t) 
		    (port = outfile(log_file "w"))
		    while(line 
			(line = ipcReadProcess(cid 1)) 
			if(line then 
			    when(verbose 
				printf("%s" line)
			    ) 
			    fprintf(port "%s" line) else
			    printf("Make PDF command finished. Refer to log file %L\n" log_file)
			)
		    ) 
		    close(port)
		)
		else 
		sh(cmd_str)
	    )
	    if(isFile(pdf_file) then 
		printf("Note: File %s  has been generated\n" pdf_file) else 
		printf("Warning: PDF file %s not generated\n" pdf_file)
	    ) 
	    unless(axlGetVariable("FLW_DEBUG") 
		foreach(fn file_list 
		    when(isFile(fn) 
			deleteFile(fn)
		    )
		)
	    )
	)
    )
)
procedure(TBX_PLOTBASE_Generate_Postscript(view_name ps_file printer_name profile_data script_file
	\@optional 
	(script_replay 
	    't
	) 
	(write_mode "w")
    ) 
    let((port result) 
	if(view_name then 
	    (result = TBX_PLOTBASE_Check_View_Data(view_name)) else 
	    (result = t)
	) 
	if(result then 
	    (port = outfile(script_file write_mode)) 
	    if(port then 
		fprintf(port "scriptmode +i\n") 
		fprintf(port "\n") 
		fprintf(port "setwindow pcb\n")
		fprintf(port "trapsize 0\n") 
		fprintf(port "\n") 
		when(view_name 
		    fprintf(port "setwindow form.vf_vis\n") 
		    fprintf(port "FORM vf_vis colorview_list %s\n" view_name) 
		    fprintf(port "\n")
		) 
		fprintf(port "plotwint initialize %L\n" printer_name) 
		if((get(profile_data 
			    'printPortrait
			) && (upperCase(get(profile_data 
				    'printPortrait
				)
			    ) == "YES")) then 
		    fprintf(port "plotwint orientation 1\n") else 
		    fprintf(port "plotwint orientation 2\n")
		)
		fprintf(port "plotwint papername %s\n" 
		    get(profile_data 
			'paperName
		    )
		) 
		fprintf(port "plotwint scale 100\n") 
		fprintf(port "plotwint copies 1\n") 
		fprintf(port "plotwint defaultsource 15\n") 
		fprintf(port "plotwint printquality %s\n" 
		    get(profile_data 
			'printQuality
		    )
		)
		fprintf(port "plotwint color 2\n") 
		fprintf(port "plotwint plottofile \"%s\"\n" ps_file) 
		fprintf(port "plotwint execute\n") 
		close(port) 
		when(isFile(script_file) 
		    (result = script_file) 
		    when(script_replay 
			(axlShell 
			    sprintf(nil "replay %L" script_file)
			)
		    )
		)
		else 
		printf("Error: Could not write file %L, Check permissions.\n" script_file)
	    ) else
	    printf("Warning: View %L does not contain data, skipping...\n" view_name)
	) result
    )
)
procedure(TBX_PLOTBASE_Get_Printer_Info() 
    let((setup_file cfg inport line active_config
	    arr printer_param printer_name key arg_list
	    cmd_exe path_list ok_match cmd_exe_path test_str
	) 
	(setup_file = car(TBX_UTIL_Search_Config("pdfprint.cfg" nil nil))) 
	(cfg = makeTable("cfg_table" nil)) 
	when((setup_file && isReadable(setup_file)) 
	    printf("Reading printer configuration from %L\n" setup_file) 
	    (inport = infile(setup_file)) 
	    while((line = _gets(inport)) 
		cond(((rexMatchp("^ *#" line) || 
			    rexMatchp("^[ \t]*\n*$" line)) t
		    ) 
		    (rexMatchp("^ *ACTIVE_CONFIG" 
			    upperCase(line)
			) 
			(active_config = cadr((parseQuotedString 
				    upperCase(line)
				)
			    ))
		    ) 
		    (rexMatchp("^ *.*_PRINTER" 
			    upperCase(line)
			) 
			(arr = (parseQuotedString 
				upperCase(line)
			    )) 
			(key = car(arr)) 
			(printer_name = cadr((parseQuotedString line))) 
			(cfg[key] = printer_name)
		    ) 
		    (rexMatchp("^ *.*_COMMAND" 
			    upperCase(line)
			) 
			(arr = parseString(line)) 
			(key = upperCase(car(arr))) 
			(cfg[key] = buildString(cdr(arr) " "))
		    )
		)
	    ) 
	    close(inport)
	) 
	when((active_config && cfg[strcat(active_config "_PRINTER")] && 
		cfg[strcat(active_config "_COMMAND")]) 
	    (printer_param = ncons(nil)) 
	    (printer_param->configName = active_config) 
	    (printer_param->driver = cfg[strcat(active_config "_PRINTER")]) 
	    (printer_param->command = cfg[strcat(active_config "_COMMAND")])
	)
	when((printer_param->command) 
	    (arg_list = (parseQuotedString 
		    (printer_param->command)
		)) 
	    (cmd_exe = car(arg_list)) 
	    unless(car((axlDMFileParts cmd_exe)) 
		(path_list = parseString(getShellEnvVar("PATH") ";")) 
		(path_list = mapcar(lambda((p) 
			    (axlOSSlash p)
			) path_list
		    )) 
		foreach(pt path_list 
		    (test_str = strcat(pt "/" cmd_exe)) 
		    when((!ok_match && isFile(test_str)) 
			(ok_match = t) 
			(cmd_exe_path = test_str) 
			when(axlGetVariable("FLW_DEBUG") 
			    printf("Resolving path for %L to %L\n" cmd_exe cmd_exe_path)
			)
		    )
		) 
		if(cmd_exe_path then 
		    (arg_list = cdr(arg_list)) 
		    (arg_list = cons(sprintf(nil "%L" cmd_exe_path) arg_list)) 
		    (printer_param->command = buildString(arg_list " "))
		    else 
		    (axlUIConfirm 
			sprintf(nil "Cannot locate %s in any directory specified by PATH variable. Check pdfprint.cfg" cmd_exe) 
			'error
		    )
		)
	    )
	) printer_param
    )
)
procedure(TBX_PLOTBASE_Print_Setup_Callback(form_handle) 
    let((profile_name_fullpath profile_name) 
	case((form_handle->curField) 
	    ("done" 
		when((form_handle->profileName) 
		    TBX_PLOTBASE_Print_Setup_Save(form_handle 
			(form_handle->profileName)
		    )
		) 
		(axlFormClose form_handle)
	    ) 
	    ("fpPlotFitToPage" 
		when((form_handle->curValue) 
		    (axlFormSetField form_handle "fpPlotAutoCenter" t)
		)
	    ) 
	    ("fpPlotAutoCenter" 
		when((axlFormGetField form_handle "fpPlotFitToPage") 
		    (axlFormSetField form_handle "fpPlotAutoCenter" t)
		)
	    ) 
	    ("fpPlotNonVectorText" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "fpPlotNonVectorTextFont" t) 
		    (axlFormSetFieldEditable form_handle "fpPlotNonVectorTextFontHeight" t) 
		    (axlFormSetFieldEditable form_handle "fpPlotNonVectorTextFontWidth" t)
		    else 
		    (axlFormSetFieldEditable form_handle "fpPlotNonVectorTextFont" nil) 
		    (axlFormSetFieldEditable form_handle "fpPlotNonVectorTextFontHeight" nil) 
		    (axlFormSetFieldEditable form_handle "fpPlotNonVectorTextFontWidth" nil)
		)
	    )
	    ("profile" 
		case((form_handle->curValue) 
		    ("save_as" 
			(profile_name = (axlEnterString ?prompts 
				list("Enter name of profile:")
			    )) 
			when(profile_name 
			    (profile_name = lowerCase(profile_name)) 
			    rexCompile("[.]profile$") 
			    (profile_name = rexReplace(profile_name "" 0)) 
			    TBX_PLOTBASE_Print_Setup_Save(form_handle profile_name)
			)
		    ) 
		    ("load_from" 
			(profile_name_fullpath = (axlDMFileBrowse nil nil ?optFilters "Plot profile (*.profile)|*.profile"
				?noSticky t
			    )) 
			when(profile_name_fullpath 
			    TBX_PLOTBASE_Print_Setup_Load(form_handle profile_name_fullpath)
			)
		    )
		)
	    ) 
	    ("my_help" 
		if(((form_handle->master) == "pcb_library_plot") then 
		    (axlShell "tbx help pcblibplot") else 
		    (axlShell "tbx help batchplot")
		)
	    )
	)
    )
)
procedure(TBX_PLOTBASE_Print_Setup_Check(config_data) 
    let((radio_buttons check_buttons invalid_flag value return_data
	    config_clean
	) 
	(config_clean = ncons(nil)) 
	(radio_buttons = list('fpPlotFitToPage 
		'fpPlotScaling 
		'fpPlotColor 
		'fpPlotBlackWhite 
		'fpPlotScreenContents
		'fpPlotSheetContents 
		'printPortrait 
		'printLandscape
	    )) 
	(check_buttons = list('fpPlotAutoCenter 
		'fpPlotMirror 
		'fpIPFVectorText 
		'fpPlotNonVectorText
	    )) 
	foreach(token 
	    (config_data->?) 
	    cond(((memq(token radio_buttons) || 
			memq(token check_buttons)) 
		    if((type(get(config_data token)) == 
			    'string) then 
			(value = upperCase(get(config_data token))) 
			if(((value == "YES") || (value == "NO")) then 
			    putprop(config_clean value token) else 
			    (invalid_flag = t)
			) else
			(invalid_flag = t)
		    )
		) 
		(((token == 'fpPlotScale) || (token == 'fpIPFVectorWidth)) 
		    if(((type(get(config_data token)) == 
				'fixnum) || (type(get(config_data token)) == 
				'flonum)) then 
			(value = get(config_data token)) 
			(value = sprintf(nil "%.2f" value)) 
			putprop(config_clean value token)
			else 
			(invalid_flag = t)
		    )
		) 
		(((token == 'fpPlotLineWeight) || (token == 'fpPlotNonVectorTextFontHeight) || (token == 'fpPlotNonVectorTextFontWidth) || (token == 'printQuality)) 
		    if(((type(get(config_data token)) == 
				'fixnum) || (type(get(config_data token)) == 
				'flonum)) then 
			(value = get(config_data token)) 
			(value = sprintf(nil "%d" value)) 
			putprop(config_clean value token)
			else 
			(invalid_flag = t)
		    )
		) 
		((token == 'fpPlotWindowsMargins) 
		    if((type(get(config_data token)) == 
			    'string) then 
			(value = upperCase(get(config_data token))) 
			(value = (axlMKSConvert value 
				car((axlDBGetDesignUnits))
			    )) 
			if(value then 
			    (value = sprintf(nil "%.2f" value)) 
			    putprop(config_clean value token) else
			    (invalid_flag = t)
			)
			else 
			(invalid_flag = t)
		    )
		) 
		(((token == 'paperName) || (token == 'fpPlotNonVectorTextFont)) 
		    if((type(get(config_data token)) == 
			    'string) then 
			(value = get(config_data token)) 
			when((token == 'paperName) 
			    (value = upperCase(sprintf(nil "%L" value)))
			) 
			putprop(config_clean value token)
			else 
			(invalid_flag = t)
		    )
		)
		(t 
		    printf("Warning: Unknown token %L, skipping..\n" token)
		)
	    )
	)
	if(invalid_flag then 
	    (return_data = nil) else 
	    (return_data = config_clean)
	) return_data
    )
)
procedure(TBX_PLOTBASE_Print_Setup_Execute(profile_data script_file \@optional 
	(script_replay 
	    't
	)
    ) 
    let((port sym_list_gen sym_list_win result) 
	(sym_list_gen = list('fpPlotFitToPage 
		'fpPlotScaling 
		'fpPlotScale 
		'fpPlotLineWeight 
		'fpPlotAutoCenter
		'fpPlotMirror 
		'fpPlotColor 
		'fpPlotBlackWhite 
		'fpPlotScreenContents 
		'fpPlotSheetContents
		'fpIPFVectorText 
		'fpIPFVectorWidth
	    )) 
	(sym_list_win = list('fpPlotNonVectorText 
		'fpPlotNonVectorTextFont 
		'fpPlotNonVectorTextFontHeight 
		'fpPlotNonVectorTextFontWidth 
		'fpPlotWindowsMargins
	    )) 
	(port = outfile(script_file "w")) 
	if(port then 
	    fprintf(port "scriptmode +i\n") 
	    fprintf(port "\n") 
	    fprintf(port "setwindow pcb\n")
	    fprintf(port "trapsize 0\n") 
	    fprintf(port "\n") 
	    fprintf(port "generaledit\n") 
	    fprintf(port "plot setup\n") 
	    fprintf(port "setwindow form.fpfileplotsetup\n")
	    fprintf(port "FORM fpfileplotsetup general\n") 
	    foreach(sym sym_list_gen 
		when(get(profile_data sym) 
		    fprintf(port "FORM fpfileplotsetup %s %s\n" 
			lowerCase(symbolToString(sym)) 
			get(profile_data sym)
		    )
		)
	    ) 
	    fprintf(port "FORM fpfileplotsetup windows\n") 
	    foreach(sym sym_list_win 
		when(get(profile_data sym) 
		    fprintf(port "FORM fpfileplotsetup %s %s\n" 
			lowerCase(symbolToString(sym)) 
			get(profile_data sym)
		    )
		)
	    ) 
	    fprintf(port "FORM fpfileplotsetup done\n")
	    close(port) 
	    when(isFile(script_file) 
		(result = script_file) 
		when(script_replay 
		    (axlShell 
			sprintf(nil "replay %L" script_file)
		    )
		)
	    ) else 
	    printf("Error: Could not write file %L, Check permissions.\n" script_file) 
	    (result = nil)
	)
	result
    )
)
procedure(TBX_PLOTBASE_Print_Setup_Load(form_handle file_name) 
    let((data check_list string_list float_list int_list
	    value
	) 
	(check_list = list('fpPlotFitToPage 
		'fpPlotScaling 
		'fpPlotColor 
		'fpPlotBlackWhite 
		'fpPlotScreenContents
		'fpPlotSheetContents 
		'printPortrait 
		'printLandscape 
		'fpPlotAutoCenter 
		'fpPlotMirror
		'fpIPFVectorText 
		'fpPlotNonVectorText
	    )) 
	(float_list = list('fpPlotScale 
		'fpIPFVectorWidth 
		'fpPlotWindowsMargins
	    )) 
	(int_list = list('fpPlotLineWeight 
		'fpPlotNonVectorTextFontHeight 
		'fpPlotNonVectorTextFontWidth 
		'printQuality
	    )) 
	(string_list = list('paperName 
		'fpPlotNonVectorTextFont
	    ))
	(data = TBX_PLOTBASE_Read_Profile(file_name)) 
	if(data then 
	    foreach(token 
		(data->?) 
		cond((memq(token check_list) 
			when((get(data token) == "YES") 
			    (axlFormSetField form_handle 
				symbolToString(token) t
			    )
			) 
			when((get(data token) == "NO") 
			    (axlFormSetField form_handle 
				symbolToString(token) nil
			    )
			)
		    ) 
		    (memq(token string_list) 
			(value = get(data token)) 
			rexCompile("\"") 
			(value = rexReplace(value "" 0)) 
			(axlFormSetField form_handle 
			    symbolToString(token) value
			)
		    ) 
		    (memq(token int_list) 
			(axlFormSetField form_handle 
			    symbolToString(token) 
			    atoi(get(data token))
			)
		    ) 
		    (memq(token float_list) 
			(axlFormSetField form_handle 
			    symbolToString(token) 
			    atof(get(data token))
			)
		    )
		)
	    ) else 
	    printf("Warning: Invalid data in profile %L" file_name)
	)
    )
)
procedure((TBX_PLOTBASE_Print_Setup_Main lcheck vstr \@optional profile_name) 
    let((FORM_FILE fid profile_path run_dir) 
	(FORM_FILE = TBX_FORM_Get_Name(lcheck "printsetup_main")) 
	(fid = (axlFormCreate 
		gensym("tbxprintsetupmain") FORM_FILE 
		'(e outer) 
		'TBX_PLOTBASE_Print_Setup_Callback
		t
	    )) 
	(run_dir = strcat(getWorkingDir() "/toolbox.run")) 
	unless(isDir(run_dir) 
	    (run_dir = getWorkingDir())
	)
	putprop(fid run_dir 
	    'runDir
	) 
	when(profile_name 
	    (profile_path = strcat(run_dir "/" profile_name ".profile")) 
	    putprop(fid profile_name 
		'profileName
	    ) 
	    putprop(fid "pcb_library_plot" 
		'master
	    )
	) 
	if((profile_name && isFile(profile_path)) then 
	    TBX_PLOTBASE_Print_Setup_Load(fid profile_path) else 
	    (axlFormSetField fid "fpPlotFitToPage" t)
	    (axlFormSetField fid "fpPlotScale" 1.0) 
	    (axlFormSetField fid "fpPlotLineWeight" 1) 
	    (axlFormSetField fid "fpPlotAutoCenter" t) 
	    (axlFormSetField fid "fpPlotMirror" nil) 
	    (axlFormSetField fid "fpPlotBlackWhite" t)
	    (axlFormSetField fid "fpPlotSheetContents" t) 
	    (axlFormSetField fid "fpIPFVectorText" nil) 
	    (axlFormSetField fid "fpIPFVectorWidth" 0.0) 
	    (axlFormSetField fid "fpPlotNonVectorText" nil) 
	    (axlFormSetFieldEditable fid "fpPlotNonVectorTextFont" nil)
	    (axlFormSetFieldEditable fid "fpViewAvailableFonts" nil) 
	    (axlFormSetFieldEditable fid "fpPlotNonVectorTextFontHeight" nil) 
	    (axlFormSetFieldEditable fid "fpPlotNonVectorTextFontWidth" nil) 
	    (axlFormSetField fid "fpPlotNonVectorTextFont" "Courier") 
	    (axlFormSetField fid "fpPlotNonVectorTextFontHeight" 100)
	    (axlFormSetField fid "fpPlotNonVectorTextFontWidth" 100) 
	    (axlFormSetField fid "fpPlotWindowsMargins" 
		(axlMKSConvert "250 MILS" 
		    car((axlDBGetDesignUnits))
		)
	    ) 
	    (axlFormSetField fid "paperName" "A3") 
	    (axlFormSetField fid "printQuality" 600) 
	    (axlFormSetField fid "printLandscape" t)
	) 
	when(profile_name 
	    (axlFormSetFieldEditable fid "profile" nil)
	) 
	TBX_FORM_Init_Header(fid "Licensed for " lcheck vstr)
	(axlFormDisplay fid) 
	TBX_FORM_Delete(lcheck FORM_FILE) t
    )
)
procedure(TBX_PLOTBASE_Print_Setup_Save(form_handle profile_name) 
    let((port margin_width file_name) 
	(file_name = strcat(get(form_handle 
		    'runDir
		) "/" profile_name ".profile"
	    )) 
	(port = outfile(file_name "w")) 
	fprintf(port "(\n") 
	if((axlFormGetField form_handle "fpPlotFitToPage") then 
	    fprintf(port "   ( fpPlotFitToPage %L )\n" "YES") else 
	    fprintf(port "   ( fpPlotScaling %L )\n" "YES")
	)
	fprintf(port "   ( fpPlotScale %.2f )\n" 
	    (axlFormGetField form_handle "fpPlotScale")
	) 
	fprintf(port "   ( fpPlotLineWeight %d )\n" 
	    (axlFormGetField form_handle "fpPlotLineWeight")
	) 
	if((axlFormGetField form_handle "fpPlotAutoCenter") then 
	    fprintf(port "   ( fpPlotAutoCenter %L )\n" "YES") else 
	    fprintf(port "   ( fpPlotAutoCenter %L )\n" "NO")
	) 
	if((axlFormGetField form_handle "fpPlotMirror") then 
	    fprintf(port "   ( fpPlotMirror %L )\n" "YES") else 
	    fprintf(port "   ( fpPlotMirror %L )\n" "NO")
	) 
	if((axlFormGetField form_handle "fpPlotColor") then 
	    fprintf(port "   ( fpPlotColor %L )\n" "YES") else 
	    fprintf(port "   ( fpPlotBlackWhite %L )\n" "YES")
	)
	if((axlFormGetField form_handle "fpPlotScreenContents") then 
	    fprintf(port "   ( fpPlotScreenContents %L )\n" "YES") else 
	    fprintf(port "   ( fpPlotSheetContents %L )\n" "YES")
	) 
	if((axlFormGetField form_handle "fpIPFVectorText") then 
	    fprintf(port "   ( fpIPFVectorText %L )\n" "YES") else 
	    fprintf(port "   ( fpIPFVectorText %L )\n" "NO")
	) 
	fprintf(port "   ( fpIPFVectorWidth %.2f )\n" 
	    (axlFormGetField form_handle "fpIPFVectorWidth")
	) 
	if((axlFormGetField form_handle "fpPlotNonVectorText") then 
	    fprintf(port "   ( fpPlotNonVectorText %L )\n" "YES") else 
	    fprintf(port "   ( fpPlotNonVectorText %L )\n" "NO")
	) 
	fprintf(port "   ( fpPlotNonVectorTextFont %L )\n" 
	    (axlFormGetField form_handle "fpPlotNonVectorTextFont")
	)
	fprintf(port "   ( fpPlotNonVectorTextFontHeight %d )\n" 
	    (axlFormGetField form_handle "fpPlotNonVectorTextFontHeight")
	) 
	fprintf(port "   ( fpPlotNonVectorTextFontWidth %d )\n" 
	    (axlFormGetField form_handle "fpPlotNonVectorTextFontWidth")
	) 
	(margin_width = (axlFormGetField form_handle "fpPlotWindowsMargins")) 
	(margin_width = sprintf(nil "%.2f %s" margin_width 
		car((axlDBGetDesignUnits))
	    )) 
	fprintf(port "   ( fpPlotWindowsMargins %L )\n" margin_width)
	fprintf(port "   ( paperName %L )\n" 
	    (axlFormGetField form_handle "paperName")
	) 
	fprintf(port "   ( printQuality %d )\n" 
	    (axlFormGetField form_handle "printQuality")
	) 
	if((axlFormGetField form_handle "printPortrait") then 
	    fprintf(port "   ( printPortrait %L )\n" "YES") else 
	    fprintf(port "   ( printLandscape %L )\n" "YES")
	) 
	fprintf(port "  ; Please note: Tokens are case sensitive! You should not manually edit the file\n") 
	fprintf(port ")\n")
	close(port) 
	printf("Note: File %L has been written.\n" file_name) t
    )
)
procedure(TBX_PLOTBASE_Read_Profile(file_name) 
    let((port data configuration profile_data profile_name) 
	(profile_name = cadr((axlDMFileParts file_name))) 
	if(isFile(file_name) then 
	    (port = infile(file_name)) 
	    (data = car(lineread(port))) 
	    close(port)
	    if(data then 
		(configuration = ncons(nil)) 
		foreach(item data 
		    putprop(configuration 
			cadr(item) 
			car(item)
		    )
		) 
		(data = TBX_PLOTBASE_Print_Setup_Check(configuration))
		if(data then 
		    putprop(data profile_name 
			'name
		    ) 
		    (profile_data = data) else
		    printf("Warning: Invalid data in profile %L" file_name)
		) else 
		printf("Warning: Invalid data in profile %L" file_name)
	    ) else 
	    printf("Warning: File %L does not exist\n" file_name)
	) profile_data
    )
)
procedure(TBX_POLARGRID_Build_Dynamics(mode form_handle stack_data) 
    let((seg_info line_width param active_color) 
	(seg_info = TBX_POLARGRID_Get_Last_Seg_Info((car(stack_data)->path))) 
	if(seg_info then 
	    case(mode 
		("route" 
		    (line_width = (axlFormGetField form_handle "line_width")) 
		    TBX_POLARGRID_ROUTE_Set_Line_Lock(form_handle) 
		    (axlClearDynamics) 
		    (axlAddSimpleRbandDynamics 
			(seg_info->endPoint) "path" ?width line_width
			?color 
			(axlDBControl 
			    'activeLayer
			)
		    )
		) 
		("shape" 
		    (line_width = (axlFormGetField form_handle "pen_width")) 
		    (param = (axlLayerGet 
			    (axlDBControl 
				'activeLayer
			    )
			)) 
		    (active_color = (param->color)) 
		    (param = (axlLayerGet 
			    ((tbx_polargrid_data->sysLayer)->tmp)
			))
		    (param->color = active_color) 
		    (axlLayerSet param) 
		    (axlClearDynamics) 
		    (axlAddSimpleRbandDynamics 
			(seg_info->endPoint) "path" ?width line_width
			?color 
			(axlDBControl 
			    'activeLayer
			)
		    )
		)
	    ) else 
	    (axlClearDynamics)
	) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_POLARGRID_Cache_Param(form_handle application) 
    let((rec session_param) 
	(rec = strcat("polargrid|" application)) 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	case(application 
	    ("place" 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "place_only") 
		    stringToSymbol("place_only")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "place_and_spin") 
		    stringToSymbol("place_and_spin")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "spin_only") 
		    stringToSymbol("spin_only")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "rotation_type") 
		    stringToSymbol("rotation_type")
		)
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "angle_value") 
		    stringToSymbol("angle_value")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "symbol_origin") 
		    stringToSymbol("symbol_origin")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "symbol_center") 
		    stringToSymbol("symbol_center")
		)
	    ) 
	    ("route" 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "class_name") 
		    stringToSymbol("class_name")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "subclass_name") 
		    stringToSymbol("subclass_name")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "line_width") 
		    stringToSymbol("line_width")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "snap_connect_point") 
		    stringToSymbol("snap_connect_point")
		)
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "follow_contour") 
		    stringToSymbol("follow_contour")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "regular_style") 
		    stringToSymbol("regular_style")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "angular_mode") 
		    stringToSymbol("angular_mode")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "radial_mode") 
		    stringToSymbol("radial_mode")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "diagonal_mode") 
		    stringToSymbol("diagonal_mode")
		)
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "lock_mode") 
		    stringToSymbol("lock_mode")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "lock_angle") 
		    stringToSymbol("lock_angle")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "corner_label") 
		    stringToSymbol("corner_label")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "corner_size") 
		    stringToSymbol("corner_size")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "corner_mode") 
		    stringToSymbol("corner_mode")
		)
		putprop(session_param[rec] 
		    car((axlDBGetDesignUnits)) 
		    stringToSymbol("units")
		)
	    ) 
	    ("shape" 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "class_name") 
		    stringToSymbol("class_name")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "subclass_name") 
		    stringToSymbol("subclass_name")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "shape_type") 
		    stringToSymbol("shape_type")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "shape_net") 
		    stringToSymbol("shape_net")
		)
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "angular_mode") 
		    stringToSymbol("angular_mode")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "radial_mode") 
		    stringToSymbol("radial_mode")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "diagonal_mode") 
		    stringToSymbol("diagonal_mode")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "pen_width") 
		    stringToSymbol("pen_width")
		) 
		putprop(session_param[rec] 
		    car((axlDBGetDesignUnits)) 
		    stringToSymbol("units")
		)
	    ) 
	    ("void" 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "class_name") 
		    stringToSymbol("class_name")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "subclass_name") 
		    stringToSymbol("subclass_name")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "angular_mode") 
		    stringToSymbol("angular_mode")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "radial_mode") 
		    stringToSymbol("radial_mode")
		)
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "diagonal_mode") 
		    stringToSymbol("diagonal_mode")
		) 
		putprop(session_param[rec] 
		    (axlFormGetField form_handle "pen_width") 
		    stringToSymbol("pen_width")
		) 
		putprop(session_param[rec] 
		    car((axlDBGetDesignUnits)) 
		    stringToSymbol("units")
		)
	    )
	)
	t
    )
)
procedure(TBX_POLARGRID_Cleanup() 
    let((lay_prm orgvis) 
	(axlVisibleLayer 
	    ((tbx_polargrid_data->sysLayer)->tmp) t
	) 
	(axlDeleteByLayer 
	    ((tbx_polargrid_data->sysLayer)->tmp)
	) 
	(lay_prm = (axlLayerGet 
		((tbx_polargrid_data->sysLayer)->tmp)
	    )) 
	(axlDeleteObject lay_prm)
	(orgvis = (axlVisibleGet)) 
	(axlLayerPriorityRestoreAll) 
	(axlVisibleSet orgvis) 
	(axlVisibleUpdate t)
    )
)
procedure(TBX_POLARGRID_Construct_Contiguous_Path(pathStack line_width) 
    let((rpath rpath_cont id last_seg end_xy
	    center_xy clockwise
	) 
	(id = 0) 
	foreach(pe 
	    reverse(pathStack) 
	    (rpath = (pe->path)) 
	    if(zerop(id) then 
		(last_seg = (axlPathGetLastPathSeg rpath)) 
		(end_xy = (axlPathSegGetEndPoint last_seg)) 
		(rpath_cont = (axlPathStart 
			list(end_xy) line_width
		    ))
		else 
		foreach(rps 
		    (axlPathGetPathSegs rpath) 
		    (end_xy = (axlPathSegGetEndPoint rps)) 
		    if((axlPathSegGetArcCenter rps) then 
			(center_xy = (axlPathSegGetArcCenter rps)) 
			if((axlPathSegGetArcClockwise rps) then 
			    (clockwise = t) else 
			    (clockwise = nil)
			) 
			(rpath_cont = (axlPathArcCenter rpath_cont line_width end_xy clockwise
				center_xy
			    ))
			else 
			(rpath_cont = (axlPathLine rpath_cont line_width end_xy))
		    )
		)
	    ) 
	    ++id
	) rpath_cont
    )
)
procedure(TBX_POLARGRID_Create_Path(rpath width) 
    let((seg_list start_point clock_wise arc_center new_path
	    end_point
	) 
	(seg_list = (axlPathGetPathSegs rpath)) 
	(start_point = (axlPathSegGetEndPoint 
		car(seg_list)
	    )) 
	(new_path = (axlPathStart 
		list(start_point) width
	    )) 
	foreach(seg 
	    cdr(seg_list) 
	    (arc_center = (axlPathSegGetArcCenter seg)) 
	    (end_point = (axlPathSegGetEndPoint seg)) 
	    if(arc_center then 
		(clock_wise = (axlPathSegGetArcClockwise seg)) 
		(new_path = (axlPathArcCenter new_path width end_point clock_wise
			arc_center
		    )) else
		(new_path = (axlPathLine new_path width end_point))
	    )
	)
	new_path
    )
)
procedure(TBX_POLARGRID_Debug_FromTo(fromto_list) 
    let((rpath) 
	foreach(entry fromto_list 
	    (rpath = (axlPathStart 
		    list(car(entry) 
			cadr(entry)
		    ) 0.2
		)) 
	    (axlDBCreatePath rpath "DRAWING FORMAT/OUTLINE")
	) t
    )
)
procedure(TBX_POLARGRID_Determine_Path(mode form_handle cur_polargrid pt_xy snap_status
	stack_data
    ) 
    let((cur_angle last_angle cur_radius last_radius follow_contour
	    cw_direction path_data rpath line_width PI
	    next_x next_y angular_mode radial_mode diagonal_mode
	    rpath_straight rpath_small_arc rpath_big_arc rpath_radial_first_small_arc rpath_radial_first_big_arc
	    rpath_angular_first_small_arc rpath_angular_first_big_arc rpath_cw rpath_ccw rpath_smart_pref
	    rpath_smart_alt last_path last_mode last_seg_info
	) 
	(angular_mode = (axlFormGetField form_handle "angular_mode")) 
	(radial_mode = (axlFormGetField form_handle "radial_mode")) 
	(diagonal_mode = (axlFormGetField form_handle "diagonal_mode")) 
	case(mode 
	    ("route" 
		(follow_contour = (axlFormGetField form_handle "follow_contour")) 
		(line_width = (axlFormGetField form_handle "line_width"))
	    ) 
	    ("shape" 
		(follow_contour = t) 
		(line_width = (axlFormGetField form_handle "pen_width"))
	    ) 
	    ("shape_close" 
		(follow_contour = t) 
		(line_width = (axlFormGetField form_handle "pen_width")) 
		(diagonal_mode = "straight_line")
	    )
	)
	(PI = ((tbx_polargrid_data->constants)->PI)) 
	(last_path = (car(stack_data)->path)) 
	(last_mode = (car(stack_data)->polarMode)) 
	(last_seg_info = TBX_POLARGRID_Get_Last_Seg_Info(last_path)) 
	if(snap_status then 
	    if(follow_contour then 
		(cur_angle = TBX_GEOM_Get_Vector_Angle((cur_polargrid->origin) pt_xy)) 
		(last_angle = TBX_GEOM_Get_Vector_Angle((cur_polargrid->origin) 
			(last_seg_info->endPoint)
		    )) 
		(cur_angle = TBX_GEOM_Round(cur_angle "absolute" 1))
		(last_angle = TBX_GEOM_Round(last_angle "absolute" 1)) 
		(cur_radius = (axlDistance pt_xy 
			(cur_polargrid->origin)
		    )) 
		(last_radius = (axlDistance 
			(last_seg_info->endPoint) 
			(cur_polargrid->origin)
		    )) 
		(cur_radius = TBX_GEOM_Round(cur_radius)) 
		(last_radius = TBX_GEOM_Round(last_radius))
		cond(((cur_angle == last_angle) 
			if(((axlGeo2Str pt_xy) != 
				(axlGeo2Str 
				    (last_seg_info->endPoint)
				)) then 
			    (rpath_straight = (axlPathStart 
				    list((last_seg_info->endPoint) pt_xy) line_width
				)) 
			    (rpath_cw = (axlPathArcAngle 
				    (axlPathStart 
					list((last_seg_info->endPoint)) 0.0
				    ) line_width pt_xy t
				    180.0
				)) 
			    (rpath_ccw = (axlPathArcAngle 
				    (axlPathStart 
					list((last_seg_info->endPoint)) 0.0
				    ) line_width pt_xy nil
				    180.0
				))
			    (rpath = (axlPathStart 
				    list((last_seg_info->endPoint)) line_width
				)) 
			    case(last_mode 
				("angular" 
				    if((cur_radius < last_radius) then 
					if((last_seg_info->clockwise) then 
					    (cw_direction = t) else 
					    (cw_direction = nil)
					) else 
					if((last_seg_info->clockwise) then 
					    (cw_direction = nil) else 
					    (cw_direction = t)
					)
				    )
				) 
				("radial" 
				    if((cur_radius < last_radius) then 
					if((last_seg_info->clockwise) then 
					    (cw_direction = nil) else 
					    (cw_direction = t)
					) else 
					if((last_seg_info->clockwise) then 
					    (cw_direction = nil) else 
					    (cw_direction = t)
					)
				    )
				) 
				(t 
				    (cw_direction = nil)
				)
			    ) 
			    (rpath_smart_pref = (axlPathArcAngle 
				    (axlPathStart 
					list((last_seg_info->endPoint)) 0.0
				    ) line_width pt_xy cw_direction
				    180.0
				)) 
			    (rpath_smart_alt = (axlPathArcAngle 
				    (axlPathStart 
					list((last_seg_info->endPoint)) 0.0
				    ) line_width pt_xy 
				    !cw_direction
				    180.0
				)) 
			    case(radial_mode 
				("straight_line" 
				    (path_data = list(list(nil 
						'path rpath_straight 
						'polarMode "radial"
					    ) 
					    list(nil 
						'path rpath_cw 
						'polarMode "radial"
					    ) 
					    list(nil 
						'path rpath_ccw 
						'polarMode "radial"
					    )
					))
				) 
				("arc_smart" 
				    (path_data = list(list(nil 
						'path rpath_smart_pref 
						'polarMode "radial"
					    ) 
					    list(nil 
						'path rpath_smart_alt 
						'polarMode "radial"
					    ) 
					    list(nil 
						'path rpath_straight 
						'polarMode "radial"
					    )
					))
				) 
				("arc_clockwise" 
				    (path_data = list(list(nil 
						'path rpath_cw 
						'polarMode "radial"
					    ) 
					    list(nil 
						'path rpath_ccw 
						'polarMode "radial"
					    ) 
					    list(nil 
						'path rpath_straight 
						'polarMode "radial"
					    )
					))
				) 
				("arc_counter_clockwise" 
				    (path_data = list(list(nil 
						'path rpath_ccw 
						'polarMode "radial"
					    ) 
					    list(nil 
						'path rpath_cw 
						'polarMode "radial"
					    ) 
					    list(nil 
						'path rpath_straight 
						'polarMode "radial"
					    )
					))
				)
			    )
			    else 
			    printf("Warning: Current pick is identical with last pick. Ignoring...\n") t
			)
		    ) 
		    (((axlGeo2Str cur_radius) == 
			    (axlGeo2Str last_radius)) 
			(rpath_straight = (axlPathStart 
				list((last_seg_info->endPoint) pt_xy) line_width
			    )) 
			(rpath = (axlPathStart 
				list((last_seg_info->endPoint)) 0.0
			    )) 
			(rpath_small_arc = TBX_POLARGRID_ROUTE_Construct_Angular_Path(cur_angle last_angle rpath pt_xy 
				(cur_polargrid->origin)
				"small_arc" line_width
			    )) 
			(rpath = (axlPathStart 
				list((last_seg_info->endPoint)) 0.0
			    ))
			(rpath_big_arc = TBX_POLARGRID_ROUTE_Construct_Angular_Path(cur_angle last_angle rpath pt_xy 
				(cur_polargrid->origin)
				"big_arc" line_width
			    )) 
			case(angular_mode 
			    ("straight_line" 
				(path_data = list(list(nil 
					    'path rpath_straight 
					    'polarMode "angular"
					) 
					list(nil 
					    'path rpath_small_arc 
					    'polarMode "angular"
					) 
					list(nil 
					    'path rpath_big_arc 
					    'polarMode "angular"
					)
				    ))
			    ) 
			    ("small_arc" 
				(path_data = list(list(nil 
					    'path rpath_small_arc 
					    'polarMode "angular"
					) 
					list(nil 
					    'path rpath_straight 
					    'polarMode "angular"
					) 
					list(nil 
					    'path rpath_big_arc 
					    'polarMode "angular"
					)
				    ))
			    ) 
			    ("big_arc" 
				(path_data = list(list(nil 
					    'path rpath_big_arc 
					    'polarMode "angular"
					) 
					list(nil 
					    'path rpath_small_arc 
					    'polarMode "angular"
					) 
					list(nil 
					    'path rpath_straight 
					    'polarMode "angular"
					)
				    ))
			    )
			)
		    ) 
		    (t 
			(rpath_straight = (axlPathStart 
				list((last_seg_info->endPoint) pt_xy) line_width
			    )) 
			(next_x = ((cos((((last_angle * 1.0) / 360.0) * 2.0 * PI)) * cur_radius) + car((cur_polargrid->origin)))) 
			(next_y = ((sin((((last_angle * 1.0) / 360.0) * 2.0 * PI)) * cur_radius) + cadr((cur_polargrid->origin)))) 
			(rpath = (axlPathStart 
				list((last_seg_info->endPoint) 
				    (next_x:next_y)
				) line_width
			    ))
			(rpath_radial_first_small_arc = TBX_POLARGRID_ROUTE_Construct_Angular_Path(cur_angle last_angle rpath pt_xy 
				(cur_polargrid->origin)
				"small_arc" line_width
			    )) 
			(rpath = (axlPathStart 
				list((last_seg_info->endPoint) 
				    (next_x:next_y)
				) line_width
			    )) 
			(rpath_radial_first_big_arc = TBX_POLARGRID_ROUTE_Construct_Angular_Path(cur_angle last_angle rpath pt_xy 
				(cur_polargrid->origin)
				"big_arc" line_width
			    )) 
			(next_x = ((cos((((cur_angle * 1.0) / 360.0) * 2.0 * PI)) * last_radius) + car((cur_polargrid->origin)))) 
			(next_y = ((sin((((cur_angle * 1.0) / 360.0) * 2.0 * PI)) * last_radius) + cadr((cur_polargrid->origin))))
			(rpath = (axlPathStart 
				list((last_seg_info->endPoint)) 0.0
			    )) 
			(rpath_angular_first_small_arc = TBX_POLARGRID_ROUTE_Construct_Angular_Path(cur_angle last_angle rpath 
				(next_x:next_y) 
				(cur_polargrid->origin)
				"small_arc" line_width
			    )) 
			(rpath = (axlPathStart 
				list((last_seg_info->endPoint)) 0.0
			    )) 
			(rpath_angular_first_big_arc = TBX_POLARGRID_ROUTE_Construct_Angular_Path(cur_angle last_angle rpath 
				(next_x:next_y) 
				(cur_polargrid->origin)
				"big_arc" line_width
			    )) 
			(next_x = ((cos((((cur_angle * 1.0) / 360.0) * 2.0 * PI)) * cur_radius) + car((cur_polargrid->origin))))
			(next_y = ((sin((((cur_angle * 1.0) / 360.0) * 2.0 * PI)) * cur_radius) + cadr((cur_polargrid->origin)))) 
			(rpath_angular_first_small_arc = (axlPathLine rpath_angular_first_small_arc line_width 
				(next_x:next_y)
			    )) 
			(rpath_angular_first_big_arc = (axlPathLine rpath_angular_first_big_arc line_width 
				(next_x:next_y)
			    )) 
			case(diagonal_mode 
			    ("straight_line" 
				(path_data = list(list(nil 
					    'path rpath_straight 
					    'polarMode "straight"
					) 
					list(nil 
					    'path rpath_radial_first_small_arc 
					    'polarMode "straight"
					) 
					list(nil 
					    'path rpath_angular_first_small_arc 
					    'polarMode "straight"
					)
				    )) 
				when((mode == "route") 
				    (path_data = append1(path_data 
					    list(nil 
						'path rpath_radial_first_big_arc 
						'polarMode "straight"
					    )
					)) 
				    (path_data = append1(path_data 
					    list(nil 
						'path rpath_angular_first_big_arc 
						'polarMode "straight"
					    )
					))
				)
			    ) 
			    ("radial_first" 
				(path_data = list(list(nil 
					    'path rpath_radial_first_small_arc 
					    'polarMode "angular"
					) 
					list(nil 
					    'path rpath_angular_first_small_arc 
					    'polarMode "angular"
					) 
					list(nil 
					    'path rpath_straight 
					    'polarMode "angular"
					)
				    )) 
				when((mode == "route") 
				    (path_data = append1(path_data 
					    list(nil 
						'path rpath_radial_first_big_arc 
						'polarMode "angular"
					    )
					)) 
				    (path_data = append1(path_data 
					    list(nil 
						'path rpath_angular_first_big_arc 
						'polarMode "angular"
					    )
					))
				)
			    ) 
			    ("angular_first" 
				(path_data = list(list(nil 
					    'path rpath_angular_first_small_arc 
					    'polarMode "radial"
					) 
					list(nil 
					    'path rpath_radial_first_small_arc 
					    'polarMode "radial"
					) 
					list(nil 
					    'path rpath_straight 
					    'polarMode "radial"
					)
				    )) 
				when((mode == "route") 
				    (path_data = append1(path_data 
					    list(nil 
						'path rpath_angular_first_big_arc 
						'polarMode "radial"
					    )
					)) 
				    (path_data = append1(path_data 
					    list(nil 
						'path rpath_radial_first_big_arc 
						'polarMode "radial"
					    )
					))
				)
			    )
			)
		    )
		) else 
		(rpath = TBX_POLARGRID_Create_Path((axlEnterPath ?points 
			    list((last_seg_info->endPoint) pt_xy)
			) line_width
		    )) 
		(path_data = list(list(nil 
			    'path rpath 
			    'polarMode nil
			)
		    ))
	    ) else 
	    if(follow_contour then 
		(rpath = (axlPathStart 
			list((last_seg_info->endPoint) pt_xy) line_width
		    )) 
		(path_data = list(list(nil 
			    'path rpath 
			    'polarMode "straight"
			)
		    )) else
		(rpath = TBX_POLARGRID_Create_Path((axlEnterPath ?points 
			    list((last_seg_info->endPoint) pt_xy)
			) line_width
		    )) 
		(path_data = list(list(nil 
			    'path rpath 
			    'polarMode nil
			)
		    ))
	    )
	)
	path_data
    )
)
procedure(TBX_POLARGRID_Get_Active_Polargrid(pt_xy dbGridInst) 
    let((cur_polargrid_info) 
	foreach(key dbGridInst 
	    foreach(loc 
		dbGridInst[key] 
		when((axlIsPointInsideBox pt_xy 
			(loc->bBox)
		    ) 
		    (cur_polargrid_info = loc)
		)
	    )
	) cur_polargrid_info
    )
)
procedure(TBX_POLARGRID_Get_Constants() 
    let((units constants) 
	(constants = ncons(nil)) 
	(constants->PI = (defMathConstants('mymathconst)->PI)) 
	(units = car((axlDBGetDesignUnits))) 
	cond((((units == "microns") || (units == "millimeters") || (units == "centimeters")) 
		(constants->extentsMargin = (axlMKSConvert "1.0   MM" units)) 
		(constants->radiusOffset = (axlMKSConvert "0.1   MM" units)) 
		(constants->isecMarkerRadius = (axlMKSConvert "0.03  MM" units)) 
		(constants->orgMarkerRadius = (axlMKSConvert "0.1   MM" units))
		(constants->lineWidthCoarse = (axlMKSConvert "0.025 MM" units)) 
		(constants->lineWidthFine = (axlMKSConvert "0.000 MM" units)) 
		(constants->lineWidthTmpCoarse = (axlMKSConvert "0.1   MM" units)) 
		(constants->lineWidthTmpFine = (axlMKSConvert "0.000 MM" units)) 
		(constants->placeRbandWidth = (axlMKSConvert "0.050 MM" units))
		(constants->initLineWidth = (axlMKSConvert "0.2   MM" units)) 
		(constants->initCornerSize = (axlMKSConvert "0.5   MM" units)) 
		(constants->initPenWidth = (axlMKSConvert "0.1   MM" units))
	    ) 
	    (t 
		(constants->extentsMargin = (axlMKSConvert "40.0  MILS" units)) 
		(constants->radiusOffset = (axlMKSConvert "4.0   MILS" units)) 
		(constants->isecMarkerRadius = (axlMKSConvert "2.0   MILS" units)) 
		(constants->orgMarkerRadius = (axlMKSConvert "4.0   MILS" units))
		(constants->lineWidthCoarse = (axlMKSConvert "1.0   MILS" units)) 
		(constants->lineWidthFine = (axlMKSConvert "0.000 MILS" units)) 
		(constants->lineWidthTmpCoarse = (axlMKSConvert "4.0   MILS" units)) 
		(constants->lineWidthTmpFine = (axlMKSConvert "0.000 MILS" units)) 
		(constants->placeRbandWidth = (axlMKSConvert "2.0   MILS" units))
		(constants->initLineWidth = (axlMKSConvert "8.0   MILS" units)) 
		(constants->initCornerSize = (axlMKSConvert "20.0  MILS" units)) 
		(constants->initPenWidth = (axlMKSConvert "4.0   MILS" units))
	    )
	)
	constants
    )
)
procedure(TBX_POLARGRID_Get_Last_Seg_Info(rpath) 
    let((last_seg seg_type isClockwise end_xy seg_info) 
	when(rpath 
	    (last_seg = (axlPathGetLastPathSeg rpath)) 
	    (end_xy = (axlPathSegGetEndPoint last_seg)) 
	    if((axlPathSegGetArcCenter last_seg) then 
		(seg_type = "arc") 
		if((axlPathSegGetArcClockwise last_seg) then 
		    (isClockwise = t) else 
		    (isClockwise = nil)
		) else
		(seg_type = "line") 
		(isClockwise = nil)
	    ) 
	    (seg_info = list(nil 
		    'segType seg_type 
		    'endPoint end_xy
		    'clockwise isClockwise
		))
	) seg_info
    )
)
procedure(TBX_POLARGRID_Get_Long_Short_Orientation(sym_dbid) 
    let((boundary_layer bbox box_ll box_ur width
	    height long_short shape_list
	) 
	(boundary_layer = strcat((axlMapClassName "PACKAGE GEOMETRY") "/PLACE_BOUND_TOP")) 
	(shape_list = setof(x 
		((sym_dbid->definition)->children) 
		(((x->objType) == "shape") && ((x->layer) == boundary_layer))
	    )) 
	if(shape_list then 
	    (bbox = (axlDBGetExtents shape_list nil)) else 
	    (bbox = (bbox = (axlDBGetExtents 
			(sym_dbid->definition) nil
		    )))
	) 
	when(bbox 
	    (box_ll = car(bbox)) 
	    (box_ur = cadr(bbox)) 
	    (width = abs((car(box_ur) - car(box_ll)))) 
	    (height = abs((cadr(box_ur) - cadr(box_ll))))
	    cond(((width > height) 
		    (long_short = list(0.0 90.0))
		) 
		((width < height) 
		    (long_short = list(90.0 0.0))
		) 
		(t 
		    (long_short = list(0.0 90.0))
		)
	    )
	)
	long_short
    )
)
procedure(TBX_POLARGRID_Get_Ratsnest_Info(sym_dbid) 
    let((refdes pin_number from_dbid to_dbid fromto_list
	    var_cnt fix_cnt fix_xy var_xy cur_net_dbid
	    net_info result rat_visible
	) 
	(refdes = (sym_dbid->refdes)) 
	when(refdes 
	    foreach(pin 
		(sym_dbid->pins) 
		(pin_number = (pin->number)) 
		when(((pin->net) && !((pin->net)->VOLTAGE) && ((((pin->net)->prop)->RATSNEST_SCHEDULE) != "POWER_GROUND")) 
		    (cur_net_dbid = (pin->net)) 
		    (rat_visible = nil) 
		    when(((pin->net)->ratsnestOn) 
			(rat_visible = t)
		    ) 
		    foreach(rn 
			((pin->net)->ratsnest) 
			(var_xy = nil) 
			(fix_xy = nil) 
			(var_cnt = 0)
			(fix_cnt = 0) 
			(from_dbid = car((rn->pins))) 
			(to_dbid = cadr((rn->pins))) 
			cond((((from_dbid->objType) == "rat_t") 
				(fix_xy = (from_dbid->xy)) 
				++fix_cnt
			    ) 
			    (((from_dbid->objType) == "pin") 
				when(((from_dbid->parent)->xy) 
				    if((strcat(((from_dbid->parent)->refdes)) == refdes) then 
					when((strcat(((from_dbid->parent)->refdes) "." 
						    (from_dbid->number)
						) == strcat(refdes "." pin_number)) 
					    (var_xy = (pin->xy)) 
					    ++var_cnt
					) else 
					(fix_xy = (from_dbid->xy))
					++fix_cnt
				    )
				)
			    ) 
			    (t 
				when(((from_dbid->parent)->xy) 
				    (fix_xy = (from_dbid->xy)) 
				    ++fix_cnt
				)
			    )
			) 
			cond((((to_dbid->objType) == "rat_t") 
				(fix_xy = (to_dbid->xy)) 
				++fix_cnt
			    ) 
			    (((to_dbid->objType) == "pin") 
				when(((to_dbid->parent)->xy) 
				    if((strcat(((to_dbid->parent)->refdes)) == refdes) then 
					when((strcat(((to_dbid->parent)->refdes) "." 
						    (to_dbid->number)
						) == strcat(refdes "." pin_number)) 
					    (var_xy = (pin->xy)) 
					    ++var_cnt
					) else 
					(fix_xy = (to_dbid->xy))
					++fix_cnt
				    )
				)
			    ) 
			    (t 
				when(((to_dbid->parent)->xy) 
				    (fix_xy = (to_dbid->xy)) 
				    ++fix_cnt
				)
			    )
			)
			when((onep(var_cnt) && onep(fix_cnt)) 
			    (fromto_list = cons(list(fix_xy var_xy 
					(sym_dbid->xy)
				    ) fromto_list
				)) 
			    unless(exists(x net_info 
				    (x == cur_net_dbid)
				) 
				(net_info = cons(list(cur_net_dbid rat_visible) net_info))
			    )
			)
		    )
		)
	    )
	) 
	(result = list(fromto_list net_info)) result
    )
)
procedure(TBX_POLARGRID_Init() 
    let((layer_coarse_line layer_fine_line layer_coarse_dot layer_fine_dot sys_layer
	    constants popup_def param tmp_layer layer
	    col_nr all_colors color_id_white class_def cl_etch
	    cl_brdgeo cl_pkggeo cl_dwgfmt cl_mfg cl_pkg_kpi
	    cl_pkg_kpo cl_rte_kpi cl_rte_kpo cl_via_kpo cl_cns_rgn
	) 
	(cl_etch = (axlMapClassName "ETCH")) 
	(cl_brdgeo = (axlMapClassName "BOARD GEOMETRY")) 
	(cl_pkggeo = (axlMapClassName "PACKAGE GEOMETRY")) 
	(cl_dwgfmt = (axlMapClassName "DRAWING FORMAT"))
	(cl_mfg = (axlMapClassName "MANUFACTURING")) 
	(cl_pkg_kpo = (axlMapClassName "PACKAGE KEEPOUT")) 
	(cl_rte_kpo = (axlMapClassName "ROUTE KEEPOUT")) 
	(cl_via_kpo = (axlMapClassName "VIA KEEPOUT")) 
	(cl_pkg_kpi = (axlMapClassName "PACKAGE KEEPIN"))
	(cl_rte_kpi = (axlMapClassName "ROUTE KEEPIN")) 
	(cl_cns_rgn = (axlMapClassName "CONSTRAINT REGION")) 
	(class_def = makeTable("class_def_table" nil)) 
	(class_def["shape"] = list(list(cl_etch cl_etch) 
		list(cl_brdgeo cl_brdgeo) 
		list(cl_pkggeo cl_pkggeo) 
		list(cl_dwgfmt cl_dwgfmt) 
		list(cl_mfg cl_mfg)
		list(cl_pkg_kpo cl_pkg_kpo) 
		list(cl_rte_kpo cl_rte_kpo) 
		list(cl_via_kpo cl_via_kpo) 
		list(cl_pkg_kpi cl_pkg_kpi) 
		list(cl_rte_kpi cl_rte_kpi)
		list(cl_cns_rgn cl_cns_rgn)
	    )) 
	(class_def["route"] = list(list(cl_etch cl_etch) 
		list(cl_brdgeo cl_brdgeo) 
		list(cl_pkggeo cl_pkggeo) 
		list(cl_dwgfmt cl_dwgfmt) 
		list(cl_mfg cl_mfg)
	    ))
	(popup_def = makeTable("popup_def_table" nil)) 
	(popup_def["place_only"] = list(list("Radial long side" "radial_long") 
		list("Radial short side" "radial_short") 
		list("Retain relative" "retain_relative") 
		list("Absolute" "absolute")
	    )) 
	(popup_def["place_and_spin"] = list(list("Polar lock" "polar_lock") 
		list("Incremental" "incremental") 
		list("Absolute" "absolute")
	    )) 
	(popup_def["spin_only"] = list(list("Polar lock" "polar_lock") 
		list("Absolute" "absolute") 
		list("Incremental" "incremental")
	    )) 
	(layer_coarse_line = "MANUFACTURING/TBX_POLAR_C_LINE")
	(layer_coarse_dot = "MANUFACTURING/TBX_POLAR_C_DOT") 
	(layer_fine_line = "MANUFACTURING/TBX_POLAR_F_LINE") 
	(layer_fine_dot = "MANUFACTURING/TBX_POLAR_F_DOT") 
	(tmp_layer = "MANUFACTURING/TBX_TMP_DRAFTING") 
	foreach(entry 
	    list(list(layer_coarse_line 81) 
		list(layer_coarse_dot 81) 
		list(layer_fine_line 66) 
		list(layer_fine_dot 66)
	    ) 
	    (layer = car(entry)) 
	    (col_nr = cadr(entry)) 
	    unless((axlIsLayer layer) 
		(axlLayerCreateNonConductor layer) 
		(param = (axlLayerGet layer)) 
		(param->color = col_nr) 
		(axlLayerSet param)
	    )
	)
	when(((axlColorGet 
		    'background
		) == list(0 0 0)) 
	    (all_colors = (axlColorGet 
		    'all
		)) 
	    for(i 0 
		(length(all_colors) - 1) 
		when((nth(i all_colors) == 
			list(255 255 255)) 
		    (color_id_white = (i + 1))
		)
	    )
	) 
	unless((axlIsLayer tmp_layer) 
	    (axlLayerCreateNonConductor tmp_layer) 
	    when(color_id_white 
		(param = (axlLayerGet tmp_layer)) 
		(param->color = color_id_white) 
		(axlLayerSet param)
	    )
	) 
	(axlVisibleUpdate t) 
	(sys_layer = list(nil 
		'coarseLine layer_coarse_line 
		'coarseDot layer_coarse_dot
		'fineLine layer_fine_line 
		'fineDot layer_fine_dot 
		'tmp
		tmp_layer
	    )) 
	unless((axlDBGetPropDictEntry "TBX_POLARGRID_RADIAL") 
	    (axlDBCreatePropDictEntry "TBX_POLARGRID_RADIAL" "STRING" 
		list("symbols")
	    )
	)
	unless((axlDBGetPropDictEntry "TBX_POLARGRID_ANGULAR") 
	    (axlDBCreatePropDictEntry "TBX_POLARGRID_ANGULAR" "STRING" 
		list("symbols")
	    )
	) 
	(constants = TBX_POLARGRID_Get_Constants()) 
	unless(boundp('tbx_polargrid_data) 
	    iliDefstruct('defstruct(tbx_polargrid_data_struct companyName eventHandler PI transMark
			formid sysLayer constants pathStack partStack
			rotationPopup runtime classPopup systemGridSnap lastRotationType
			dbGridParam dbGridInst curGridParam curGridInst runMode
			transMarkPoly
		    )
	    ) 
	    defvar(tbx_polargrid_data nil)
	) 
	if(!tbx_polargrid_data then 
	    (tbx_polargrid_data = (make_tbx_polargrid_data_struct ?companyName nil ?eventHandler 
		    ncons(nil)
		    ?constants constants ?transMark nil ?transMarkPoly
		    nil ?formid nil ?dbGridParam nil
		    ?dbGridInst nil ?curGridParam nil ?curGridInst
		    nil ?pathStack nil ?partStack nil
		    ?runtime 
		    ncons(nil) ?rotationPopup popup_def ?classPopup
		    class_def ?runMode nil ?sysLayer sys_layer
		    ?systemGridSnap nil
		)) else 
	    (tbx_polargrid_data->companyName = nil)
	    (tbx_polargrid_data->eventHandler = ncons(nil)) 
	    (tbx_polargrid_data->constants = constants) 
	    (tbx_polargrid_data->transMark = nil) 
	    (tbx_polargrid_data->transMarkPoly = nil) 
	    (tbx_polargrid_data->formid = nil)
	    (tbx_polargrid_data->dbGridParam = nil) 
	    (tbx_polargrid_data->dbGridInst = nil) 
	    (tbx_polargrid_data->curGridParam = nil) 
	    (tbx_polargrid_data->curGridInst = nil) 
	    (tbx_polargrid_data->formid = nil)
	    (tbx_polargrid_data->pathStack = nil) 
	    (tbx_polargrid_data->partStack = nil) 
	    (tbx_polargrid_data->runtime = ncons(nil)) 
	    (tbx_polargrid_data->rotationPopup = popup_def) 
	    (tbx_polargrid_data->classPopup = class_def)
	    (tbx_polargrid_data->runMode = nil) 
	    (tbx_polargrid_data->sysLayer = sys_layer) 
	    (tbx_polargrid_data->systemGridSnap = nil)
	)
    )
)
procedure(TBX_POLARGRID_Init_UI(form_handle mode) 
    let((class_name subclass_name param active_color record
	    placement_mode via_name class_list via_list
	) 
	(axlFormSetField form_handle "coarse_style" "lines") 
	(axlFormSetField form_handle "fine_style" "lines") 
	when((!(axlIsVisibleLayer 
			((tbx_polargrid_data->sysLayer)->coarseLine)
		    ) && !(axlIsVisibleLayer 
			((tbx_polargrid_data->sysLayer)->fineLine)
		    ) && !(axlIsVisibleLayer 
			((tbx_polargrid_data->sysLayer)->coarseDot)
		    ) && !(axlIsVisibleLayer 
			((tbx_polargrid_data->sysLayer)->fineDot)
		    )) 
	    (axlVisibleLayer 
		((tbx_polargrid_data->sysLayer)->coarseLine) t
	    )
	) 
	when(((axlIsVisibleLayer 
		    ((tbx_polargrid_data->sysLayer)->coarseLine)
		) || (axlIsVisibleLayer 
		    ((tbx_polargrid_data->sysLayer)->coarseDot)
		)) 
	    (axlFormSetField form_handle "snap_coarse_grid" t)
	)
	when((axlIsVisibleLayer 
		((tbx_polargrid_data->sysLayer)->coarseDot)
	    ) 
	    (axlFormSetField form_handle "coarse_style" "dots")
	) 
	when((axlIsVisibleLayer 
		((tbx_polargrid_data->sysLayer)->coarseLine)
	    ) 
	    (axlFormSetField form_handle "coarse_style" "lines") 
	    (axlVisibleLayer 
		((tbx_polargrid_data->sysLayer)->coarseDot) nil
	    )
	) 
	when(((axlIsVisibleLayer 
		    ((tbx_polargrid_data->sysLayer)->fineLine)
		) || (axlIsVisibleLayer 
		    ((tbx_polargrid_data->sysLayer)->fineDot)
		)) 
	    (axlFormSetField form_handle "snap_fine_grid" t)
	) 
	when((axlIsVisibleLayer 
		((tbx_polargrid_data->sysLayer)->fineDot)
	    ) 
	    (axlFormSetField form_handle "fine_style" "dots")
	) 
	when((axlIsVisibleLayer 
		((tbx_polargrid_data->sysLayer)->fineLine)
	    ) 
	    (axlFormSetField form_handle "fine_style" "lines") 
	    (axlVisibleLayer 
		((tbx_polargrid_data->sysLayer)->fineDot) nil
	    )
	)
	cond((((mode == "route") || (mode == "shape") || (mode == "void")) 
		(record = strcat("polargrid|" mode)) 
		(class_name = TBX_SESSION_Get_Param(record "class_name" 
			(axlMapClassName "ETCH")
		    )) 
		(class_name = (axlMapClassName class_name)) 
		(subclass_name = TBX_SESSION_Get_Param(record "subclass_name" "TOP"))
		unless(member(subclass_name 
			(axlSubclasses class_name)
		    ) 
		    (subclass_name = car((axlSubclasses class_name)))
		) 
		(axlDBControl 
		    'activeLayer 
		    strcat(class_name "/" subclass_name)
		) 
		unless((axlIsVisibleLayer 
			(axlDBControl 
			    'activeLayer
			)
		    ) 
		    (axlVisibleLayer 
			(axlDBControl 
			    'activeLayer
			) t
		    )
		) 
		(param = (axlLayerGet 
			(axlDBControl 
			    'activeLayer
			)
		    )) 
		(active_color = (param->color))
		(param = (axlLayerGet 
			((tbx_polargrid_data->sysLayer)->tmp)
		    )) 
		(param->color = active_color) 
		(axlLayerSet param) 
		if(((mode == "shape") || (mode == "void")) then 
		    (class_list = (tbx_polargrid_data->classPopup)["shape"]) 
		    (axlFormBuildPopup form_handle "class_name" class_list) 
		    (axlBuildSubclassPopup form_handle "subclass_name" class_name)
		    (axlFormSetField form_handle "class_name" class_name) 
		    (axlFormSetField form_handle "subclass_name" subclass_name) 
		    when((mode == "shape") 
			(axlFormSetField form_handle "shape_type" 
			    TBX_SESSION_Get_Param(record "shape_type" "dynamic")
			) 
			(axlFormSetField form_handle "shape_net" 
			    TBX_SESSION_Get_Param(record "shape_net" "")
			)
		    ) 
		    when((mode == "void") 
			(axlFormSetFieldEditable form_handle "shape_type" nil) 
			(axlFormSetFieldEditable form_handle "shape_net" nil) 
			(axlFormSetFieldEditable form_handle "browse_net" nil)
		    ) 
		    (axlFormSetField form_handle "angular_mode" 
			TBX_SESSION_Get_Param(record "angular_mode" "small_arc")
		    )
		    (axlFormSetField form_handle "radial_mode" 
			TBX_SESSION_Get_Param(record "radial_mode" "straight_line")
		    ) 
		    (axlFormSetField form_handle "diagonal_mode" 
			TBX_SESSION_Get_Param(record "diagonal_mode" "straight_line")
		    ) 
		    (axlFormSetFieldEditable form_handle "diagonal_mode" nil) 
		    (axlFormSetField form_handle "pen_width" 
			TBX_SESSION_Get_Param(record "pen_width" 
			    ((tbx_polargrid_data->constants)->initPenWidth) t
			)
		    ) else
		    (class_list = (tbx_polargrid_data->classPopup)["route"]) 
		    (axlFormBuildPopup form_handle "class_name" class_list) 
		    (axlBuildSubclassPopup form_handle "subclass_name" class_name) 
		    (axlFormSetField form_handle "class_name" class_name) 
		    (axlFormSetField form_handle "subclass_name" subclass_name)
		    (via_list = mapcar(lambda((x) 
				(x->name)
			    ) 
			    (axlGetAllViaList)
			)) 
		    (axlFormBuildPopup form_handle "via_name" via_list) 
		    (via_name = TBX_SESSION_Get_Param(record "via_name" "")) 
		    unless(member(via_name via_list) 
			(via_name = car(via_list))
		    ) 
		    (axlFormSetField form_handle "via_name" via_name)
		    (axlFormSetField form_handle "line_width" 
			TBX_SESSION_Get_Param(record "line_width" 
			    ((tbx_polargrid_data->constants)->initLineWidth) t
			)
		    ) 
		    (axlFormSetField form_handle "snap_connect_point" 
			TBX_SESSION_Get_Param(record "snap_connect_point" t)
		    ) 
		    (axlFormSetField form_handle "follow_contour" 
			TBX_SESSION_Get_Param(record "follow_contour" t)
		    ) 
		    (axlFormSetField form_handle "regular_style" 
			TBX_SESSION_Get_Param(record "regular_style" nil)
		    ) 
		    (axlFormSetField form_handle "angular_mode" 
			TBX_SESSION_Get_Param(record "angular_mode" "small_arc")
		    )
		    (axlFormSetField form_handle "radial_mode" 
			TBX_SESSION_Get_Param(record "radial_mode" "straight_line")
		    ) 
		    (axlFormSetField form_handle "diagonal_mode" 
			TBX_SESSION_Get_Param(record "diagonal_mode" "straight_line")
		    ) 
		    (axlFormSetField form_handle "lock_mode" 
			TBX_SESSION_Get_Param(record "lock_mode" "line")
		    ) 
		    (axlFormSetField form_handle "lock_angle" 
			TBX_SESSION_Get_Param(record "lock_angle" "45")
		    ) 
		    (axlFormSetField form_handle "corner_label" 
			TBX_SESSION_Get_Param(record "corner_label" "Miter")
		    )
		    (axlFormSetField form_handle "corner_size" 
			TBX_SESSION_Get_Param(record "corner_size" 
			    ((tbx_polargrid_data->constants)->initCornerSize) t
			)
		    ) 
		    (axlFormSetField form_handle "corner_mode" 
			TBX_SESSION_Get_Param(record "corner_mode" "min")
		    )
		)
	    ) 
	    ("place" 
		(axlDBControl 
		    'activeLayer "PACKAGE GEOMETRY/ASSEMBLY_TOP"
		) 
		(tbx_polargrid_data->lastRotationType = makeTable("last_rotation_type_info" nil)) 
		((tbx_polargrid_data->lastRotationType)["place_only"] = "radial_long") 
		((tbx_polargrid_data->lastRotationType)["place_and_spin"] = "polar_lock")
		((tbx_polargrid_data->lastRotationType)["spin_only"] = "polar_lock") 
		(record = "polargrid|place") 
		when(TBX_SESSION_Get_Param(record "place_only" t) 
		    (axlFormSetField form_handle "place_only" t) 
		    (placement_mode = "place_only")
		) 
		when(TBX_SESSION_Get_Param(record "place_and_spin" nil) 
		    (axlFormSetField form_handle "place_and_spin" t) 
		    (placement_mode = "place_and_spin")
		) 
		when(TBX_SESSION_Get_Param(record "spin_only" nil) 
		    (axlFormSetField form_handle "spin_only" t) 
		    (placement_mode = "spin_only")
		)
		(axlFormBuildPopup form_handle "rotation_type" 
		    (tbx_polargrid_data->rotationPopup)[placement_mode]
		) 
		(axlFormSetField form_handle "rotation_type" 
		    TBX_SESSION_Get_Param(record "rotation_type" "radial_long")
		) 
		(axlFormSetField form_handle "angle_value" 
		    TBX_SESSION_Get_Param(record "angle_value" "90.0")
		) 
		TBX_POLARGRID_PLACE_Update_Form(form_handle) 
		when(TBX_SESSION_Get_Param(record "symbol_origin" t) 
		    (axlFormSetField form_handle "symbol_origin" t)
		)
		when(TBX_SESSION_Get_Param(record "symbol_center" nil) 
		    (axlFormSetField form_handle "symbol_center" t)
		)
	    )
	) 
	(axlVisibleUpdate t) t
    )
)
procedure((TBX_POLARGRID_Main \@optional arg) 
    let((lic_check_result info_file FC_FEATURE FC_VERSION SUB_VERSION
	    VERSION_STR port grid_params FORM_FILE fid
	    result msg
	) 
	(FC_FEATURE = "POLARGRID") 
	(FC_VERSION = "17.1") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Polar Grid %s (C)2017" FC_VERSION))
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./polargrid_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Polar Grid Utilities information:\n") 
		fprintf(port "====================================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version      : Prints the current version of the module\n") 
		fprintf(port "  setup        : Setup polar grid application\n") 
		fprintf(port "  place        : Polar placement application\n") 
		fprintf(port "  route        : Polar draw and route application\n")
		fprintf(port "  shape        : Polar shape application\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Polar Grid Utilities: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (arg 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    TBX_POLARGRID_Init() 
		    if((axlSelectByProperty "symdef" "FLW_POLARGRID_ANGULAR") then 
			(msg = "Need to update database for compatibility with current version of Polar Grid. Relaunch tool once migration has finished.") 
			(axlUIConfirm msg) 
			TBX_POLARGRID_Migrate()
			else 
			TBX_POLARGRID_Write_View_Files() 
			(axlLayerPrioritySaveAll) 
			TBX_UTIL_Set_Layer_Priority(list(((tbx_polargrid_data->sysLayer)->coarseLine) 
				((tbx_polargrid_data->sysLayer)->fineLine) 
				((tbx_polargrid_data->sysLayer)->coarseDot) 
				((tbx_polargrid_data->sysLayer)->fineDot)
			    )
			) 
			(result = TBX_POLARGRID_Read_Grid_Symbols_From_Database())
			(tbx_polargrid_data->dbGridParam = car(result)) 
			(tbx_polargrid_data->dbGridInst = cadr(result)) 
			if((axlOKToProceed t) then 
			    (arg = lowerCase(arg)) 
			    cond(((arg == "setup") 
				    (grid_params = TBX_POLARGRID_SETUP_Get_Defaults()) 
				    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "polargrid_setup_main")) 
				    (fid = (axlFormCreate 
					    gensym("tbxpolargridsetup") FORM_FILE 
					    '(e outer) 
					    'TBX_POLARGRID_SETUP_Callback
					    t nil
					)) 
				    (tbx_polargrid_data->formid = fid)
				    TBX_FORM_Init_Header(fid "Licensed for " lic_check_result VERSION_STR) 
				    (axlFormSetField fid "angle_start" 
					(grid_params->angleStart)
				    ) 
				    (axlFormSetField fid "angle_end" 
					(grid_params->angleEnd)
				    ) 
				    (axlFormSetField fid "angle_step" 
					(grid_params->angleStep)
				    ) 
				    (axlFormSetField fid "angle_multiplier" 
					(grid_params->angleMultiplier)
				    )
				    (axlFormSetField fid "radius_start" 
					(grid_params->radiusStart)
				    ) 
				    (axlFormSetField fid "radius_end" 
					(grid_params->radiusEnd)
				    ) 
				    (axlFormSetField fid "radius_step" 
					(grid_params->radiusStep)
				    ) 
				    (axlFormSetField fid "radius_multiplier" 
					(grid_params->radiusMultiplier)
				    ) 
				    (axlFormDisplay fid)
				    TBX_FORM_Delete(lic_check_result FORM_FILE) 
				    (axlVisibleLayer 
					((tbx_polargrid_data->sysLayer)->coarseLine) t
				    ) 
				    TBX_POLARGRID_SETUP_Init_Next(fid) 
				    TBX_POLARGRID_SETUP_Event_Loop(fid)
				) 
				((arg == "route") 
				    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "polargrid_route_mini")) 
				    (fid = (axlMiniStatusLoad 
					    gensym("tbxpolargriroute") FORM_FILE 
					    'TBX_POLARGRID_ROUTE_Callback nil
					)) 
				    (tbx_polargrid_data->formid = fid) 
				    TBX_FORM_Init_Header(fid nil lic_check_result nil)
				    TBX_POLARGRID_Init_UI(fid "route") 
				    TBX_POLARGRID_ROUTE_Update_Form(fid) 
				    TBX_POLARGRID_ROUTE_Set_Line_Lock(fid) 
				    (axlVisibleUpdate t) 
				    (axlFormDisplay fid)
				    TBX_FORM_Delete(lic_check_result FORM_FILE) 
				    (axlAutoOpenFindFilter) 
				    TBX_POLARGRID_ROUTE_Event_Loop(fid) 
				    TBX_POLARGRID_Cache_Param(fid "route")
				) 
				(((arg == "shape") || (arg == "void")) 
				    (tbx_polargrid_data->runMode = arg) 
				    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "polargrid_shape_mini")) 
				    (fid = (axlMiniStatusLoad 
					    gensym() FORM_FILE 
					    'TBX_POLARGRID_SHAPE_Callback nil
					)) 
				    (tbx_polargrid_data->formid = fid)
				    TBX_FORM_Init_Header(fid nil lic_check_result nil) 
				    TBX_POLARGRID_Init_UI(fid arg) 
				    (axlSetLineLock ?arcEnable nil ?lockAngle 0
					?fixed45 nil
				    ) 
				    (axlVisibleLayer 
					((tbx_polargrid_data->sysLayer)->tmp) t
				    ) 
				    (axlDeleteByLayer 
					((tbx_polargrid_data->sysLayer)->tmp) 
					'fixed
				    )
				    (axlVisibleUpdate t) 
				    (axlFormDisplay fid) 
				    TBX_FORM_Delete(lic_check_result FORM_FILE) 
				    (axlAutoOpenFindFilter) 
				    TBX_POLARGRID_SHAPE_Event_Loop(fid)
				    if((arg == "shape") then 
					TBX_POLARGRID_Cache_Param(fid "shape") else 
					TBX_POLARGRID_Cache_Param(fid "void")
				    )
				) 
				("place" 
				    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "polargrid_place_mini")) 
				    (fid = (axlMiniStatusLoad 
					    gensym() FORM_FILE 
					    'TBX_POLARGRID_PLACE_Callback nil
					)) 
				    (tbx_polargrid_data->formid = fid) 
				    TBX_FORM_Init_Header(fid nil lic_check_result nil)
				    TBX_POLARGRID_Init_UI(fid "place") 
				    (axlFormDisplay fid) 
				    TBX_FORM_Delete(lic_check_result FORM_FILE) 
				    (axlAutoOpenFindFilter) 
				    TBX_POLARGRID_PLACE_Event_Loop(fid)
				    TBX_POLARGRID_Cache_Param(fid "place")
				)
			    ) 
			    TBX_POLARGRID_Cleanup()
			    else 
			    printf("Warning: Finish active command first\n")
			)
		    )
		)
	    )
	)
    )
)
procedure(TBX_POLARGRID_Migrate() 
    let((arr design_units angle_start angle_end angle_step
	    angle_multiplier config_units radius_start radius_end radius_step
	    radius_multiplier grid_param symdef_list form_handle loc_data
	    def_extents loc_data_ok_fit sym_name result cur_info
	    grid_instances legacy_layers
	) 
	(legacy_layers = list(strcat((axlMapClassName "MANUFACTURING") "/FLW_POLAR_C_LINE") 
		strcat((axlMapClassName "MANUFACTURING") "/FLW_POLAR_C_DOT") 
		strcat((axlMapClassName "MANUFACTURING") "/FLW_POLAR_F_LINE") 
		strcat((axlMapClassName "MANUFACTURING") "/FLW_POLAR_F_DOT")
	    )) 
	(symdef_list = (axlSelectByProperty "symdef" "FLW_POLARGRID_ANGULAR")) 
	(grid_param = makeTable("grid_param_table" nil)) 
	(grid_instances = makeTable("grid_instances_table" nil))
	(design_units = car((axlDBGetDesignUnits))) 
	foreach(sd symdef_list 
	    (sym_name = upperCase((sd->name))) 
	    (arr = parseString(((sd->prop)->FLW_POLARGRID_ANGULAR) "|")) 
	    (angle_start = atof(car(arr)))
	    (angle_end = atof(cadr(arr))) 
	    (angle_step = atof(caddr(arr))) 
	    (angle_multiplier = atoi(nth(3 arr))) 
	    (arr = parseString(((sd->prop)->FLW_POLARGRID_RADIAL) "|")) 
	    (config_units = car(arr))
	    (radius_start = (axlMKSConvert 
		    atof(cadr(arr)) config_units design_units
		)) 
	    (radius_end = (axlMKSConvert 
		    atof(caddr(arr)) config_units design_units
		)) 
	    (radius_step = (axlMKSConvert 
		    atof(nth(3 arr)) config_units design_units
		)) 
	    (radius_multiplier = atoi(nth(4 arr))) 
	    (grid_param[sym_name] = list(nil 
		    'angleStart angle_start 
		    'angleEnd angle_end
		    'angleStep angle_step 
		    'angleMultiplier angle_multiplier 
		    'radiusStart
		    radius_start 
		    'radiusEnd radius_end 
		    'radiusStep radius_step
		    'radiusMultiplier radius_multiplier 
		    'name 
		    upperCase((sd->name))
		))
	    foreach(si 
		(sd->instances) 
		(cur_info = list(nil 
			'bBox 
			(si->bBox) 
			'origin 
			(si->xy)
			'mirror 
			(si->isMirrored) 
			'rotation 
			(si->rotation) 
			'dbid
			si 
			'name sym_name
		    )) 
		(grid_instances[sym_name] = cons(cur_info 
			grid_instances[sym_name]
		    ))
	    )
	) 
	(tbx_polargrid_data->dbGridParam = grid_param) 
	(tbx_polargrid_data->dbGridInst = grid_instances) 
	(form_handle = (axlFormCreate 
		gensym("flwpolargrid") "tbx_polargrid_setup_main" 
		'(e outer) 
		'_FLW_POLARGRID_SETUP_Callback
		t nil
	    ))
	(tbx_polargrid_data->formid = form_handle) 
	(axlFormDisplay form_handle) 
	foreach(sdn 
	    (tbx_polargrid_data->dbGridParam) 
	    (axlFormSetField form_handle "angle_start" 
		((tbx_polargrid_data->dbGridParam)[sdn]->angleStart)
	    ) 
	    (axlFormSetField form_handle "angle_end" 
		((tbx_polargrid_data->dbGridParam)[sdn]->angleEnd)
	    ) 
	    (axlFormSetField form_handle "angle_step" 
		((tbx_polargrid_data->dbGridParam)[sdn]->angleStep)
	    )
	    (axlFormSetField form_handle "angle_multiplier" 
		((tbx_polargrid_data->dbGridParam)[sdn]->angleMultiplier)
	    ) 
	    (axlFormSetField form_handle "radius_start" 
		((tbx_polargrid_data->dbGridParam)[sdn]->radiusStart)
	    ) 
	    (axlFormSetField form_handle "radius_end" 
		((tbx_polargrid_data->dbGridParam)[sdn]->radiusEnd)
	    ) 
	    (axlFormSetField form_handle "radius_step" 
		((tbx_polargrid_data->dbGridParam)[sdn]->radiusStep)
	    ) 
	    (axlFormSetField form_handle "radius_multiplier" 
		((tbx_polargrid_data->dbGridParam)[sdn]->radiusMultiplier)
	    )
	    foreach(dpl 
		(tbx_polargrid_data->dbGridInst)[sdn] 
		(axlDeleteObject 
		    (dpl->dbid)
		) 
		(loc_data = cons(list((dpl->origin) 
			    (dpl->rotation) 
			    (dpl->mirror)
			) loc_data
		    ))
	    ) 
	    (axlDBRefreshId nil) 
	    foreach(loc loc_data 
		(result = TBX_POLARGRID_SETUP_Check_Extents(form_handle loc)) 
		when(result 
		    (def_extents = caddr(result)) 
		    (loc_data_ok_fit = cons(loc loc_data_ok_fit))
		)
	    ) 
	    when(def_extents 
		TBX_POLARGRID_SETUP_Draw_Geometry(form_handle "final" def_extents loc_data_ok_fit nil)
	    )
	) 
	(axlFinishEnterFun) 
	(axlFormClose form_handle)
	(axlClearDynamics) 
	(axlUIPopupSet nil) 
	foreach(lyr legacy_layers 
	    printf("Deleting legacy layer %L\n" lyr) 
	    (axlDeleteObject 
		(axlLayerGet lyr)
	    )
	) 
	foreach(prp 
	    list("FLW_POLARGRID_ANGULAR" "FLW_POLARGRID_ANGULAR") 
	    printf("Deleting legacy property definition %L\n" prp) 
	    (axlDBDeletePropDictEntry prp)
	) 
	(axlClearSelSet)
	t
    )
)
procedure(TBX_POLARGRID_PLACE_Build_Dynamics(sym_dbid ref_location rat_info) 
    let((fix_xy var_xy offset_x offset_y dx
	    dy line_width sym_xy_old
	) 
	(line_width = ((tbx_polargrid_data->constants)->placeRbandWidth)) 
	(axlClearDynamics) 
	(axlEraseObject sym_dbid) 
	(axlDynamicsObject 
	    list(sym_dbid) ref_location
	)
	foreach(ft rat_info 
	    (fix_xy = car(ft)) 
	    (var_xy = cadr(ft)) 
	    (sym_xy_old = caddr(ft))
	    when(((axlGeo2Str 
			(sym_dbid->xy)
		    ) != (axlGeo2Str sym_xy_old)) 
		(offset_x = (car((sym_dbid->xy)) - car(sym_xy_old))) 
		(offset_y = (cadr((sym_dbid->xy)) - cadr(sym_xy_old))) 
		(var_xy = ((car(var_xy) + offset_x):(cadr(var_xy) + offset_y)))
	    ) 
	    (dx = (car(var_xy) - car(ref_location))) 
	    (dy = (cadr(var_xy) - cadr(ref_location))) 
	    (axlAddSimpleRbandDynamics fix_xy "directline" ?origin ref_location
		?var_point 
		(dx:dy) ?width line_width
	    )
	) 
	(axlVisibleUpdate t)
    )
)
procedure(TBX_POLARGRID_PLACE_Calculate_Init_Spin_Angle(form_handle obj_dbid grid_xy cur_polargrid current) 
    let((object_rotation radial_lock_angle grid_angle angle long_side_orientation
	    short_side_orientation result init_spin_angle diff_list last_angle
	) 
	case((obj_dbid->objType) 
	    ("symbol" 
		(object_rotation = (obj_dbid->rotation)) 
		(result = TBX_POLARGRID_Get_Long_Short_Orientation(obj_dbid)) 
		(long_side_orientation = car(result)) 
		(short_side_orientation = cadr(result))
	    ) 
	    ("module" t)
	) 
	(grid_angle = TBX_GEOM_Get_Vector_Angle((cur_polargrid->origin) grid_xy)) 
	case((axlFormGetField form_handle "rotation_type") 
	    ("radial_long" 
		(object_rotation = (long_side_orientation + (obj_dbid->rotation))) 
		when((object_rotation > 360.0) 
		    (object_rotation = (object_rotation - 360.0))
		) 
		(diff_list = list(list(TBX_GEOM_Get_Vector_Angle_Difference(grid_angle object_rotation "min") grid_angle) 
			list(TBX_GEOM_Get_Vector_Angle_Difference((grid_angle + 180.0) object_rotation "min") 
			    (grid_angle + 180.0)
			)
		    )) 
		(diff_list = sortcar(diff_list 
			'lessp
		    ))
		(radial_lock_angle = cadar(diff_list)) 
		(init_spin_angle = (radial_lock_angle - object_rotation))
	    ) 
	    ("radial_short" 
		(object_rotation = (short_side_orientation + (obj_dbid->rotation))) 
		when((object_rotation > 360.0) 
		    (object_rotation = (object_rotation - 360.0))
		) 
		(diff_list = list(list(TBX_GEOM_Get_Vector_Angle_Difference(grid_angle object_rotation "min") grid_angle) 
			list(TBX_GEOM_Get_Vector_Angle_Difference((grid_angle + 180.0) object_rotation "min") 
			    (grid_angle + 180.0)
			)
		    )) 
		(diff_list = sortcar(diff_list 
			'lessp
		    ))
		(radial_lock_angle = cadar(diff_list)) 
		(init_spin_angle = (radial_lock_angle - object_rotation))
	    ) 
	    ("polar_lock" 
		(diff_list = list(list(TBX_GEOM_Get_Vector_Angle_Difference(grid_angle object_rotation "min") grid_angle) 
			list(TBX_GEOM_Get_Vector_Angle_Difference((grid_angle + 90.0) object_rotation "min") 
			    (grid_angle + 90.0)
			) 
			list(TBX_GEOM_Get_Vector_Angle_Difference((grid_angle + 180.0) object_rotation "min") 
			    (grid_angle + 180.0)
			) 
			list(TBX_GEOM_Get_Vector_Angle_Difference((grid_angle + 270.0) object_rotation "min") 
			    (grid_angle + 270.0)
			)
		    )) 
		(diff_list = sortcar(diff_list 
			'lessp
		    )) 
		(radial_lock_angle = cadar(diff_list)) 
		(init_spin_angle = (radial_lock_angle - object_rotation))
	    ) 
	    ("retain_relative" 
		(last_angle = TBX_GEOM_Get_Vector_Angle((cur_polargrid->origin) 
			(current->sourceOrigin)
		    )) 
		(init_spin_angle = (grid_angle - last_angle))
	    )
	    ("absolute" 
		(angle = atof((axlFormGetField form_handle "angle_value"))) 
		(init_spin_angle = (angle - object_rotation))
	    ) 
	    ("incremental" 
		(init_spin_angle = 0.0)
	    )
	) 
	(init_spin_angle = TBX_GEOM_Round(init_spin_angle "absolute" 1))
	init_spin_angle
    )
)
procedure(TBX_POLARGRID_PLACE_Callback(form_handle) 
    let((angle_incr) 
	case((form_handle->curField) 
	    ("snap_coarse_grid" 
		TBX_POLARGRID_Set_Snap_Options(form_handle "coarse")
	    ) 
	    ("snap_fine_grid" 
		TBX_POLARGRID_Set_Snap_Options(form_handle "fine")
	    ) 
	    ("snap_system_grid" 
		TBX_POLARGRID_Set_Snap_Options(form_handle "system")
	    ) 
	    ("toggle_coarse_grid" 
		TBX_POLARGRID_Toggle_Grid_Display(form_handle "coarse")
	    )
	    ("toggle_fine_grid" 
		TBX_POLARGRID_Toggle_Grid_Display(form_handle "fine")
	    ) 
	    ("toggle_system_grid" 
		TBX_POLARGRID_Toggle_Grid_Display(form_handle "system")
	    ) 
	    ("coarse_style" 
		TBX_POLARGRID_Update_Grid_Display_Style(form_handle "coarse")
	    ) 
	    ("fine_style" 
		TBX_POLARGRID_Update_Grid_Display_Style(form_handle "fine")
	    ) 
	    ("place_only" 
		(axlFormBuildPopup form_handle "rotation_type" 
		    (tbx_polargrid_data->rotationPopup)["place_only"]
		) 
		(axlFormSetField form_handle "rotation_type" 
		    (tbx_polargrid_data->lastRotationType)["place_only"]
		) 
		TBX_POLARGRID_PLACE_Update_Form(form_handle)
	    )
	    ("place_and_spin" 
		(axlFormBuildPopup form_handle "rotation_type" 
		    (tbx_polargrid_data->rotationPopup)["place_and_spin"]
		) 
		(axlFormSetField form_handle "rotation_type" 
		    (tbx_polargrid_data->lastRotationType)["place_and_spin"]
		) 
		TBX_POLARGRID_PLACE_Update_Form(form_handle)
	    ) 
	    ("spin_only" 
		(axlFormBuildPopup form_handle "rotation_type" 
		    (tbx_polargrid_data->rotationPopup)["spin_only"]
		) 
		(axlFormSetField form_handle "rotation_type" 
		    (tbx_polargrid_data->lastRotationType)["spin_only"]
		) 
		TBX_POLARGRID_PLACE_Update_Form(form_handle)
	    ) 
	    ("rotation_type" 
		cond(((axlFormGetField form_handle "place_only") 
			((tbx_polargrid_data->lastRotationType)["place_only"] = (form_handle->curValue))
		    ) 
		    ((axlFormGetField form_handle "place_and_spin") 
			((tbx_polargrid_data->lastRotationType)["place_and_spin"] = (form_handle->curValue))
		    ) 
		    ((axlFormGetField form_handle "spin_only") 
			((tbx_polargrid_data->lastRotationType)["spin_only"] = (form_handle->curValue))
		    )
		) 
		TBX_POLARGRID_PLACE_Update_Form(form_handle)
	    ) 
	    ("angle_value" 
		if(atof((form_handle->curValue)) then 
		    if(((axlFormGetField form_handle "rotation_type") == "absolute") then 
			(axlSetDynamicsRotation 
			    atof((form_handle->curValue))
			) else 
			(angle_incr = atof((form_handle->curValue)))
			(axlSetRotateIncrement ?angular angle_incr)
		    ) else 
		    printf("Warning: Invalid value\n")
		    (axlFormSetField form_handle "angle_value" "0")
		)
	    ) 
	    ("symbol_origin" 
		when((car((tbx_polargrid_data->partStack)) && ((tbx_polargrid_data->runtime)->sourceOrigin)) 
		    (axlTransformObject 
			car((tbx_polargrid_data->partStack)) ?move 
			(0.0:0.0)
		    ) 
		    ((tbx_polargrid_data->runtime)->sourceOrigin = TBX_POLARGRID_PLACE_Symbol_Alt_Origin(form_handle 
			    car((tbx_polargrid_data->partStack))
			)) 
		    TBX_POLARGRID_PLACE_Build_Dynamics(car((tbx_polargrid_data->partStack)) 
			((tbx_polargrid_data->runtime)->sourceOrigin) 
			((tbx_polargrid_data->runtime)->ratInfo)
		    )
		)
	    )
	    ("symbol_center" 
		when((car((tbx_polargrid_data->partStack)) && ((tbx_polargrid_data->runtime)->sourceOrigin)) 
		    (axlTransformObject 
			car((tbx_polargrid_data->partStack)) ?move 
			(0.0:0.0)
		    ) 
		    ((tbx_polargrid_data->runtime)->sourceOrigin = TBX_POLARGRID_PLACE_Symbol_Alt_Origin(form_handle 
			    car((tbx_polargrid_data->partStack))
			)) 
		    TBX_POLARGRID_PLACE_Build_Dynamics(car((tbx_polargrid_data->partStack)) 
			((tbx_polargrid_data->runtime)->sourceOrigin) 
			((tbx_polargrid_data->runtime)->ratInfo)
		    )
		)
	    ) 
	    ("done" 
		(axlFinishEnterFun) 
		(axlFormClose form_handle) 
		(axlClearDynamics) 
		(axlUIPopupSet nil)
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_POLARGRID_PLACE_Event_Loop(form_handle) 
    let((eventMask loop event) 
	(form_handle = form_handle) 
	(axlEventSetStartPopup 
	    'TBX_POLARGRID_PLACE_Popup
	) 
	(eventMask = list('PICK)) 
	(loop = t)
	(axlClearSelSet) 
	(tbx_polargrid_data->transMark = (axlDBTransactionStart)) 
	((tbx_polargrid_data->eventHandler)->selectPart = t) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil 
		    (tbx_polargrid_data->systemGridSnap)
		)) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(PICK 
		    if(((tbx_polargrid_data->eventHandler)->dummyPick) then 
			((tbx_polargrid_data->eventHandler)->dummyPick = nil) 
			when((car((tbx_polargrid_data->partStack)) && ((tbx_polargrid_data->runtime)->sourceOrigin)) 
			    TBX_POLARGRID_PLACE_Build_Dynamics(car((tbx_polargrid_data->partStack)) 
				((tbx_polargrid_data->runtime)->sourceOrigin) 
				((tbx_polargrid_data->runtime)->ratInfo)
			    )
			) else
			TBX_POLARGRID_PLACE_Process(form_handle 
			    (event->xy) 
			    (event->xySnap)
			)
		    )
		) 
		(DONE 
		    (axlDBTransactionCommit 
			(tbx_polargrid_data->transMark)
		    ) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    (loop = nil)
		) 
		(CANCEL 
		    (axlDBTransactionRollback 
			(tbx_polargrid_data->transMark)
		    ) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    (loop = nil)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_POLARGRID_PLACE_Popup(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Oops" 
			'TBX_POLARGRID_PLACE_Popup_Oops
		    ) 
		    list("Next" 
			'TBX_POLARGRID_PLACE_Popup_Next
		    ) 
		    list("Done" 
			'TBX_POLARGRID_PLACE_Popup_Done
		    ) 
		    list("Cancel" 
			'TBX_POLARGRID_PLACE_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_POLARGRID_PLACE_Popup_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_POLARGRID_PLACE_Popup_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_POLARGRID_PLACE_Popup_Next() 
    (axlDBTransactionCommit 
	(tbx_polargrid_data->transMark)
    ) 
    (axlClearDynamics) 
    (tbx_polargrid_data->runtime = ncons(nil)) 
    (tbx_polargrid_data->transMark = (axlDBTransactionStart))
)
procedure(TBX_POLARGRID_PLACE_Popup_Oops() 
    (axlDBTransactionOops 
	(tbx_polargrid_data->transMark)
    ) 
    when(car((tbx_polargrid_data->partStack)) 
	(axlClearDynamics) 
	(axlTransformObject 
	    car((tbx_polargrid_data->partStack)) ?move 
	    (0.0:0.0)
	) 
	(tbx_polargrid_data->runtime = ncons(nil)) 
	((tbx_polargrid_data->eventHandler)->selectPart = t)
	(axlVisibleUpdate t)
    )
)
procedure(TBX_POLARGRID_PLACE_Process(form_handle event_xy event_xySnap) 
    let((cur_polargrid sym_dbid ref_location result grid_xy
	    snap_status dx dy init_spin_angle sym_type
	) 
	cond((((tbx_polargrid_data->eventHandler)->selectPart) 
		(axlClearSelSet) 
		(axlSetFindFilter ?enabled 
		    list("noall" "symbols") ?onButtons 
		    list("all")
		) 
		(axlSingleSelectPoint event_xy) 
		when((axlGetSelSet) 
		    (sym_type = upperCase((car((axlGetSelSet))->type))) 
		    (sym_dbid = car((axlGetSelSet))) 
		    cond((((sym_type == "FORMAT") && (((sym_dbid->definition)->prop)->TBX_POLARGRID_RADIAL)) 
			    printf("Here we go\n") 
			    (axlClearSelSet)
			) 
			(((sym_type == "PACKAGE") || (sym_type == "MECHANICAL")) 
			    if(((((axlDBIsFixed sym_dbid)->objType) == "component") || 
				    (((axlDBIsFixed sym_dbid)->objType) == "symbol")) then 
				printf("Warning: Invalid selection, element is fixed.\n") 
				(axlClearSelSet) else
				(tbx_polargrid_data->partStack = nil) 
				(cur_polargrid = TBX_POLARGRID_Get_Active_Polargrid(event_xy 
					(tbx_polargrid_data->dbGridInst)
				    )) 
				(ref_location = TBX_POLARGRID_PLACE_Symbol_Alt_Origin(form_handle sym_dbid)) 
				(result = TBX_POLARGRID_Get_Ratsnest_Info(sym_dbid)) 
				((tbx_polargrid_data->runtime)->ratInfo = car(result))
				((tbx_polargrid_data->runtime)->netInfo = cadr(result)) 
				if((axlFormGetField form_handle "spin_only") then 
				    if(cur_polargrid then 
					(init_spin_angle = 0.0) 
					when(cur_polargrid 
					    (init_spin_angle = TBX_POLARGRID_PLACE_Calculate_Init_Spin_Angle(form_handle sym_dbid ref_location cur_polargrid nil))
					) 
					when((init_spin_angle != 0.0) 
					    (sym_dbid = (axlTransformObject sym_dbid ?angle init_spin_angle ?origin
						    ref_location
						)) 
					    (axlDBRefreshId nil) 
					    (axlClearDynamics)
					)
					(sym_dbid = TBX_POLARGRID_PLACE_Spin_Object(form_handle sym_dbid ref_location 
						((tbx_polargrid_data->runtime)->ratInfo) 
						((tbx_polargrid_data->runtime)->netInfo)
					    )) else 
					printf("Warning: Pick not within the boundary of a polargrid symbol.\n")
				    ) 
				    TBX_POLARGRID_PLACE_Rat_Visibility_Control(((tbx_polargrid_data->runtime)->netInfo) "reset") 
				    ((tbx_polargrid_data->eventHandler)->selectPart = t)
				    (tbx_polargrid_data->runtime = ncons(nil)) else 
				    ((tbx_polargrid_data->eventHandler)->selectDestination = t) 
				    ((tbx_polargrid_data->eventHandler)->selectPart = nil) 
				    ((tbx_polargrid_data->runtime)->sourcePick = event_xy)
				    ((tbx_polargrid_data->runtime)->sourceOrigin = ref_location) 
				    (tbx_polargrid_data->partStack = cons(sym_dbid 
					    (tbx_polargrid_data->partStack)
					)) 
				    TBX_POLARGRID_PLACE_Rat_Visibility_Control(((tbx_polargrid_data->runtime)->netInfo) "set") 
				    TBX_POLARGRID_PLACE_Build_Dynamics(sym_dbid ref_location 
					((tbx_polargrid_data->runtime)->ratInfo)
				    )
				)
			    )
			)
		    )
		)
	    ) 
	    (((tbx_polargrid_data->eventHandler)->selectDestination) 
		(cur_polargrid = TBX_POLARGRID_Get_Active_Polargrid(event_xy 
			(tbx_polargrid_data->dbGridInst)
		    )) 
		(axlDBTransactionMark 
		    (tbx_polargrid_data->transMark)
		) 
		(result = TBX_POLARGRID_Snap_Polar(form_handle cur_polargrid event_xy event_xySnap)) 
		(grid_xy = car(result))
		(snap_status = cadr(result)) 
		(snap_status = snap_status) 
		if(((axlFormGetField form_handle "place_only") || 
			(axlFormGetField form_handle "place_and_spin")) then 
		    (sym_dbid = car((tbx_polargrid_data->partStack))) 
		    (dx = (car(grid_xy) - car(((tbx_polargrid_data->runtime)->sourceOrigin)))) 
		    (dy = (cadr(grid_xy) - cadr(((tbx_polargrid_data->runtime)->sourceOrigin))))
		    (init_spin_angle = 0.0) 
		    when(cur_polargrid 
			(init_spin_angle = TBX_POLARGRID_PLACE_Calculate_Init_Spin_Angle(form_handle sym_dbid grid_xy cur_polargrid 
				(tbx_polargrid_data->runtime)
			    ))
		    ) 
		    (sym_dbid = (axlTransformObject sym_dbid ?move 
			    (dx:dy)
			)) 
		    when((init_spin_angle != 0.0) 
			(sym_dbid = (axlTransformObject sym_dbid ?angle init_spin_angle ?origin
				grid_xy
			    ))
		    ) 
		    if((axlFormGetField form_handle "place_only") then t else 
			(sym_dbid = TBX_POLARGRID_PLACE_Spin_Object(form_handle sym_dbid grid_xy 
				((tbx_polargrid_data->runtime)->ratInfo) 
				((tbx_polargrid_data->runtime)->netInfo)
			    ))
		    )
		    else t
		) 
		TBX_POLARGRID_PLACE_Rat_Visibility_Control(((tbx_polargrid_data->runtime)->netInfo) "reset") 
		((tbx_polargrid_data->eventHandler)->selectPart = t)
		((tbx_polargrid_data->eventHandler)->selectDestination = nil) 
		(tbx_polargrid_data->runtime = ncons(nil)) 
		(axlClearSelSet) 
		(axlClearDynamics) 
		(axlDBRefreshId nil)
		(axlVisibleUpdate t)
	    )
	) t
    )
)
procedure(TBX_POLARGRID_PLACE_Rat_Visibility_Control(net_info mode) 
    let((net_dbid rat_visible) 
	case(mode 
	    ("set" 
		foreach(entry net_info 
		    (net_dbid = car(entry)) 
		    (axlRatsnestBlank net_dbid)
		)
	    ) 
	    ("reset" 
		foreach(entry net_info 
		    (rat_visible = cadr(entry)) 
		    when(rat_visible 
			(net_dbid = car(entry)) 
			(axlRatsnestDisplay net_dbid)
		    )
		)
	    )
	) 
	(axlDBRefreshId nil)
    )
)
procedure(TBX_POLARGRID_PLACE_Spin_Object(form_handle obj_dbid ref_location ratInfo netInfo) 
    let((obj_dbid_mod angle angle_incr) 
	(obj_dbid_mod = obj_dbid) 
	TBX_POLARGRID_PLACE_Rat_Visibility_Control(netInfo "set") 
	case((axlFormGetField form_handle "rotation_type") 
	    ("incremental" 
		(angle_incr = atof((axlFormGetField form_handle "angle_value"))) 
		TBX_POLARGRID_PLACE_Build_Dynamics(obj_dbid ref_location ratInfo) 
		(axlSetRotateIncrement ?angular angle_incr) 
		(angle = (axlEnterAngle ref_location ?lockAngle angle_incr))
		(obj_dbid_mod = (axlTransformObject obj_dbid ?angle angle ?origin
			ref_location
		    )) 
		(axlClearDynamics)
	    ) 
	    ("polar_lock" 
		(angle_incr = 90.0) 
		TBX_POLARGRID_PLACE_Build_Dynamics(obj_dbid ref_location ratInfo) 
		(axlSetRotateIncrement ?angular angle_incr) 
		(angle = (axlEnterAngle ref_location ?lockAngle angle_incr))
		(obj_dbid_mod = (axlTransformObject obj_dbid ?angle angle ?origin
			ref_location
		    )) 
		(axlClearDynamics)
	    )
	) obj_dbid_mod
    )
)
procedure(TBX_POLARGRID_PLACE_Symbol_Alt_Origin(form_handle sym_dbid) 
    let((sym_xy) 
	cond(((axlFormGetField form_handle "symbol_origin") 
		(sym_xy = (axlDBAltOrigin 
			'origin sym_dbid
		    ))
	    ) 
	    ((axlFormGetField form_handle "symbol_center") 
		(sym_xy = (axlDBAltOrigin 
			'center sym_dbid
		    ))
	    ) 
	    (t 
		(sym_xy = (sym_dbid->xy))
	    )
	) sym_xy
    )
)
procedure(TBX_POLARGRID_PLACE_Update_Form(form_handle) 
    let((a) 
	(a = a) 
	case((axlFormGetField form_handle "rotation_type") 
	    ("radial_long" 
		(axlFormSetFieldEditable form_handle "angle_value" nil)
	    ) 
	    ("radial_short" 
		(axlFormSetFieldEditable form_handle "angle_value" nil)
	    ) 
	    ("retain_relative" 
		(axlFormSetFieldEditable form_handle "angle_value" nil)
	    ) 
	    ("polar_lock" 
		(axlFormSetFieldEditable form_handle "angle_value" nil)
	    )
	    ("absolute" 
		(axlFormSetFieldEditable form_handle "angle_value" t) 
		unless(atof((axlFormGetField form_handle "angle_value")) 
		    (axlFormSetField form_handle "angle_value" 0) 
		    (axlSetDynamicsRotation 0.0)
		)
	    ) 
	    ("incremental" 
		(axlFormSetFieldEditable form_handle "angle_value" t) 
		unless(atof((axlFormGetField form_handle "angle_value")) 
		    (axlFormSetField form_handle "angle_value" 45.0) 
		    (axlSetDynamicsRotation 0.0)
		)
	    )
	)
    )
)
procedure(TBX_POLARGRID_Parse_Grid_Properties(symdef) 
    let((arr design_units angle_start angle_end angle_step
	    angle_multiplier config_units radius_start radius_end radius_step
	    radius_multiplier grid_param
	) 
	(design_units = car((axlDBGetDesignUnits))) 
	(arr = parseString(((symdef->prop)->TBX_POLARGRID_ANGULAR) "|")) 
	(angle_start = atof(car(arr))) 
	(angle_end = atof(cadr(arr)))
	(angle_step = atof(caddr(arr))) 
	(angle_multiplier = atoi(nth(3 arr))) 
	(arr = parseString(((symdef->prop)->TBX_POLARGRID_RADIAL) "|")) 
	(config_units = car(arr)) 
	(radius_start = (axlMKSConvert 
		atof(cadr(arr)) config_units design_units
	    ))
	(radius_end = (axlMKSConvert 
		atof(caddr(arr)) config_units design_units
	    )) 
	(radius_step = (axlMKSConvert 
		atof(nth(3 arr)) config_units design_units
	    )) 
	(radius_multiplier = atoi(nth(4 arr))) 
	(grid_param = list(nil 
		'angleStart angle_start 
		'angleEnd angle_end
		'angleStep angle_step 
		'angleMultiplier angle_multiplier 
		'radiusStart
		radius_start 
		'radiusEnd radius_end 
		'radiusStep radius_step
		'radiusMultiplier radius_multiplier 
		'name 
		upperCase((symdef->name))
	    )) grid_param
    )
)
procedure(TBX_POLARGRID_ROUTE_Callback(form_handle) 
    let((cur_class cur_subclass) 
	case((form_handle->curField) 
	    ("class_name" 
		(axlBuildSubclassPopup form_handle "subclass_name" 
		    (form_handle->curValue)
		) 
		(cur_subclass = car((axlSubclasses 
			    (form_handle->curValue)
			)
		    )) 
		(axlFormSetField form_handle "subclass_name" cur_subclass) 
		(axlDBControl 
		    'activeLayer 
		    strcat((form_handle->curValue) "/" cur_subclass)
		)
		TBX_POLARGRID_Build_Dynamics("route" form_handle 
		    (tbx_polargrid_data->pathStack)
		)
	    ) 
	    ("subclass_name" 
		(cur_class = (axlFormGetField form_handle "class_name")) 
		(axlDBControl 
		    'activeLayer 
		    strcat(cur_class "/" 
			(form_handle->curValue)
		    )
		) 
		TBX_POLARGRID_Build_Dynamics("route" form_handle 
		    (tbx_polargrid_data->pathStack)
		)
	    ) 
	    ("line_width" 
		TBX_POLARGRID_Build_Dynamics("route" form_handle 
		    (tbx_polargrid_data->pathStack)
		)
	    ) 
	    ("snap_coarse_grid" 
		TBX_POLARGRID_Set_Snap_Options(form_handle "coarse")
	    )
	    ("snap_fine_grid" 
		TBX_POLARGRID_Set_Snap_Options(form_handle "fine") 
		TBX_POLARGRID_Build_Dynamics("route" form_handle 
		    (tbx_polargrid_data->pathStack)
		)
	    ) 
	    ("snap_system_grid" 
		TBX_POLARGRID_Set_Snap_Options(form_handle "system") 
		TBX_POLARGRID_Build_Dynamics("route" form_handle 
		    (tbx_polargrid_data->pathStack)
		)
	    ) 
	    ("toggle_coarse_grid" 
		TBX_POLARGRID_Toggle_Grid_Display(form_handle "coarse")
	    ) 
	    ("toggle_fine_grid" 
		TBX_POLARGRID_Toggle_Grid_Display(form_handle "fine")
	    ) 
	    ("toggle_system_grid" 
		TBX_POLARGRID_Toggle_Grid_Display(form_handle "system")
	    )
	    ("coarse_style" 
		TBX_POLARGRID_Update_Grid_Display_Style(form_handle "coarse")
	    ) 
	    ("fine_style" 
		TBX_POLARGRID_Update_Grid_Display_Style(form_handle "fine")
	    ) 
	    ("follow_contour" 
		TBX_POLARGRID_ROUTE_Update_Form(form_handle) 
		TBX_POLARGRID_ROUTE_Set_Line_Lock(form_handle) 
		TBX_POLARGRID_Build_Dynamics("route" form_handle 
		    (tbx_polargrid_data->pathStack)
		)
	    ) 
	    ("lock_mode" 
		if(((form_handle->curValue) == "line") then 
		    (axlFormSetField form_handle "corner_label" "Miter:") else 
		    (axlFormSetField form_handle "corner_label" "Radius")
		) 
		TBX_POLARGRID_ROUTE_Set_Line_Lock(form_handle)
	    ) 
	    ("lock_angle" 
		case((form_handle->curValue) 
		    ("0" 
			(axlFormSetFieldEditable form_handle "corner_size" nil) 
			(axlFormSetFieldEditable form_handle "corner_mode" nil)
		    ) 
		    ("45" 
			(axlFormSetFieldEditable form_handle "corner_size" t) 
			(axlFormSetFieldEditable form_handle "corner_mode" t)
		    ) 
		    ("90" 
			if(((axlFormGetField form_handle "lock_mode") == "line") then 
			    (axlFormSetFieldEditable form_handle "corner_size" nil) 
			    (axlFormSetFieldEditable form_handle "corner_mode" nil) else
			    (axlFormSetFieldEditable form_handle "corner_size" t) 
			    (axlFormSetFieldEditable form_handle "corner_mode" t)
			)
		    )
		) 
		TBX_POLARGRID_ROUTE_Set_Line_Lock(form_handle)
	    )
	    ("corner_size" 
		TBX_POLARGRID_ROUTE_Set_Line_Lock(form_handle)
	    ) 
	    ("corner_mode" 
		TBX_POLARGRID_ROUTE_Set_Line_Lock(form_handle)
	    ) 
	    ("done" 
		(axlFinishEnterFun) 
		(axlFormClose form_handle) 
		(axlClearDynamics) 
		(axlUIPopupSet nil)
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_POLARGRID_ROUTE_Construct_Angular_Path(cur_angle ref_angle rpath end_xy center_xy
	arc_type line_width
    ) 
    let((angle_diff_ccw rpath_arc) 
	(angle_diff_ccw = TBX_GEOM_Get_Vector_Angle_Difference(ref_angle cur_angle "ccw")) 
	if((angle_diff_ccw > 180.0) then 
	    case(lowerCase(arc_type) 
		("small_arc" 
		    (rpath_arc = (axlPathArcCenter rpath line_width end_xy t
			    center_xy
			))
		) 
		("big_arc" 
		    (rpath_arc = (axlPathArcCenter rpath line_width end_xy nil
			    center_xy
			))
		) 
		(t 
		    (rpath_arc = (axlPathArcCenter rpath line_width end_xy t
			    center_xy
			))
		)
	    ) else 
	    case(lowerCase(arc_type) 
		("small_arc" 
		    (rpath_arc = (axlPathArcCenter rpath line_width end_xy nil
			    center_xy
			))
		) 
		("big_arc" 
		    (rpath_arc = (axlPathArcCenter rpath line_width end_xy t
			    center_xy
			))
		) 
		(t 
		    (rpath_arc = (axlPathArcCenter rpath line_width end_xy nil
			    center_xy
			))
		)
	    )
	) rpath_arc
    )
)
procedure(TBX_POLARGRID_ROUTE_Event_Loop(form_handle) 
    let((eventMask loop event cur_polargrid result
	    pt_xy ok_polar_snap rpath
	) 
	(form_handle = form_handle) 
	(axlEventSetStartPopup 
	    'TBX_POLARGRID_ROUTE_Popup
	) 
	(eventMask = list('PICK)) 
	(loop = t)
	(tbx_polargrid_data->transMark = (axlDBTransactionStart)) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil 
		    (tbx_polargrid_data->systemGridSnap)
		)) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(PICK 
		    if(((tbx_polargrid_data->eventHandler)->dummyPick) then 
			((tbx_polargrid_data->eventHandler)->dummyPick = nil) else 
			(cur_polargrid = TBX_POLARGRID_Get_Active_Polargrid((event->xy) 
				(tbx_polargrid_data->dbGridInst)
			    ))
			(result = TBX_POLARGRID_ROUTE_Snap_Wrapper(form_handle cur_polargrid 
				(event->xy) 
				(event->xySnap)
			    )) 
			(pt_xy = car(result)) 
			(ok_polar_snap = cadr(result)) 
			((tbx_polargrid_data->runtime)->netName = caddr(result)) 
			((tbx_polargrid_data->runtime)->seg2Split = nth(3 result))
			TBX_POLARGRID_ROUTE_Highlight_Net(((tbx_polargrid_data->runtime)->netName) t) 
			if(!(tbx_polargrid_data->pathStack) then 
			    (rpath = (axlPathStart 
				    list(pt_xy) 0.0
				)) 
			    (tbx_polargrid_data->pathStack = list(list(nil 
					'path rpath 
					'polarMode nil
				    )
				)) else
			    ((tbx_polargrid_data->runtime)->curPathData = TBX_POLARGRID_Determine_Path("route" form_handle cur_polargrid pt_xy ok_polar_snap
				    (tbx_polargrid_data->pathStack)
				)) 
			    when(((tbx_polargrid_data->runtime)->curPathData) 
				(axlDBTransactionMark 
				    (tbx_polargrid_data->transMark)
				) 
				(result = (axlDBCreatePath 
					(car(((tbx_polargrid_data->runtime)->curPathData))->path) 
					(axlDBControl 
					    'activeLayer
					)
				    )) 
				((tbx_polargrid_data->runtime)->curDbid = caar(result)) 
				(tbx_polargrid_data->pathStack = cons(car(((tbx_polargrid_data->runtime)->curPathData)) 
					(tbx_polargrid_data->pathStack)
				    ))
			    )
			) 
			when(((tbx_polargrid_data->runtime)->seg2Split) 
			    TBX_POLARGRID_ROUTE_Split_Path(((tbx_polargrid_data->runtime)->seg2Split) pt_xy)
			)
		    ) 
		    TBX_POLARGRID_Build_Dynamics("route" form_handle 
			(tbx_polargrid_data->pathStack)
		    )
		) 
		(DONE 
		    (axlDBTransactionCommit 
			(tbx_polargrid_data->transMark)
		    ) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    TBX_POLARGRID_ROUTE_Highlight_Net(((tbx_polargrid_data->runtime)->netName) nil)
		    (loop = nil)
		) 
		(CANCEL 
		    (axlDBTransactionRollback 
			(tbx_polargrid_data->transMark)
		    ) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    (loop = nil)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_POLARGRID_ROUTE_Highlight_Net(net_name mode) 
    let((net_dbid) 
	when(net_name 
	    (net_dbid = (axlSelectByName "NET" net_name))
	) 
	if(mode then 
	    when((net_dbid && !(axlIsHighlighted net_dbid)) 
		((tbx_polargrid_data->runtime)->netHighlighted = t) 
		(axlHighlightObject net_dbid)
	    ) else 
	    when((net_dbid && !(axlIsHighlighted net_dbid) && 
		    ((tbx_polargrid_data->runtime)->netHighlighted)) 
		((tbx_polargrid_data->runtime)->netHighlighted = nil) 
		(axlDehighlightObject net_dbid)
	    )
	)
    )
)
procedure(TBX_POLARGRID_ROUTE_Popup(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Oops" 
			'TBX_POLARGRID_ROUTE_Popup_Oops
		    ) 
		    list("Toggle current" 
			'TBX_POLARGRID_ROUTE_Popup_Toggle
		    ) 
		    list("Add via" 
			'TBX_POLARGRID_ROUTE_Popup_Add_Via
		    ) 
		    list("Next" 
			'TBX_POLARGRID_ROUTE_Popup_Next
		    ) 
		    list("Done" 
			'TBX_POLARGRID_ROUTE_Popup_Done
		    )
		    list("Cancel" 
			'TBX_POLARGRID_ROUTE_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_POLARGRID_ROUTE_Popup_Add_Via() 
    let((via_name seg_info via_xy net_name) 
	(via_name = (axlFormGetField 
		(tbx_polargrid_data->formid) "via_name"
	    )) 
	when(via_name 
	    (seg_info = TBX_POLARGRID_Get_Last_Seg_Info((car(((tbx_polargrid_data->runtime)->curPathData))->path))) 
	    (via_xy = (seg_info->endPoint)) 
	    (net_name = ((tbx_polargrid_data->runtime)->netName)) 
	    (axlDBCreateVia via_name via_xy net_name)
	) t
    )
)
procedure(TBX_POLARGRID_ROUTE_Popup_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_POLARGRID_ROUTE_Popup_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_POLARGRID_ROUTE_Popup_Next() 
    (axlDBTransactionCommit 
	(tbx_polargrid_data->transMark)
    ) 
    (axlClearDynamics) 
    (tbx_polargrid_data->pathStack = nil) 
    TBX_POLARGRID_ROUTE_Highlight_Net(((tbx_polargrid_data->runtime)->netName) nil)
    TBX_POLARGRID_Build_Dynamics("route" 
	(tbx_polargrid_data->formid) 
	(tbx_polargrid_data->pathStack)
    ) 
    (tbx_polargrid_data->runtime = ncons(nil)) 
    (tbx_polargrid_data->transMark = (axlDBTransactionStart))
)
procedure(TBX_POLARGRID_ROUTE_Popup_Oops() 
    (axlDBTransactionOops 
	(tbx_polargrid_data->transMark)
    ) 
    (tbx_polargrid_data->pathStack = cdr((tbx_polargrid_data->pathStack))) 
    TBX_POLARGRID_Build_Dynamics("route" 
	(tbx_polargrid_data->formid) 
	(tbx_polargrid_data->pathStack)
    )
)
procedure(TBX_POLARGRID_ROUTE_Popup_Toggle() 
    let((first_entry result) 
	when((length(((tbx_polargrid_data->runtime)->curPathData)) > 1) 
	    (axlDeleteObject 
		((tbx_polargrid_data->runtime)->curDbid)
	    ) 
	    (first_entry = car(((tbx_polargrid_data->runtime)->curPathData))) 
	    ((tbx_polargrid_data->runtime)->curPathData = cdr(((tbx_polargrid_data->runtime)->curPathData))) 
	    ((tbx_polargrid_data->runtime)->curPathData = append1(((tbx_polargrid_data->runtime)->curPathData) first_entry))
	    (tbx_polargrid_data->pathStack = cdr((tbx_polargrid_data->pathStack))) 
	    (tbx_polargrid_data->pathStack = cons(car(((tbx_polargrid_data->runtime)->curPathData)) 
		    (tbx_polargrid_data->pathStack)
		)) 
	    foreach(pe 
		cdr(reverse((tbx_polargrid_data->pathStack))) 
		(result = (axlDBCreatePath 
			(pe->path) 
			(axlDBControl 
			    'activeLayer
			)
		    ))
	    ) 
	    when(result 
		((tbx_polargrid_data->runtime)->curDbid = caar(result))
	    )
	)
    )
)
procedure(TBX_POLARGRID_ROUTE_Set_Line_Lock(form_handle) 
    let((corner_size) 
	if((axlFormGetField form_handle "follow_contour") then 
	    (axlSetLineLock ?arcEnable nil ?lockAngle 0
		?fixed45 nil
	    ) else 
	    if(((axlFormGetField form_handle "lock_mode") == "line") then 
		case((axlFormGetField form_handle "lock_angle") 
		    ("0" 
			(axlSetLineLock ?arcEnable nil ?lockAngle 0
			    ?fixed45 nil
			)
		    ) 
		    ("45" 
			(corner_size = (axlFormGetField form_handle "corner_size")) 
			cond((((axlFormGetField form_handle "corner_mode") == "min") 
				(axlSetLineLock ?arcEnable nil ?lockAngle 45
				    ?length45 corner_size ?fixed45 nil
				)
			    ) 
			    (((axlFormGetField form_handle "corner_mode") == "fixed") 
				(axlSetLineLock ?arcEnable nil ?lockAngle 45
				    ?fixed45 t ?length45 corner_size
				)
			    )
			)
		    ) 
		    ("90" 
			(axlSetLineLock ?arcEnable nil ?lockAngle 90
			    ?fixed45 nil
			)
		    )
		) else 
		case((axlFormGetField form_handle "lock_angle") 
		    ("0" 
			(axlSetLineLock ?arcEnable t ?lockAngle 0
			    ?fixed45 nil
			)
		    ) 
		    ("45" 
			(corner_size = (axlFormGetField form_handle "corner_size")) 
			cond((((axlFormGetField form_handle "corner_mode") == "min") 
				(axlSetLineLock ?arcEnable t ?lockAngle 45
				    ?minRadius corner_size ?fixedRadius nil ?fixed45
				    nil
				)
			    ) 
			    (((axlFormGetField form_handle "corner_mode") == "fixed") 
				(axlSetLineLock ?arcEnable t ?lockAngle 45
				    ?lengthRadius corner_size ?fixedRadius t ?fixed45
				    nil
				)
			    )
			)
		    ) 
		    ("90" 
			(corner_size = (axlFormGetField form_handle "corner_size")) 
			cond((((axlFormGetField form_handle "corner_mode") == "min") 
				(axlSetLineLock ?arcEnable t ?lockAngle 90
				    ?minRadius corner_size ?fixedRadius nil ?fixed45
				    nil
				)
			    ) 
			    (((axlFormGetField form_handle "corner_mode") == "fixed") 
				(axlSetLineLock ?arcEnable t ?lockAngle 90
				    ?lengthRadius corner_size ?fixedRadius t ?fixed45
				    nil
				)
			    )
			)
		    )
		)
	    )
	) t
    )
)
procedure(TBX_POLARGRID_ROUTE_Snap_Wrapper(form_handle cur_polargrid event_xy event_xySnap) 
    let((active_class xy_corr net_name result1 result2
	    ok_polar_snap ret_data seg2split
	) 
	(xy_corr = event_xy) 
	(active_class = car(parseString((axlDBControl 
			'activeLayer
		    ) "/"
		)
	    )) 
	cond((((axlFormGetField form_handle "snap_connect_point") && 
		    ((axlMapClassName active_class t) == "ETCH")) 
		(result1 = TBX_POLARGRID_Snap_Object(event_xy)) 
		if(result1 then 
		    (xy_corr = car(result1)) 
		    (net_name = cadr(result1)) 
		    (seg2split = caddr(result1))
		    else 
		    (net_name = nil) 
		    (result2 = TBX_POLARGRID_Snap_Polar(form_handle cur_polargrid event_xy event_xySnap)) 
		    (xy_corr = car(result2)) 
		    (ok_polar_snap = cadr(result2))
		    (seg2split = nil)
		) 
		(ret_data = list(xy_corr ok_polar_snap net_name seg2split))
	    ) 
	    (t 
		(net_name = nil) 
		(result2 = TBX_POLARGRID_Snap_Polar(form_handle cur_polargrid event_xy event_xySnap)) 
		(xy_corr = car(result2)) 
		(ok_polar_snap = cadr(result2))
		(ret_data = list(xy_corr ok_polar_snap net_name seg2split))
	    )
	) ret_data
    )
)
procedure(TBX_POLARGRID_ROUTE_Split_Path(seg2split pt_xy) 
    let((rpath start_xy end_xy width layer
	    center isCw
	) 
	(start_xy = car((seg2split->startEnd))) 
	(end_xy = cadr((seg2split->startEnd))) 
	(width = (seg2split->width)) 
	(layer = (seg2split->layer))
	printf("Note: Splitting existing cline/line at %L\n" pt_xy) 
	case((seg2split->objType) 
	    ("line" 
		(rpath = (axlPathStart 
			list(start_xy pt_xy end_xy) width
		    )) 
		(axlDeleteObject seg2split) 
		(axlDBCreatePath rpath layer)
	    ) 
	    ("arc" 
		(isCw = (seg2split->isClockwise)) 
		(center = (seg2split->xy)) 
		(rpath = (axlPathStart 
			list(start_xy) width
		    )) 
		(rpath = (axlPathArcCenter rpath width pt_xy isCw
			center
		    ))
		(rpath = (axlPathArcCenter rpath width end_xy isCw
			center
		    )) 
		(axlDeleteObject seg2split) 
		(axlDBCreatePath rpath layer)
	    )
	) t
    )
)
procedure(TBX_POLARGRID_ROUTE_Update_Form(form_handle) 
    if((axlFormGetField form_handle "follow_contour") then 
	(axlFormSetFieldEditable form_handle "angular_mode" t) 
	(axlFormSetFieldEditable form_handle "radial_mode" t) 
	(axlFormSetFieldEditable form_handle "diagonal_mode" t)
	(axlFormSetFieldEditable form_handle "lock_mode" nil) 
	(axlFormSetFieldEditable form_handle "lock_angle" nil) 
	(axlFormSetFieldEditable form_handle "corner_size" nil) 
	(axlFormSetFieldEditable form_handle "corner_mode" nil) else
	(axlFormSetFieldEditable form_handle "angular_mode" nil) 
	(axlFormSetFieldEditable form_handle "radial_mode" nil) 
	(axlFormSetFieldEditable form_handle "diagonal_mode" nil) 
	(axlFormSetFieldEditable form_handle "lock_mode" t) 
	(axlFormSetFieldEditable form_handle "lock_angle" t)
	(axlFormSetFieldEditable form_handle "corner_size" t) 
	(axlFormSetFieldEditable form_handle "corner_mode" t)
    )
)
procedure(TBX_POLARGRID_Read_Grid_Symbols_From_Database() 
    let((cur_info symdef_list sym_name grid_param grid_instances
	    result
	) 
	(symdef_list = (axlSelectByProperty "symdef" "TBX_POLARGRID_ANGULAR")) 
	(grid_param = makeTable("grid_param_table" nil)) 
	(grid_instances = makeTable("grid_instances_table" nil)) 
	when(symdef_list 
	    foreach(sd symdef_list 
		(sym_name = upperCase((sd->name))) 
		(grid_param[sym_name] = TBX_POLARGRID_Parse_Grid_Properties(sd)) 
		foreach(si 
		    (sd->instances) 
		    (cur_info = list(nil 
			    'bBox 
			    (si->bBox) 
			    'origin 
			    (si->xy)
			    'mirror 
			    (si->isMirrored) 
			    'rotation 
			    (si->rotation) 
			    'dbid
			    si 
			    'name 
			    upperCase((sd->name))
			)) 
		    (grid_instances[sym_name] = cons(cur_info 
			    grid_instances[sym_name]
			))
		)
	    )
	)
	(result = list(grid_param grid_instances)) result
    )
)
procedure(TBX_POLARGRID_SETUP_Callback(form_handle) 
    let((sym_name loc_data loc_data_ok_fit origin_x origin_y
	    def_extents result
	) 
	case((form_handle->curField) 
	    ("angle_start" 
		TBX_POLARGRID_SETUP_Update_Preview(form_handle)
	    ) 
	    ("angle_end" 
		TBX_POLARGRID_SETUP_Update_Preview(form_handle)
	    ) 
	    ("angle_step" 
		TBX_POLARGRID_SETUP_Update_Preview(form_handle)
	    ) 
	    ("angle_multiplier" 
		TBX_POLARGRID_SETUP_Update_Preview(form_handle)
	    )
	    ("radius_start" 
		TBX_POLARGRID_SETUP_Update_Preview(form_handle)
	    ) 
	    ("radius_end" 
		TBX_POLARGRID_SETUP_Update_Preview(form_handle)
	    ) 
	    ("radius_step" 
		TBX_POLARGRID_SETUP_Update_Preview(form_handle)
	    ) 
	    ("radius_multiplier" 
		TBX_POLARGRID_SETUP_Update_Preview(form_handle)
	    ) 
	    ("origin_x" 
		((tbx_polargrid_data->runtime)->validX = t) 
		TBX_POLARGRID_SETUP_Update_Preview(form_handle)
	    )
	    ("origin_y" 
		((tbx_polargrid_data->runtime)->validY = t) 
		TBX_POLARGRID_SETUP_Update_Preview(form_handle)
	    ) 
	    ("pick_symbol" 
		((tbx_polargrid_data->eventHandler)->pickEditSymbol = t)
	    ) 
	    ("pick_origin" 
		((tbx_polargrid_data->eventHandler)->pickOrigin = t)
	    ) 
	    ("generate" 
		(sym_name = (axlFormGetField form_handle "symbol_name")) 
		if((sym_name && (sym_name != "")) then 
		    foreach(entry 
			(tbx_polargrid_data->curGridInst) 
			(axlDeleteObject 
			    (entry->dbid)
			)
		    ) 
		    (axlDBRefreshId nil) 
		    if(!(axlSelectByName "SYMTYPE" sym_name nil) then 
			if((length((tbx_polargrid_data->curGridInst)) > 1) then 
			    foreach(entry 
				(tbx_polargrid_data->curGridInst) 
				(loc_data = cons(list((entry->origin) 
					    (entry->rotation) 
					    (entry->mirror)
					) loc_data
				    ))
			    ) else 
			    (origin_x = (axlFormGetField form_handle "origin_x"))
			    (origin_y = (axlFormGetField form_handle "origin_y")) 
			    (loc_data = list(list((origin_x:origin_y) 0.0 nil)))
			) 
			foreach(loc loc_data 
			    (result = TBX_POLARGRID_SETUP_Check_Extents(form_handle loc)) 
			    when(result 
				(def_extents = caddr(result)) 
				(loc_data_ok_fit = cons(loc loc_data_ok_fit))
			    )
			) 
			when(def_extents 
			    TBX_POLARGRID_SETUP_Draw_Geometry(form_handle "final" def_extents loc_data_ok_fit nil) 
			    TBX_POLARGRID_SETUP_Init_Next(form_handle)
			)
			else 
			(axlUIConfirm "Symbol name already in use. Specify another name.")
		    )
		    else 
		    (axlUIConfirm "Specify valid symbol name")
		)
	    ) 
	    ("clear_preview" 
		(axlClearDynamics) 
		(axlVisibleLayer 
		    ((tbx_polargrid_data->sysLayer)->tmp) t
		) 
		(axlDeleteByLayer 
		    ((tbx_polargrid_data->sysLayer)->tmp) 
		    'fixed
		) 
		(axlVisibleUpdate t)
	    )
	    ("done" 
		foreach(entry 
		    (tbx_polargrid_data->curGridInst) 
		    (axlTransformObject 
			(entry->dbid) ?move 
			(0.0:0.0)
		    )
		) 
		(axlFinishEnterFun) 
		(axlFormClose form_handle) 
		(axlClearDynamics)
		(axlUIPopupSet nil)
	    ) 
	    ("myhelp" 
		TBX_HELP_Launch("polargrid")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_POLARGRID_SETUP_Check_Extents(form_handle loc_info) 
    let((PI start_x start_y end_x end_y
	    result origin rotation mirror angle_start
	    angle_end radius_end inst_extents def_extents def_extents_margin
	    lower_left upper_right def_lower_left def_upper_right ret_data
	    rpath offset offset_box
	) 
	(angle_start = (axlFormGetField form_handle "angle_start")) 
	(angle_end = (axlFormGetField form_handle "angle_end")) 
	(radius_end = (axlFormGetField form_handle "radius_end")) 
	(PI = ((tbx_polargrid_data->constants)->PI))
	(offset = ((tbx_polargrid_data->constants)->extentsMargin)) 
	(origin = car(loc_info)) 
	(rotation = cadr(loc_info)) 
	(mirror = caddr(loc_info)) 
	(rotation = rotation)
	(mirror = mirror) 
	(angle_start = ((angle_start / 360.0) * 2 * PI)) 
	(angle_end = ((angle_end / 360.0) * 2 * PI)) 
	(start_x = ((cos(angle_start) * radius_end) + car(origin))) 
	(start_y = ((sin(angle_start) * radius_end) + cadr(origin)))
	(end_x = ((cos(angle_end) * radius_end) + car(origin))) 
	(end_y = ((sin(angle_end) * radius_end) + cadr(origin))) 
	if(((axlGeo2Str 
		    (start_x:start_y)
		) == (axlGeo2Str 
		    (end_x:end_y)
		)) then 
	    (rpath = (axlPathStartCircle 
		    list(origin radius_end) 0.0
		)) else 
	    (rpath = (axlPathStart 
		    list(origin) 0.0
		))
	    (rpath = (axlPathLine rpath 0.0 
		    (start_x:start_y)
		)) 
	    (rpath = (axlPathArcCenter rpath 0.0 
		    (end_x:end_y) nil
		    origin
		)) 
	    (rpath = (axlPathLine rpath 0.0 origin))
	) 
	(result = (axlPolyFromDB rpath)) 
	if(result then 
	    (inst_extents = (car(result)->bBox)) 
	    (offset_box = list(((- offset):(- offset)) 
		    (offset:offset)
		)) 
	    (lower_left = car(inst_extents))
	    (upper_right = cadr(inst_extents)) 
	    (def_lower_left = ((car(lower_left) - car(origin)):(cadr(lower_left) - cadr(origin)))) 
	    (def_upper_right = ((car(upper_right) - car(origin)):(cadr(upper_right) - cadr(origin)))) 
	    (def_extents = list(def_lower_left def_upper_right)) 
	    (def_extents_margin = (bBoxAdd def_extents offset_box))
	    (ret_data = list(inst_extents def_extents def_extents_margin)) else 
	    printf("Warning: Geometry does not fit into design extents. Adjust parameters such as origin etc.\n") 
	    (ret_data = nil)
	)
	ret_data
    )
)
procedure(TBX_POLARGRID_SETUP_Draw_Geometry(form_handle mode def_extents loc_data hide_fine_grid) 
    let((PI symbol_name symdef ref_x ref_y
	    ref_xy_list cur_angle angle_start angle_end angle_step
	    angle_multiplier fine_angle fine_step radius_start radius_end
	    radius_step radius_multiplier radius_offset cur_radius fine_radius
	    start_x start_y end_x end_y rpath
	    marker_size prop_string_radial prop_string_angular result width_coarse
	    width_fine layer_coarse layer_fine angle_list radius_list
	    line_type sym_origin sym_rotation sym_mirror continue
	) 
	(PI = ((tbx_polargrid_data->constants)->PI)) 
	(radius_offset = ((tbx_polargrid_data->constants)->radiusOffset)) 
	(angle_start = (axlFormGetField form_handle "angle_start")) 
	(angle_end = (axlFormGetField form_handle "angle_end"))
	(angle_step = (axlFormGetField form_handle "angle_step")) 
	(angle_multiplier = (axlFormGetField form_handle "angle_multiplier")) 
	(radius_start = (axlFormGetField form_handle "radius_start")) 
	(radius_end = (axlFormGetField form_handle "radius_end")) 
	(radius_step = (axlFormGetField form_handle "radius_step"))
	(radius_multiplier = (axlFormGetField form_handle "radius_multiplier")) 
	(continue = t) 
	cond(((angle_end < angle_start) 
		(angle_end = (angle_end + 360.0))
	    ) 
	    ((angle_start == angle_end) 
		printf("Error: Start and end angle must not be equal. Cannot generate grid.\n") 
		(continue = nil)
	    )
	) 
	when(continue 
	    case(mode 
		("final" 
		    (symbol_name = (axlFormGetField form_handle "symbol_name")) 
		    (symdef = (axlDBCreateSymDefSkeleton 
			    list(symbol_name "format") def_extents
			)) 
		    (ref_xy_list = list((0.0:0.0))) 
		    (width_coarse = ((tbx_polargrid_data->constants)->lineWidthCoarse))
		    (width_fine = ((tbx_polargrid_data->constants)->lineWidthFine)) 
		    (layer_coarse = ((tbx_polargrid_data->sysLayer)->coarseLine)) 
		    (layer_fine = ((tbx_polargrid_data->sysLayer)->fineLine))
		) 
		("tmp" 
		    (symdef = nil) 
		    foreach(entry loc_data 
			(ref_xy_list = cons(car(entry) ref_xy_list))
		    ) 
		    (width_coarse = ((tbx_polargrid_data->constants)->lineWidthTmpCoarse)) 
		    (width_fine = ((tbx_polargrid_data->constants)->lineWidthTmpFine))
		    (layer_coarse = ((tbx_polargrid_data->sysLayer)->tmp)) 
		    (layer_fine = ((tbx_polargrid_data->sysLayer)->tmp))
		)
	    ) 
	    foreach(pt ref_xy_list 
		(ref_x = car(pt)) 
		(ref_y = cadr(pt)) 
		(marker_size = (radius_start / 10.0))
		when((marker_size < ((tbx_polargrid_data->constants)->orgMarkerRadius)) 
		    (marker_size = ((tbx_polargrid_data->constants)->orgMarkerRadius))
		) 
		(rpath = (axlPathStart 
			list(((ref_x - marker_size):ref_y) 
			    ((ref_x + marker_size):ref_y)
			) width_coarse
		    )) 
		(axlDBCreatePath rpath layer_coarse 
		    'line symdef
		) 
		(rpath = (axlPathStart 
			list((ref_x:(ref_y - marker_size)) 
			    (ref_x:(ref_y + marker_size))
			) width_coarse
		    )) 
		(axlDBCreatePath rpath layer_coarse 
		    'line symdef
		)
		(axlDBCreateCircle 
		    list((ref_x:ref_y) marker_size) width_coarse layer_coarse symdef
		) 
		(rpath = (axlPathStart 
			list(((ref_x - marker_size):ref_y) 
			    ((ref_x + marker_size):ref_y)
			) width_fine
		    )) 
		(axlDBCreatePath rpath layer_fine 
		    'line symdef
		) 
		(rpath = (axlPathStart 
			list((ref_x:(ref_y - marker_size)) 
			    (ref_x:(ref_y + marker_size))
			) width_fine
		    )) 
		(axlDBCreatePath rpath layer_fine 
		    'line symdef
		)
		(axlDBCreateCircle 
		    list((ref_x:ref_y) marker_size) width_fine layer_fine symdef
		) 
		(angle_list = tconc(nil nil)) 
		(cur_angle = angle_start) 
		while((cur_angle <= angle_end) 
		    if(((cur_angle == 360.0) && (angle_start == 0.0)) then t else 
			tconc(angle_list 
			    list(cur_angle "common")
			)
			if(((mode == "tmp") && hide_fine_grid) then t else 
			    (fine_step = ((angle_step * 1.0) / angle_multiplier))
			    for(i 1 
				(angle_multiplier - 1) 
				(fine_angle = (cur_angle + (fine_step * i))) 
				when((TBX_GEOM_Round(fine_angle "absolute" 1) < 
					TBX_GEOM_Round(angle_end "absolute" 1)) 
				    tconc(angle_list 
					list(fine_angle "fine_only")
				    )
				)
			    )
			)
		    ) 
		    if(((cur_angle < angle_end) && ((cur_angle + angle_step) > angle_end)) then 
			(cur_angle = angle_end) else 
			(cur_angle = (cur_angle + angle_step))
		    )
		) 
		(angle_list = cdar(angle_list))
		(radius_list = tconc(nil nil)) 
		(cur_radius = radius_start) 
		while((cur_radius <= radius_end) 
		    tconc(radius_list 
			list(cur_radius "common")
		    ) 
		    if(((mode == "tmp") && hide_fine_grid) then t else 
			(fine_step = ((radius_step * 1.0) / radius_multiplier))
			for(i 1 
			    (radius_multiplier - 1) 
			    (fine_radius = (cur_radius + (fine_step * i))) 
			    when((TBX_GEOM_Round(fine_radius "absolute" 1) < 
				    TBX_GEOM_Round(radius_end "absolute" 1)) 
				tconc(radius_list 
				    list(fine_radius "fine_only")
				)
			    )
			)
		    ) 
		    if(((cur_radius < radius_end) && ((cur_radius + radius_step) > radius_end)) then 
			(cur_radius = radius_end) else 
			(cur_radius = (cur_radius + radius_step))
		    )
		) 
		(radius_list = cdar(radius_list)) 
		foreach(entry angle_list 
		    (cur_angle = car(entry)) 
		    (line_type = cadr(entry)) 
		    (start_x = ((cos(((cur_angle / 360.0) * 2 * PI)) * (radius_start - radius_offset)) + ref_x))
		    (start_y = ((sin(((cur_angle / 360.0) * 2 * PI)) * (radius_start - radius_offset)) + ref_y)) 
		    (end_x = ((cos(((cur_angle / 360.0) * 2 * PI)) * (radius_end + radius_offset)) + ref_x)) 
		    (end_y = ((sin(((cur_angle / 360.0) * 2 * PI)) * (radius_end + radius_offset)) + ref_y)) 
		    when((line_type == "common") 
			(rpath = (axlPathStart 
				list((start_x:start_y) 
				    (end_x:end_y)
				) width_coarse
			    )) 
			(axlDBCreatePath rpath layer_coarse 
			    'line symdef
			)
		    ) 
		    (rpath = (axlPathStart 
			    list((start_x:start_y) 
				(end_x:end_y)
			    ) width_fine
			))
		    (axlDBCreatePath rpath layer_fine 
			'line symdef
		    )
		)
		foreach(entry radius_list 
		    (cur_radius = car(entry)) 
		    (line_type = cadr(entry)) 
		    (start_x = ((cos(((angle_start / 360.0) * 2 * PI)) * cur_radius) + ref_x))
		    (start_y = ((sin(((angle_start / 360.0) * 2 * PI)) * cur_radius) + ref_y)) 
		    (end_x = ((cos(((angle_end / 360.0) * 2 * PI)) * cur_radius) + ref_x)) 
		    (end_y = ((sin(((angle_end / 360.0) * 2 * PI)) * cur_radius) + ref_y)) 
		    when((line_type == "common") 
			(rpath = (axlPathStart 
				list((start_x:start_y)) width_coarse
			    )) 
			(rpath = (axlPathArcCenter rpath width_coarse 
				(end_x:end_y) nil
				(ref_x:ref_y)
			    )) 
			(axlDBCreatePath rpath layer_coarse 
			    'line symdef
			)
		    ) 
		    (rpath = (axlPathStart 
			    list((start_x:start_y)) width_fine
			))
		    (rpath = (axlPathArcCenter rpath width_fine 
			    (end_x:end_y) nil
			    (ref_x:ref_y)
			)) 
		    (axlDBCreatePath rpath layer_fine 
			'line symdef
		    )
		)
	    ) 
	    when((mode == "final") 
		TBX_POLARGRID_SETUP_Draw_Isec_Markers(symdef angle_list radius_list 
		    (ref_x:ref_y)
		) 
		(prop_string_radial = sprintf(nil "%s|%.4f|%.4f|%.4f|%d" 
			TBX_UTIL_Get_Short_Units() radius_start radius_end
			radius_step radius_multiplier
		    )) 
		(prop_string_angular = sprintf(nil "%.4f|%.4f|%.4f|%d" angle_start angle_end angle_step
			angle_multiplier
		    )) 
		(axlDBAddProp symdef 
		    list(list("TBX_POLARGRID_RADIAL" prop_string_radial) 
			list("TBX_POLARGRID_ANGULAR" prop_string_angular)
		    )
		)
		(axlDBAddProp symdef 
		    list("LOCKED" t)
		) 
		foreach(entry loc_data 
		    (sym_origin = car(entry)) 
		    (sym_rotation = cadr(entry)) 
		    (sym_mirror = caddr(entry))
		    (result = (axlDBCreateSymbol 
			    list(symbol_name "FORMAT") sym_origin sym_mirror sym_rotation
			)) 
		    (result = result)
		)
	    )
	) t
    )
)
procedure(TBX_POLARGRID_SETUP_Draw_Isec_Markers(symdef angle_list radius_list ref_xy) 
    let((PI center_x center_y marker_radius marker_line_width
	    cur_angle cur_angle_type cur_radius cur_radius_type ref_x
	    ref_y
	) 
	(PI = ((tbx_polargrid_data->constants)->PI)) 
	(marker_radius = ((tbx_polargrid_data->constants)->isecMarkerRadius)) 
	(marker_line_width = (marker_radius / 2.0)) 
	(ref_x = car(ref_xy))
	(ref_y = cadr(ref_xy)) 
	foreach(angle_entry angle_list 
	    (cur_angle = car(angle_entry)) 
	    (cur_angle_type = cadr(angle_entry)) 
	    foreach(radius_entry radius_list 
		(cur_radius = car(radius_entry)) 
		(cur_radius_type = cadr(radius_entry)) 
		(center_x = ((cos(((cur_angle / 360.0) * 2 * PI)) * cur_radius) + ref_x))
		(center_y = ((sin(((cur_angle / 360.0) * 2 * PI)) * cur_radius) + ref_y)) 
		when(((cur_angle_type == "common") && (cur_radius_type == "common")) 
		    (axlDBCreateCircle 
			list((center_x:center_y) marker_radius) marker_line_width 
			((tbx_polargrid_data->sysLayer)->coarseDot) symdef
		    )
		) 
		(axlDBCreateCircle 
		    list((center_x:center_y) marker_radius) marker_line_width 
		    ((tbx_polargrid_data->sysLayer)->fineDot) symdef
		)
	    )
	) t
    )
)
procedure(TBX_POLARGRID_SETUP_Event_Loop(form_handle) 
    let((eventMask loop event xy syminst
	    symbol_name
	) 
	(axlEventSetStartPopup 
	    'TBX_POLARGRID_SETUP_Popup
	) 
	(eventMask = list('PICK)) 
	(loop = t) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil nil)) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(PICK 
		    cond((((tbx_polargrid_data->eventHandler)->pickOrigin) 
			    (xy = (event->xy)) 
			    (axlFormSetField form_handle "origin_x" 
				car(xy)
			    ) 
			    (axlFormSetField form_handle "origin_y" 
				cadr(xy)
			    ) 
			    ((tbx_polargrid_data->eventHandler)->pickOrigin = nil)
			    ((tbx_polargrid_data->runtime)->validX = t) 
			    ((tbx_polargrid_data->runtime)->validY = t) 
			    TBX_POLARGRID_SETUP_Update_Preview(form_handle)
			) 
			(((tbx_polargrid_data->eventHandler)->pickProbeSymbol) 
			    (axlClearSelSet) 
			    (axlSetFindFilter ?enabled 
				list("noall" "symbols") ?onButtons 
				list("all")
			    ) 
			    (axlSingleSelectPoint 
				(event->xy)
			    ) 
			    when((axlGetSelSet) 
				(syminst = car((axlGetSelSet))) 
				if(((((syminst->definition)->prop)->TBX_POLARGRID_ANGULAR) && (((syminst->definition)->prop)->TBX_POLARGRID_RADIAL)) then 
				    (symbol_name = upperCase((syminst->name))) 
				    (tbx_polargrid_data->curGridParam = copy((tbx_polargrid_data->dbGridParam)[symbol_name])) 
				    (tbx_polargrid_data->curGridInst = nil)
				    TBX_POLARGRID_SETUP_Update_Form(form_handle 
					(tbx_polargrid_data->curGridParam) 
					(tbx_polargrid_data->curGridInst)
				    ) else 
				    printf("Warning: Not a valid polar grid symbol\n")
				) 
				(axlClearSelSet)
			    )
			    ((tbx_polargrid_data->eventHandler)->pickEditSymbol = nil)
			) 
			(((tbx_polargrid_data->eventHandler)->pickEditSymbol) 
			    (axlClearSelSet) 
			    (axlSetFindFilter ?enabled 
				list("noall" "symbols") ?onButtons 
				list("all")
			    ) 
			    (axlSingleSelectPoint 
				(event->xy)
			    ) 
			    when((axlGetSelSet) 
				(syminst = car((axlGetSelSet))) 
				((tbx_polargrid_data->runtime)->validX = t) 
				((tbx_polargrid_data->runtime)->validY = t) 
				if(((((syminst->definition)->prop)->TBX_POLARGRID_ANGULAR) && (((syminst->definition)->prop)->TBX_POLARGRID_RADIAL)) then 
				    (symbol_name = upperCase((syminst->name))) 
				    (tbx_polargrid_data->curGridParam = copy((tbx_polargrid_data->dbGridParam)[symbol_name])) 
				    (tbx_polargrid_data->curGridInst = copy((tbx_polargrid_data->dbGridInst)[symbol_name]))
				    TBX_POLARGRID_SETUP_Update_Form(form_handle 
					(tbx_polargrid_data->curGridParam) 
					(tbx_polargrid_data->curGridInst)
				    ) 
				    foreach(entry 
					(tbx_polargrid_data->curGridInst) 
					(axlEraseObject 
					    (entry->dbid)
					)
				    ) 
				    TBX_POLARGRID_SETUP_Update_Preview(form_handle) else 
				    printf("Warning: Not a valid polar grid symbol\n")
				)
				(axlClearSelSet)
			    )
			    ((tbx_polargrid_data->eventHandler)->pickEditSymbol = nil)
			)
		    )
		) 
		(DONE 
		    (loop = nil)
		) 
		(CANCEL 
		    (loop = nil)
		)
	    )
	)
	(axlEventSetStartPopup)
    )
)
procedure(TBX_POLARGRID_SETUP_Get_Defaults() 
    let((units params) 
	(params = ncons(nil)) 
	(params->angleStart = 0.0) 
	(params->angleEnd = 90.0) 
	(params->angleStep = 10.0)
	(params->angleMultiplier = 5) 
	(params->originX = 0.0) 
	(params->originY = 0.0) 
	(params->radiusMultiplier = 5) 
	(units = car((axlDBGetDesignUnits)))
	cond((((units == "microns") || (units == "millimeters") || (units == "centimeters")) 
		(params->radiusStart = (axlMKSConvert "5.0  MM" units)) 
		(params->radiusEnd = (axlMKSConvert "20.0 MM" units)) 
		(params->radiusStep = (axlMKSConvert "5.0  MM" units))
	    ) 
	    (t 
		(params->radiusStart = (axlMKSConvert "200.0 MILS" units)) 
		(params->radiusEnd = (axlMKSConvert "800.0 MILS" units)) 
		(params->radiusStep = (axlMKSConvert "200.0  MILS" units))
	    )
	) params
    )
)
procedure(TBX_POLARGRID_SETUP_Init_Next(form_handle) 
    let((result) 
	(axlFormSetFieldEditable form_handle "origin_x" t) 
	(axlFormSetFieldEditable form_handle "origin_y" t) 
	(axlFormSetFieldEditable form_handle "pick_origin" t) 
	(axlFormSetFieldEditable form_handle "symbol_name" t)
	(axlFormSetFieldEditable form_handle "pick_symbol" t) 
	(axlFormSetField form_handle "origin_x" nil) 
	(axlFormSetField form_handle "origin_y" nil) 
	(axlFormSetField form_handle "symbol_name" nil) 
	(tbx_polargrid_data->eventHandler = ncons(nil))
	(tbx_polargrid_data->runtime = ncons(nil)) 
	(tbx_polargrid_data->curGridParam = nil) 
	(tbx_polargrid_data->curGridInst = nil) 
	(axlVisibleLayer 
	    ((tbx_polargrid_data->sysLayer)->tmp) t
	) 
	(axlDeleteByLayer 
	    ((tbx_polargrid_data->sysLayer)->tmp) 
	    'fixed
	)
	(result = TBX_POLARGRID_Read_Grid_Symbols_From_Database()) 
	(tbx_polargrid_data->dbGridParam = car(result)) 
	(tbx_polargrid_data->dbGridInst = cadr(result)) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_POLARGRID_SETUP_Popup(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Update Preview" 
			'TBX_POLARGRID_SETUP_Popup_Update_Preview
		    ) 
		    list("Clear Preview" 
			'TBX_POLARGRID_SETUP_Popup_Clear_Preview
		    ) 
		    list("Toggle fine grid" 
			'TBX_POLARGRID_SETUP_Popup_Toggle_Fine
		    ) 
		    list("Probe" 
			'TBX_POLARGRID_SETUP_Popup_Probe
		    ) 
		    list("Cancel" 
			'TBX_POLARGRID_SETUP_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_POLARGRID_SETUP_Popup_Cancel() 
    foreach(entry 
	(tbx_polargrid_data->curGridInst) 
	(axlTransformObject 
	    (entry->dbid) ?move 
	    (0.0:0.0)
	) 
	(axlVisibleUpdate t)
    ) 
    TBX_POLARGRID_SETUP_Init_Next((tbx_polargrid_data->formid))
)
procedure(TBX_POLARGRID_SETUP_Popup_Clear_Preview() 
    (axlClearDynamics) 
    (axlVisibleLayer 
	((tbx_polargrid_data->sysLayer)->tmp) t
    ) 
    (axlDeleteByLayer 
	((tbx_polargrid_data->sysLayer)->tmp) 
	'fixed
    ) 
    (axlVisibleUpdate t)
)
procedure(TBX_POLARGRID_SETUP_Popup_Probe() 
    ((tbx_polargrid_data->eventHandler)->pickProbeSymbol = t)
)
procedure(TBX_POLARGRID_SETUP_Popup_Toggle_Fine() 
    if(((tbx_polargrid_data->runtime)->hideFineGrid) then 
	((tbx_polargrid_data->runtime)->hideFineGrid = nil) else 
	((tbx_polargrid_data->runtime)->hideFineGrid = t)
    ) 
    TBX_POLARGRID_SETUP_Update_Preview((tbx_polargrid_data->formid))
)
procedure(TBX_POLARGRID_SETUP_Popup_Update_Preview() 
    TBX_POLARGRID_SETUP_Update_Preview((tbx_polargrid_data->formid))
)
procedure(TBX_POLARGRID_SETUP_Update_Form(form_handle gridParam gridInst) 
    let((msg instance) 
	cond(((length(gridInst) > 1) 
		(axlFormSetFieldEditable form_handle "origin_x" nil) 
		(axlFormSetFieldEditable form_handle "origin_y" nil) 
		(axlFormSetFieldEditable form_handle "pick_origin" nil) 
		(axlFormSetField form_handle "origin_x" nil)
		(axlFormSetField form_handle "origin_y" nil) 
		(axlFormSetField form_handle "symbol_name" 
		    (gridParam->name)
		) 
		(axlFormSetFieldEditable form_handle "symbol_name" nil) 
		(axlFormSetFieldEditable form_handle "pick_symbol" nil) 
		(msg = sprintf(nil "Info: Several instances of symbol %L found, parameter changes will be applied to all instances." 
			upperCase((gridParam->name))
		    ))
		(axlUIConfirm msg)
	    ) 
	    (onep(length(gridInst)) 
		(instance = car(gridInst)) 
		(axlFormSetFieldEditable form_handle "origin_x" t) 
		(axlFormSetFieldEditable form_handle "origin_y" t) 
		(axlFormSetFieldEditable form_handle "pick_origin" t)
		(axlFormSetField form_handle "symbol_name" 
		    (gridParam->name)
		) 
		(axlFormSetFieldEditable form_handle "symbol_name" t) 
		(axlFormSetFieldEditable form_handle "pick_symbol" nil) 
		(axlFormSetField form_handle "origin_x" 
		    car((instance->origin))
		) 
		(axlFormSetField form_handle "origin_y" 
		    cadr((instance->origin))
		)
	    ) 
	    (zerop(length(gridInst)) 
		(axlFormSetField form_handle "origin_x" nil) 
		(axlFormSetField form_handle "origin_y" nil) 
		(axlFormSetField form_handle "symbol_name" nil) 
		(axlFormSetFieldEditable form_handle "origin_x" t)
		(axlFormSetFieldEditable form_handle "origin_y" t) 
		(axlFormSetFieldEditable form_handle "symbol_name" t)
	    ) 
	    (t t)
	) 
	(axlFormSetField form_handle "angle_start" 
	    (gridParam->angleStart)
	) 
	(axlFormSetField form_handle "angle_end" 
	    (gridParam->angleEnd)
	) 
	(axlFormSetField form_handle "angle_step" 
	    (gridParam->angleStep)
	)
	(axlFormSetField form_handle "angle_multiplier" 
	    (gridParam->angleMultiplier)
	) 
	(axlFormSetField form_handle "radius_start" 
	    (gridParam->radiusStart)
	) 
	(axlFormSetField form_handle "radius_end" 
	    (gridParam->radiusEnd)
	) 
	(axlFormSetField form_handle "radius_step" 
	    (gridParam->radiusStep)
	) 
	(axlFormSetField form_handle "radius_multiplier" 
	    (gridParam->radiusMultiplier)
	)
	t
    )
)
procedure(TBX_POLARGRID_SETUP_Update_Preview(form_handle) 
    let((loc_data loc_data_ok_fit origin_x origin_y result) 
	when((((tbx_polargrid_data->runtime)->validX) && ((tbx_polargrid_data->runtime)->validY)) 
	    (axlVisibleLayer 
		((tbx_polargrid_data->sysLayer)->tmp) t
	    ) 
	    (axlDeleteByLayer 
		((tbx_polargrid_data->sysLayer)->tmp) 
		'fixed
	    ) 
	    if((length((tbx_polargrid_data->curGridInst)) > 1) then 
		foreach(entry 
		    (tbx_polargrid_data->curGridInst) 
		    (loc_data = cons(list((entry->origin) 
				(entry->rotation) 
				(entry->mirror)
			    ) loc_data
			))
		) else 
		(origin_x = (axlFormGetField form_handle "origin_x"))
		(origin_y = (axlFormGetField form_handle "origin_y")) 
		(loc_data = list(list((origin_x:origin_y) 0.0 nil)))
	    ) 
	    foreach(loc loc_data 
		(result = TBX_POLARGRID_SETUP_Check_Extents(form_handle loc)) 
		when(result 
		    (loc_data_ok_fit = cons(loc loc_data_ok_fit))
		)
	    )
	    TBX_POLARGRID_SETUP_Draw_Geometry(form_handle "tmp" nil loc_data_ok_fit 
		((tbx_polargrid_data->runtime)->hideFineGrid)
	    ) 
	    (axlVisibleUpdate t)
	) t
    )
)
procedure(TBX_POLARGRID_SHAPE_Callback(form_handle) 
    let((result cur_class cur_subclass) 
	case((form_handle->curField) 
	    ("class_name" 
		if(((axlMapClassName 
			    (form_handle->curValue) t
			) == "ETCH") then 
		    (axlFormSetFieldEditable form_handle "shape_net" t) else 
		    (axlFormSetFieldEditable form_handle "shape_net" nil)
		) 
		(axlBuildSubclassPopup form_handle "subclass_name" 
		    (form_handle->curValue)
		) 
		(cur_subclass = car((axlSubclasses 
			    (form_handle->curValue)
			)
		    )) 
		(axlFormSetField form_handle "subclass_name" cur_subclass)
		(axlDBControl 
		    'activeLayer 
		    strcat((form_handle->curValue) "/" cur_subclass)
		) 
		TBX_POLARGRID_Build_Dynamics("shape" form_handle 
		    (tbx_polargrid_data->pathStack)
		)
	    ) 
	    ("subclass_name" 
		(cur_class = (axlFormGetField form_handle "class_name")) 
		(axlDBControl 
		    'activeLayer 
		    strcat(cur_class "/" 
			(form_handle->curValue)
		    )
		) 
		TBX_POLARGRID_Build_Dynamics("shape" form_handle 
		    (tbx_polargrid_data->pathStack)
		)
	    ) 
	    ("pen_width" 
		TBX_POLARGRID_Build_Dynamics("shape" form_handle 
		    (tbx_polargrid_data->pathStack)
		)
	    ) 
	    ("snap_coarse_grid" 
		TBX_POLARGRID_Set_Snap_Options(form_handle "coarse")
	    )
	    ("snap_fine_grid" 
		TBX_POLARGRID_Set_Snap_Options(form_handle "fine")
	    ) 
	    ("snap_system_grid" 
		TBX_POLARGRID_Set_Snap_Options(form_handle "system")
	    ) 
	    ("toggle_coarse_grid" 
		TBX_POLARGRID_Toggle_Grid_Display(form_handle "coarse")
	    ) 
	    ("toggle_fine_grid" 
		TBX_POLARGRID_Toggle_Grid_Display(form_handle "fine")
	    ) 
	    ("toggle_system_grid" 
		TBX_POLARGRID_Toggle_Grid_Display(form_handle "system")
	    )
	    ("coarse_style" 
		TBX_POLARGRID_Update_Grid_Display_Style(form_handle "coarse")
	    ) 
	    ("fine_style" 
		TBX_POLARGRID_Update_Grid_Display_Style(form_handle "fine")
	    ) 
	    ("browse_net" 
		(axlClearSelSet) 
		(result = (axlUIDataBrowse 
			'NET 
			list('RETRIEVE_NAME) "Select net" t
		    )) 
		when(result 
		    (axlFormSetField form_handle "shape_net" 
			car(result)
		    )
		)
	    ) 
	    ("done" 
		(axlFinishEnterFun) 
		(axlFormClose form_handle) 
		(axlClearDynamics) 
		(axlUIPopupSet nil)
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_POLARGRID_SHAPE_Create_Shape(boundary_path run_mode form_handle shape2void) 
    let((shape_layer arr active_class active_subclass shape_net
	    shape_fill result shape_poly void_poly
	) 
	if(((run_mode == "void") && shape2void) then 
	    (shape_layer = (shape2void->layer)) 
	    (shape_fill = (shape2void->fill)) 
	    (shape_net = ((shape2void->net)->name))
	    else 
	    (shape_layer = (axlDBControl 
		    'activeLayer
		)) 
	    (shape_net = (axlFormGetField form_handle "shape_net")) 
	    case((axlFormGetField form_handle "shape_type") 
		("dynamic" 
		    (arr = parseString(shape_layer "/")) 
		    (active_class = car(arr)) 
		    (active_subclass = cadr(arr)) 
		    when(((axlMapClassName active_class t) == "ETCH") 
			(shape_layer = strcat((axlMapClassName "BOUNDARY") "/" active_subclass))
		    )
		    (shape_fill = t)
		) 
		("static_filled" 
		    (shape_fill = t)
		) 
		("static_unfilled" 
		    (shape_fill = nil)
		)
	    )
	) 
	if(((run_mode == "void") && shape2void) then 
	    (shape_poly = car((axlPolyFromDB shape2void ?holes t))) 
	    (axlDeleteObject shape2void) 
	    (void_poly = car((axlPolyFromDB boundary_path)))
	    foreach(pl 
		(axlPolyOperation shape_poly void_poly 
		    'ANDNOT
		) 
		(result = (axlDBCreateShape pl shape_fill shape_layer shape_net))
	    ) else 
	    (result = (axlDBCreateShape boundary_path shape_fill shape_layer shape_net))
	) result
    )
)
procedure(TBX_POLARGRID_SHAPE_Event_Loop(form_handle) 
    let((eventMask loop event cur_polargrid result
	    pt_xy snap_status rpath boundary_path arr
	    active_layer
	) 
	(form_handle = form_handle) 
	(axlEventSetStartPopup 
	    'TBX_POLARGRID_SHAPE_Popup
	) 
	(eventMask = list('PICK)) 
	(loop = t)
	(tbx_polargrid_data->transMark = (axlDBTransactionStart)) 
	(tbx_polargrid_data->transMarkPoly = (axlDBTransactionStart)) 
	when(((tbx_polargrid_data->runMode) == "void") 
	    ((tbx_polargrid_data->eventHandler)->pickShape = t)
	) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil 
		    (tbx_polargrid_data->systemGridSnap)
		)) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(PICK 
		    cond((((tbx_polargrid_data->eventHandler)->dummyPick) 
			    ((tbx_polargrid_data->eventHandler)->dummyPick = nil)
			) 
			((((tbx_polargrid_data->runMode) == "void") && ((tbx_polargrid_data->eventHandler)->pickShape)) 
			    (axlSetFindFilter ?enabled 
				list("noall" "boundary_shapes" "shapes") ?onButtons 
				list("all")
			    ) 
			    (axlClearSelSet) 
			    (axlSingleSelectPoint 
				(event->xy)
			    ) 
			    if((axlGetSelSet) then 
				((tbx_polargrid_data->runtime)->shape2void = car((axlGetSelSet))) 
				(arr = parseString((((tbx_polargrid_data->runtime)->shape2void)->layer) "/")) 
				if((car(arr) == "BOUNDARY") then 
				    (active_layer = strcat((axlMapClassName "ETCH") "/" 
					    cadr(arr)
					)) else 
				    (active_layer = (((tbx_polargrid_data->runtime)->shape2void)->layer))
				)
				(axlDBControl 
				    'activeLayer active_layer
				) 
				(axlVisibleUpdate t) 
				((tbx_polargrid_data->eventHandler)->pickShape = nil) else 
				printf("Nothing selected. Pick again.\n")
			    )
			) 
			(t 
			    (cur_polargrid = TBX_POLARGRID_Get_Active_Polargrid((event->xy) 
				    (tbx_polargrid_data->dbGridInst)
				)) 
			    (result = TBX_POLARGRID_Snap_Polar(form_handle cur_polargrid 
				    (event->xy) 
				    (event->xySnap)
				)) 
			    (pt_xy = car(result)) 
			    (snap_status = cadr(result))
			    if(!(tbx_polargrid_data->pathStack) then 
				(rpath = (axlPathStart 
					list(pt_xy) 0.0
				    )) 
				(tbx_polargrid_data->pathStack = list(list(nil 
					    'path rpath 
					    'polarMode nil
					)
				    )) 
				((tbx_polargrid_data->runtime)->startXY = pt_xy)
				else 
				((tbx_polargrid_data->runtime)->curPathData = TBX_POLARGRID_Determine_Path("shape" form_handle cur_polargrid pt_xy snap_status
					(tbx_polargrid_data->pathStack)
				    )) 
				when(((tbx_polargrid_data->runtime)->curPathData) 
				    (axlDBTransactionMark 
					(tbx_polargrid_data->transMarkPoly)
				    ) 
				    (result = (axlDBCreatePath 
					    (car(((tbx_polargrid_data->runtime)->curPathData))->path) 
					    ((tbx_polargrid_data->sysLayer)->tmp)
					)) 
				    ((tbx_polargrid_data->runtime)->curDbid = caar(result)) 
				    (tbx_polargrid_data->pathStack = cons(car(((tbx_polargrid_data->runtime)->curPathData)) 
					    (tbx_polargrid_data->pathStack)
					))
				    when(((axlGeo2Str pt_xy) == 
					    (axlGeo2Str 
						((tbx_polargrid_data->runtime)->startXY)
					    )) 
					(axlDBTransactionMark 
					    (tbx_polargrid_data->transMark)
					) 
					(boundary_path = TBX_POLARGRID_Construct_Contiguous_Path((tbx_polargrid_data->pathStack) 0.0)) 
					(result = TBX_POLARGRID_SHAPE_Create_Shape(boundary_path 
						(tbx_polargrid_data->runMode) form_handle 
						((tbx_polargrid_data->runtime)->shape2void)
					    )) 
					TBX_POLARGRID_SHAPE_Init_Next()
				    )
				)
			    )
			)
		    ) 
		    TBX_POLARGRID_Build_Dynamics("shape" form_handle 
			(tbx_polargrid_data->pathStack)
		    ) 
		    when((((tbx_polargrid_data->runMode) == "void") && ((tbx_polargrid_data->runtime)->shape2void)) 
			(axlSingleSelectObject 
			    ((tbx_polargrid_data->runtime)->shape2void)
			)
		    )
		) 
		(DONE 
		    (axlDBTransactionCommit 
			(tbx_polargrid_data->transMark)
		    ) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics) 
		    (loop = nil)
		) 
		(CANCEL 
		    (axlDBTransactionOops 
			(tbx_polargrid_data->transMark)
		    ) 
		    (axlDBTransactionCommit 
			(tbx_polargrid_data->transMark)
		    ) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics)
		    (loop = nil)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_POLARGRID_SHAPE_Init_Next() 
    let((a) 
	(a = a) 
	(axlDBTransactionCommit 
	    (tbx_polargrid_data->transMarkPoly)
	) 
	(tbx_polargrid_data->transMarkPoly = (axlDBTransactionStart)) 
	(axlClearDynamics)
	(tbx_polargrid_data->pathStack = nil) 
	(tbx_polargrid_data->runtime = ncons(nil)) 
	(tbx_polargrid_data->eventHandler = ncons(nil)) 
	(axlVisibleLayer 
	    ((tbx_polargrid_data->sysLayer)->tmp) t
	) 
	(axlDeleteByLayer 
	    ((tbx_polargrid_data->sysLayer)->tmp)
	)
	if(((tbx_polargrid_data->runMode) == "void") then 
	    ((tbx_polargrid_data->eventHandler)->pickShape = t) else 
	    ((tbx_polargrid_data->eventHandler)->pickShape = nil)
	) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_POLARGRID_SHAPE_Popup(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Oops" 
			'TBX_POLARGRID_SHAPE_Popup_Oops
		    ) 
		    list("Close shape" 
			'TBX_POLARGRID_SHAPE_Popup_Close_Shape
		    ) 
		    list("Toggle current" 
			'TBX_POLARGRID_SHAPE_Popup_Toggle
		    ) 
		    list("Next" 
			'TBX_POLARGRID_SHAPE_Popup_Next
		    ) 
		    list("Done" 
			'TBX_POLARGRID_SHAPE_Popup_Done
		    )
		    list("Cancel" 
			'TBX_POLARGRID_SHAPE_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_POLARGRID_SHAPE_Popup_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_POLARGRID_SHAPE_Popup_Close_Shape() 
    let((end_xy cur_polargrid snap_status boundary_path seg_info
	    result
	) 
	when(((tbx_polargrid_data->runtime)->startXY) 
	    (end_xy = ((tbx_polargrid_data->runtime)->startXY)) 
	    (cur_polargrid = TBX_POLARGRID_Get_Active_Polargrid(end_xy 
		    (tbx_polargrid_data->dbGridInst)
		)) 
	    (snap_status = t) 
	    ((tbx_polargrid_data->runtime)->curPathData = TBX_POLARGRID_Determine_Path("shape_close" 
		    (tbx_polargrid_data->formid) cur_polargrid end_xy snap_status
		    (tbx_polargrid_data->pathStack)
		))
	    when(((tbx_polargrid_data->runtime)->curPathData) 
		(seg_info = TBX_POLARGRID_Get_Last_Seg_Info((car(((tbx_polargrid_data->runtime)->curPathData))->path))) 
		(axlDBTransactionMark 
		    (tbx_polargrid_data->transMarkPoly)
		) 
		(axlDBTransactionMark 
		    (tbx_polargrid_data->transMark)
		) 
		(result = (axlDBCreatePath 
			(car(((tbx_polargrid_data->runtime)->curPathData))->path) 
			((tbx_polargrid_data->sysLayer)->tmp)
		    ))
		(tbx_polargrid_data->pathStack = cons(car(((tbx_polargrid_data->runtime)->curPathData)) 
			(tbx_polargrid_data->pathStack)
		    )) 
		when(((axlGeo2Str 
			    (seg_info->endPoint)
			) == (axlGeo2Str 
			    ((tbx_polargrid_data->runtime)->startXY)
			)) 
		    (boundary_path = TBX_POLARGRID_Construct_Contiguous_Path((tbx_polargrid_data->pathStack) 0.0)) 
		    (result = TBX_POLARGRID_SHAPE_Create_Shape(boundary_path 
			    (tbx_polargrid_data->runMode) 
			    (tbx_polargrid_data->formid) 
			    ((tbx_polargrid_data->runtime)->shape2void)
			)) 
		    if(result then 
			TBX_POLARGRID_SHAPE_Init_Next() else 
			(axlDBTransactionOops 
			    (tbx_polargrid_data->transMarkPoly)
			)
			(tbx_polargrid_data->pathStack = cdr((tbx_polargrid_data->pathStack))) 
			TBX_POLARGRID_Build_Dynamics("shape" 
			    (tbx_polargrid_data->formid) 
			    (tbx_polargrid_data->pathStack)
			)
		    )
		)
	    )
	) t
    )
)
procedure(TBX_POLARGRID_SHAPE_Popup_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_POLARGRID_SHAPE_Popup_Next() 
    TBX_POLARGRID_SHAPE_Init_Next()
)
procedure(TBX_POLARGRID_SHAPE_Popup_Oops() 
    when((length((tbx_polargrid_data->pathStack)) > 1) 
	(axlDBTransactionOops 
	    (tbx_polargrid_data->transMarkPoly)
	)
    ) 
    (tbx_polargrid_data->pathStack = cdr((tbx_polargrid_data->pathStack))) 
    TBX_POLARGRID_Build_Dynamics("shape" 
	(tbx_polargrid_data->formid) 
	(tbx_polargrid_data->pathStack)
    )
)
procedure(TBX_POLARGRID_SHAPE_Popup_Toggle() 
    let((first_entry result) 
	when((length(((tbx_polargrid_data->runtime)->curPathData)) > 1) 
	    (axlDeleteObject 
		((tbx_polargrid_data->runtime)->curDbid)
	    ) 
	    (first_entry = car(((tbx_polargrid_data->runtime)->curPathData))) 
	    ((tbx_polargrid_data->runtime)->curPathData = cdr(((tbx_polargrid_data->runtime)->curPathData))) 
	    ((tbx_polargrid_data->runtime)->curPathData = append1(((tbx_polargrid_data->runtime)->curPathData) first_entry))
	    (tbx_polargrid_data->pathStack = cdr((tbx_polargrid_data->pathStack))) 
	    (tbx_polargrid_data->pathStack = cons(car(((tbx_polargrid_data->runtime)->curPathData)) 
		    (tbx_polargrid_data->pathStack)
		)) 
	    foreach(pe 
		cdr(reverse((tbx_polargrid_data->pathStack))) 
		(result = (axlDBCreatePath 
			(pe->path) 
			((tbx_polargrid_data->sysLayer)->tmp)
		    ))
	    ) 
	    when(result 
		((tbx_polargrid_data->runtime)->curDbid = caar(result))
	    )
	) t
    )
)
procedure(TBX_POLARGRID_Set_Snap_Options(form_handle mode) 
    let((snap_regular_grid) 
	case(mode 
	    ("coarse" 
		(axlFormSetField form_handle "snap_system_grid" nil)
	    ) 
	    ("fine" 
		(axlFormSetField form_handle "snap_system_grid" nil)
	    ) 
	    ("system" 
		(axlFormSetField form_handle "snap_coarse_grid" nil) 
		(axlFormSetField form_handle "snap_fine_grid" nil)
	    )
	) 
	cond((((axlFormGetField form_handle "snap_coarse_grid") || 
		    (axlFormGetField form_handle "snap_fine_grid")) 
		(snap_regular_grid = nil)
	    ) 
	    ((axlFormGetField form_handle "snap_system_grid") 
		(snap_regular_grid = t)
	    ) 
	    (t 
		(snap_regular_grid = nil)
	    )
	) 
	((tbx_polargrid_data->eventHandler)->dummyPick = t) 
	(tbx_polargrid_data->systemGridSnap = snap_regular_grid)
	(axlShell "pick 0 0") 
	(axlVisibleUpdate t)
    )
)
procedure(TBX_POLARGRID_Snap_Object(xy) 
    let((ret_data net_name xyObjectSnap orgvis subclass_name
	    line_seg seg2split
	) 
	(orgvis = (axlVisibleGet)) 
	(axlVisibleDesign nil) 
	(axlVisibleLayer 
	    (axlDBControl 
		'activeLayer
	    ) t
	) 
	(subclass_name = cadr(parseString((axlDBControl 
			'activeLayer
		    ) "/"
		)
	    ))
	(axlVisibleLayer 
	    strcat((axlMapClassName "PIN") "/" subclass_name) t
	) 
	(axlVisibleLayer 
	    strcat((axlMapClassName "VIA CLASS") "/" subclass_name) t
	) 
	(axlVisibleUpdate nil) 
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    list("noall" "pins" "vias") ?onButtons 
	    list("all")
	)
	(axlSingleSelectPoint xy) 
	if((axlGetSelSet) then 
	    (xyObjectSnap = (car((axlGetSelSet))->xy)) 
	    (net_name = ((car((axlGetSelSet))->net)->name)) 
	    (seg2split = nil)
	    else 
	    (axlClearSelSet) 
	    (axlSetFindFilter ?enabled 
		list("noall" "clinesegs" "linesegs") ?onButtons 
		list("all")
	    ) 
	    (axlSingleSelectPoint xy) 
	    when((axlGetSelSet) 
		(line_seg = car((axlGetSelSet))) 
		(net_name = (((line_seg->parent)->net)->name)) 
		(xyObjectSnap = TBX_GEOM_Closest_Point_on_Seg(xy line_seg t)) 
		(seg2split = line_seg)
	    )
	) 
	when(xyObjectSnap 
	    (ret_data = list(xyObjectSnap net_name seg2split))
	) 
	(axlVisibleSet orgvis) 
	(axlVisibleUpdate nil)
	ret_data
    )
)
procedure(TBX_POLARGRID_Snap_Polar(form_handle cur_polargrid event_xy event_xySnap) 
    let((angle_step radius_step PI box_size box_ll
	    box_ur pick_distance angle_distance marker_list dist_data
	    center_xy result grid_param orgvis
	) 
	(orgvis = (axlVisibleGet)) 
	(PI = ((tbx_polargrid_data->constants)->PI)) 
	(grid_param = (tbx_polargrid_data->dbGridParam)[(cur_polargrid->name)]) 
	cond(((axlFormGetField form_handle "snap_system_grid") 
		(result = list(event_xySnap nil))
	    ) 
	    (!cur_polargrid 
		(result = list(event_xy nil))
	    ) 
	    (((axlFormGetField form_handle "snap_coarse_grid") || 
		    (axlFormGetField form_handle "snap_fine_grid")) 
		when((axlFormGetField form_handle "snap_coarse_grid") 
		    (angle_step = (grid_param->angleStep)) 
		    (radius_step = (grid_param->radiusStep))
		) 
		when((axlFormGetField form_handle "snap_fine_grid") 
		    (angle_step = (((grid_param->angleStep) * 1.0) / (grid_param->angleMultiplier))) 
		    (radius_step = (((grid_param->radiusStep) * 1.0) / (grid_param->radiusMultiplier)))
		) 
		(result = list(event_xy nil)) 
		(pick_distance = (axlDistance event_xy 
			(cur_polargrid->origin)
		    ))
		(angle_distance = (pick_distance * 1.0 * sqrt((2 * (1 - cos(((angle_step / 360.0) * 2 * PI))))))) 
		(box_size = (1.0 * max(angle_distance radius_step))) 
		(box_ll = ((car(event_xy) - box_size):(cadr(event_xy) - box_size))) 
		(box_ur = ((car(event_xy) + box_size):(cadr(event_xy) + box_size))) 
		(axlVisibleLayer 
		    ((tbx_polargrid_data->sysLayer)->coarseDot) t
		)
		(axlVisibleLayer 
		    ((tbx_polargrid_data->sysLayer)->fineDot) t
		) 
		(axlClearSelSet) 
		(axlSetFindFilter ?enabled 
		    list("noall" "lines") ?onButtons 
		    list("all")
		) 
		(axlSingleSelectBox 
		    list(box_ll box_ur)
		) 
		if((axlGetSelSet) then 
		    if((axlFormGetField form_handle "snap_fine_grid") then 
			(marker_list = setof(x 
				(axlGetSelSet) 
				((x->layer) == ((tbx_polargrid_data->sysLayer)->fineDot))
			    )) else 
			(marker_list = setof(x 
				(axlGetSelSet) 
				((x->layer) == ((tbx_polargrid_data->sysLayer)->coarseDot))
			    ))
		    ) 
		    if(marker_list then 
			foreach(mkr marker_list 
			    (center_xy = (car((mkr->segments))->xy)) 
			    (dist_data = cons(list((axlDistance event_xy center_xy) center_xy) dist_data))
			) 
			(dist_data = sortcar(dist_data 
				'lessp
			    )) 
			when(dist_data 
			    printf("Info: Snap to polar location %L\n" 
				cadar(dist_data)
			    ) 
			    (result = list(cadar(dist_data) t))
			)
			else 
			printf("Warning: No markers found\n") 
			(result = list(event_xy nil))
		    ) else
		    printf("Warning: No polar grid point found in box %L\n" 
			list(box_ll box_ur)
		    ) 
		    (result = list(event_xy nil))
		)
	    ) 
	    (t 
		(result = list(event_xy nil))
	    )
	)
	(axlClearSelSet) 
	(axlVisibleSet orgvis) 
	(axlVisibleUpdate nil) result
    )
)
procedure(TBX_POLARGRID_Toggle_Grid_Display(form_handle grid_type) 
    let((check_layer) 
	case(grid_type 
	    ("coarse" 
		case((axlFormGetField form_handle "coarse_style") 
		    ("lines" 
			(axlVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->coarseDot) nil
			) 
			(check_layer = ((tbx_polargrid_data->sysLayer)->coarseLine))
		    ) 
		    ("dots" 
			(axlVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->coarseLine) nil
			) 
			(check_layer = ((tbx_polargrid_data->sysLayer)->coarseDot))
		    )
		) 
		if((axlIsVisibleLayer check_layer) then 
		    (axlVisibleLayer check_layer nil) else 
		    (axlVisibleLayer check_layer t)
		)
	    ) 
	    ("fine" 
		case((axlFormGetField form_handle "fine_style") 
		    ("lines" 
			(axlVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->fineDot) nil
			) 
			(check_layer = ((tbx_polargrid_data->sysLayer)->fineLine))
		    ) 
		    ("dots" 
			(axlVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->fineLine) nil
			) 
			(check_layer = ((tbx_polargrid_data->sysLayer)->fineDot))
		    )
		) 
		if((axlIsVisibleLayer check_layer) then 
		    (axlVisibleLayer check_layer nil) else 
		    (axlVisibleLayer check_layer t)
		)
	    ) 
	    ("system" 
		if(onep((axlDBControl 
			    'gridEnable
			)
		    ) then 
		    (axlDBControl 
			'gridEnable nil
		    ) else 
		    (axlDBControl 
			'gridEnable t
		    )
		)
	    )
	) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_POLARGRID_Update_Grid_Display_Style(form_handle grid_type) 
    case(grid_type 
	("coarse" 
	    case((axlFormGetField form_handle "coarse_style") 
		("lines" 
		    when((axlIsVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->coarseDot)
			) 
			(axlVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->coarseDot) nil
			) 
			(axlVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->coarseLine) t
			)
		    )
		) 
		("dots" 
		    when((axlIsVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->coarseLine)
			) 
			(axlVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->coarseLine) nil
			) 
			(axlVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->coarseDot) t
			)
		    )
		)
	    )
	) 
	("fine" 
	    case((axlFormGetField form_handle "fine_style") 
		("lines" 
		    when((axlIsVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->fineDot)
			) 
			(axlVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->fineDot) nil
			) 
			(axlVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->fineLine) t
			)
		    )
		) 
		("dots" 
		    when((axlIsVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->fineLine)
			) 
			(axlVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->fineLine) nil
			) 
			(axlVisibleLayer 
			    ((tbx_polargrid_data->sysLayer)->fineDot) t
			)
		    )
		)
	    )
	)
    ) 
    (axlVisibleUpdate t)
)
procedure(TBX_POLARGRID_Write_View_Files() 
    let((port view_file) 
	(view_file = strcat(getWorkingDir() "/PG_All_Off.color")) 
	(port = outfile(view_file "w")) 
	fprintf(port "color -invis %s\n" 
	    ((tbx_polargrid_data->sysLayer)->coarseLine)
	) 
	fprintf(port "color -invis %s\n" 
	    ((tbx_polargrid_data->sysLayer)->coarseDot)
	)
	fprintf(port "color -invis %s\n" 
	    ((tbx_polargrid_data->sysLayer)->fineLine)
	) 
	fprintf(port "color -invis %s\n" 
	    ((tbx_polargrid_data->sysLayer)->fineDot)
	) 
	close(port) 
	(view_file = strcat(getWorkingDir() "/PG_Line_Coarse.color")) 
	(port = outfile(view_file "w"))
	fprintf(port "color -toggle %s\n" 
	    ((tbx_polargrid_data->sysLayer)->coarseLine)
	) 
	close(port) 
	(view_file = strcat(getWorkingDir() "/PG_Line_Fine.color")) 
	(port = outfile(view_file "w")) 
	fprintf(port "color -toggle %s\n" 
	    ((tbx_polargrid_data->sysLayer)->fineLine)
	)
	close(port) 
	(view_file = strcat(getWorkingDir() "/PG_Dot_Coarse.color")) 
	(port = outfile(view_file "w")) 
	fprintf(port "color -toggle %s\n" 
	    ((tbx_polargrid_data->sysLayer)->coarseDot)
	) 
	close(port)
	(view_file = strcat(getWorkingDir() "/PG_Dot_Fine.color")) 
	(port = outfile(view_file "w")) 
	fprintf(port "color -toggle %s\n" 
	    ((tbx_polargrid_data->sysLayer)->fineDot)
	) 
	close(port) t
    )
)
procedure(TBX_POSPTROC_Get_Plotset_Names() 
    let((cfg_file port data plotset_list) 
	(cfg_file = strcat(getWorkingDir() "/batchplot.cfg")) 
	when(isFile(cfg_file) 
	    (port = infile(cfg_file)) 
	    (data = car(lineread(port))) 
	    close(port)
	) 
	when(data 
	    (plotset_list = mapcar(lambda((x) 
			car(x)
		    ) data
		))
	) plotset_list
    )
)
procedure(TBX_POSPTROC_Get_Variant_Names() 
    let((cfg_file port data variant_names) 
	(cfg_file = strcat(getWorkingDir() "/variants.lst")) 
	when(isFile(cfg_file) 
	    (port = infile(cfg_file)) 
	    (data = car(lineread(port))) 
	    close(port)
	) 
	when(data 
	    (variant_names = mapcar(lambda((x) 
			car(x)
		    ) data
		))
	) variant_names
    )
)
procedure(TBX_POSTPROC_BASICBOM_Calculate_Column_Width(attrTable attr_list) 
    let((column_width cmp_cnt param_cnt pvalue col_nr) 
	(param_cnt = (length(attr_list) + 1)) 
	declare(column_width[param_cnt]) 
	(column_width[0] = strlen("POS")) 
	(cmp_cnt = strlen(sprintf(nil "%d" 
		    length(attrTable)
		)
	    ))
	when((cmp_cnt > column_width[0]) 
	    (column_width[0] = cmp_cnt)
	) 
	(col_nr = 1) 
	foreach(attr attr_list 
	    (column_width[col_nr] = strlen(symbolToString(attr))) 
	    ++col_nr
	) 
	(col_nr = 1) 
	foreach(attr attr_list 
	    foreach(ref attrTable 
		(pvalue = get(attrTable[ref] attr)) 
		when((strlen(pvalue) > column_width[col_nr]) 
		    (column_width[col_nr] = strlen(pvalue))
		)
	    ) 
	    ++col_nr
	)
	column_width
    )
)
procedure(TBX_POSTPROC_BASICBOM_Extract_Master_Design(attr_list) 
    let((comp_attr data refdes x y
	    cdef_props c_props attr_value_def attr_value_inst attr_value
	) 
	(comp_attr = makeTable("comp_attr_table" nil)) 
	foreach(comp 
	    ((axlDBGetDesign)->components) 
	    (data = ncons(nil)) 
	    (refdes = upperCase((comp->name))) 
	    when(((comp->symbol)->xy) 
		foreach(attr_name attr_list 
		    caseq(attr_name 
			(REFDES 
			    putprop(data refdes 
				'REFDES
			    )
			) 
			(DEVICE_TYPE 
			    putprop(data 
				(comp->deviceType) 
				'DEVICE_TYPE
			    )
			) 
			(ROTATION 
			    putprop(data 
				((comp->symbol)->rotation) 
				'ROTATION
			    )
			) 
			(MIRROR 
			    putprop(data 
				((comp->symbol)->isMirrored) 
				'MIRROR
			    )
			)
			(X 
			    (x = car(((comp->symbol)->xy))) 
			    putprop(data x 
				'X
			    )
			) 
			(Y 
			    (y = cadr(((comp->symbol)->xy))) 
			    putprop(data y 
				'Y
			    )
			) 
			(t 
			    (cdef_props = (((comp->compdef)->prop)->??)) 
			    (cdef_props = cons(nil cdef_props)) 
			    (c_props = ((comp->prop)->??)) 
			    (c_props = cons(nil c_props))
			    (attr_value_def = get(cdef_props attr_name)) 
			    (attr_value_inst = get(c_props attr_name)) 
			    if(attr_value_inst then 
				(attr_value = attr_value_inst) else 
				(attr_value = attr_value_def)
			    ) 
			    putprop(data attr_value attr_name)
			)
		    )
		) 
		(comp_attr[refdes] = data)
	    )
	) comp_attr
    )
)
procedure(TBX_POSTPROC_BASICBOM_Format_Data(attrTable attr_list) 
    let((pvalue_str pvalue undef_value format_str decimal_point) 
	(undef_value = "NA") 
	foreach(ref attrTable 
	    foreach(attr attr_list 
		(pvalue = get(attrTable[ref] attr)) 
		cond((((attr == 'REFDES) || (attr == 'PART_NUMBER) || (attr == 'VALUE) || (attr == 'DEVICE_TYPE)) 
			if(pvalue then 
			    if((type(pvalue) == 'string) then 
				(pvalue_str = sprintf(nil "%s" pvalue)) else 
				(pvalue_str = sprintf(nil "%L" pvalue))
			    ) else 
			    (pvalue_str = undef_value)
			) 
			putprop(attrTable[ref] pvalue_str attr)
		    ) 
		    (((attr == 'X) || (attr == 'Y) || (attr == 'ROTATION)) 
			(pvalue = (pvalue * 1.0)) 
			(format_str = "%.3f") 
			if(pvalue then 
			    (pvalue_str = sprintf(nil format_str pvalue)) else 
			    (pvalue_str = undef_value)
			) 
			when(axlGetVariable("TBX_VARIBOM_DECIMAL_POINT") 
			    (decimal_point = axlGetVariable("TBX_VARIBOM_DECIMAL_POINT")) 
			    rexCompile("[.]") 
			    (pvalue_str = rexReplace(pvalue_str decimal_point 0))
			)
			putprop(attrTable[ref] pvalue_str attr)
		    ) 
		    ((attr == 'MIRROR) 
			if(pvalue then 
			    putprop(attrTable[ref] "BOT" 
				'MIRROR
			    ) else 
			    putprop(attrTable[ref] "TOP" 
				'MIRROR
			    )
			)
		    )
		)
	    )
	)
    )
)
procedure(TBX_POSTPROC_BASICBOM_Print_CSV_File(attrData attr_list) 
    let((data_str port pvalue ref_list row_nr
	    tmp_list tmp_value csv_file header_str out_str
	) 
	(tmp_list = list()) 
	foreach(attr attr_list 
	    (tmp_list = cons(symbolToString(attr) tmp_list))
	) 
	(tmp_list = reverse(tmp_list)) 
	(tmp_list = cons("POS" tmp_list))
	if(axlGetVariable("TBX_VARIBOM_CSV_CHAR") then 
	    (data_str = buildString(tmp_list 
		    axlGetVariable("TBX_VARIBOM_CSV_CHAR")
		)) else 
	    (data_str = buildString(tmp_list ";"))
	) 
	(header_str = data_str) 
	foreach(key attrData 
	    (ref_list = cons(key ref_list))
	) 
	(ref_list = sort(ref_list 
		'axlStrcmpAlpNum
	    )) 
	(csv_file = strcat(getWorkingDir() "/" 
		(axlCurrentDesign) "_BOM.csv"
	    ))
	(port = outfile(csv_file "w")) 
	fprintf(port "%s\n" header_str) 
	(row_nr = 1) 
	foreach(refdes ref_list 
	    (tmp_list = list()) 
	    foreach(attr attr_list 
		(pvalue = get(attrData[refdes] attr)) 
		(tmp_list = cons(pvalue tmp_list))
	    ) 
	    (tmp_list = reverse(tmp_list))
	    (tmp_value = sprintf(nil "%d" row_nr)) 
	    (tmp_list = cons(tmp_value tmp_list)) 
	    if(axlGetVariable("TBX_VARIBOM_CSV_CHAR") then 
		(out_str = buildString(tmp_list 
			axlGetVariable("TBX_VARIBOM_CSV_CHAR")
		    )) else 
		(out_str = buildString(tmp_list ";"))
	    ) 
	    fprintf(port "%s\n" out_str) 
	    (row_nr = (row_nr + 1))
	) 
	close(port)
	printf("Note: File %s has been written\n" csv_file)
    )
)
procedure(TBX_POSTPROC_BASICBOM_Print_Formated_File(attrData attr_list col_width) 
    let((col_nr port tmp_list tmp_value format_str
	    out_str data_str sep_str row_nr ref_list
	    pvalue header_str ascii_file
	) 
	(tmp_list = list()) 
	(col_nr = 1) 
	foreach(attr attr_list 
	    (format_str = strcat("%-" 
		    sprintf(nil "%d" 
			col_width[col_nr]
		    ) "s"
		)) 
	    (tmp_value = sprintf(nil format_str 
		    symbolToString(attr)
		)) 
	    (tmp_list = cons(tmp_value tmp_list))
	    ++col_nr
	) 
	(tmp_list = reverse(tmp_list))
	(format_str = strcat("%-" 
		sprintf(nil "%d" 
		    col_width[0]
		) "s"
	    )) 
	(tmp_value = sprintf(nil format_str "POS")) 
	(tmp_list = cons(tmp_value tmp_list)) 
	(data_str = buildString(tmp_list " | ")) 
	(sep_str = "")
	for(i 0 
	    strlen(data_str) 
	    (sep_str = strcat(sep_str "+"))
	) 
	(header_str = sprintf(nil "%s" sep_str)) 
	(header_str = sprintf(nil "%s\n%s" header_str data_str)) 
	(header_str = sprintf(nil "%s\n%s" header_str sep_str)) 
	foreach(key attrData 
	    (ref_list = cons(key ref_list))
	)
	(ref_list = sort(ref_list 
		'axlStrcmpAlpNum
	    )) 
	(ascii_file = strcat(getWorkingDir() "/" 
		(axlCurrentDesign) "_BOM.txt"
	    )) 
	(port = outfile(ascii_file "w")) 
	fprintf(port "%s\n" header_str) 
	(row_nr = 1)
	foreach(refdes ref_list 
	    (tmp_list = list()) 
	    (col_nr = 1) 
	    foreach(attr attr_list 
		(format_str = strcat("%-" 
			sprintf(nil "%d" 
			    col_width[col_nr]
			) "s"
		    )) 
		(pvalue = get(attrData[refdes] attr)) 
		(tmp_value = sprintf(nil format_str pvalue))
		(tmp_list = cons(tmp_value tmp_list)) 
		++col_nr
	    )
	    (tmp_list = reverse(tmp_list)) 
	    (format_str = strcat("%-" 
		    sprintf(nil "%d" 
			col_width[0]
		    ) "d"
		)) 
	    (tmp_value = sprintf(nil format_str row_nr)) 
	    (tmp_list = cons(tmp_value tmp_list)) 
	    (out_str = buildString(tmp_list " | "))
	    fprintf(port "%s\n" out_str) 
	    (row_nr = (row_nr + 1))
	) 
	close(port) 
	printf("Note: File %s has been written\n" ascii_file)
    )
)
procedure(TBX_POSTPROC_Basic_BOM() 
    let((attr_list bom_data col_width) 
	(attr_list = list('REFDES 
		'PART_NUMBER 
		'VALUE 
		'DEVICE_TYPE 
		'X
		'Y 
		'ROTATION 
		'MIRROR
	    )) 
	(bom_data = TBX_POSTPROC_BASICBOM_Extract_Master_Design(attr_list)) 
	TBX_POSTPROC_BASICBOM_Format_Data(bom_data attr_list) 
	(col_width = TBX_POSTPROC_BASICBOM_Calculate_Column_Width(bom_data attr_list))
	TBX_POSTPROC_BASICBOM_Print_Formated_File(bom_data attr_list col_width) 
	TBX_POSTPROC_BASICBOM_Print_CSV_File(bom_data attr_list)
    )
)
procedure(TBX_POSTPROC_Batchplot_Check_Arg(arg predef_args) 
    let((result) 
	cond(((!arg || (type(arg) != 'string)) 
		printf("Warning: Invalid argument %L specified.\n" arg) 
		(result = nil)
	    ) 
	    (exists(x predef_args 
		    (lowerCase(arg) == x)
		) 
		(result = t)
	    ) 
	    (!(tbx_postproc_data->plotsetNames) 
		printf("Warning: Cannot check Batchplot argument %L. File batchplot.cfg does not exist or can't be accessed.\n" arg) 
		(result = t)
	    ) 
	    (!exists(x 
			(tbx_postproc_data->plotsetNames) 
			(lowerCase(arg) == lowerCase(x))
		    ) 
		printf("Warning: Plotset %L not listed in configuration file batchplot.cfg.\n" arg) 
		(result = t)
	    ) 
	    (t 
		(result = t)
	    )
	) result
    )
)
procedure(TBX_POSTPROC_Callback_Main(form_handle) 
    let((input_file output_file port inport data
	    task_type task_name task_arg task_title task_handle
	    user_script script_file design_extents x_ul y_ul
	    cnt ps_file ps_list line file_list
	    view_name new_job active_job name_list result
	    new_list tmp_file on_off_str script_str tmp_script
	    profile_data do_pick cur_task_info new_arg arg_limits
	    arr ok_script
	) 
	case((form_handle->curField) 
	    ("done" 
		(active_job = (axlFormGetField form_handle "job_name")) 
		TBX_POSTPROC_Save_Config(active_job 
		    (tbx_postproc_data->jobData) nil
		) 
		(axlFormClose form_handle)
	    ) 
	    ("add_new_job" 
		(new_job = (axlUIPrompt "Enter new job name:")) 
		when((new_job != "") 
		    (name_list = list()) 
		    foreach(key 
			(tbx_postproc_data->jobData) 
			(name_list = cons(key name_list))
		    ) 
		    if(member(new_job name_list) then 
			printf("Info: Job name already exists\n") else 
			(name_list = cons(new_job name_list))
			(name_list = sort(name_list nil)) 
			(axlFormBuildPopup form_handle "job_name" name_list) 
			(axlFormSetField form_handle "job_name" new_job) 
			((tbx_postproc_data->jobData)[new_job] = TBX_POSTPROC_Copy_Data((tbx_postproc_data->jobDataInit))) 
			TBX_POSTPROC_Load_Joblist(form_handle new_job 
			    (tbx_postproc_data->jobData)
			)
		    )
		)
	    ) 
	    ("delete_job" 
		(active_job = (axlFormGetField form_handle "job_name")) 
		(name_list = list()) 
		foreach(key 
		    (tbx_postproc_data->jobData) 
		    (name_list = cons(key name_list))
		) 
		(name_list = sort(name_list nil))
		(name_list = remove(active_job name_list)) 
		remove(active_job 
		    (tbx_postproc_data->jobData)
		) 
		if((length(name_list) > 0) then 
		    (active_job = car(name_list)) 
		    (axlFormBuildPopup form_handle "job_name" name_list) 
		    (axlFormSetField form_handle "job_name" active_job)
		    TBX_POSTPROC_Load_Joblist(form_handle active_job 
			(tbx_postproc_data->jobData)
		    ) else 
		    (axlFormTreeViewSet form_handle "job_tree" 
			'TV_REMOVEALL nil
		    ) 
		    (axlFormBuildPopup form_handle "job_name" 
			list("")
		    ) 
		    (axlFormSetField form_handle "job_name" "")
		)
	    ) 
	    ("job_name" 
		(active_job = (form_handle->curValue)) 
		TBX_POSTPROC_Load_Joblist(form_handle active_job 
		    (tbx_postproc_data->jobData)
		)
	    )
	    ("job_tree" 
		(active_job = (axlFormGetField form_handle "job_name")) 
		(task_handle = (form_handle->curValueInt)) 
		caseq((form_handle->event) 
		    (rightpopup 
			case((form_handle->curValue) 
			    ("edit_task" 
				(cur_task_info = nil) 
				foreach(dpl 
				    (tbx_postproc_data->jobData)[active_job] 
				    when(((dpl->handle) == task_handle) 
					(cur_task_info = dpl)
				    )
				) 
				when(cur_task_info 
				    cond((((cur_task_info->taskType) == "user") 
					    printf("Info: User defined script\n")
					) 
					((tbx_postproc_data->argLimits)[(cur_task_info->taskName)] 
					    (arg_limits = (tbx_postproc_data->argLimits)[(cur_task_info->taskName)]) 
					    (new_arg = (axlUIPrompt 
						    sprintf(nil "Edit argument for task %L" 
							(cur_task_info->taskDisplayStr)
						    ) 
						    (cur_task_info->taskArg)
						)) 
					    when(new_arg 
						(arr = (parseQuotedString new_arg)) 
						if(((car(arg_limits) <= length(arr)) && (length(arr) <= cadr(arg_limits))) then 
						    cond((((cur_task_info->taskName) == "cleanup") 
							    (result = TBX_POSTPROC_Cleanup_Check_Arg(new_arg)) 
							    unless(car(result) 
								(axlFormSetField form_handle "predef_task_arg" "")
							    )
							) 
							(((cur_task_info->taskName) == "batchplot") 
							    (result = TBX_POSTPROC_Batchplot_Check_Arg(new_arg 
								    list("all")
								)) 
							    unless(result 
								(axlFormSetField form_handle "predef_task_arg" "all")
							    )
							) 
							(((cur_task_info->taskName) == "varibom") 
							    (result = TBX_POSTPROC_Variant_Check_Arg(new_arg 
								    list("all" "common" "core")
								)) 
							    unless(result 
								(axlFormSetField form_handle "predef_task_arg" "all")
							    )
							) 
							(((cur_task_info->taskName) == "variassy") 
							    (result = TBX_POSTPROC_Variant_Check_Arg(new_arg 
								    list("all" "core")
								)) 
							    unless(result 
								(axlFormSetField form_handle "predef_task_arg" "all")
							    )
							)
						    ) 
						    (cur_task_info->taskArg = new_arg) 
						    (axlFormTreeViewChangeLabel form_handle "job_tree" task_handle 
							strcat((cur_task_info->taskDisplayStr) ": " new_arg)
						    )
						    else 
						    (axlUIConfirm 
							caddr(arg_limits)
						    )
						)
					    )
					) 
					(t 
					    printf("Info: Task %L takes no arguments\n" 
						(cur_task_info->taskDisplayStr)
					    )
					)
				    )
				)
			    ) 
			    ("insert_task" 
				(tbx_postproc_data->newTask = ncons(nil)) 
				((tbx_postproc_data->newTask)->mode = "insert") 
				((tbx_postproc_data->newTask)->refHandle = task_handle) 
				((tbx_postproc_data->newTask)->activeJob = active_job)
				TBX_POSTPROC_Task_Add()
			    ) 
			    ("append_task" 
				(tbx_postproc_data->newTask = ncons(nil)) 
				((tbx_postproc_data->newTask)->mode = "append") 
				((tbx_postproc_data->newTask)->refHandle = task_handle) 
				((tbx_postproc_data->newTask)->activeJob = active_job)
				TBX_POSTPROC_Task_Add()
			    ) 
			    ("delete_task" 
				(new_list = tconc(nil nil)) 
				foreach(tsk 
				    (tbx_postproc_data->jobData)[active_job] 
				    if(((tsk->handle) == task_handle) then t else 
					tconc(new_list tsk)
				    )
				) 
				(new_list = cdar(new_list)) 
				((tbx_postproc_data->jobData)[active_job] = new_list)
				TBX_POSTPROC_Load_Joblist(form_handle active_job 
				    (tbx_postproc_data->jobData)
				)
			    )
			    ("show_info" 
				(tmp_file = (axlTempFile)) 
				(port = outfile(tmp_file "w")) 
				foreach(tsk 
				    (tbx_postproc_data->jobData)[active_job] 
				    when(((tsk->handle) == task_handle) 
					if(((tsk->onState) == t) then 
					    (on_off_str = "On") else 
					    (on_off_str = "Off")
					) 
					if((tsk->replayScript) then 
					    (script_str = (tsk->replayScript)) else 
					    (script_str = "NA")
					) 
					fprintf(port "Name:          %s\n" 
					    (tsk->taskName)
					) 
					fprintf(port "Display title: %s\n" 
					    (tsk->taskDisplayStr)
					)
					fprintf(port "Type:          %s\n" 
					    (tsk->taskType)
					) 
					fprintf(port "State:         %s\n" on_off_str) 
					fprintf(port "User script:   %s\n" script_str) 
					fprintf(port "\n") 
					fprintf(port "Description:\n")
					if((((tsk->taskType) == "system") || ((tsk->taskType) == "toolbox")) then 
					    fprintf(port "%s\n" 
						(tbx_postproc_data->taskFunc)[(tsk->taskName)]
					    ) else 
					    fprintf(port "User defined script\n")
					)
				    )
				) 
				close(port)
				(axlUIViewFileCreate tmp_file "Post Processing: Task info" nil) 
				(axlTempFileRemove tmp_file)
			    )
			)
		    ) 
		    (normal 
			TBX_POSTPROC_Update_Task_State(form_handle task_handle active_job 
			    (tbx_postproc_data->jobData)
			)
		    )
		)
	    ) 
	    ("all_on" 
		(active_job = (axlFormGetField form_handle "job_name")) 
		foreach(tsk 
		    (tbx_postproc_data->jobData)[active_job] 
		    (axlFormTreeViewSetSelectState form_handle "job_tree" 
			(tsk->handle) t
		    ) 
		    TBX_POSTPROC_Update_Task_State(form_handle 
			(tsk->handle) active_job 
			(tbx_postproc_data->jobData)
		    )
		)
	    ) 
	    ("all_off" 
		(active_job = (axlFormGetField form_handle "job_name")) 
		foreach(tsk 
		    (tbx_postproc_data->jobData)[active_job] 
		    (axlFormTreeViewSetSelectState form_handle "job_tree" 
			(tsk->handle) nil
		    ) 
		    TBX_POSTPROC_Update_Task_State(form_handle 
			(tsk->handle) active_job 
			(tbx_postproc_data->jobData)
		    )
		)
	    ) 
	    ("save_config" 
		(active_job = (axlFormGetField form_handle "job_name")) 
		(output_file = (axlDMFileBrowse "ALLEGRO_TEXT" t)) 
		when(output_file 
		    TBX_POSTPROC_Save_Config(active_job 
			(tbx_postproc_data->jobData) output_file
		    )
		)
	    ) 
	    ("load_config" 
		(input_file = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
		when(input_file 
		    (port = infile(input_file)) 
		    (data = car(lineread(port))) 
		    close(port) 
		    (result = TBX_POSTPROC_Parse_Config(data))
		    (active_job = car(result)) 
		    (tbx_postproc_data->jobData = cadr(result)) 
		    (name_list = TBX_UTIL_Get_Hash_Keys((tbx_postproc_data->jobData) t)) 
		    (axlFormBuildPopup form_handle "job_name" name_list) 
		    (axlFormSetField form_handle "job_name" active_job)
		    TBX_POSTPROC_Load_Joblist(form_handle active_job 
			(tbx_postproc_data->jobData)
		    )
		)
	    )
	    ("setup_artwork" 
		(axlShell "artwork")
	    ) 
	    ("setup_basic_plot" 
		TBX_PLOTBASE_Print_Setup_Main((tbx_postproc_data->licCheck) 
		    (tbx_postproc_data->version) "basicplot"
		)
	    ) 
	    ("setup_batch_plot" 
		when(isCallable('TBX_BATCHPLOT_Main) 
		    TBX_BATCHPLOT_Main()
		)
	    ) 
	    ("setup_cross_section" 
		when(isCallable('TBX_XSECGEN_Main) 
		    TBX_XSECGEN_Main()
		)
	    ) 
	    ("setup_custom_variables" 
		when(isCallable('TBX_CUSTOMVAR_Main) 
		    TBX_CUSTOMVAR_Main("update")
		)
	    )
	    ("setup_drawing_designer" 
		when(isCallable('TBX_DRAWINGDES_Main) 
		    (TBX_DRAWINGDES_Main)
		)
	    ) 
	    ("setup_nc_drill_legend" 
		(axlShell "ncdrill legend")
	    ) 
	    ("setup_nc_drill_data" 
		(axlShell "nctape_full")
	    ) 
	    ("setup_nc_route" 
		(axlShell "ncroute")
	    ) 
	    ("setup_mfg_collect" 
		when(isCallable('TBX_MFGCOLLECT_Main) 
		    TBX_MFGCOLLECT_Main()
		)
	    )
	    ("setup_variant_assembly" 
		when(isCallable('TBX_VARIASSY_Main) 
		    TBX_VARIASSY_Main()
		)
	    ) 
	    ("setup_variant_bom" 
		when(isCallable('TBX_VARIBOM_Main) 
		    TBX_VARIBOM_Main()
		)
	    ) 
	    ("run" 
		(design_extents = ((axlGetParam "paramDesign")->bBox)) 
		(x_ul = caar(design_extents)) 
		(y_ul = cadadr(design_extents)) 
		(x_ul = (x_ul + (axlMKSConvert "1.0 MM" 
			    car((axlDBGetDesignUnits))
			)))
		(y_ul = (y_ul - (axlMKSConvert "1.0 MM" 
			    car((axlDBGetDesignUnits))
			))) 
		(script_file = strcat((tbx_postproc_data->runDir) "/postproc.scr")) 
		(port = outfile(script_file "w")) 
		fprintf(port "scriptmode +i\n") 
		fprintf(port "trapsize 0\n")
		fprintf(port "setwindow pcb\n") 
		fprintf(port "generaledit\n") 
		fprintf(port "echo Starting mfg processes...\n") 
		(active_job = (axlFormGetField form_handle "job_name")) 
		foreach(tsk 
		    (tbx_postproc_data->jobData)[active_job] 
		    when((tsk->onState) 
			(task_type = (tsk->taskType)) 
			(task_name = (tsk->taskName)) 
			(task_arg = (tsk->taskArg)) 
			(task_title = (tsk->taskDisplayStr))
			(user_script = (tsk->replayScript)) 
			fprintf(port "echo -----------------------------------------\n") 
			fprintf(port "echo Process %s...\n" task_title) 
			fprintf(port "echo -----------------------------------------\n") 
			when(((lowerCase(task_type) == "system") || (lowerCase(task_type) == "toolbox")) 
			    case(lowerCase(task_name) 
				("customvar" 
				    if(rexMatchList("^TBX_CUSTOMVAR" 
					    (tbx_postproc_data->tbxCmdList)
					) then 
					fprintf(port "tbx customvar update\n") 
					fprintf(port "setwindow form.tbx_customvar_main\n") 
					fprintf(port "FORM tbx_customvar_main var_update\n")
					fprintf(port "FORM tbx_customvar_main done\n") 
					fprintf(port "setwindow pcb\n") else 
					fprintf(port "echo Warning: Module CUSTOMVAR not available. Skipping....\n")
				    )
				) 
				("xsecgen" 
				    unless((axlSelectByName "SYMTYPE" "TBX_XSECGEN") 
					(do_pick = t)
				    ) 
				    if(rexMatchList("^TBX_XSECGEN" 
					    (tbx_postproc_data->tbxCmdList)
					) then 
					fprintf(port "tbx xsecgen\n") 
					when(do_pick 
					    ((tbx_postproc_data->batchControl)->xsecgenSymLocation = (x_ul:y_ul))
					) 
					fprintf(port "setwindow form.tbx_xsecgen_main\n")
					fprintf(port "FORM tbx_xsecgen_main run\n") 
					fprintf(port "FORM tbx_xsecgen_main done \n") 
					fprintf(port "setwindow pcb\n") else 
					fprintf(port "echo Warning: Module XSECGEN not available. Skipping....\n")
				    )
				) 
				("varibom" 
				    if(rexMatchList("^TBX_VARIBOM" 
					    (tbx_postproc_data->tbxCmdList)
					) then 
					(ok_script = nil) 
					case(lowerCase(task_arg) 
					    ("core" 
						(ok_script = t)
					    ) 
					    ("all" 
						if((length((tbx_postproc_data->variantNames)) > 0) then 
						    (ok_script = t) else 
						    (ok_script = nil)
						    fprintf(port "echo Warning: Cannot process Variant BOM. There are no variants defined.\n")
						)
					    ) 
					    ("common" 
						if((length((tbx_postproc_data->variantNames)) > 0) then 
						    (ok_script = t) else 
						    (ok_script = nil)
						    fprintf(port "echo Warning: echo Warning: Cannot process Variant BOM. There are no variants defined.\n")
						)
					    ) 
					    (t 
						if(exists(x 
							(tbx_postproc_data->variantNames) 
							(upperCase(x) == upperCase(task_arg))
						    ) then 
						    (ok_script = t) else 
						    (ok_script = nil)
						    fprintf(port "echo Warning: echo Warning: Cannot process Variant BOM. Unknown variant name %L.\n" 
							upperCase(task_arg)
						    )
						)
					    )
					) 
					when(ok_script 
					    fprintf(port "tbx varibom\n") 
					    fprintf(port "setwindow form.tbx_varibom_main\n") 
					    case(lowerCase(task_arg) 
						("core" 
						    fprintf(port "FORM tbx_varibom_main variant_name Core Design\n") 
						    fprintf(port "FORM tbx_varibom_main report_name core\n")
						) 
						("all" 
						    fprintf(port "FORM tbx_varibom_main variant_name All Variants\n")
						) 
						("common" 
						    fprintf(port "FORM tbx_varibom_main variant_name Common\n") 
						    fprintf(port "FORM tbx_varibom_main report_name common\n")
						) 
						(t 
						    fprintf(port "FORM tbx_varibom_main variant_name %s\n" 
							upperCase(task_arg)
						    ) 
						    fprintf(port "FORM tbx_varibom_main report_name %s\n" 
							lowerCase(task_arg)
						    )
						)
					    ) 
					    fprintf(port "FORM tbx_varibom_main view_text  NO\n")
					    fprintf(port "FORM tbx_varibom_main view_csv   NO\n") 
					    fprintf(port "FORM tbx_varibom_main view_html  NO\n") 
					    fprintf(port "FORM tbx_varibom_main run\n") 
					    fprintf(port "FORM tbx_varibom_main done\n") 
					    fprintf(port "setwindow pcb\n")
					)
					else 
					fprintf(port "echo Warning: Module VARIBOM not available. Skipping....\n")
				    )
				) 
				("variassy" 
				    if(rexMatchList("^TBX_VARIASSY" 
					    (tbx_postproc_data->tbxCmdList)
					) then 
					(ok_script = nil) 
					case(lowerCase(task_arg) 
					    ("core" 
						(ok_script = t)
					    ) 
					    ("all" 
						if((length((tbx_postproc_data->variantNames)) > 0) then 
						    (ok_script = t) else 
						    (ok_script = nil)
						    fprintf(port "echo Warning: Cannot process Variant Assembly. There are no variants defined.\n")
						)
					    ) 
					    (t 
						if(exists(x 
							(tbx_postproc_data->variantNames) 
							(upperCase(x) == upperCase(task_arg))
						    ) then 
						    (ok_script = t) else 
						    (ok_script = nil)
						    fprintf(port "echo Warning: Cannot process Variant Assembly. Unknown variant name %L.\n" 
							upperCase(task_arg)
						    )
						)
					    )
					) 
					when(ok_script 
					    fprintf(port "tbx variassy \n") 
					    fprintf(port "setwindow form.tbx_variassy_main\n") 
					    case(lowerCase(task_arg) 
						("core" 
						    fprintf(port "FORM tbx_variassy_main variant Core Design \n")
						) 
						("all" 
						    fprintf(port "FORM tbx_variassy_main variant All Variants \n")
						) 
						(t 
						    fprintf(port "FORM tbx_variassy_main variant %s\n" 
							upperCase(task_arg)
						    )
						)
					    ) 
					    fprintf(port "FORM tbx_variassy_main run  \n")
					    fprintf(port "FORM tbx_variassy_main done  \n") 
					    fprintf(port "setwindow pcb\n")
					)
					else 
					fprintf(port "echo Warning: Module VARIASSY not available. Skipping....\n")
				    )
				)
				("drawingdes" 
				    if(rexMatchList("^TBX_DRAWINGDES" 
					    (tbx_postproc_data->tbxCmdList)
					) then 
					fprintf(port "tbx drawingdes\n") 
					fprintf(port "setwindow form.tbx_drawingdes_main\n") 
					fprintf(port "FORM tbx_drawingdes_main update_all\n")
					fprintf(port "FORM tbx_drawingdes_main done\n") 
					fprintf(port "setwindow pcb\n") else 
					fprintf(port "echo Warning: Module  DRAWINGDES not available. Skipping....\n")
				    )
				) 
				("batchplot" 
				    if(rexMatchList("^TBX_BATCHPLOT" 
					    (tbx_postproc_data->tbxCmdList)
					) then 
					(ok_script = nil) 
					case(lowerCase(task_arg) 
					    ("all" 
						if((length((tbx_postproc_data->plotsetNames)) > 0) then 
						    (ok_script = t) else 
						    (ok_script = nil)
						    fprintf(port "echo Warning: echo Warning: Cannot process Batch Plot. There are no plot sets defined.\n")
						)
					    ) 
					    (t 
						if(exists(x 
							(tbx_postproc_data->plotsetNames) 
							(lowerCase(x) == lowerCase(task_arg))
						    ) then 
						    (ok_script = t) else 
						    (ok_script = nil)
						    fprintf(port "echo Warning: Cannot process Batch Plot. Unknown plot set name %L.\n" task_arg)
						)
					    )
					) 
					when(ok_script 
					    fprintf(port "tbx batchplot\n") 
					    fprintf(port "setwindow form.tbx_batchplot_main\n") 
					    case(lowerCase(task_arg) 
						("all" 
						    fprintf(port "FORM tbx_batchplot_main plot_all\n")
						) 
						(t 
						    fprintf(port "FORM tbx_batchplot_main plot_set_list %s\n" 
							lowerCase(task_arg)
						    ) 
						    fprintf(port "FORM tbx_batchplot_main plot_selected\n")
						)
					    ) 
					    fprintf(port "FORM tbx_batchplot_main done\n")
					    fprintf(port "setwindow pcb\n")
					)
					else 
					fprintf(port "echo Warning: Module  BATCHPLOT not available. Skipping....\n")
				    )
				) 
				("shapeupdate" 
				    fprintf(port "tbx batch shapeupdate\n") 
				    fprintf(port "setwindow pcb\n")
				) 
				("basicbom" 
				    fprintf(port "tbx batch basicbom\n") 
				    fprintf(port "setwindow pcb\n")
				) 
				("cleanup" 
				    fprintf(port "tbx batch cleanup %s\n" task_arg) 
				    fprintf(port "setwindow pcb\n")
				)
				("zipdata" 
				    ((tbx_postproc_data->batchControl)->zipArg = task_arg) 
				    fprintf(port "tbx batch zip\n") 
				    fprintf(port "setwindow pcb\n")
				) 
				("ncdrilllegend" 
				    fprintf(port "ncdrill legend\n") 
				    fprintf(port "setwindow form.nc_drilllegend\n") 
				    fprintf(port "FORM nc_drilllegend done\n") 
				    fprintf(port "setwindow pcb\n")
				    fprintf(port "pick grid %f  %f\n" x_ul y_ul) 
				    fprintf(port "setwindow pcb\n")
				) 
				("ncdrilldata" 
				    fprintf(port "nctape_full \n") 
				    fprintf(port "setwindow form.nc_drill\n") 
				    fprintf(port "FORM nc_drill execute  \n") 
				    fprintf(port "FORM nc_drill close  \n")
				    fprintf(port "setwindow pcb\n")
				) 
				("ncroutedata" 
				    fprintf(port "ncroute \n") 
				    fprintf(port "setwindow form.nc_route\n") 
				    fprintf(port "FORM nc_route execute \n") 
				    fprintf(port "FORM nc_route close \n")
				    fprintf(port "setwindow pcb\n")
				) 
				("artwork" 
				    fprintf(port "artwork \n") 
				    fprintf(port "setwindow form.film_control\n") 
				    fprintf(port "FORM film_control select_all  \n") 
				    fprintf(port "FORM film_control create  \n")
				    fprintf(port "FORM film_control ok  \n") 
				    fprintf(port "setwindow pcb\n")
				)
				("basicplot" 
				    when(TBX_PLOTBASE_Check_System_Environment() 
					(cnt = 1) 
					(ps_list = list()) 
					if(((axlGetParam "artwork")->groupMembers) then 
					    (file_list = (TBX_UTIL_Search_Config "basicplot.profile" "postproc" nil ?includeWorkDir
						    t ?includeRunDir t
						)) 
					    if(car(file_list) then 
						(profile_data = TBX_PLOTBASE_Read_Profile(car(file_list))) 
						(tmp_script = (axlTempFile t)) 
						(tmp_script = TBX_PLOTBASE_Print_Setup_Execute(profile_data tmp_script nil))
						when(tmp_script 
						    (inport = infile(tmp_script)) 
						    while((line = _gets(inport)) 
							fprintf(port "%s" line)
						    ) 
						    close(inport)
						) 
						unless(axlGetVariable("FLW_DEBUG") 
						    deleteFile(tmp_script)
						) 
						(tmp_script = (axlTempFile t)) 
						foreach(flm 
						    ((axlGetParam "artwork")->groupMembers) 
						    (ps_file = strcat("artwork_" 
							    sprintf(nil "%02d" cnt) ".ps"
							)) 
						    (cnt = (cnt + 1)) 
						    (ps_list = cons(ps_file ps_list))
						    (view_name = strcat("Film: " flm)) 
						    (tmp_script = TBX_PLOTBASE_Generate_Postscript(view_name ps_file 
							    ((tbx_postproc_data->printerParam)->driver) profile_data tmp_script
							    nil "a"
							))
						) 
						when(tmp_script 
						    (inport = infile(tmp_script)) 
						    while((line = _gets(inport)) 
							fprintf(port "%s" line)
						    ) 
						    close(inport)
						)
						unless(axlGetVariable("FLW_DEBUG") 
						    deleteFile(tmp_script)
						) 
						(ps_list = reverse(ps_list)) 
						(tbx_postproc_data->psList = ps_list) 
						fprintf(port "tbx batch makepdf\n") else
						printf("Warning: Missing configuration file basicplot.profile  in share/pcb/toolbox/config/postproc directory. Skipping plot process...\n")
					    ) else
					    printf("Warning: Missing artwork film definitions. Skipping plot process...\n")
					)
				    )
				) 
				("mfgcollect" 
				    fprintf(port "tbx mfgcollect\n") 
				    fprintf(port "setwindow form.tbx_mfgcollect_main\n") 
				    fprintf(port "FORM tbx_mfgcollect_main run\n") 
				    fprintf(port "FORM tbx_mfgcollect_main done\n")
				    fprintf(port "setwindow pcb\n")
				)
			    )
			)
			when((lowerCase(task_type) == "user") 
			    when(user_script 
				(user_script = (axlOSSlash user_script)) 
				(user_script = TBX_UTIL_Get_Flat_Path(user_script)) 
				if((isFile(user_script) && isReadable(user_script)) then 
				    (inport = infile(user_script)) 
				    while((line = _gets(inport)) 
					fprintf(port "%s" line)
				    ) 
				    close(inport)
				    else 
				    printf("Error: Cannot read file %L\n" user_script)
				)
			    )
			)
		    )
		)
		close(port) 
		(axlShell 
		    strcat("replay " 
			sprintf(nil "%L" script_file)
		    )
		) 
		(axlVisibleSet 
		    (tbx_postproc_data->orgVis)
		) 
		(axlVisibleUpdate t) 
		when(isFile(script_file) t)
	    ) 
	    ("my_help" 
		(axlShell "tbx help postproc")
	    ) 
	    (t)
	)
    )
)
procedure(TBX_POSTPROC_Cleanup(arg) 
    let((result cur_dir item name_regxp os_object) 
	(result = TBX_POSTPROC_Cleanup_Check_Arg(arg)) 
	when(axlGetVariable("FLW_DEBUG") 
	    foreach(entry arg 
		printf("---> Cleanup arguments: %L\n" entry)
	    )
	) 
	if(car(result) then 
	    foreach(arg_list 
		cadr(result) 
		(cur_dir = car(arg_list)) 
		(item = cadr(arg_list)) 
		when(isDir(cur_dir) 
		    (name_regxp = TBX_UTIL_Regex_From_Shell(item t)) 
		    foreach(obj 
			rexMatchList(name_regxp 
			    getDirFiles(cur_dir)
			) 
			when(((obj != ".") && (obj != "..")) 
			    (os_object = strcat(cur_dir "/" obj)) 
			    if(isDir(os_object) then 
				TBX_UTIL_Clear_Directory(os_object) 
				printf("Deleting directory: %L ...\n" os_object) 
				deleteDir(os_object)
				else 
				printf("Deleting file: %L ...\n" os_object) 
				deleteFile(os_object)
			    )
			)
		    )
		)
	    ) else 
	    printf("%s\n" 
		cadr(result)
	    )
	) t
    )
)
procedure(TBX_POSTPROC_Cleanup_Check_Arg(arg) 
    let((clean_arg work_dir file_parts clean_dir file
	    ext result okay_arg msg tmp_list
	    item
	) 
	(work_dir = (axlOSSlash 
		getWorkingDir()
	    )) 
	rexCompile("[*]+") 
	(arg = rexReplace(arg "*" 0)) 
	foreach(entry 
	    (parseQuotedString arg) 
	    (okay_arg = nil) 
	    (clean_arg = (axlOSSlash 
		    simplifyFilename(entry)
		)) 
	    (file_parts = (axlDMFileParts clean_arg))
	    (clean_dir = car(file_parts)) 
	    (file = cadr(file_parts)) 
	    (item = caddr(file_parts)) 
	    (ext = nth(3 file_parts)) 
	    cond((!clean_dir 
		    (okay_arg = nil) 
		    (msg = sprintf(nil "Warning: Invalid directory specified\n"))
		) 
		(!index(clean_dir work_dir) 
		    (okay_arg = nil) 
		    (msg = sprintf(nil "Error: For safety reasons only local subdirectories  (e.g. . or ./mfg ) are allowed, cannot point outside\n"))
		) 
		(index(clean_dir work_dir) 
		    if((clean_dir == work_dir) then 
			if(((file == "*") && (!ext || (ext == "*"))) then 
			    (okay_arg = nil) 
			    (msg = sprintf(nil "Error: Global wildcard not allowed when deleting files in current working directory\n")) else
			    (okay_arg = t)
			) else 
			(okay_arg = t)
		    )
		)
	    )
	    if(okay_arg then 
		(tmp_list = cons(list(clean_dir item) tmp_list)) else 
		printf("Warning: Skipping invalid argument: %L\n" entry)
	    )
	)
	if(tmp_list then 
	    (result = list(t tmp_list)) else 
	    (result = list(nil msg))
	) result
    )
)
procedure(TBX_POSTPROC_Copy_Data(list_data) 
    let((ret_list) 
	(ret_list = list()) 
	foreach(entry list_data 
	    (ret_list = cons(copy(entry) ret_list))
	) 
	(ret_list = reverse(ret_list)) ret_list
    )
)
procedure(TBX_POSTPROC_Generate_PDF() 
    let((pdf_file ps_list) 
	if(axlGetVariable("ads_sdplot") then 
	    (ps_list = list()) 
	    (pdf_file = strcat(axlGetVariable("ads_sdplot") "/artwork.pdf")) 
	    foreach(ps 
		(tbx_postproc_data->psList) 
		(ps_list = cons(strcat(axlGetVariable("ads_sdplot") "/" ps) ps_list))
	    )
	    else 
	    (pdf_file = "./artwork.pdf") 
	    (ps_list = (tbx_postproc_data->psList))
	) 
	if(axlGetVariable("FLW_DEBUG") then 
	    TBX_PLOTBASE_Generate_PDF(ps_list pdf_file 
		(tbx_postproc_data->printerParam) t t
	    ) else 
	    TBX_PLOTBASE_Generate_PDF(ps_list pdf_file 
		(tbx_postproc_data->printerParam) t nil
	    )
	) 
	unless(axlGetVariable("FLW_DEBUG") 
	    foreach(f ps_list 
		deleteFile(f)
	    )
	) t
    )
)
procedure(TBX_POSTPROC_Init() 
    let((init_job_data default_list task_function str tbx_cmd_list
	    tbx_command_pattern ok_include arg_limits design_type layout_type
	    run_dir plotset_names variant_names
	) 
	(design_type = upperCase((axlDesignType t))) 
	if(((design_type == "MCM") || (design_type == "SIP")) then 
	    (layout_type = "MCM/SIP") else 
	    (layout_type = "BRD")
	) 
	(run_dir = strcat(getWorkingDir() "/toolbox.run")) 
	unless(isDir(run_dir) 
	    createDir(run_dir)
	)
	if((layout_type == "MCM/SIP") then 
	    (default_list = list(list("system" "shapeupdate" nil "Update Shapes" t
			nil
		    ) 
		    list("toolbox" "customvar" nil "Custom Variables" nil
			nil
		    ) 
		    list("system" "cleanup" "./mfg/*.*" "Clean Data" nil
			nil
		    ) 
		    list("system" "ncdrilllegend" nil "NC Drill Legend" t
			nil
		    ) 
		    list("system" "ncdrilldata" nil "NC Drill Data" t
			nil
		    )
		    list("system" "ncroutedata" nil "NC Route Data" nil
			nil
		    ) 
		    list("system" "artwork" nil "Artwork Data" t
			nil
		    ) 
		    list("system" "basicplot" nil "Standard Plot" t
			nil
		    ) 
		    list("toolbox" "batchplot" "all" "Batch Plot" nil
			nil
		    ) 
		    list("system" "mfgcollect" nil "Mfg Collector" nil
			nil
		    )
		    list("system" "zipdata" "output.zip ./mfg" "Zip Data" t
			nil
		    )
		)) else 
	    (default_list = list(list("system" "shapeupdate" nil "Update Shapes" t
			nil
		    ) 
		    list("toolbox" "customvar" nil "Custom Variables" nil
			nil
		    ) 
		    list("toolbox" "xsecgen" nil "Cross Section" nil
			nil
		    ) 
		    list("system" "cleanup" "./mfg/*.*" "Clean Data" nil
			nil
		    ) 
		    list("system" "basicbom" nil "Standard BOM" t
			nil
		    )
		    list("toolbox" "varibom" "core" "Variant BOM" nil
			nil
		    ) 
		    list("toolbox" "variassy" "core" "Variant Assembly" nil
			nil
		    ) 
		    list("toolbox" "drawingdes" nil "Drawing Designer" nil
			nil
		    ) 
		    list("system" "ncdrilllegend" nil "NC Drill Legend" t
			nil
		    ) 
		    list("system" "ncdrilldata" nil "NC Drill Data" t
			nil
		    )
		    list("system" "ncroutedata" nil "NC Route Data" nil
			nil
		    ) 
		    list("system" "artwork" nil "Artwork Data" t
			nil
		    ) 
		    list("system" "basicplot" nil "Standard Plot" t
			nil
		    ) 
		    list("toolbox" "batchplot" "all" "Batch Plot" nil
			nil
		    ) 
		    list("system" "mfgcollect" nil "Mfg Collector" nil
			nil
		    )
		    list("system" "zipdata" "output.zip ./mfg" "Zip Data" t
			nil
		    )
		))
	) 
	(tbx_cmd_list = TBX_UTIL_Get_Toolbox_Functions()) 
	(init_job_data = list()) 
	foreach(entry default_list 
	    (ok_include = nil) 
	    cond(((car(entry) == "system") 
		    (ok_include = t)
		) 
		((car(entry) == "toolbox") 
		    (tbx_command_pattern = upperCase(strcat("^TBX_" 
				cadr(entry)
			    )
			)) 
		    when(rexMatchList(tbx_command_pattern tbx_cmd_list) 
			(ok_include = t)
		    )
		)
	    ) 
	    when(ok_include 
		(init_job_data = cons(list(nil 
			    'taskType 
			    car(entry) 
			    'taskName 
			    cadr(entry)
			    'taskArg 
			    caddr(entry) 
			    'taskDisplayStr 
			    nth(3 entry) 
			    'onState
			    nth(4 entry) 
			    'replayScript 
			    nth(5 entry)
			) init_job_data
		    ))
	    )
	) 
	(init_job_data = reverse(init_job_data))
	(task_function = makeTable("task_function_table" nil)) 
	(str = "") 
	(str = sprintf(nil "%s This function will update all dynamic shapes in the design.\n" str)) 
	(task_function["shapeupdate"] = str) 
	(str = "")
	(str = sprintf(nil "%s This function will update all custom variables in the design.\n" str)) 
	(task_function["customvar"] = str) 
	(str = "") 
	(str = sprintf(nil "%s This function will update the cross section drawing in the design.\n" str)) 
	(task_function["xsecgen"] = str)
	(str = "") 
	(str = sprintf(nil "%s This function will generate a standard BOM report in csv and text format.\n" str)) 
	(str = sprintf(nil "%s Builtin function in module \"Post Processing\".\n" str)) 
	(task_function["basicbom"] = str) 
	(str = "")
	(str = sprintf(nil "%s This function will generate advanced BOM reports (csv and txt)\n" str)) 
	(str = sprintf(nil "%s for core design as well as for individual variants.\n" str)) 
	(str = sprintf(nil "%s Arguments can be provided: \"core\", \"all\", \"common\" \n" str)) 
	(str = sprintf(nil "%s the name of the individual variant.\n" str)) 
	(task_function["varibom"] = str)
	(str = "") 
	(str = sprintf(nil "%s This function will generate advanced assembly drawings\n" str)) 
	(str = sprintf(nil "%s for core design as well as for individual variants.\n" str)) 
	(str = sprintf(nil "%s Arguments can be provided: \"core\", \"all\" or\n" str)) 
	(str = sprintf(nil "%s the name of the individual variant.\n" str))
	(task_function["variassy"] = str) 
	(str = "") 
	(str = sprintf(nil "%s This function will update drawing items (e.g. scaled views) which have been\n" str)) 
	(str = sprintf(nil "%s defined by Floware module \"Drawing Designer\".\n" str)) 
	(task_function["drawingdes"] = str)
	(str = "") 
	(str = sprintf(nil "%s This function will update drill legends in the design.\n" str)) 
	(task_function["ncdrilllegend"] = str) 
	(str = "") 
	(str = sprintf(nil "%s This function will generate NC drill data for the design.\n" str))
	(task_function["ncdrilldata"] = str) 
	(str = "") 
	(str = sprintf(nil "%s This function will generate NC route data for the design.\n" str)) 
	(task_function["ncroutedata"] = str) 
	(str = "")
	(str = sprintf(nil "%s This function will generate artwork data for the design.\n" str)) 
	(task_function["artwork"] = str) 
	(str = "") 
	(str = sprintf(nil "%s This function will generate a combined PDF of all artwork records in the design.\n" str)) 
	(str = sprintf(nil "%s Builtin function in module \"Post Processing\".\n" str))
	(task_function["basicplot"] = str) 
	(str = "") 
	(str = sprintf(nil "%s This function will generate PDF data according to module \"BatchPlot\".\n" str)) 
	(str = sprintf(nil "%s Arguments can be provided: \"all\"  when plotting all plotsets or\n" str)) 
	(str = sprintf(nil "%s the name of the individual plotset for which a PDF file has to be genearated.\n" str))
	(task_function["batchplot"] = str) 
	(str = "") 
	(str = sprintf(nil "%s This function will rename and move files based on rulesets provided.\n" str)) 
	(str = sprintf(nil "%s Builtin function in module \"Post Processing\".\n" str)) 
	(task_function["mfgcollect"] = str)
	(str = "") 
	(str = sprintf(nil "%s This function will cleanup directories based on arguments provided.\n" str)) 
	(str = sprintf(nil "%s Builtin function in module \"Post Processing\".\n" str)) 
	(task_function["cleanup"] = str) 
	(str = "")
	(str = sprintf(nil "%s This function will zip data based on arguments provided.\n" str)) 
	(str = sprintf(nil "%s Builtin function in module \"Post Processing\".\n" str)) 
	(task_function["zipdata"] = str) 
	(arg_limits = makeTable("arg_limits_table" nil)) 
	(arg_limits["varibom"] = list(1 1 "Takes only one argument: <variant_name>, core, common or all"))
	(arg_limits["variassy"] = list(1 1 "Takes only one argument: <variant_name> core or all")) 
	(arg_limits["batchplot"] = list(1 1 "Takes only one argument: <plotset_name> or all")) 
	(arg_limits["cleanup"] = list(1 10 "Takes at least one argument for directories or files to be deleted: e.g. \"./*.log*  ./.*jrl*\"")) 
	(arg_limits["zipdata"] = list(2 10 "Takes at least two arguments output_file followed by item to be zipped, e.g. \"myoutput.zip  ./mfg  ./fab/*.pdf\"")) 
	(plotset_names = TBX_POSPTROC_Get_Plotset_Names())
	(variant_names = TBX_POSPTROC_Get_Variant_Names()) 
	unless(boundp('tbx_postproc_data) 
	    iliDefstruct('defstruct(tbx_postproc_data_struct jobDataInit jobData printerParam batchControl
			orgVis psList taskFunc newTask formHandle
			licCheck version argLimits tbxCmdList layoutType
			runDir plotsetNames variantNames
		    )
	    ) 
	    defvar(tbx_postproc_data nil)
	) 
	if(!tbx_postproc_data then 
	    (tbx_postproc_data = (make_tbx_postproc_data_struct ?jobDataInit init_job_data ?jobData nil
		    ?batchControl 
		    ncons(nil) ?printerParam nil ?psList
		    nil ?newTask nil ?orgVis 
		    (axlVisibleGet)
		    ?formHandle 
		    ncons(nil) ?licCheck nil ?version
		    nil ?taskFunc task_function ?argLimits arg_limits
		    ?tbxCmdList tbx_cmd_list ?layoutType layout_type ?runDir
		    run_dir ?plotsetNames plotset_names ?variantNames variant_names
		)) else 
	    (tbx_postproc_data->jobDataInit = init_job_data)
	    (tbx_postproc_data->jobData = nil) 
	    (tbx_postproc_data->batchControl = ncons(nil)) 
	    (tbx_postproc_data->printerParam = nil) 
	    (tbx_postproc_data->psList = nil) 
	    (tbx_postproc_data->newTask = nil)
	    (tbx_postproc_data->orgVis = (axlVisibleGet)) 
	    (tbx_postproc_data->formHandle = ncons(nil)) 
	    (tbx_postproc_data->licCheck = nil) 
	    (tbx_postproc_data->version = nil) 
	    (tbx_postproc_data->taskFunc = task_function)
	    (tbx_postproc_data->argLimits = arg_limits) 
	    (tbx_postproc_data->tbxCmdList = tbx_cmd_list) 
	    (tbx_postproc_data->layoutType = layout_type) 
	    (tbx_postproc_data->runDir = run_dir) 
	    (tbx_postproc_data->plotsetNames = plotset_names)
	    (tbx_postproc_data->variantNames = variant_names)
	)
    )
)
procedure(TBX_POSTPROC_Load_Joblist(form_handle active_job job_data) 
    let((handle task_display) 
	(axlFormTreeViewSet form_handle "job_tree" 
	    'TV_REMOVEALL nil
	) 
	when((active_job && job_data[active_job]) 
	    foreach(tsk 
		job_data[active_job] 
		(task_display = (tsk->taskDisplayStr)) 
		if((tsk->taskArg) then 
		    (task_display = strcat((tsk->taskDisplayStr) ": " 
			    (tsk->taskArg)
			)) else 
		    (task_display = (tsk->taskDisplayStr))
		) 
		(handle = (axlFormTreeViewAddItem form_handle "job_tree" task_display nil
			nil t
		    ))
		(tsk->handle = handle) 
		(axlFormTreeViewSetSelectState form_handle "job_tree" 
		    (tsk->handle) 
		    (tsk->onState)
		)
	    ) 
	    (axlFormTreeViewSet form_handle "job_tree" 
		'TV_NOEDITLABEL nil
	    )
	)
    )
)
procedure((TBX_POSTPROC_Main \@optional arg) 
    let((lic_check_result FORM_FILE fid VERSION_STR FC_FEATURE
	    FC_VERSION SUB_VERSION port info_file att
	    data result active_job name_list printer_param
	    ok_continue msg cfg_list ini_file
	) 
	(FC_FEATURE = "POSTPROC") 
	(FC_VERSION = "17.1") 
	(SUB_VERSION = "02") 
	(VERSION_STR = sprintf(nil "Post Processing %s (C)2017" FC_VERSION))
	(printer_param = TBX_PLOTBASE_Check_System_Environment(nil)) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./postproc_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Post Processing information:\n") 
		fprintf(port "=============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  reset   : Deletes configuration from database. Default settings will be used after launch\n") 
		fprintf(port "  version : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port)
		(axlUIViewFileCreate info_file "Post Processing: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "reset")) 
		when((axlUIYesNo "Delete configuration from database?" nil 
			'no
		    ) 
		    printf("Deleting configuration from database...\n") 
		    (axlDeleteAttachment "tbx_postproc")
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    (ok_continue = t) 
		    cond(((((printer_param->platform) == "wint") && (!(printer_param->driver) || !(printer_param->command))) 
			    (msg = sprintf(nil "Warning: PDF Printer not properly configured. Continue anyway?")) 
			    (ok_continue = (axlUIYesNo msg nil 
				    'no
				))
			) 
			(((printer_param->platform) != "wint") 
			    (msg = sprintf(nil "Note: PDF Printing is not supported while running Post Processing on Linux/Unix platforms. Refer to documentation for details (command: tbx help).\nContinue anyway?")) 
			    (ok_continue = (axlUIYesNo msg nil 
				    'no
				))
			)
		    ) 
		    when(ok_continue 
			TBX_POSTPROC_Init() 
			TBX_UTIL_Migrate("flw_postproc" "tbx_postproc") 
			(axlCmdRegister "tbx batch cleanup" 
			    'TBX_POSTPROC_Cleanup ?cmdType "general"
			) 
			(axlCmdRegister "tbx batch zip" 
			    'TBX_POSTPROC_Zip ?cmdType "general"
			)
			(axlCmdRegister "tbx batch shapeupdate" 
			    'TBX_POSTPROC_Update_Shapes ?cmdType "general"
			) 
			(axlCmdRegister "tbx batch basicbom" 
			    'TBX_POSTPROC_Basic_BOM ?cmdType "general"
			) 
			(axlCmdRegister "tbx batch makepdf" 
			    'TBX_POSTPROC_Generate_PDF ?cmdType "general"
			) 
			(axlCmdRegister "tbx batchplot" 
			    'TBX_BATCHPLOT_Main ?cmdType "general"
			) 
			(axlCmdRegister "tbx customvar" 
			    'TBX_CUSTOMVAR_Main ?cmdType "interactive"
			)
			(axlCmdRegister "tbx mfgcollect" 
			    'TBX_MFGCOLLECT_Main ?cmdType "general"
			) 
			(axlCmdRegister "tbx variassy" 
			    'TBX_VARIASSY_Main ?cmdType "general"
			) 
			(axlCmdRegister "tbx varibom" 
			    'TBX_VARIBOM_Main ?cmdType "general"
			) 
			(axlCmdRegister "tbx xsecgen" 
			    'TBX_XSECGEN_Main ?cmdType "interactive"
			) 
			when(isCallable('TBX_DRAWINGDES_Main) 
			    (axlCmdRegister "tbx drawingdes" 
				'TBX_DRAWINGDES_Main ?cmdType "interactive"
			    )
			)
			(tbx_postproc_data->licCheck = lic_check_result) 
			(tbx_postproc_data->version = VERSION_STR) 
			(tbx_postproc_data->printerParam = printer_param) 
			(att = (axlGetAttachment "tbx_postproc" 
				'string
			    )) 
			(tbx_postproc_data->jobData = makeTable("job_data_table" nil))
			(active_job = "default") 
			if(att then 
			    (data = car(linereadstring((att->data)))) else 
			    (ini_file = car(TBX_UTIL_Search_Config("postproc.ini" nil nil ?includeWorkDir t)))
			    when(ini_file 
				printf("Reading defaults from %L\n" ini_file) 
				(data = TBX_UTIL_File_Lineread(ini_file))
			    )
			) 
			when(data 
			    (result = TBX_POSTPROC_Parse_Config(data)) 
			    (active_job = car(result)) 
			    (tbx_postproc_data->jobData = cadr(result))
			) 
			unless((tbx_postproc_data->jobData)[active_job] 
			    ((tbx_postproc_data->jobData)[active_job] = TBX_POSTPROC_Copy_Data((tbx_postproc_data->jobDataInit)))
			) 
			if(((tbx_postproc_data->layoutType) == "MCM/SIP") then 
			    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "postproc_mcm")) else 
			    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "postproc_main"))
			)
			unless(boundp('tbxPostprocMainHandle) 
			    defvar(tbxPostprocMainHandle nil)
			) 
			(fid = (axlFormCreate 
				'tbxPostprocMainHandle FORM_FILE 
				'(e outer) 
				'TBX_POSTPROC_Callback_Main
				t
			    )) 
			when(fid 
			    ((tbx_postproc_data->formHandle)->main = fid) 
			    TBX_FORM_Init_Header(fid "Licensed for " lic_check_result VERSION_STR) 
			    (name_list = TBX_UTIL_Get_Hash_Keys((tbx_postproc_data->jobData) t)) 
			    (axlFormBuildPopup fid "job_name" name_list)
			    (axlFormSetField fid "job_name" active_job) 
			    (cfg_list = list(list("^TBX_BATCHPLOT" "setup_batch_plot") 
				    list("^TBX_XSECGEN" "setup_cross_section") 
				    list("^TBX_CUSTOMVAR" "setup_custom_variables") 
				    list("^TBX_DRAWINGDES" "setup_drawing_designer") 
				    list("^TBX_VARIASSY" "setup_variant_assembly")
				    list("^TBX_VARIBOM" "setup_variant_bom")
				)) 
			    foreach(entry cfg_list 
				unless(rexMatchList(car(entry) 
					(tbx_postproc_data->tbxCmdList)
				    ) 
				    (axlFormSetFieldEditable fid 
					cadr(entry) nil
				    )
				)
			    ) 
			    TBX_POSTPROC_Load_Joblist(fid active_job 
				(tbx_postproc_data->jobData)
			    ) 
			    (axlFormDisplay fid)
			    TBX_FORM_Delete(lic_check_result FORM_FILE)
			)
		    )
		)
	    )
	)
    )
)
procedure(TBX_POSTPROC_Parse_Config(data) 
    let((active_job job_data job_name result tmp_list
	    name_list
	) 
	(job_data = makeTable("job_data_table" nil)) 
	foreach(entry data 
	    caseq(car(entry) 
		(jobData 
		    (job_name = cadr(entry)) 
		    (tmp_list = list()) 
		    foreach(info 
			cddr(entry) 
			(tmp_list = cons(list(nil 
				    'taskType 
				    car(info) 
				    'taskName 
				    cadr(info)
				    'taskArg 
				    caddr(info) 
				    'taskDisplayStr 
				    nth(3 info) 
				    'onState
				    nth(4 info) 
				    'replayScript 
				    nth(5 info)
				) tmp_list
			    ))
		    ) 
		    (tmp_list = reverse(tmp_list))
		    (job_data[job_name] = tmp_list)
		) 
		(activeJob 
		    (active_job = cadr(entry))
		) 
		(t t)
	    )
	) 
	(name_list = TBX_UTIL_Get_Hash_Keys(job_data t)) 
	when((!active_job && (length(name_list) > 0)) 
	    (active_job = car(name_list))
	)
	(result = list(active_job job_data)) result
    )
)
procedure(TBX_POSTPROC_Save_Config(active_job job_data file_arg) 
    let((port data_str task_type task_name task_arg
	    task_display_str task_on_state task_script
	) 
	(data_str = "(\n") 
	(data_str = sprintf(nil "%s   %L\n" data_str 
		list('activeJob active_job)
	    )) 
	foreach(job_name job_data 
	    (data_str = sprintf(nil "%s   (jobData  %L\n" data_str job_name)) 
	    (task_type = "; type") 
	    (task_name = "name")
	    (task_arg = "argument") 
	    (task_display_str = "display title") 
	    (task_on_state = "on/off") 
	    (task_script = "script path") 
	    (data_str = sprintf(nil "%s       %-10s  %-15s  %-10s  %-20s  %-6s  %-12s\n" data_str task_type task_name
		    task_arg task_display_str task_on_state task_script
		))
	    foreach(tsk 
		job_data[job_name] 
		(task_type = sprintf(nil "%L" 
			(tsk->taskType)
		    )) 
		(task_name = sprintf(nil "%L" 
			(tsk->taskName)
		    )) 
		(task_arg = sprintf(nil "%L" 
			(tsk->taskArg)
		    ))
		(task_display_str = sprintf(nil "%L" 
			(tsk->taskDisplayStr)
		    )) 
		(task_on_state = sprintf(nil "%L" 
			(tsk->onState)
		    )) 
		(task_script = sprintf(nil "%L" 
			(tsk->replayScript)
		    )) 
		(data_str = sprintf(nil "%s      (%-10s  %-15s  %-10s  %-20s   %-6s  %-12s)\n" data_str task_type task_name
			task_arg task_display_str task_on_state task_script
		    ))
	    ) 
	    (data_str = sprintf(nil "%s   )\n" data_str))
	) 
	(data_str = sprintf(nil "%s)\n" data_str))
	if(file_arg then 
	    (port = outfile(file_arg "w")) 
	    if(port then 
		fprintf(port "%s" data_str) 
		close(port) else
		printf("Error: Cannot open file %s for write access\n" file_arg)
	    ) else
	    (axlDeleteAttachment "tbx_postproc") 
	    when((length(job_data) > 0) 
		(axlCreateAttachment "tbx_postproc" nil 1 
		    'string
		    data_str
		)
	    )
	) t
    )
)
procedure(TBX_POSTPROC_Task_Add() 
    let((FORM_FILE fid) 
	(FORM_FILE = TBX_FORM_Get_Name((tbx_postproc_data->licCheck) "postproc_task")) 
	(fid = (axlFormCreate 
		gensym("tbxpostprocnewtask") FORM_FILE 
		'(e outer) 
		'TBX_POSTPROC_Task_Form_Action
		t nil
	    )) 
	TBX_FORM_Init_Header(fid "Licensed for " 
	    (tbx_postproc_data->licCheck) 
	    (tbx_postproc_data->version)
	) 
	(axlFormDisplay fid)
	(axlFormSetField fid "add_user_task" t) 
	(axlFormSetFieldEditable fid "user_task_name" t) 
	(axlFormSetFieldEditable fid "user_task_title" t) 
	(axlFormSetFieldEditable fid "user_task_script" t) 
	(axlFormSetFieldEditable fid "browse_script" t)
	(axlFormSetFieldEditable fid "predef_task_name" nil) 
	(axlFormSetFieldEditable fid "predef_task_arg" nil) 
	TBX_POSTPROC_Task_Build_Popup(fid) 
	TBX_FORM_Delete((tbx_postproc_data->licCheck) FORM_FILE) t
    )
)
procedure(TBX_POSTPROC_Task_Build_Popup(fh) 
    let((popup_list) 
	(popup_list = list()) 
	foreach(tsk 
	    (tbx_postproc_data->jobDataInit) 
	    (popup_list = cons(list((tsk->taskDisplayStr) 
			(tsk->taskName)
		    ) popup_list
		))
	) 
	(popup_list = sortcar(popup_list nil)) 
	(axlFormBuildPopup fh "predef_task_name" popup_list)
    )
)
procedure(TBX_POSTPROC_Task_Form_Action(fh) 
    let((result task_name task_title task_arg task_type
	    continue task_script active_job new_list
	) 
	case((fh->curField) 
	    ("add_user_task" 
		if((fh->curValue) then 
		    (axlFormSetFieldEditable fh "user_task_name" t) 
		    (axlFormSetFieldEditable fh "user_task_title" t) 
		    (axlFormSetFieldEditable fh "user_task_script" t)
		    (axlFormSetFieldEditable fh "browse_script" t) 
		    (axlFormSetFieldEditable fh "predef_task_name" nil) 
		    (axlFormSetFieldEditable fh "predef_task_arg" nil) else 
		    (axlFormSetFieldEditable fh "user_task_name" nil)
		    (axlFormSetFieldEditable fh "user_task_title" nil) 
		    (axlFormSetFieldEditable fh "user_task_script" nil) 
		    (axlFormSetFieldEditable fh "browse_script" nil) 
		    (axlFormSetFieldEditable fh "predef_task_name" t) 
		    (axlFormSetFieldEditable fh "predef_task_arg" t)
		) 
		(axlFormSetField fh "predef_task_info" "")
	    ) 
	    ("add_predef_task" 
		if((fh->curValue) then 
		    (axlFormSetFieldEditable fh "user_task_name" nil) 
		    (axlFormSetFieldEditable fh "user_task_title" nil) 
		    (axlFormSetFieldEditable fh "user_task_script" nil)
		    (axlFormSetFieldEditable fh "browse_script" nil) 
		    (axlFormSetFieldEditable fh "predef_task_name" t) 
		    (axlFormSetFieldEditable fh "predef_task_arg" t) else 
		    (axlFormSetFieldEditable fh "user_task_name" t)
		    (axlFormSetFieldEditable fh "user_task_title" t) 
		    (axlFormSetFieldEditable fh "user_task_script" t) 
		    (axlFormSetFieldEditable fh "browse_script" t) 
		    (axlFormSetFieldEditable fh "predef_task_name" nil) 
		    (axlFormSetFieldEditable fh "predef_task_arg" nil)
		)
	    ) 
	    ("browse_script" 
		(task_script = (axlDMFileBrowse nil nil ?optFilters "Script(*.scr)|*.scr|")) 
		when(task_script 
		    (axlFormSetField fh "user_task_script" task_script)
		)
	    ) 
	    ("predef_task_name" 
		(result = TBX_POSTPROC_Task_Form_Info((fh->curValue))) 
		if(car(result) then 
		    (axlFormSetFieldEditable fh "predef_task_arg" t) else 
		    (axlFormSetFieldEditable fh "predef_task_arg" nil)
		    (axlFormSetField fh "predef_task_arg" "")
		) 
		(axlFormSetField fh "predef_task_info" 
		    cadr(result)
		)
	    )
	    ("predef_task_arg" 
		(task_name = (axlFormGetField fh "predef_task_name")) 
		cond(((task_name == "cleanup") 
			(result = TBX_POSTPROC_Cleanup_Check_Arg((fh->curValue))) 
			unless(car(result) 
			    (axlFormSetField fh "predef_task_arg" "")
			)
		    ) 
		    ((task_name == "batchplot") 
			(result = TBX_POSTPROC_Batchplot_Check_Arg((fh->curValue) 
				list("all")
			    )) 
			unless(result 
			    (axlFormSetField fh "predef_task_arg" "all")
			)
		    ) 
		    ((task_name == "varibom") 
			(result = TBX_POSTPROC_Variant_Check_Arg((fh->curValue) 
				list("all" "common" "core")
			    )) 
			unless(result 
			    (axlFormSetField fh "predef_task_arg" "all")
			)
		    ) 
		    ((task_name == "variassy") 
			(result = TBX_POSTPROC_Variant_Check_Arg((fh->curValue) 
				list("all" "core")
			    )) 
			unless(result 
			    (axlFormSetField fh "predef_task_arg" "all")
			)
		    )
		)
	    ) 
	    ("done" 
		if((axlFormGetField fh "add_user_task") then 
		    (continue = t) 
		    (task_name = (axlFormGetField fh "user_task_name")) 
		    (task_title = (axlFormGetField fh "user_task_title"))
		    (task_arg = nil) 
		    (task_script = (axlFormGetField fh "user_task_script")) 
		    if(((task_name != "") && (task_title != "") && (task_script != "")) then 
			((tbx_postproc_data->newTask)->taskType = "user") 
			((tbx_postproc_data->newTask)->taskName = task_name) 
			((tbx_postproc_data->newTask)->taskArg = nil)
			((tbx_postproc_data->newTask)->taskDisplayStr = task_title) 
			((tbx_postproc_data->newTask)->onState = nil) 
			((tbx_postproc_data->newTask)->replayScript = task_script) else 
			(continue = nil)
			printf("Warning: Invalid or unsufficient data specified\n")
		    ) else 
		    (continue = t)
		    (task_name = lowerCase((axlFormGetField fh "predef_task_name"))) 
		    (task_arg = (axlFormGetField fh "predef_task_arg")) 
		    (task_arg = (axlStringRemoveSpaces task_arg)) 
		    if(((tbx_postproc_data->argLimits)[task_name] && (task_arg == "")) then 
			(continue = nil) 
			(axlUIConfirm 
			    caddr((tbx_postproc_data->argLimits)[task_name])
			) else
			foreach(dpl 
			    (tbx_postproc_data->jobDataInit) 
			    when((task_name == lowerCase((dpl->taskName))) 
				(task_title = (dpl->taskDisplayStr)) 
				(task_type = lowerCase((dpl->taskType)))
			    )
			) 
			((tbx_postproc_data->newTask)->taskType = task_type) 
			((tbx_postproc_data->newTask)->taskName = task_name) 
			((tbx_postproc_data->newTask)->taskArg = task_arg) 
			((tbx_postproc_data->newTask)->taskDisplayStr = task_title)
			((tbx_postproc_data->newTask)->onState = nil) 
			((tbx_postproc_data->newTask)->replayScript = nil)
		    )
		) 
		when(continue 
		    (axlFormClose fh) 
		    (axlFinishEnterFun) 
		    (active_job = ((tbx_postproc_data->newTask)->activeJob)) 
		    (new_list = tconc(nil nil))
		    foreach(tsk 
			(tbx_postproc_data->jobData)[active_job] 
			if(((tsk->handle) == ((tbx_postproc_data->newTask)->refHandle)) then 
			    case(((tbx_postproc_data->newTask)->mode) 
				("insert" 
				    tconc(new_list 
					list(nil 
					    'taskType 
					    ((tbx_postproc_data->newTask)->taskType) 
					    'taskName 
					    ((tbx_postproc_data->newTask)->taskName)
					    'taskArg 
					    ((tbx_postproc_data->newTask)->taskArg) 
					    'taskDisplayStr 
					    ((tbx_postproc_data->newTask)->taskDisplayStr) 
					    'onState
					    ((tbx_postproc_data->newTask)->onState) 
					    'replayScript 
					    ((tbx_postproc_data->newTask)->replayScript)
					)
				    ) 
				    tconc(new_list tsk)
				) 
				("append" 
				    tconc(new_list tsk) 
				    tconc(new_list 
					list(nil 
					    'taskType 
					    ((tbx_postproc_data->newTask)->taskType) 
					    'taskName 
					    ((tbx_postproc_data->newTask)->taskName)
					    'taskArg 
					    ((tbx_postproc_data->newTask)->taskArg) 
					    'taskDisplayStr 
					    ((tbx_postproc_data->newTask)->taskDisplayStr) 
					    'onState
					    ((tbx_postproc_data->newTask)->onState) 
					    'replayScript 
					    ((tbx_postproc_data->newTask)->replayScript)
					)
				    )
				) 
				(t t)
			    ) else 
			    tconc(new_list tsk)
			)
		    ) 
		    (new_list = cdar(new_list)) 
		    ((tbx_postproc_data->jobData)[active_job] = new_list) 
		    TBX_POSTPROC_Load_Joblist(((tbx_postproc_data->formHandle)->main) active_job 
			(tbx_postproc_data->jobData)
		    )
		)
	    ) 
	    ("cancel" 
		(axlFormClose fh) 
		(axlFinishEnterFun)
	    ) 
	    ("my_help" 
		(axlShell "tbx help postproc")
	    )
	)
    )
)
procedure(TBX_POSTPROC_Task_Form_Info(task_name) 
    let((edit_arg info_msg) 
	(info_msg = "") 
	case(lowerCase(task_name) 
	    ("varibom" 
		(edit_arg = t) 
		(info_msg = strcat(info_msg "Specify argument: \"core\" when generating the BOM for core design only, ")) 
		(info_msg = strcat(info_msg "\"all\" for all variants, or the appropriate variant name for an individual Variant BOM."))
	    ) 
	    ("variassy" 
		(edit_arg = t) 
		(info_msg = strcat(info_msg "Specify argument: \"core\" when generating assembly drawing for core design, ")) 
		(info_msg = strcat(info_msg "\"all\" for all variants, or the appropriate variant name for individual variant assembly drawings."))
	    ) 
	    ("batchplot" 
		(edit_arg = t) 
		(info_msg = strcat(info_msg "Specify argument: \"all\" when plotting all plotsets, or the appropriate plotset name when plotting individual items from batchplot configuration."))
	    ) 
	    ("cleanup" 
		(edit_arg = t) 
		(info_msg = strcat(info_msg "Specify argument for data to be cleaned in wildcard format, e.g. \"mfg/*\", \"mfg/*.art\" or \"./*.log\". Use relative pathes only. ")) 
		(info_msg = strcat(info_msg "Directories outside the current working directory are not accepted. When deleting files in the current working directory ")) 
		(info_msg = strcat(info_msg "you have to specify an extention. (e.g. \"./*.log\")"))
	    )
	    ("zipdata" 
		(edit_arg = t) 
		(info_msg = strcat(info_msg "Specify at least two arguments: name of the zip file and directories or files to be zipped. Wildcards are supported. ")) 
		(info_msg = strcat(info_msg "For example my_output.zip  ./mfg/*.art  ./plot/*pdf"))
	    ) 
	    (t 
		(edit_arg = nil) 
		(info_msg = "No arguments required")
	    )
	) 
	list(edit_arg info_msg)
    )
)
procedure(TBX_POSTPROC_Update_Shapes() 
    (axlShapeDynamicUpdate nil t) 
    (axlVisibleUpdate t)
)
procedure(TBX_POSTPROC_Update_Task_State(form_handle handle_selected active_job job_data) 
    let((result on_state) 
	foreach(tsk 
	    job_data[active_job] 
	    when(((tsk->handle) == handle_selected) 
		(result = (axlFormTreeViewGetSelectState form_handle "job_tree" 
			(tsk->handle)
		    )) 
		caseq(result 
		    (0 
			(on_state = nil)
		    ) 
		    (1 
			(on_state = t)
		    ) 
		    (t 
			(on_state = nil)
		    )
		) 
		(tsk->onState = on_state)
	    )
	) t
    )
)
procedure(TBX_POSTPROC_Variant_Check_Arg(arg predef_args) 
    let((result) 
	cond(((!arg || (type(arg) != 'string)) 
		printf("Warning: Invalid argument %L specified.\n" arg) 
		(result = nil)
	    ) 
	    (exists(x predef_args 
		    (lowerCase(arg) == x)
		) 
		(result = t)
	    ) 
	    (!(tbx_postproc_data->variantNames) 
		printf("Warning: Cannot check Variant argument %L. File variants.lst does not exist or can't be accessed.\n" arg) 
		(result = t)
	    ) 
	    (!exists(x 
			(tbx_postproc_data->variantNames) 
			(lowerCase(arg) == lowerCase(x))
		    ) 
		printf("Warning: Variant %L not listed in file variants.lst.\n" arg) 
		(result = t)
	    ) 
	    (t 
		(result = t)
	    )
	) result
    )
)
procedure(TBX_POSTPROC_Zip() 
    let((launch_dir arr output_file item_list) 
	(launch_dir = getWorkingDir()) 
	(arr = (parseQuotedString 
		((tbx_postproc_data->batchControl)->zipArg)
	    )) 
	if((length(arr) >= 2) then 
	    (output_file = car(arr)) 
	    (output_file = cadr((axlDMFileParts output_file))) 
	    (output_file = strcat(output_file ".zip"))
	    foreach(itm 
		cdr(arr) 
		if(rexMatchp("[*]" itm) then 
		    (item_list = cons(list(itm t) item_list)) else 
		    (item_list = cons(list(itm nil) item_list))
		)
	    ) 
	    (item_list = reverse(item_list)) 
	    TBX_UTIL_Zip_Data(launch_dir item_list output_file nil) else t
	) t
    )
)
procedure(TBX_PUSH2GRID_Build_Dynamics() 
    let((fix_xy var_xy line_width net_info rat_info
	    ref_point rpath dx dy sel_set
	) 
	(net_info = ((tbx_push2grid_global->runTime)->netInfo)) 
	(rat_info = ((tbx_push2grid_global->runTime)->ratInfo)) 
	(ref_point = ((tbx_push2grid_global->runTime)->refPoint)) 
	(sel_set = ((tbx_push2grid_global->runTime)->selSet))
	(line_width = (axlMKSConvert "0.025 MM" 
		car((axlDBGetDesignUnits))
	    )) 
	foreach(net net_info 
	    (axlRatsnestBlank net)
	) 
	(axlTransformObject sel_set ?move 
	    (0.0:0.0)
	) 
	(axlEraseObject sel_set) 
	(axlDynamicsObject sel_set ref_point)
	foreach(entry rat_info 
	    case(car(entry) 
		("rubber_band" 
		    (fix_xy = cadr(entry)) 
		    (var_xy = caddr(entry)) 
		    (dx = (car(var_xy) - car(ref_point))) 
		    (dy = (cadr(var_xy) - cadr(ref_point)))
		    (axlAddSimpleRbandDynamics fix_xy "directline" ?origin ref_point
			?var_point 
			(dx:dy) ?width line_width
		    )
		) 
		("path" 
		    (rpath = (axlPathStart 
			    list(cadr(entry) 
				caddr(entry)
			    ) line_width
			)) 
		    (axlAddSimpleMoveDynamics ref_point rpath "path")
		) 
		(t t)
	    )
	) 
	(axlVisibleUpdate t)
    )
)
procedure(TBX_PUSH2GRID_Callback(form_handle) 
    let((color_list grid_value) 
	case((form_handle->curField) 
	    ("grid_value" 
		(grid_value = TBX_GEOM_Convert_Unit_String((form_handle->curValue) 
			car((axlDBGetDesignUnits))
		    )) 
		if(grid_value then 
		    (axlFormSetField form_handle "grid_value" 
			sprintf(nil "%L" grid_value)
		    ) 
		    TBX_DBDISPLAY_Canvas_Grid('setGrid grid_value) 
		    (tbx_push2grid_global->lastGrid = grid_value)
		    else 
		    (axlFormSetField form_handle "grid_value" 
			sprintf(nil "%L" 
			    (tbx_push2grid_global->lastGrid)
			)
		    )
		)
	    ) 
	    ("highlight_color" 
		(color_list = (axlCVFColorChooserDlg 0)) 
		when(color_list 
		    (tbx_push2grid_global->colorId = car(color_list)) 
		    (axlFormSetField form_handle "highlight_color" 
			car(color_list)
		    ) 
		    (axlVisibleUpdate t)
		)
	    ) 
	    ("dehighlight" 
		case((form_handle->curValue) 
		    ("all_symbols" 
			TBX_DBDISPLAY_Dehighlight_By_Type(list("symbols"))
		    ) 
		    ("complete_design" 
			TBX_DBDISPLAY_Dehighlight_By_Type(list("groups" "symbols" "nets" "pins" "vias"
				"drcs"
			    )
			)
		    )
		)
	    ) 
	    ("highlight_only" 
		when((form_handle->curValue) 
		    TBX_PUSH2GRID_Place_Terminate() 
		    (tbx_push2grid_global->eventHandler = nil) 
		    (tbx_push2grid_global->runTime = ncons(nil)) 
		    (tbx_push2grid_global->eventMask = list('PICK 
			    'STARTDRAG 
			    'STOPDRAG
			))
		)
	    )
	    ("force2grid" 
		when((form_handle->curValue) 
		    TBX_PUSH2GRID_Place_Terminate() 
		    (tbx_push2grid_global->eventHandler = nil) 
		    (tbx_push2grid_global->runTime = ncons(nil)) 
		    (tbx_push2grid_global->eventMask = list('PICK 
			    'STARTDRAG 
			    'STOPDRAG
			))
		)
	    ) 
	    ("place_regular" 
		when((form_handle->curValue) 
		    (tbx_push2grid_global->eventHandler = "select_objects") 
		    (tbx_push2grid_global->eventMask = list('PICK 
			    'STARTDRAG 
			    'STOPDRAG
			)) 
		    (tbx_push2grid_global->runTime = ncons(nil))
		)
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_PUSH2GRID_Event_Loop(form_handle) 
    let((loop event start_pick bBox) 
	(axlEventSetStartPopup 
	    'TBX_PUSH2GRID_Popup_Callback
	) 
	(loop = t) 
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    list("noall" "symbols") ?onButtons 
	    list("all")
	)
	printf("Pick or drag window to select\n") 
	(tbx_push2grid_global->transMark = (axlDBTransactionStart)) 
	while(loop 
	    (event = (axlEnterEvent 
		    (tbx_push2grid_global->eventMask) nil t
		)) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(STARTDRAG t 
		    (axlAddSimpleRbandDynamics 
			(event->xy) "box" ?origin 
			(0.0:0.0)
		    ) 
		    (start_pick = (event->xy))
		) 
		(STOPDRAG 
		    (bBox = list(start_pick 
			    (event->xy)
			)) 
		    TBX_PUSH2GRID_Start(bBox form_handle) 
		    (bBox = nil)
		) 
		(PICK 
		    TBX_PUSH2GRID_Start((event->xy) form_handle)
		) 
		(DONE 
		    (loop = nil)
		)
		(CANCEL 
		    (loop = nil)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_PUSH2GRID_Execute(form_handle) 
    let((dx dy angle mirror) 
	(axlClearSelSet) 
	(dx = (car(((tbx_push2grid_global->runTime)->destinationPick)) - car(((tbx_push2grid_global->runTime)->refPoint)))) 
	(dy = (cadr(((tbx_push2grid_global->runTime)->destinationPick)) - cadr(((tbx_push2grid_global->runTime)->refPoint)))) 
	(angle = ((tbx_push2grid_global->runTime)->angle))
	unless(angle 
	    (angle = 0.0)
	) 
	(mirror = ((tbx_push2grid_global->runTime)->doMirror)) 
	unless((axlFormGetField form_handle "exclude_fixed") 
	    foreach(sym 
		((tbx_push2grid_global->runTime)->selSet) 
		(axlDBDeleteProp sym 
		    list("FIXED")
		)
	    ) 
	    (axlDBRefreshId nil)
	) 
	(axlTransformObject 
	    ((tbx_push2grid_global->runTime)->selSet) ?move 
	    (dx:dy)
	) 
	(axlTransformObject 
	    ((tbx_push2grid_global->runTime)->selSet) ?mirror mirror ?angle
	    angle ?origin 
	    ((tbx_push2grid_global->runTime)->destinationPick)
	)
	(axlTransformObject 
	    ((tbx_push2grid_global->runTime)->selSet) ?move 
	    (0.0:0.0)
	) 
	(axlClearSelSet) 
	(axlClearDynamics)
    )
)
procedure(TBX_PUSH2GRID_Get_Dynamic_Ratsnest_Info(sym_dbid_list selection_box) 
    let((from_dbid to_dbid fromto_list fix_xy_list var_xy_list
	    result pin_refdes pin_refdes_list net_list cur_pin_refdes
	) 
	(sym_dbid_list = setof(x sym_dbid_list 
		(x->refdes)
	    )) 
	foreach(sym sym_dbid_list 
	    foreach(pin 
		(sym->pins) 
		when(((pin->net) && !((pin->net)->VOLTAGE) && ((((pin->net)->prop)->RATSNEST_SCHEDULE) != "POWER_GROUND")) 
		    when((((pin->net)->ratsnestOn) && !memq((pin->net) net_list)) 
			(net_list = cons((pin->net) net_list))
		    )
		) 
		(pin_refdes = strcat((sym->refdes) "." 
			(pin->number)
		    )) 
		(pin_refdes_list = cons(pin_refdes pin_refdes_list))
	    )
	) 
	foreach(net net_list 
	    foreach(rn 
		(net->ratsnest) 
		(var_xy_list = nil) 
		(fix_xy_list = nil) 
		(from_dbid = car((rn->pins)))
		(to_dbid = cadr((rn->pins))) 
		cond((((from_dbid->objType) == "rat_t") 
			if((selection_box && (axlIsPointInsideBox 
				    (from_dbid->xy) selection_box
				)) then 
			    (var_xy_list = cons((from_dbid->xy) var_xy_list)) else 
			    (fix_xy_list = cons((from_dbid->xy) fix_xy_list))
			)
		    ) 
		    (((from_dbid->objType) == "pin") 
			when(((from_dbid->parent)->xy) 
			    (cur_pin_refdes = strcat(((from_dbid->parent)->refdes) "." 
				    (from_dbid->number)
				)) 
			    if(exists(x pin_refdes_list 
				    (x == cur_pin_refdes)
				) then 
				(var_xy_list = cons((from_dbid->xy) var_xy_list)) else 
				(fix_xy_list = cons((from_dbid->xy) fix_xy_list))
			    )
			)
		    ) 
		    (t t)
		) 
		cond((((to_dbid->objType) == "rat_t") 
			if((selection_box && (axlIsPointInsideBox 
				    (to_dbid->xy) selection_box
				)) then 
			    (var_xy_list = cons((to_dbid->xy) var_xy_list)) else 
			    (fix_xy_list = cons((to_dbid->xy) fix_xy_list))
			)
		    ) 
		    (((to_dbid->objType) == "pin") 
			when(((to_dbid->parent)->xy) 
			    (cur_pin_refdes = strcat(((to_dbid->parent)->refdes) "." 
				    (to_dbid->number)
				)) 
			    if(exists(x pin_refdes_list 
				    (x == cur_pin_refdes)
				) then 
				(var_xy_list = cons((to_dbid->xy) var_xy_list)) else 
				(fix_xy_list = cons((to_dbid->xy) fix_xy_list))
			    )
			)
		    ) 
		    (t t)
		) 
		cond(((onep(length(var_xy_list)) && onep(length(fix_xy_list))) 
			(fromto_list = cons(list("rubber_band" 
				    car(fix_xy_list) 
				    car(var_xy_list)
				) fromto_list
			    ))
		    ) 
		    ((length(var_xy_list) == 2) 
			(fromto_list = cons(list("path" 
				    car(var_xy_list) 
				    cadr(var_xy_list)
				) fromto_list
			    ))
		    )
		)
	    )
	) 
	(result = list(fromto_list net_list))
	result
    )
)
procedure(TBX_PUSH2GRID_Init() 
    let((msg) 
	(msg = msg) 
	(axlDBDisplayControl 
	    'gridEnable t
	) 
	(axlDBDisplayControl 
	    'customColorEnabled t
	) 
	(axlVisibleUpdate t)
	unless(boundp('tbx_push2grid_global) 
	    iliDefstruct('defstruct(tbx_push2grid_global_struct colorId companyName formId transMark
			runTime eventMask eventHandler gridParam
		    )
	    ) 
	    defvar(tbx_push2grid_global nil)
	) 
	if(!tbx_push2grid_global then 
	    (tbx_push2grid_global = (make_tbx_push2grid_global_struct ?colorId nil ?companyName nil
		    ?eventMask nil ?eventHandler nil ?formId
		    nil ?runTime 
		    ncons(nil) ?transMark nil
		    ?gridParam nil
		)) else 
	    (tbx_push2grid_global->colorId = nil)
	    (tbx_push2grid_global->companyName = nil) 
	    (tbx_push2grid_global->eventMask = nil) 
	    (tbx_push2grid_global->eventHandler = nil) 
	    (tbx_push2grid_global->formId = nil) 
	    (tbx_push2grid_global->runTime = ncons(nil))
	    (tbx_push2grid_global->transMark = nil) 
	    (tbx_push2grid_global->gridParam = nil)
	)
    )
)
procedure((TBX_PUSH2GRID_Main \@optional arg) 
    let((info_file VERSION_STR FC_VERSION SUB_VERSION port
	    fid FORM_FILE FC_FEATURE lic_check_result record
	    default_grid grid_value default_color color_id
	) 
	(FC_FEATURE = "PUSH2GRID") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Push to Grid %s (C)2017" FC_VERSION))
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./push2grid_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Place to Grid information:\n") 
		fprintf(port "=======================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Place to Grid: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    printf("For additional help enter: 'tbx help push2grid' in console window\n") 
		    TBX_PUSH2GRID_Init() 
		    (tbx_push2grid_global->gridParam = TBX_DBDISPLAY_Canvas_Grid('getGrid)) 
		    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "push2grid_mini"))
		    (fid = (axlMiniStatusLoad 
			    gensym() FORM_FILE 
			    'TBX_PUSH2GRID_Callback nil
			)) 
		    (tbx_push2grid_global->formId = fid) 
		    TBX_FORM_Init_Header(fid nil lic_check_result VERSION_STR) 
		    (record = "push2grid") 
		    (default_grid = (axlMKSConvert "0.254 MM" 
			    car((axlDBGetDesignUnits))
			))
		    (grid_value = TBX_SESSION_Get_Param(record "grid_value" default_grid t)) 
		    (axlFormSetField fid "grid_value" 
			sprintf(nil "%L" grid_value)
		    ) 
		    TBX_DBDISPLAY_Canvas_Grid('setGrid grid_value) 
		    (axlFormSetField fid "highlight_only" 
			TBX_SESSION_Get_Param(record "highlight_only" t)
		    ) 
		    (axlFormSetField fid "force2grid" 
			TBX_SESSION_Get_Param(record "force2grid" nil)
		    )
		    (axlFormSetField fid "place_regular" 
			TBX_SESSION_Get_Param(record "place_regular" nil)
		    ) 
		    when((axlFormGetField fid "place_regular") 
			(tbx_push2grid_global->eventHandler = "select_objects") 
			(tbx_push2grid_global->eventMask = list('PICK 
				'STARTDRAG 
				'STOPDRAG
			    )) 
			(tbx_push2grid_global->runTime = ncons(nil))
		    ) 
		    (tbx_push2grid_global->eventMask = list('PICK 
			    'STARTDRAG 
			    'STOPDRAG
			)) 
		    (default_color = 1) 
		    (color_id = TBX_SESSION_Get_Param(record "highlight_color" default_color))
		    (axlFormSetField fid "highlight_color" color_id) 
		    (tbx_push2grid_global->colorId = color_id) 
		    (axlFormSetField fid "exclude_mechanical" 
			TBX_SESSION_Get_Param(record "exclude_fixed" t)
		    ) 
		    (axlFormSetField fid "exclude_fixed" 
			TBX_SESSION_Get_Param(record "exclude_fixed" t)
		    ) 
		    (axlFormSetField fid "angle_incr" 
			TBX_SESSION_Get_Param(record "angle_incr" "45")
		    )
		    (axlFormDisplay fid) 
		    TBX_FORM_Delete(lic_check_result FORM_FILE) 
		    (axlAutoOpenFindFilter) 
		    TBX_PUSH2GRID_Event_Loop(fid) 
		    TBX_DBDISPLAY_Canvas_Grid('setGrid 
			(tbx_push2grid_global->gridParam)
		    )
		)
	    )
	)
    )
)
procedure(TBX_PUSH2GRID_Place_Init_Next(form_handle) 
    when(((tbx_push2grid_global->runTime)->netInfo) 
	foreach(net 
	    ((tbx_push2grid_global->runTime)->netInfo) 
	    (axlRatsnestDisplay net)
	)
    ) 
    (tbx_push2grid_global->runTime = ncons(nil)) 
    (tbx_push2grid_global->eventMask = list('PICK 
	    'STARTDRAG 
	    'STOPDRAG
	)) 
    if((axlFormGetField form_handle "place_regular") then 
	(tbx_push2grid_global->eventHandler = "select_objects") 
	printf("Select element(s) to place\n") else
    )
    (axlClearSelSet) 
    (axlClearDynamics) 
    (axlDBRefreshId nil) 
    (axlVisibleUpdate t) t
)
procedure(TBX_PUSH2GRID_Place_Terminate() 
    foreach(net 
	((tbx_push2grid_global->runTime)->netInfo) 
	(axlRatsnestDisplay net)
    ) 
    (axlClearDynamics)
)
procedure(TBX_PUSH2GRID_Popup_Callback(event) 
    let((popup) 
	(event = event) 
	if((axlFormGetField 
		(tbx_push2grid_global->formId) "place_regular"
	    ) then 
	    (popup = (axlUIPopupDefine nil 
		    list(list("Done" 
			    'TBX_PUSH2GRID_Popup_Done
			) 
			list("Mirror" 
			    'TBX_PUSH2GRID_Popup_Mirror
			) 
			list("Rotate" 
			    'TBX_PUSH2GRID_Popup_Rotate
			) 
			list("Oops" 
			    'TBX_PUSH2GRID_Popup_Oops
			) 
			list("Cancel" 
			    'TBX_PUSH2GRID_Popup_Cancel
			)
		    )
		)) else 
	    (popup = (axlUIPopupDefine nil 
		    list(list("Done" 
			    'TBX_PUSH2GRID_Popup_Done
			) 
			list("Oops" 
			    'TBX_PUSH2GRID_Popup_Oops
			) 
			list("Cancel" 
			    'TBX_PUSH2GRID_Popup_Cancel
			)
		    )
		))
	) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_PUSH2GRID_Popup_Cancel() 
    (axlDBTransactionOops 
	(tbx_push2grid_global->transMark)
    ) 
    (axlDBTransactionCommit 
	(tbx_push2grid_global->transMark)
    ) 
    (axlCancelEnterFun) 
    (axlUIPopupSet nil)
    (axlClearDynamics)
)
procedure(TBX_PUSH2GRID_Popup_Done() 
    let((rec session_param) 
	when(((tbx_push2grid_global->eventHandler) == "pick_destination") 
	    (axlDBTransactionOops 
		(tbx_push2grid_global->transMark)
	    )
	) 
	TBX_PUSH2GRID_Place_Terminate() 
	(rec = "push2grid") 
	(session_param = eval('tbx_session_param))
	(session_param[rec] = ncons(nil)) 
	putprop(session_param[rec] 
	    atof((axlFormGetField 
		    (tbx_push2grid_global->formId) "grid_value"
		)
	    ) 
	    stringToSymbol("grid_value")
	) 
	putprop(session_param[rec] 
	    car((axlDBGetDesignUnits)) 
	    stringToSymbol("units")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField 
		(tbx_push2grid_global->formId) "highlight_only"
	    ) 
	    stringToSymbol("highlight_only")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField 
		(tbx_push2grid_global->formId) "force2grid"
	    ) 
	    stringToSymbol("force2grid")
	)
	putprop(session_param[rec] 
	    (axlFormGetField 
		(tbx_push2grid_global->formId) "place_regular"
	    ) 
	    stringToSymbol("place_regular")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField 
		(tbx_push2grid_global->formId) "exclude_mechanical"
	    ) 
	    stringToSymbol("exclude_mechanical")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField 
		(tbx_push2grid_global->formId) "exclude_fixed"
	    ) 
	    stringToSymbol("exclude_fixed")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField 
		(tbx_push2grid_global->formId) "angle_incr"
	    ) 
	    stringToSymbol("angle_incr")
	) 
	putprop(session_param[rec] 
	    (tbx_push2grid_global->colorId) 
	    stringToSymbol("highlight_color")
	)
	(axlDBTransactionCommit 
	    (tbx_push2grid_global->transMark)
	) 
	(axlFinishEnterFun) 
	(axlUIPopupSet nil) 
	(axlClearDynamics)
    )
)
procedure(TBX_PUSH2GRID_Popup_Mirror() 
    if(!((tbx_push2grid_global->runTime)->doMirror) then 
	(axlSetDynamicsMirror t) 
	((tbx_push2grid_global->runTime)->doMirror = t) else
	(axlSetDynamicsMirror nil) 
	((tbx_push2grid_global->runTime)->doMirror = nil)
    ) 
    (axlVisibleUpdate t)
)
procedure(TBX_PUSH2GRID_Popup_Oops() 
    (axlDBTransactionOops 
	(tbx_push2grid_global->transMark)
    ) 
    TBX_PUSH2GRID_Place_Init_Next((tbx_push2grid_global->formId)) 
    (axlDBRefreshId nil) 
    (axlVisibleUpdate t)
)
procedure(TBX_PUSH2GRID_Popup_Rotate() 
    let((angle_incr angle) 
	(angle_incr = atof((axlFormGetField 
		    (tbx_push2grid_global->formId) "angle_incr"
		)
	    )) 
	((tbx_push2grid_global->runTime)->angleIncr = angle_incr) 
	(axlSetRotateIncrement ?angular angle_incr) 
	(angle = (axlEnterAngle 
		(axlCursorGet nil) ?lockAngle angle_incr
	    ))
	(axlSetDynamicsRotation angle) 
	((tbx_push2grid_global->runTime)->angle = angle)
    )
)
procedure(TBX_PUSH2GRID_Rat_Visibility_Control(net_info mode) 
    let((net_dbid rat_visible) 
	case(mode 
	    ("set" 
		foreach(entry net_info 
		    (net_dbid = car(entry)) 
		    (axlRatsnestBlank net_dbid)
		)
	    ) 
	    ("reset" 
		foreach(entry net_info 
		    (rat_visible = cadr(entry)) 
		    when(rat_visible 
			(net_dbid = car(entry)) 
			(axlRatsnestDisplay net_dbid)
		    )
		)
	    )
	) 
	(axlDBRefreshId nil)
    )
)
procedure(TBX_PUSH2GRID_Start(user_input form_handle) 
    let((result off_xy off_x off_y selection_set) 
	(axlDBIgnoreFixed t) 
	cond(((axlFormGetField form_handle "highlight_only") 
		(selection_set = TBX_PUSH2GRID_Symbol_Select(user_input form_handle)) 
		when(selection_set 
		    (axlDBTransactionMark 
			(tbx_push2grid_global->transMark)
		    ) 
		    foreach(sym selection_set 
			(result = TBX_GEOM_Point_On_Grid((sym->xy) "non-etch")) 
			unless(car(result) 
			    (axlCustomColorObject sym 
				(tbx_push2grid_global->colorId)
			    )
			)
		    ) 
		    (axlClearSelSet)
		)
	    ) 
	    ((axlFormGetField form_handle "force2grid") 
		(selection_set = TBX_PUSH2GRID_Symbol_Select(user_input form_handle)) 
		when(selection_set 
		    (axlDBTransactionMark 
			(tbx_push2grid_global->transMark)
		    ) 
		    foreach(sym selection_set 
			(result = TBX_GEOM_Point_On_Grid((sym->xy) "non-etch")) 
			unless(car(result) 
			    (off_xy = cadr(result)) 
			    (off_x = car(off_xy)) 
			    (off_y = cadr(off_xy)) 
			    (axlTransformObject sym ?move 
				((- off_x):(- off_y))
			    )
			    (axlClearObjectCustomColor sym)
			)
		    ) 
		    (axlClearSelSet)
		)
	    ) 
	    ((axlFormGetField form_handle "place_regular") 
		cond((((tbx_push2grid_global->eventHandler) == "select_objects") 
			(selection_set = TBX_PUSH2GRID_Symbol_Select(user_input form_handle)) 
			if(selection_set then 
			    (axlDBTransactionMark 
				(tbx_push2grid_global->transMark)
			    ) 
			    ((tbx_push2grid_global->runTime)->selSet = selection_set) 
			    if(onep(length(selection_set)) then 
				((tbx_push2grid_global->runTime)->refPoint = (car(selection_set)->xy)) 
				(result = TBX_PUSH2GRID_Get_Dynamic_Ratsnest_Info(selection_set nil)) 
				((tbx_push2grid_global->runTime)->ratInfo = car(result))
				((tbx_push2grid_global->runTime)->netInfo = cadr(result)) 
				(tbx_push2grid_global->eventHandler = "pick_destination") 
				TBX_PUSH2GRID_Build_Dynamics() else 
				(tbx_push2grid_global->eventHandler = "pick_origin")
				((tbx_push2grid_global->runTime)->userBox = user_input) 
				printf("Pick origin\n")
			    )
			    (tbx_push2grid_global->eventMask = list('PICK)) else 
			    (tbx_push2grid_global->eventHandler = "select_objects") 
			    (axlClearSelSet)
			)
		    ) 
		    (((tbx_push2grid_global->eventHandler) == "pick_origin") 
			if((user_input && !(isBoxp user_input)) then 
			    ((tbx_push2grid_global->runTime)->refPoint = user_input) 
			    (result = TBX_PUSH2GRID_Get_Dynamic_Ratsnest_Info(((tbx_push2grid_global->runTime)->selSet) 
				    ((tbx_push2grid_global->runTime)->userBox)
				)) 
			    ((tbx_push2grid_global->runTime)->ratInfo = car(result))
			    ((tbx_push2grid_global->runTime)->netInfo = cadr(result)) 
			    (tbx_push2grid_global->eventHandler = "pick_destination") 
			    TBX_PUSH2GRID_Build_Dynamics() else t
			)
		    ) 
		    (((tbx_push2grid_global->eventHandler) == "pick_destination") 
			if((user_input && !(isBoxp user_input)) then 
			    ((tbx_push2grid_global->runTime)->destinationPick = TBX_GEOM_Point_To_Grid(user_input "non-etch")) 
			    TBX_PUSH2GRID_Execute(form_handle) 
			    TBX_PUSH2GRID_Place_Init_Next(form_handle)
			    else t
			)
		    )
		) 
		(axlClearSelSet)
	    )
	) 
	(axlDBIgnoreFixed nil) 
	(axlDBRefreshId nil)
	(axlVisibleUpdate t)
    )
)
procedure(TBX_PUSH2GRID_Symbol_Select(user_input form_handle) 
    let((selection_set selected_mech selected_fix) 
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    list("noall" "symbols") ?onButtons 
	    list("all")
	) 
	if((isBoxp user_input) then 
	    (axlSingleSelectBox user_input) else 
	    (axlSingleSelectPoint user_input)
	) 
	(selection_set = (axlGetSelSet))
	when((axlFormGetField form_handle "exclude_mechanical") 
	    (selected_mech = setof(x selection_set 
		    (lowerCase((x->type)) == "mechanical")
		)) 
	    when(selected_mech 
		printf("Ignoring selected mechanical symbols.\n")
	    ) 
	    (selection_set = setof(x selection_set 
		    (lowerCase((x->type)) != "mechanical")
		))
	) 
	when((axlFormGetField form_handle "exclude_fixed") 
	    (selected_fix = setof(x selection_set 
		    ((x->prop)->FIXED)
		)) 
	    when(selected_fix 
		printf("Ignoring selected fixed symbols.\n")
	    ) 
	    (selection_set = setof(x selection_set 
		    !((x->prop)->FIXED)
		))
	) selection_set
    )
)
procedure(TBX_QUICKSYMEDIT_Callback(form_handle) 
    let((symbol_name pattern filtered_items cmd symbol_drawing
	    symbol_type dir_name msg answer
	) 
	case((form_handle->curField) 
	    ("symbol_filter" 
		(pattern = (form_handle->curValue)) 
		(pattern = TBX_UTIL_Regex_From_Shell(pattern t)) 
		(filtered_items = rexMatchList(pattern 
			(tbx_quicksymedit_data->symbolNames)
		    )) 
		(axlFormListDeleteAll form_handle "symbol_list")
		(axlFormSetField form_handle "symbol_list" filtered_items)
	    ) 
	    ("symbol_list" 
		(symbol_name = upperCase((form_handle->curValue))) 
		(axlFormSetField form_handle "active_symbol" symbol_name) 
		((tbx_quicksymedit_data->activeSymbol)->definition = nil) 
		when((tbx_quicksymedit_data->symbolsHighlight) 
		    (axlDehighlightObject 
			(tbx_quicksymedit_data->symbolsHighlight)
		    )
		)
		(tbx_quicksymedit_data->symbolsHighlight = (axlSelectByName "SYMTYPE" symbol_name)) 
		(axlHighlightObject 
		    (tbx_quicksymedit_data->symbolsHighlight)
		) 
		foreach(sdef 
		    ((axlDBGetDesign)->symdefs) 
		    when((upperCase((sdef->name)) == symbol_name) 
			((tbx_quicksymedit_data->activeSymbol)->definition = sdef) 
			(symbol_type = lowerCase((sdef->type)))
		    )
		) 
		(axlFormSetField form_handle "active_type" symbol_type) 
		if(((symbol_type == "shape") || (symbol_type == "flash")) then 
		    (axlFormSetFieldEditable form_handle "edit_same_session" nil) else 
		    (axlFormSetFieldEditable form_handle "edit_same_session" t)
		)
	    ) 
	    ("edit_same_session" 
		if(((tbx_quicksymedit_data->activeSymbol)->definition) then 
		    if((axlSaveEnable) then 
			(msg = "Do you want save current database before opening symbol drawing?") 
			caseq((axlUIYesNoCancel msg nil 
				'yes
			    ) 
			    (0 
				(answer = "no")
			    ) 
			    (1 
				(answer = "yes")
			    ) 
			    (2 
				(answer = "cancel")
			    ) 
			    (t 
				(answer = "no")
			    )
			) else
			(answer = "no")
		    ) 
		    (axlFinishEnterFun) 
		    (axlUIPopupSet nil)
		    (axlClearDynamics) 
		    when(((answer == "no") || (answer == "yes")) 
			when((tbx_quicksymedit_data->inTrigger) 
			    (axlTriggerClear 
				'menu 
				'TBX_QUICKSYMEDIT_Menu_Trigger
			    ) 
			    (tbx_quicksymedit_data->inTrigger = nil)
			) 
			when((axlTriggerSet 
				'menu 
				'TBX_QUICKSYMEDIT_Menu_Trigger
			    ) 
			    (tbx_quicksymedit_data->inTrigger = t)
			) 
			((tbx_quicksymedit_data->activeSymbol)->name = (((tbx_quicksymedit_data->activeSymbol)->definition)->name)) 
			(tbx_quicksymedit_data->boardName = (axlGetDrawingName))
			((tbx_quicksymedit_data->activeSymbol)->symbolInfo = TBX_QUICKSYMEDIT_Get_Symbol_Info(((tbx_quicksymedit_data->activeSymbol)->definition))) 
			(axlWritePackageFile 
			    ((tbx_quicksymedit_data->activeSymbol)->definition) 
			    (tbx_quicksymedit_data->symbolDir)
			) 
			(symbol_drawing = TBX_UTIL_Find_File((tbx_quicksymedit_data->symbolDir) 
				strcat(((tbx_quicksymedit_data->activeSymbol)->name) ".dra")
			    )) 
			if(symbol_drawing then 
			    TBX_QUICKSYMEDIT_Change_Env("set") 
			    (axlSaveEnable nil) 
			    when((answer == "yes") 
				(axlSaveDesign)
			    )
			    (cmd = sprintf(nil "opencd %L" symbol_drawing)) 
			    printf("Opening drawing %L\n" symbol_drawing) 
			    (axlShell cmd) else 
			    printf("Warning: Cannot open symbol drawing\n")
			)
		    ) else 
		    printf("Warning: No symbol selected\n")
		)
	    ) 
	    ("edit_new_session" 
		if(((tbx_quicksymedit_data->activeSymbol)->definition) then 
		    (axlFinishEnterFun) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics)
		    ((tbx_quicksymedit_data->activeSymbol)->name = (((tbx_quicksymedit_data->activeSymbol)->definition)->name)) 
		    (tbx_quicksymedit_data->boardName = (axlGetDrawingName)) 
		    ((tbx_quicksymedit_data->activeSymbol)->symbolInfo = TBX_QUICKSYMEDIT_Get_Symbol_Info(((tbx_quicksymedit_data->activeSymbol)->definition))) 
		    (axlWritePackageFile 
			((tbx_quicksymedit_data->activeSymbol)->definition) 
			(tbx_quicksymedit_data->symbolDir)
		    ) 
		    (symbol_drawing = TBX_UTIL_Find_File((tbx_quicksymedit_data->symbolDir) 
			    strcat(((tbx_quicksymedit_data->activeSymbol)->name) ".dra")
			))
		    if(symbol_drawing then 
			TBX_QUICKSYMEDIT_Launch_Session(symbol_drawing) else 
			printf("Warning: Cannot open symbol drawing\n")
		    ) else 
		    printf("Warning: No symbol selected\n")
		)
	    )
	    ("export_only" 
		if(((tbx_quicksymedit_data->activeSymbol)->definition) then 
		    (dir_name = (axlDMDirectoryBrowse "." t ?title "Pick a directory")) 
		    when((dir_name && (dir_name != "")) 
			(axlWritePackageFile 
			    ((tbx_quicksymedit_data->activeSymbol)->definition) dir_name
			) 
			printf("Symbol data for %L has been exported to %L\n" 
			    (((tbx_quicksymedit_data->activeSymbol)->definition)->name) dir_name
			)
		    ) else
		    printf("Warning: No symbol selected\n")
		)
	    )
	)
    )
)
procedure(TBX_QUICKSYMEDIT_Change_Env(mode) 
    case(mode 
	("set" 
	    unless(axlGetVariable("NOCONFIRM_SAVEDB") 
		(axlSetVariable "NOCONFIRM_SAVEDB" t) 
		((tbx_quicksymedit_data->envSettings)->noConfirmSaveOrig = nil)
	    ) 
	    unless(axlGetVariable("DB_TIER_NOMSG") 
		(axlSetVariable "DB_TIER_NOMSG" t) 
		((tbx_quicksymedit_data->envSettings)->noTierMessageOrig = nil)
	    ) 
	    unless(axlGetVariable("NOCONFIRM_UPREV") 
		(axlSetVariable "NOCONFIRM_UPREV" t) 
		((tbx_quicksymedit_data->envSettings)->noConfirmUprevOrig = nil)
	    ) 
	    ((tbx_quicksymedit_data->envSettings)->padPath = axlGetVariable("PADPATH"))
	    ((tbx_quicksymedit_data->envSettings)->psmPath = axlGetVariable("PSMPATH"))
	) 
	("reset" 
	    unless(((tbx_quicksymedit_data->envSettings)->noConfirmSaveOrig) 
		(axlUnsetVariable "NOCONFIRM_SAVEDB")
	    ) 
	    unless(((tbx_quicksymedit_data->envSettings)->noTierMessageOrig) 
		(axlUnsetVariable "DB_TIER_NOMSG")
	    ) 
	    unless(((tbx_quicksymedit_data->envSettings)->noConfirmUprevOrig) 
		(axlUnsetVariable "NOCONFIRM_UPREV")
	    )
	) 
	(t t)
    ) t
)
procedure(TBX_QUICKSYMEDIT_Cleanup_Files(symbol_info) 
    let((work_dir file_list file_on_disk) 
	(work_dir = getWorkingDir()) 
	foreach(entry symbol_info 
	    cond((((cadr(entry) == "package") || (cadr(entry) == "mechanical") || (cadr(entry) == "format") || (cadr(entry) == "flash_fsm") || (cadr(entry) == "shape_ssm")) 
		    (file_list = cons(strcat(car(entry) ".dra") file_list)) 
		    case(cadr(entry) 
			("package" 
			    (file_list = cons(strcat(car(entry) ".psm") file_list)) 
			    (file_list = cons(strcat(car(entry) ".log") file_list))
			) 
			("mechanical" 
			    (file_list = cons(strcat(car(entry) ".bsm") file_list)) 
			    (file_list = cons(strcat(car(entry) ".log") file_list))
			) 
			("format" 
			    (file_list = cons(strcat(car(entry) ".osm") file_list)) 
			    (file_list = cons(strcat(car(entry) ".log") file_list))
			) 
			("flash_fsm" 
			    (file_list = cons(strcat(car(entry) ".fsm") file_list))
			)
			("shape_ssm" 
			    (file_list = cons(strcat(car(entry) ".ssm") file_list))
			)
		    )
		) 
		((cadr(entry) == "pad") 
		    (file_list = cons(strcat(car(entry) ".pad") file_list))
		)
	    )
	) 
	foreach(fn file_list 
	    (file_on_disk = TBX_UTIL_Find_File(work_dir fn)) 
	    when(file_on_disk 
		printf("Cleanup file %L\n" file_on_disk) 
		deleteFile(file_on_disk)
	    )
	) t
    )
)
procedure(TBX_QUICKSYMEDIT_Event_Loop() 
    let((eventMask loop event symbol_name sym_dbid) 
	(eventMask = list('PICK)) 
	(loop = t) 
	printf("Pick symbol to edit\n") 
	(axlClearSelSet)
	(axlSetFindFilter ?enabled 
	    list("noall" "symbols") ?onButtons 
	    list("all")
	) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil nil)) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(PICK 
		    (axlSingleSelectPoint 
			(event->xy)
		    ) 
		    if(car((axlGetSelSet)) then 
			(sym_dbid = car((axlGetSelSet))) 
			(symbol_name = (sym_dbid->name)) 
			(axlFormSetFieldEditable 
			    (tbx_quicksymedit_data->formId) "edit_same_session" t
			)
			((tbx_quicksymedit_data->activeSymbol)->definition = (sym_dbid->definition)) 
			(axlFormSetField 
			    (tbx_quicksymedit_data->formId) "active_symbol" symbol_name
			) 
			(axlFormSetField 
			    (tbx_quicksymedit_data->formId) "active_type" 
			    ((sym_dbid->definition)->type)
			) 
			(axlFormSetField 
			    (tbx_quicksymedit_data->formId) "symbol_filter" "*"
			) 
			(axlFormListDeleteAll 
			    (tbx_quicksymedit_data->formId) "symbol_list"
			)
			(axlFormSetField 
			    (tbx_quicksymedit_data->formId) "symbol_list" 
			    (tbx_quicksymedit_data->symbolNames)
			) 
			(axlFormListSelect 
			    (tbx_quicksymedit_data->formId) "symbol_list" symbol_name
			) 
			(axlClearSelSet) 
			when((tbx_quicksymedit_data->symbolsHighlight) 
			    (axlDehighlightObject 
				(tbx_quicksymedit_data->symbolsHighlight)
			    )
			) 
			(tbx_quicksymedit_data->symbolsHighlight = (axlSelectByName "SYMTYPE" symbol_name))
			(axlHighlightObject 
			    (tbx_quicksymedit_data->symbolsHighlight)
			) else 
			printf("Warning: No net selected\n")
		    )
		) 
		(DONE 
		    when((tbx_quicksymedit_data->symbolsHighlight) 
			(axlDehighlightObject 
			    (tbx_quicksymedit_data->symbolsHighlight)
			)
		    ) 
		    (loop = nil)
		) 
		(CANCEL 
		    when((tbx_quicksymedit_data->symbolsHighlight) 
			(axlDehighlightObject 
			    (tbx_quicksymedit_data->symbolsHighlight)
			)
		    ) 
		    (loop = nil)
		)
	    )
	)
    )
)
procedure(TBX_QUICKSYMEDIT_Get_Symbol_Info(symdef) 
    let((padstack_list flash_list symbol_info shape_list) 
	case(lowerCase((symdef->type)) 
	    ("package" 
		(symbol_info = cons(list((symdef->name) "package") symbol_info))
	    ) 
	    ("mechanical" 
		(symbol_info = cons(list((symdef->name) "mechanical") symbol_info))
	    ) 
	    ("format" 
		(symbol_info = cons(list((symdef->name) "format") symbol_info))
	    )
	) 
	foreach(pin 
	    (symdef->pins) 
	    unless(exists(x padstack_list 
		    (x == (pin->name))
		) 
		(padstack_list = cons((pin->name) padstack_list)) 
		(symbol_info = cons(list((pin->name) "pad") symbol_info))
	    ) 
	    foreach(pad 
		(pin->pads) 
		cond((((pad->flash) && ((pad->flash) != "")) 
			unless(exists(x flash_list 
				(x == (pad->flash))
			    ) 
			    (flash_list = cons((pad->flash) flash_list)) 
			    (symbol_info = cons(list((pad->flash) "flash_fsm") symbol_info))
			)
		    ) 
		    (((pad->name) && ((pad->figureName) == "SHAPE")) 
			unless(exists(x shape_list 
				(x == (pad->name))
			    ) 
			    (shape_list = cons((pad->name) shape_list)) 
			    (symbol_info = cons(list((pad->name) "shape_ssm") symbol_info))
			)
		    )
		)
	    )
	) symbol_info
    )
)
procedure(TBX_QUICKSYMEDIT_Init() 
    let((symbol_names symbol_dir) 
	(symbol_names = mapcar(lambda((x) 
		    (x->name)
		) 
		((axlDBGetDesign)->symdefs)
	    )) 
	(symbol_names = sort(symbol_names nil)) 
	(symbol_dir = getWorkingDir()) 
	unless(boundp('tbx_quicksymedit_data) 
	    iliDefstruct('defstruct(tbx_quicksymedit_data_struct symbolNames activeSymbol envSettings updateSettings
			symbolDir boardName licCheck inTrigger symbolsHighlight
		    )
	    ) 
	    defvar(tbx_quicksymedit_data nil)
	)
	if(!tbx_quicksymedit_data then 
	    (tbx_quicksymedit_data = (make_tbx_quicksymedit_data_struct ?symbolNames symbol_names ?symbolDir symbol_dir
		    ?boardName nil ?activeSymbol 
		    ncons(nil) ?envSettings
		    ncons(nil) ?updateSettings 
		    ncons(nil) ?licCheck nil
		    ?inTrigger nil ?symbolsHighlight nil
		)) else 
	    (tbx_quicksymedit_data->symbolNames = symbol_names)
	    (tbx_quicksymedit_data->symbolDir = symbol_dir) 
	    (tbx_quicksymedit_data->boardName = nil) 
	    (tbx_quicksymedit_data->activeSymbol = ncons(nil)) 
	    (tbx_quicksymedit_data->envSettings = ncons(nil)) 
	    (tbx_quicksymedit_data->updateSettings = ncons(nil))
	    (tbx_quicksymedit_data->licCheck = nil) 
	    (tbx_quicksymedit_data->symbolsHighlight = nil)
	)
    )
)
procedure(TBX_QUICKSYMEDIT_Launch_Session(symbol_drawing) 
    let((local_env_dir local_env_tmp tmp_env_file batch_file port
	    cmd master_env_file inport line temp_dir
	) 
	if((lowerCase(cdsPlat()) == "wint") then 
	    (local_env_dir = axlGetVariable("LOCALENV")) 
	    (local_env_tmp = strcat(car((axlDMFileParts local_env_dir)) "/pcbenv_tbxtmp")) 
	    (master_env_file = strcat(local_env_dir "/env"))
	    (tmp_env_file = strcat(local_env_tmp "/env")) 
	    when(isDir(local_env_tmp) 
		(axlRecursiveDelete local_env_tmp)
	    ) 
	    createDir(local_env_tmp) 
	    (port = outfile(tmp_env_file "w")) 
	    (inport = infile(master_env_file))
	    while((line = _gets(inport)) 
		fprintf(port "%s" line)
	    ) 
	    close(inport) 
	    fprintf(port "set noconfirm\n") 
	    close(port) 
	    (temp_dir = car((axlDMFileParts 
			(axlTempFile)
		    )
		))
	    (batch_file = strcat(temp_dir "/alg.bat")) 
	    (port = outfile(batch_file "w")) 
	    fprintf(port "echo off\n") 
	    fprintf(port "set CDS_LIC_FILE=\n") 
	    fprintf(port "set ALLEGRO_PCBENV=%s\n" local_env_tmp)
	    fprintf(port "cd /D %L\n" 
		getWorkingDir()
	    ) 
	    fprintf(port "allegro -orcad %s\n" symbol_drawing) 
	    fprintf(port "cmd.exe\n") 
	    close(port) 
	    (cmd = sprintf(nil "run -b %L" batch_file))
	    (axlShell cmd) else 
	    (cmd = sprintf(nil "run -b allegro %L" symbol_drawing)) 
	    (axlShell cmd)
	)
    )
)
procedure((TBX_QUICKSYMEDIT_Main \@optional arg) 
    let((lic_check_result info_file FC_FEATURE FC_VERSION SUB_VERSION
	    VERSION_STR port FORM_FILE fid
	) 
	(FC_FEATURE = "QUICKSYMEDIT") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Quick Symbol Edit %s (C)2017" FC_VERSION))
	(VERSION_STR = VERSION_STR) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./quicksymedit_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Quick Symbol Editor information:\n") 
		fprintf(port "============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Quick Symbol Edit: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    printf("For additional help enter: 'tbx help quicksymedit' in console window\n") 
		    if((lowerCase((axlDesignType nil)) == "layout") then 
			if(((car((parseQuotedString 
					    axlGetVariable("PADPATH")
					)
				    ) == ".") && (car((parseQuotedString 
					    axlGetVariable("PSMPATH")
					)
				    ) == ".")) then 
			    TBX_QUICKSYMEDIT_Init() 
			    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "quicksymedit_mini")) 
			    (fid = (axlMiniStatusLoad 
				    gensym("tbxquicksymeditmini") FORM_FILE 
				    'TBX_QUICKSYMEDIT_Callback t
				))
			    (tbx_quicksymedit_data->formId = fid) 
			    (tbx_quicksymedit_data->licCheck = lic_check_result) 
			    TBX_FORM_Init_Header(fid nil lic_check_result nil) 
			    (axlFormSetField fid "symbol_filter" "*") 
			    (axlFormListDeleteAll fid "symbol_list")
			    (axlFormSetField fid "symbol_list" 
				(tbx_quicksymedit_data->symbolNames)
			    ) 
			    (axlFormSetField fid "active_symbol" "<nothing selected>") 
			    (axlFormSetField fid "active_type" "") 
			    (axlFormDisplay fid) 
			    TBX_FORM_Delete(lic_check_result FORM_FILE)
			    (axlAutoOpenFindFilter) 
			    TBX_QUICKSYMEDIT_Event_Loop() else 
			    (axlUIConfirm "Warning: PADPATH and PSMPATH must point to \".\" in the first place\n. Cannot proceed")
			) else 
			(axlUIConfirm "Warning: Quick Symbol Edit can be launched from layout databases only")
		    )
		)
	    )
	)
    )
)
procedure(TBX_QUICKSYMEDIT_Menu_Trigger(t_menufile) 
    (t_menufile = t_menufile) 
    (axlUIMenuFind nil 0 
	'top
    ) 
    when(((lowerCase((axlDesignType nil)) == "symbol") && 
	    (tbx_quicksymedit_data->boardName)) 
	(axlCmdRegister "tbx quicksymedit_return" 
	    'TBX_QUICKSYMEDIT_Return ?cmdType "interactive"
	) 
	(axlUIMenuInsert nil 
	    'popup "Quick Symbol Edit"
	) 
	(axlUIMenuInsert nil "Return to Layout" "tbx quicksymedit_return") 
	TBX_QUICKSYMEDIT_Setup_Grid()
    )
)
procedure(TBX_QUICKSYMEDIT_Refresh_Padstacks(symbol_info reset_custom_drill_data) 
    let((port script_file cmd padstack_list_file) 
	(padstack_list_file = strcat(getWorkingDir() "/padstack.lst")) 
	(port = outfile(padstack_list_file "w")) 
	foreach(entry symbol_info 
	    when((cadr(entry) == "pad") 
		fprintf(port "%s\n" 
		    car(entry)
		)
	    )
	) 
	close(port)
	(script_file = strcat(getWorkingDir() "/refresh_pad.scr")) 
	(port = outfile(script_file "w")) 
	fprintf(port "scriptmode +i +n\n") 
	fprintf(port "setwindow pcb\n") 
	fprintf(port "generaledit\n")
	fprintf(port "refresh padstack\n") 
	fprintf(port "setwindow form.rf_pad\n") 
	fprintf(port "FORM rf_pad padstack_list YES\n") 
	fprintf(port "FORM rf_pad listfile %L\n" padstack_list_file) 
	if(reset_custom_drill_data then 
	    fprintf(port "FORM rf_pad reset_drill_data YES\n") else 
	    fprintf(port "FORM rf_pad reset_drill_data NO\n")
	)
	fprintf(port "FORM rf_pad execute\n") 
	fprintf(port "FORM rf_pad cancel\n") 
	fprintf(port "setwindow pcb\n") 
	fprintf(port "generaledit\n") 
	close(port)
	(cmd = sprintf(nil "replay %L" script_file)) 
	(axlShell cmd) 
	unless(axlGetVariable("FLW_DEBUG") 
	    when(isFile(script_file) 
		deleteFile(script_file)
	    ) 
	    when(isFile(padstack_list_file) 
		deleteFile(padstack_list_file)
	    )
	) t
    )
)
procedure(TBX_QUICKSYMEDIT_Return() 
    let((FORM_FILE fid) 
	when((tbx_quicksymedit_data->boardName) 
	    (FORM_FILE = TBX_FORM_Get_Name((tbx_quicksymedit_data->licCheck) "quicksymedit_update")) 
	    (fid = (axlFormCreate 
		    gensym("tbxquicksymeditupdate") FORM_FILE 
		    '(e outer) 
		    'TBX_QUICKSYMEDIT_Update_Callback
		    t nil
		)) 
	    (axlFormSetField fid "sym_update" t) 
	    (axlFormSetFieldEditable fid "reset_customizable_drill_data" nil)
	    (axlFormDisplay fid) 
	    TBX_FORM_Delete((tbx_quicksymedit_data->licCheck) FORM_FILE)
	)
    )
)
procedure(TBX_QUICKSYMEDIT_Setup_Grid() 
    let((design_units grid_value grd_param) 
	(design_units = lowerCase(car((axlDBGetDesignUnits)))) 
	if(((design_units == "microns") || (design_units == "millimeters") || (design_units == "centimeters")) then 
	    (grid_value = (axlMKSConvert "0.1 MM" design_units)) else 
	    (grid_value = (axlMKSConvert "4.0 MILS" design_units))
	) 
	printf("Note: Changing grid to %L\n" grid_value) 
	(grd_param = (axlDBGridGet "non-etch"))
	(grd_param->name = 'all) 
	(grd_param->xGrids = grid_value) 
	(grd_param->yGrids = grid_value) 
	(grd_param->xOrigin = 0.0) 
	(grd_param->yOrigin = 0.0)
	(axlDBGridSet grd_param) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_QUICKSYMEDIT_Update_Callback(form_handle) 
    let((cmd refresh_args) 
	case((form_handle->curField) 
	    ("refresh_padstack" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "reset_customizable_drill_data" t) else 
		    (axlFormSetFieldEditable form_handle "reset_customizable_drill_data" nil)
		    (axlFormSetField form_handle "reset_customizable_drill_data" nil)
		)
	    ) 
	    ("sym_update" 
		(axlFormSetFieldEditable form_handle "reset_text" t) 
		(axlFormSetFieldEditable form_handle "reset_fanout" t) 
		(axlFormSetFieldEditable form_handle "refresh_padstack" t) 
		if((axlFormGetField form_handle "refresh_padstack") then 
		    (axlFormSetFieldEditable form_handle "reset_customizable_drill_data" t) else 
		    (axlFormSetFieldEditable form_handle "reset_customizable_drill_data" nil)
		    (axlFormSetField form_handle "reset_customizable_drill_data" nil)
		)
	    ) 
	    ("skip_sym_update" 
		(axlFormSetFieldEditable form_handle "reset_text" nil) 
		(axlFormSetFieldEditable form_handle "reset_fanout" nil) 
		(axlFormSetFieldEditable form_handle "refresh_padstack" nil) 
		(axlFormSetFieldEditable form_handle "reset_customizable_drill_data" nil)
	    ) 
	    ("return_to_layout" 
		if((axlFormGetField form_handle "sym_update") then 
		    ((tbx_quicksymedit_data->updateSettings)->okUpdate = t) else 
		    ((tbx_quicksymedit_data->updateSettings)->okUpdate = nil)
		) 
		when((axlFormGetField form_handle "reset_text") 
		    ((tbx_quicksymedit_data->updateSettings)->resetText = t)
		) 
		when((axlFormGetField form_handle "reset_fanout") 
		    ((tbx_quicksymedit_data->updateSettings)->resetFanout = t)
		) 
		when((axlFormGetField form_handle "refresh_padstack") 
		    ((tbx_quicksymedit_data->updateSettings)->refreshPadstacks = t)
		)
		when((axlFormGetField form_handle "reset_customizable_drill_data") 
		    ((tbx_quicksymedit_data->updateSettings)->resetCustomizableDrillData = t)
		) 
		when((axlFormGetField form_handle "cleanup_local_files") 
		    ((tbx_quicksymedit_data->updateSettings)->cleanupFiles = t)
		) 
		(axlFormClose form_handle) 
		(axlCompileSymbol ?silent t ?silentOnOverwrite t) 
		(axlSaveDesign)
		(cmd = sprintf(nil "opencd %L" 
			(tbx_quicksymedit_data->boardName)
		    )) 
		(axlShell cmd) 
		when(((tbx_quicksymedit_data->updateSettings)->okUpdate) 
		    when(((tbx_quicksymedit_data->updateSettings)->resetText) 
			(refresh_args = list('text))
		    ) 
		    when(((tbx_quicksymedit_data->updateSettings)->resetFanout) 
			(refresh_args = append1(refresh_args 
				'fanout
			    ))
		    ) 
		    (axlRefreshSymbol 
			((tbx_quicksymedit_data->activeSymbol)->name) refresh_args
		    ) 
		    when(((tbx_quicksymedit_data->updateSettings)->refreshPadstacks) 
			TBX_QUICKSYMEDIT_Refresh_Padstacks(((tbx_quicksymedit_data->activeSymbol)->symbolInfo) 
			    ((tbx_quicksymedit_data->updateSettings)->resetCustomizableDrillData)
			)
		    )
		) 
		when(((tbx_quicksymedit_data->updateSettings)->cleanupFiles) 
		    TBX_QUICKSYMEDIT_Cleanup_Files(((tbx_quicksymedit_data->activeSymbol)->symbolInfo))
		) 
		TBX_QUICKSYMEDIT_Change_Env("reset")
		when((tbx_quicksymedit_data->inTrigger) 
		    (axlTriggerClear 
			'menu 
			'TBX_QUICKSYMEDIT_Menu_Trigger
		    ) 
		    (tbx_quicksymedit_data->inTrigger = nil)
		) 
		(tbx_quicksymedit_data->boardName = nil)
	    )
	    ("cancel" 
		(axlFormClose form_handle) 
		(axlFinishEnterFun)
	    )
	)
    )
)
procedure(TBX_READTECHXML_Load_File(tech_file) 
    let((inport tech_hash table_cnt) 
	printf("Loading XML techfile ...\n") 
	(inport = infile(tech_file)) 
	(tech_hash = makeTable("tech_hash" nil)) 
	(table_cnt = 0)
	TBX_READTECHXML_Parse_Data(tech_hash nil table_cnt inport) 
	close(inport) tech_hash
    )
)
procedure(TBX_READTECHXML_Parse_Data(parent start_tag table_cnt inport) 
    let((arr dl tag child_hash child_print_name
	    value tagNameCnt loop result
	) 
	(tagNameCnt = makeTable("tagNameList" 0)) 
	(loop = t) 
	while((loop && (dl = _gets(inport))) 
	    (dl = TBX_READTECHXML_Trim_String(dl "basic")) 
	    cond((rexMatchp("<?xml .* ?>$" dl) 
		    (tag = "XML-DECLARATION") 
		    (tagNameCnt[tag] = (tagNameCnt[tag] + 1)) 
		    when((tagNameCnt[tag] > 1) 
			(tag = sprintf(nil "%s_%d" tag 
				sub1(tagNameCnt[tag])
			    ))
		    ) 
		    (value = TBX_READTECHXML_Trim_String(dl "declaration"))
		    (parent[tag] = value)
		) 
		(rexMatchp("<!--.*-->" dl) 
		    (tag = "XML-COMMENT") 
		    (tagNameCnt[tag] = (tagNameCnt[tag] + 1)) 
		    when((tagNameCnt[tag] > 1) 
			(tag = sprintf(nil "%s_%d" tag 
				sub1(tagNameCnt[tag])
			    ))
		    ) 
		    (value = TBX_READTECHXML_Trim_String(dl "comment"))
		    (parent[tag] = value)
		) 
		(rexMatchp("<\\(.*\\)>.*</\\1>$" dl) 
		    (arr = parseString(dl "<>")) 
		    (tag = car(arr)) 
		    (value = cadr(arr)) 
		    (tagNameCnt[tag] = (tagNameCnt[tag] + 1))
		    when((tagNameCnt[tag] > 1) 
			sprintf(tag "%s_%d" tag 
			    sub1(tagNameCnt[tag])
			)
		    ) 
		    (parent[tag] = value)
		) 
		(rexMatchp("<.*/>$" dl) 
		    (tag = car(parseString(dl "</>"))) 
		    (value = "EMPTY") 
		    (tagNameCnt[tag] = (tagNameCnt[tag] + 1)) 
		    when((tagNameCnt[tag] > 1) 
			sprintf(tag "%s_%d" tag 
			    sub1(tagNameCnt[tag])
			)
		    )
		    (parent[tag] = value)
		) 
		(rexMatchp("</.*>$" dl) 
		    (arr = parseString(dl "</_>")) 
		    (tag = car(arr)) 
		    unless(start_tag 
			(result = t)
		    ) 
		    (loop = nil)
		    if((tag != car(parseString(start_tag "_"))) then 
			printf("Error: Start tag and end tag do not match: %L %L\n" start_tag tag) 
			(result = nil) else
			(result = t)
		    )
		)
		(rexMatchp("<.*>$" dl) 
		    (arr = parseString(dl "<>")) 
		    (tag = car(parseString(car(arr)))) 
		    (tagNameCnt[tag] = (tagNameCnt[tag] + 1)) 
		    when((tagNameCnt[tag] > 1) 
			sprintf(tag "%s_%d" tag 
			    sub1(tagNameCnt[tag])
			)
		    )
		    ++table_cnt 
		    (child_print_name = sprintf(nil "tech_hash%d" table_cnt)) 
		    (child_hash = makeTable(child_print_name nil)) 
		    (parent[tag] = child_hash) 
		    (result = TBX_READTECHXML_Parse_Data(child_hash tag table_cnt inport))
		) 
		(t t)
	    )
	) result
    )
)
procedure(TBX_READTECHXML_Trim_String(str mode) 
    cond(((mode == "basic") 
	    rexCompile("^ *") 
	    (str = rexReplace(str "" 0)) 
	    rexCompile(" *\n$") 
	    (str = rexReplace(str "" 0))
	) 
	((mode == "declaration") 
	    rexCompile("^<[?]xml *") 
	    (str = rexReplace(str "" 0)) 
	    rexCompile(" *[?] *>$") 
	    (str = rexReplace(str "" 0))
	) 
	((mode == "comment") 
	    rexCompile("^<!-- *") 
	    (str = rexReplace(str "" 0)) 
	    rexCompile(" *-->$") 
	    (str = rexReplace(str "" 0))
	)
    ) str
)
procedure((TBX_SESSION_Get_Param record field_name default_value \@optional
	is_unit
    ) 
    let((param_value current_units cache_units session_param) 
	(current_units = car((axlDBGetDesignUnits))) 
	(session_param = eval('tbx_session_param)) 
	when(is_unit 
	    (cache_units = get(session_param[record] 
		    stringToSymbol("units")
		))
	) 
	if(session_param[record] then 
	    (param_value = get(session_param[record] 
		    stringToSymbol(field_name)
		)) 
	    when((param_value && is_unit && numberp(param_value)) 
		(param_value = (axlMKSConvert param_value cache_units current_units))
	    ) else
	    (param_value = default_value)
	)
	param_value
    )
)
procedure(TBX_SESSION_Init() 
    printf("Initializing toolbox...\n") 
    when(isCallable('axlTriggerSet) 
	(axlTriggerSet 
	    'open 
	    'TBX_SESSION_Param_Trigger
	)
    ) t
)
procedure(TBX_SESSION_Param_Trigger(t_open) 
    (t_open = t_open) 
    defvar(tbx_session_param 
	makeTable("tbx_session_param_table" nil)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Add_Vertex_Label(text_value text_xy) 
    let((text_orient) 
	(text_orient = (make_axlTextOrientation ?textBlock "2" ?rotation 0.0
		?mirrored nil ?justify "center"
	    )) 
	(axlDBCreateText text_value text_xy text_orient "DRAWING FORMAT/OUTLINE"
	    nil
	)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Cache_Param(form_handle) 
    let((rec session_param active_layer) 
	(rec = "shapeutils|advedit") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	when((axlFormGetField form_handle "modify_arc") 
	    (axlFormSetField form_handle "round_off_vertex" t)
	)
	if((tbx_shapeutils_data->adveditObjectInfo) then 
	    (active_layer = strcat(((tbx_shapeutils_data->adveditObjectInfo)->className) "/" 
		    ((tbx_shapeutils_data->adveditObjectInfo)->subclassName)
		)) else 
	    (active_layer = strcat((axlMapClassName "ETCH") "/TOP"))
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "stretch") 
	    stringToSymbol("stretch")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "cut") 
	    stringToSymbol("cut")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "snap_to_grid") 
	    stringToSymbol("snap_to_grid")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "trim_to_user_window") 
	    stringToSymbol("trim_to_user_window")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "round_off_vertex") 
	    stringToSymbol("round_off_vertex")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "change_round_off_vertex") 
	    stringToSymbol("change_round_off_vertex")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "round_off_radius_value") 
	    stringToSymbol("round_off_radius_value")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "modify_arc") 
	    stringToSymbol("modify_arc")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "center_x_incr") 
	    stringToSymbol("center_x_incr")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "center_y_incr") 
	    stringToSymbol("center_y_incr")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "arc_radius_incr") 
	    stringToSymbol("arc_radius_incr")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "handle_size") 
	    stringToSymbol("handle_size")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "display_skeleton") 
	    stringToSymbol("display_skeleton")
	) 
	putprop(session_param[rec] active_layer 
	    stringToSymbol("active_layer")
	)
	putprop(session_param[rec] 
	    car((axlDBGetDesignUnits)) 
	    stringToSymbol("units")
	) 
	putprop(session_param[rec] 
	    cons("NOALL" 
		(axlGetFindFilter nil)
	    ) 
	    stringToSymbol("ff_enable")
	) 
	putprop(session_param[rec] 
	    cons("NOALL" 
		(axlGetFindFilter t)
	    ) 
	    stringToSymbol("ff_on")
	) t
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Calculate_Offset_Intersections(cur_seg_info prev_seg_info radius_value) 
    let((cur_off_seg_list prev_off_seg_list isec_list result) 
	(cur_off_seg_list = TBX_SHAPEUTILS_ADVEDIT_Copy_Parallel(cur_seg_info radius_value 
		(tbx_shapeutils_data->tmpLayer2)
	    )) 
	(prev_off_seg_list = TBX_SHAPEUTILS_ADVEDIT_Copy_Parallel(prev_seg_info radius_value 
		(tbx_shapeutils_data->tmpLayer2)
	    )) 
	(isec_list = list()) 
	foreach(sega cur_off_seg_list 
	    foreach(segb prev_off_seg_list 
		(result = (_axlFindIntersectionPoint sega segb)) 
		when(car(result) 
		    foreach(isec result 
			(isec_list = cons(isec isec_list))
		    )
		)
	    )
	)
	(axlDeleteObject cur_off_seg_list) 
	(axlDeleteObject prev_off_seg_list) isec_list
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Callback(form_handle) 
    let((x_value y_value radius_value arc_id seg_info) 
	case((form_handle->curField) 
	    ("stretch" 
		TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("stretch_init") 
		when((form_handle->curValue) 
		    ((tbx_shapeutils_data->runTime)->action = "stretch") 
		    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
			    (tbx_shapeutils_data->adveditCurSegTable) 
			    (tbx_shapeutils_data->adveditObjectInfo) form_handle
			))
		)
	    ) 
	    ("cut" 
		TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("cut") 
		when((form_handle->curValue) 
		    ((tbx_shapeutils_data->runTime)->action = "cut") 
		    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
			    (tbx_shapeutils_data->adveditCurSegTable) 
			    (tbx_shapeutils_data->adveditObjectInfo) form_handle
			))
		)
	    ) 
	    ("round_off_vertex" 
		TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("round_off_vertex") 
		when((form_handle->curValue) 
		    ((tbx_shapeutils_data->runTime)->action = "round_off_vertex") 
		    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
			    (tbx_shapeutils_data->adveditCurSegTable) 
			    (tbx_shapeutils_data->adveditObjectInfo) form_handle
			))
		)
	    ) 
	    ("change_round_off_vertex" 
		TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("change_round_off_vertex") 
		when((form_handle->curValue) 
		    ((tbx_shapeutils_data->runTime)->action = "change_round_off_vertex") 
		    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
			    (tbx_shapeutils_data->adveditCurSegTable) 
			    (tbx_shapeutils_data->adveditObjectInfo) form_handle
			))
		)
	    )
	    ("modify_arc" 
		TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("modify_arc_init") 
		when((form_handle->curValue) 
		    ((tbx_shapeutils_data->runTime)->action = "modify_arc") 
		    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
			    (tbx_shapeutils_data->adveditCurSegTable) 
			    (tbx_shapeutils_data->adveditObjectInfo) form_handle
			))
		)
	    ) 
	    ("center_x" 
		TBX_SHAPEUTILS_ADVEDIT_Modify_Arc_Param(form_handle)
	    ) 
	    ("toggle_x_minus" 
		(x_value = (axlFormGetField form_handle "center_x")) 
		(x_value = (x_value - (axlFormGetField form_handle "center_x_incr"))) 
		(axlFormSetField form_handle "center_x" x_value) 
		TBX_SHAPEUTILS_ADVEDIT_Modify_Arc_Param(form_handle)
	    ) 
	    ("toggle_x_plus" 
		(x_value = (axlFormGetField form_handle "center_x")) 
		(x_value = (x_value + (axlFormGetField form_handle "center_x_incr"))) 
		(axlFormSetField form_handle "center_x" x_value) 
		TBX_SHAPEUTILS_ADVEDIT_Modify_Arc_Param(form_handle)
	    ) 
	    ("center_y" 
		TBX_SHAPEUTILS_ADVEDIT_Modify_Arc_Param(form_handle)
	    )
	    ("toggle_y_minus" 
		(y_value = (axlFormGetField form_handle "center_y")) 
		(y_value = (y_value - (axlFormGetField form_handle "center_y_incr"))) 
		(axlFormSetField form_handle "center_y" y_value) 
		TBX_SHAPEUTILS_ADVEDIT_Modify_Arc_Param(form_handle)
	    ) 
	    ("toggle_y_plus" 
		(y_value = (axlFormGetField form_handle "center_y")) 
		(y_value = (y_value + (axlFormGetField form_handle "center_y_incr"))) 
		(axlFormSetField form_handle "center_y" y_value) 
		TBX_SHAPEUTILS_ADVEDIT_Modify_Arc_Param(form_handle)
	    ) 
	    ("arc_radius" 
		TBX_SHAPEUTILS_ADVEDIT_Modify_Arc_Param(form_handle)
	    ) 
	    ("toggle_radius_minus" 
		(radius_value = (axlFormGetField form_handle "arc_radius")) 
		(radius_value = (radius_value - (axlFormGetField form_handle "arc_radius_incr"))) 
		(axlFormSetField form_handle "arc_radius" radius_value) 
		TBX_SHAPEUTILS_ADVEDIT_Modify_Arc_Param(form_handle)
	    ) 
	    ("toggle_radius_plus" 
		(radius_value = (axlFormGetField form_handle "arc_radius")) 
		(radius_value = (radius_value + (axlFormGetField form_handle "arc_radius_incr"))) 
		(axlFormSetField form_handle "arc_radius" radius_value) 
		TBX_SHAPEUTILS_ADVEDIT_Modify_Arc_Param(form_handle)
	    )
	    ("swap_direction" 
		(arc_id = ((tbx_shapeutils_data->runTime)->arcId)) 
		(seg_info = copy((tbx_shapeutils_data->adveditCurSegTable)[arc_id])) 
		if((seg_info->isClockwise) then 
		    (seg_info->isClockwise = nil) else 
		    (seg_info->isClockwise = t)
		) 
		((tbx_shapeutils_data->adveditCurSegTable)[arc_id] = TBX_SHAPEUTILS_ADVEDIT_Update_Arc_Angles(seg_info))
		(axlDBTransactionMark 
		    (tbx_shapeutils_data->transMark)
		) 
		(tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
			(tbx_shapeutils_data->adveditCurSegTable) 
			(tbx_shapeutils_data->adveditObjectInfo) form_handle
		    ))
	    ) 
	    ("handle_size" 
		(tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
			(tbx_shapeutils_data->adveditCurSegTable) 
			(tbx_shapeutils_data->adveditObjectInfo) form_handle
		    ))
	    ) 
	    ("display_skeleton" 
		if((form_handle->curValue) then 
		    (axlVisibleLayer 
			(tbx_shapeutils_data->tmpLayer2) t
		    ) else 
		    (axlVisibleLayer 
			(tbx_shapeutils_data->tmpLayer2) nil
		    )
		) 
		(axlVisibleUpdate t)
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Change_Round_Off_Vertex(segData id_list radius_value) 
    let((segDataMod segDataFinal seg_info segment_id cur_seg_id
	    prev_seg_id next_seg_id extended_intersection result isec_list
	    min_threshold new_arc_center next_seg prev_end_new next_start_new
	    pi ext_x ext_y angle prev_seg
	    prev_threshold next_threshold tmp_list prev_info cur_info
	    next_info arc_is_clockwise
	) 
	(pi = (defMathConstants('mymathconst)->PI)) 
	(segDataMod = makeTable("seg_data_mod_table" nil)) 
	for(i 1 
	    length(segData) 
	    (segDataMod[i] = copy(segData[i]))
	) 
	foreach(entry id_list 
	    (cur_seg_id = car(entry)) 
	    if(onep(cur_seg_id) then 
		(prev_seg_id = length(segDataMod)) else 
		(prev_seg_id = (cur_seg_id - 1))
	    ) 
	    if((cur_seg_id == length(segDataMod)) then 
		(next_seg_id = 1) else 
		(next_seg_id = (cur_seg_id + 1))
	    )
	    (prev_info = copy(segDataMod[prev_seg_id])) 
	    (cur_info = copy(segDataMod[cur_seg_id])) 
	    (next_info = copy(segDataMod[next_seg_id])) 
	    when((prev_info && cur_info && next_info) 
		if(((prev_info->segType) == "arc") then 
		    (prev_threshold = (prev_info->radius)) else 
		    (prev_threshold = abs((axlDistance 
				(prev_info->startXY) 
				(prev_info->endXY)
			    )
			))
		) 
		if(((next_info->segType) == "arc") then 
		    (next_threshold = (next_info->radius)) else 
		    (next_threshold = abs((axlDistance 
				(next_info->startXY) 
				(next_info->endXY)
			    )
			))
		) 
		(min_threshold = min(prev_threshold next_threshold)) 
		if((radius_value > min_threshold) then 
		    printf("Warning: Radius value too large for selected vertex. Choose a smaller value\n") else 
		    (prev_seg = TBX_SHAPEUTILS_ADVEDIT_Draw_Secondary_Segment(prev_info))
		    (next_seg = TBX_SHAPEUTILS_ADVEDIT_Draw_Secondary_Segment(next_info)) 
		    (isec_list = (_axlFindIntersectionPoint prev_seg next_seg)) 
		    (axlDeleteObject 
			list(prev_seg next_seg)
		    ) 
		    cond((!car(isec_list) 
			    cond(((((prev_info->segType) == "arc") && ((next_info->segType) == "arc")) 
				    (angle = TBX_GEOM_Get_Vector_Info((next_info->centerXY) 
					    (next_info->centerXY)
					)) 
				    when((angle && (TBX_GEOM_Round((axlDistance 
							(next_info->centerXY) 
							(prev_info->centerXY)
						    ) "reduce" 1
						) == TBX_GEOM_Round(((next_info->radius) + (prev_info->radius)) "reduce" 1))) 
					(ext_x = (car((prev_info->centerXY)) + (cos(((angle / 360.0) * 2 * pi)) * (prev_info->radius)))) 
					(ext_y = (cadr((prev_info->centerXY)) + (sin(((angle / 360.0) * 2 * pi)) * (prev_info->radius)))) 
					(extended_intersection = (ext_x:ext_y))
				    )
				) 
				((((prev_info->segType) == "line") && ((next_info->segType) == "arc")) 
				    (result = TBX_SHAPEUTILS_ADVEDIT_Get_Normal_Projection((next_info->centerXY) prev_info nil nil)) 
				    when((result && (TBX_GEOM_Round((axlDistance result 
							(next_info->centerXY)
						    ) "reduce" 1
						) == TBX_GEOM_Round((next_info->radius) "reduce" 1))) 
					(extended_intersection = result)
				    )
				) 
				((((prev_info->segType) == "arc") && ((next_info->segType) == "line")) 
				    (result = TBX_SHAPEUTILS_ADVEDIT_Get_Normal_Projection((prev_info->centerXY) next_info nil nil)) 
				    when((result && (TBX_GEOM_Round((axlDistance result 
							(prev_info->centerXY)
						    ) "reduce" 1
						) == TBX_GEOM_Round((prev_info->radius) "reduce" 1))) 
					(extended_intersection = result)
				    )
				) 
				(t 
				    (extended_intersection = nil) 
				    printf("Warning: There are no intersections between previous and next segment. Cannot proceed\n")
				)
			    )
			) 
			((car(isec_list) && onep(length(isec_list))) 
			    (extended_intersection = car(isec_list))
			) 
			((car(isec_list) && (length(isec_list) == 2)) 
			    (tmp_list = list()) 
			    (tmp_list = cons(list((axlDistance 
					    car(isec_list) 
					    (segDataMod[cur_seg_id]->centerXY)
					) 
					car(isec_list)
				    ) tmp_list
				)) 
			    (tmp_list = cons(list((axlDistance 
					    cadr(isec_list) 
					    (segDataMod[cur_seg_id]->centerXY)
					) 
					cadr(isec_list)
				    ) tmp_list
				)) 
			    (tmp_list = sortcar(tmp_list 
				    'lessp
				))
			    (extended_intersection = cadar(tmp_list))
			)
		    ) 
		    cond(((extended_intersection && (radius_value > 0.0)) 
			    (prev_info->endXY = extended_intersection) 
			    (next_info->startXY = extended_intersection) 
			    when(((prev_info->segType) == "arc") 
				(prev_info = TBX_SHAPEUTILS_ADVEDIT_Update_Arc_Angles(prev_info))
			    ) 
			    when(((next_info->segType) == "arc") 
				(next_info = TBX_SHAPEUTILS_ADVEDIT_Update_Arc_Angles(next_info))
			    )
			    (result = TBX_SHAPEUTILS_ADVEDIT_Get_Round_Off_Direction(next_info prev_info)) 
			    (isec_list = TBX_SHAPEUTILS_ADVEDIT_Calculate_Offset_Intersections(next_info prev_info radius_value)) 
			    (isec_list = TBX_SHAPEUTILS_ADVEDIT_Filter_Points(isec_list prev_info next_info radius_value)) 
			    when((car(result) && isec_list) 
				(arc_is_clockwise = cadr(result)) 
				(tmp_list = list()) 
				(prev_end_new = nil) 
				(next_start_new = nil)
				foreach(isec isec_list 
				    (prev_end_new = TBX_SHAPEUTILS_ADVEDIT_Get_Normal_Projection(isec prev_info t t)) 
				    (next_start_new = TBX_SHAPEUTILS_ADVEDIT_Get_Normal_Projection(isec next_info t t)) 
				    when((prev_end_new && next_start_new) 
					(tmp_list = cons(list((axlDistance isec 
							(next_info->startXY)
						    ) isec prev_end_new next_start_new
						) tmp_list
					    ))
				    )
				) 
				when(tmp_list 
				    (tmp_list = sortcar(tmp_list 
					    'lessp
					)) 
				    (result = car(tmp_list)) 
				    (new_arc_center = cadr(result)) 
				    (prev_end_new = caddr(result))
				    (next_start_new = nth(3 result)) 
				    (segDataMod[prev_seg_id]->endXY = prev_end_new) 
				    (segDataMod[next_seg_id]->startXY = next_start_new) 
				    (seg_info = ncons(nil)) 
				    (seg_info->width = 0.0)
				    (seg_info->segType = "arc") 
				    (seg_info->isRegular = t) 
				    (seg_info->startXY = prev_end_new) 
				    (seg_info->endXY = next_start_new) 
				    (seg_info->radius = radius_value)
				    (seg_info->isClockwise = arc_is_clockwise) 
				    (seg_info->isCircle = nil) 
				    (seg_info->centerXY = new_arc_center) 
				    (segDataMod[cur_seg_id] = seg_info)
				)
			    )
			) 
			((extended_intersection && (radius_value == 0.0)) 
			    (segDataMod[prev_seg_id]->endXY = extended_intersection) 
			    (segDataMod[cur_seg_id] = nil) 
			    (segDataMod[next_seg_id]->startXY = extended_intersection)
			)
		    )
		)
	    )
	)
	(segDataFinal = makeTable("seg_data_final_table" nil)) 
	(segment_id = 0) 
	for(i 1 
	    length(segDataMod) 
	    when(segDataMod[i] 
		if(((segDataMod[i]->segType) == "arc") then 
		    (segDataFinal[++segment_id] = TBX_SHAPEUTILS_ADVEDIT_Update_Arc_Angles(segDataMod[i])) else 
		    (segDataFinal[++segment_id] = copy(segDataMod[i]))
		)
	    )
	) 
	list(t segDataFinal)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Clear_Groups() 
    foreach(name 
	list("TBX_SHAPEUTILS_SEGMENT" "TBX_SHAPEUTILS_VERTEX" "TBX_SHAPEUTILS_ARC") 
	foreach(grp 
	    (axlSelectByName "GROUP" name) 
	    (axlDeleteObject 
		(grp->groupMembers)
	    ) 
	    (axlDBRefreshId grp) 
	    (axlDBDisbandGroup grp)
	)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus(mode) 
    case(mode 
	("stretch_init" 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "cut" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "snap_to_grid" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "trim_to_user_window" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "round_off_vertex" t
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "change_round_off_vertex" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "round_off_radius_value" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "modify_arc" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_x" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_x_minus" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_x_incr" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_x_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_y" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_y_minus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_y_incr" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_y_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "arc_radius" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_radius_minus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "arc_radius_incr" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_radius_plus" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "swap_direction" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "handle_size" t
	    )
	) 
	("stretch_wait" 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "cut" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "snap_to_grid" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "trim_to_user_window" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "round_off_vertex" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "change_round_off_vertex" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "round_off_radius_value" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "modify_arc" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_x" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_x_minus" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_x_incr" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_x_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_y" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_y_minus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_y_incr" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_y_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "arc_radius" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_radius_minus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "arc_radius_incr" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_radius_plus" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "swap_direction" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "handle_size" nil
	    )
	) 
	("cut" 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "snap_to_grid" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "trim_to_user_window" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "round_off_radius_value" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_x" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_x_minus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_x_incr" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_x_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_y" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_y_minus" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_y_incr" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_y_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "arc_radius" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_radius_minus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "arc_radius_incr" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_radius_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "swap_direction" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "handle_size" t
	    )
	) 
	("round_off_vertex" 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "snap_to_grid" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "trim_to_user_window" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "round_off_radius_value" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_x" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_x_minus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_x_incr" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_x_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_y" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_y_minus" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_y_incr" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_y_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "arc_radius" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_radius_minus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "arc_radius_incr" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_radius_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "swap_direction" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "handle_size" t
	    )
	)
	("change_round_off_vertex" 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "snap_to_grid" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "trim_to_user_window" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "round_off_radius_value" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_x" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_x_minus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_x_incr" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_x_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_y" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_y_minus" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_y_incr" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_y_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "arc_radius" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_radius_minus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "arc_radius_incr" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_radius_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "handle_size" t
	    )
	) 
	("modify_arc_init" 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "stretch" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "cut" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "snap_to_grid" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "trim_to_user_window" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "round_off_vertex" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "change_round_off_vertex" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "round_off_radius_value" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_x" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_x_minus" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_x_incr" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_x_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_y" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_y_minus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_y_incr" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_y_plus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "arc_radius" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_radius_minus" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "arc_radius_incr" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_radius_plus" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "swap_direction" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "handle_size" t
	    )
	) 
	("modify_arc_wait" 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "stretch" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "cut" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "snap_to_grid" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "trim_to_user_window" nil
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "round_off_vertex" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "change_round_off_vertex" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "round_off_radius_value" nil
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_x" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_x_minus" t
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_x_incr" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_x_plus" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_y" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_y_minus" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "center_y_incr" t
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_y_plus" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "arc_radius" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_radius_minus" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "arc_radius_incr" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "toggle_radius_plus" t
	    )
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "swap_direction" t
	    ) 
	    (axlFormSetFieldEditable 
		(tbx_shapeutils_data->formId) "handle_size" t
	    )
	)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Copy_Parallel(seg_info distance layer) 
    let((line_angle_deg line_angle_rad line_length pi beta_deg
	    beta_rad start_xy end_xy start_x start_y
	    end_x end_y offset_start_x offset_start_y rpath
	    tmp_segs result
	) 
	(pi = (defMathConstants('mymathconst)->PI)) 
	case((seg_info->segType) 
	    ("line" 
		(start_xy = (seg_info->startXY)) 
		(end_xy = (seg_info->endXY)) 
		(result = TBX_GEOM_Get_Vector_Info(end_xy start_xy)) 
		(line_angle_deg = car(result))
		(line_length = caddr(result)) 
		(line_angle_rad = ((line_angle_deg * 2 * pi) / 360.0)) 
		foreach(ang 
		    list(90.0 -90.0) 
		    (beta_deg = (line_angle_deg + ang)) 
		    (beta_rad = ((beta_deg * 2 * pi) / 360.0)) 
		    (offset_start_x = (cos(beta_rad) * distance))
		    (offset_start_y = (sin(beta_rad) * distance)) 
		    (start_x = (car(start_xy) + offset_start_x)) 
		    (start_y = (cadr(start_xy) + offset_start_y)) 
		    (end_x = (start_x + (cos(line_angle_rad) * line_length))) 
		    (end_y = (start_y + (sin(line_angle_rad) * line_length)))
		    (rpath = (axlPathStart 
			    list((start_x:start_y) 
				(end_x:end_y)
			    ) 0.0
			)) 
		    (result = (axlDBCreatePath rpath layer)) 
		    when(result 
			foreach(p 
			    car(result) 
			    (tmp_segs = cons(car((p->segments)) tmp_segs))
			)
		    )
		)
	    ) 
	    ("arc" 
		foreach(dist 
		    list(((seg_info->radius) + distance) 
			((seg_info->radius) - distance)
		    ) 
		    when((dist > 0.0) 
			(result = (axlDBCreateCircle 
				list((seg_info->centerXY) dist) 0.0 layer
			    )) 
			when(result 
			    foreach(p 
				car(result) 
				(tmp_segs = cons(car((p->segments)) tmp_segs))
			    )
			)
		    )
		)
	    )
	) tmp_segs
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Create_Shape(rpath layer shape_info) 
    let((void_poly_list outline_poly result) 
	cond(((((shape_info->dataType) == "dynamic_shape") || ((shape_info->dataType) == "static_shape")) 
		if((shape_info->voidEdit) then 
		    (void_poly_list = cons(car((axlPolyFromDB rpath)) 
			    (shape_info->voidPolyList)
			)) 
		    foreach(poly 
			(axlPolyOperation 
			    list((shape_info->outlinePoly)) void_poly_list 
			    'ANDNOT
			) 
			(result = (axlDBCreateShape poly 
				(shape_info->fillStyle) layer 
				(shape_info->netName)
				(shape_info->parentId)
			    ))
		    ) else
		    (outline_poly = car((axlPolyFromDB rpath))) 
		    if((shape_info->voidPolyList) then 
			foreach(poly 
			    (axlPolyOperation 
				list(outline_poly) 
				(shape_info->voidPolyList) 
				'ANDNOT
			    ) 
			    (result = (axlDBCreateShape poly 
				    (shape_info->fillStyle) layer 
				    (shape_info->netName)
				    (shape_info->parentId)
				))
			) else 
			(result = (axlDBCreateShape outline_poly 
				(shape_info->fillStyle) layer 
				(shape_info->netName)
				(shape_info->parentId)
			    ))
		    )
		)
	    ) 
	    (((shape_info->dataType) == "polygon") 
		(result = (axlDBCreateShape rpath 
			(shape_info->fillStyle) layer nil
			(shape_info->parentId)
		    ))
	    )
	) result
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Cut_By_Box(tmp_path_list user_box trim_to_user_window) 
    let((box_ll box_ur box_path segment_id intersection_list
	    i1 i2 seg_info rpath inside_count
	    outside_count isec_once_count isec_twice_count isec_multi_count segData
	    segDataNew segDataFinal result tmp_seg start_xy
	    end_xy xy_list base_info cleanRecord i_next
	    ready_to_process
	) 
	(cleanRecord = lambda((info) 
		remprop(info 
		    'isClockwise
		) 
		remprop(info 
		    'radius
		) 
		remprop(info 
		    'centerXY
		) 
		remprop(info 
		    'isCircle
		)
	    )) 
	(box_ll = car(user_box)) 
	(box_ur = cadr(user_box)) 
	(rpath = (axlPathStart 
		list((car(box_ll):cadr(box_ll)) 
		    (car(box_ur):cadr(box_ll)) 
		    (car(box_ur):cadr(box_ur)) 
		    (car(box_ll):cadr(box_ur)) 
		    (car(box_ll):cadr(box_ll))
		) 0.0
	    ))
	(result = (axlDBCreatePath rpath 
		(tbx_shapeutils_data->tmpLayer)
	    )) 
	when(result 
	    (box_path = caar(result))
	) 
	(segData = makeTable("seg_data_table" nil)) 
	(inside_count = 0) 
	(outside_count = 0)
	(isec_once_count = 0) 
	(isec_twice_count = 0) 
	(isec_multi_count = 0) 
	(segment_id = 0) 
	foreach(tmp_path tmp_path_list 
	    (tmp_seg = car((tmp_path->segments))) 
	    (segment_id = atoi(((tmp_path->prop)->TBX_SHAPEUTILS_SEGMENT_ID))) 
	    (segData[segment_id] = tmp_seg)
	)
	(segDataNew = makeTable("seg_data_new_table" nil)) 
	(segment_id = 0) 
	for(i 1 
	    length(segData) 
	    (tmp_seg = segData[i]) 
	    (intersection_list = list())
	    (base_info = ncons(nil)) 
	    (base_info->oldId = i) 
	    (base_info->width = (tmp_seg->width)) 
	    (base_info->segType = "line") 
	    (base_info->isRegular = t)
	    (base_info->startXY = car((tmp_seg->startEnd))) 
	    (base_info->endXY = cadr((tmp_seg->startEnd))) 
	    when(((tmp_seg->objType) == "arc") 
		(base_info->segType = "arc") 
		(base_info->radius = (tmp_seg->radius)) 
		(base_info->isClockwise = (tmp_seg->isClockwise)) 
		(base_info->isCircle = (tmp_seg->isCircle))
		(base_info->centerXY = (tmp_seg->xy))
	    ) 
	    if(TBX_SHAPEUTILS_Is_Object_Inside_Box(tmp_seg user_box) then 
		++inside_count else 
		(intersection_list = TBX_SHAPEUTILS_Find_Box_Intersection(tmp_seg box_path))
		(intersection_list = TBX_GEOM_Sort_Intersection(intersection_list base_info "start")) 
		cond((zerop(length(intersection_list)) 
			++outside_count 
			(seg_info = copy(base_info)) 
			(seg_info->startXY = car((tmp_seg->startEnd))) 
			(seg_info->endXY = cadr((tmp_seg->startEnd)))
			(segDataNew[++segment_id] = seg_info)
		    ) 
		    (onep(length(intersection_list)) 
			++isec_once_count 
			(start_xy = car((tmp_seg->startEnd))) 
			(i1 = car(intersection_list)) 
			(end_xy = cadr((tmp_seg->startEnd)))
			(seg_info = copy(base_info)) 
			if(trim_to_user_window then 
			    cond(((axlIsPointInsideBox start_xy user_box) 
				    (seg_info->startXY = i1) 
				    (seg_info->endXY = end_xy) 
				    (segDataNew[++segment_id] = seg_info)
				) 
				((axlIsPointInsideBox end_xy user_box) 
				    (seg_info->startXY = start_xy) 
				    (seg_info->endXY = i1) 
				    (segDataNew[++segment_id] = seg_info)
				)
			    ) else t
			)
		    ) 
		    ((length(intersection_list) == 2) 
			++isec_twice_count 
			(start_xy = car((tmp_seg->startEnd))) 
			(i1 = car(intersection_list)) 
			(i2 = cadr(intersection_list))
			(end_xy = cadr((tmp_seg->startEnd))) 
			if(trim_to_user_window then 
			    if((axlIsPointInsideBox start_xy user_box) then 
				(seg_info = copy(base_info)) 
				(seg_info->startXY = i1) 
				(seg_info->endXY = i2)
				(segDataNew[++segment_id] = seg_info) else 
				if(((base_info->segType) == "line") then 
				    (seg_info = copy(base_info)) 
				    (seg_info->startXY = start_xy) 
				    (seg_info->endXY = end_xy)
				    (segDataNew[++segment_id] = seg_info) else 
				    (seg_info = copy(base_info)) 
				    (seg_info->startXY = start_xy) 
				    (seg_info->endXY = i1)
				    (segDataNew[++segment_id] = seg_info) 
				    (seg_info = copy(base_info)) 
				    (seg_info->startXY = i1) 
				    (seg_info->endXY = i2) 
				    (seg_info->segType = "line")
				    funcall(cleanRecord seg_info) 
				    (segDataNew[++segment_id] = seg_info) 
				    (seg_info = copy(base_info)) 
				    (seg_info->startXY = i2) 
				    (seg_info->endXY = end_xy)
				    (segDataNew[++segment_id] = seg_info)
				)
			    ) else t
			)
		    ) 
		    ((length(intersection_list) > 2) 
			++isec_multi_count 
			(xy_list = cons(car((tmp_seg->startEnd)) intersection_list)) 
			(xy_list = append1(xy_list 
				cadr((tmp_seg->startEnd))
			    )) 
			(start_xy = car(xy_list))
			(end_xy = (lastelem xy_list)) 
			if(trim_to_user_window then 
			    if((axlIsPointInsideBox start_xy user_box) then 
				for(n 0 
				    (length(xy_list) - 2) 
				    cond((zerop(n) t) 
					((n == (length(xy_list) - 2)) 
					    unless((axlIsPointInsideBox end_xy user_box) 
						(seg_info = copy(base_info)) 
						(seg_info->startXY = nth(n xy_list)) 
						(seg_info->endXY = nth((n + 1) xy_list)) 
						(segDataNew[++segment_id] = seg_info)
					    )
					) 
					(zerop(mod(n 2)) 
					    (seg_info = copy(base_info)) 
					    (seg_info->startXY = nth(n xy_list)) 
					    (seg_info->endXY = nth((n + 1) xy_list)) 
					    (seg_info->segType = "line")
					    (segDataNew[++segment_id] = seg_info)
					) 
					(t 
					    (seg_info = copy(base_info)) 
					    (seg_info->startXY = nth(n xy_list)) 
					    (seg_info->endXY = nth((n + 1) xy_list)) 
					    (segDataNew[++segment_id] = seg_info)
					)
				    )
				) else 
				for(n 0 
				    (length(xy_list) - 2) 
				    cond(((n == (length(xy_list) - 2)) 
					    unless((axlIsPointInsideBox end_xy user_box) 
						(seg_info = copy(base_info)) 
						(seg_info->startXY = nth(n xy_list)) 
						(seg_info->endXY = nth((n + 1) xy_list)) 
						(segDataNew[++segment_id] = seg_info)
					    )
					) 
					(zerop(mod(n 2)) 
					    (seg_info = copy(base_info)) 
					    (seg_info->startXY = nth(n xy_list)) 
					    (seg_info->endXY = nth((n + 1) xy_list)) 
					    (segDataNew[++segment_id] = seg_info)
					) 
					(t 
					    (seg_info = copy(base_info)) 
					    (seg_info->startXY = nth(n xy_list)) 
					    (seg_info->endXY = nth((n + 1) xy_list)) 
					    (seg_info->segType = "line")
					    (segDataNew[++segment_id] = seg_info)
					)
				    )
				)
			    ) else t
			)
		    )
		)
	    )
	) 
	(axlDeleteObject box_path) 
	(axlDBRefreshId nil)
	(segDataFinal = makeTable("seg_data_final_table" nil)) 
	(segment_id = 0) 
	for(i 1 
	    length(segDataNew) 
	    if((i == length(segDataNew)) then 
		(i_next = 1) else 
		(i_next = (i + 1))
	    ) 
	    if(((axlGeo2Str 
			(segDataNew[i]->endXY)
		    ) != (axlGeo2Str 
			(segDataNew[i_next]->startXY)
		    )) then 
		(seg_info = copy(segDataNew[i])) 
		(segDataFinal[++segment_id] = seg_info) 
		(seg_info = ncons(nil))
		(seg_info->startXY = (segDataNew[i]->endXY)) 
		(seg_info->endXY = (segDataNew[i_next]->startXY)) 
		(seg_info->segType = "line") 
		(seg_info->isRegular = t) 
		(segDataFinal[++segment_id] = seg_info)
		else 
		(seg_info = copy(segDataNew[i])) 
		(segDataFinal[++segment_id] = seg_info)
	    )
	) 
	for(i 1 
	    length(segDataFinal) 
	    when(((segDataFinal[i]->segType) == "arc") 
		(segDataFinal[i] = TBX_SHAPEUTILS_ADVEDIT_Update_Arc_Angles(segDataFinal[i]))
	    )
	) 
	if(((inside_count > 0) || (isec_once_count > 0) || (isec_twice_count > 0) || (isec_multi_count > 0)) then 
	    (ready_to_process = t) else 
	    (ready_to_process = nil)
	)
	list(ready_to_process segDataFinal)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Cut_By_Pick(segData cur_vertex_id) 
    let((segDataFinal segment_id prev_vertex_id ready_to_process) 
	if(onep(cur_vertex_id) then 
	    (prev_vertex_id = length(segData)) else 
	    (prev_vertex_id = (cur_vertex_id - 1))
	) 
	(segData[prev_vertex_id]->endXY = (segData[cur_vertex_id]->endXY)) 
	(segData[prev_vertex_id]->segType = "line") 
	remprop(segData[prev_vertex_id] 
	    'radius
	)
	remprop(segData[prev_vertex_id] 
	    'centerXY
	) 
	remprop(segData[prev_vertex_id] 
	    'isClockwise
	) 
	remprop(segData[prev_vertex_id] 
	    'isCircle
	) 
	(segData[cur_vertex_id] = nil) 
	(segDataFinal = makeTable("seg_data_final_table" nil))
	(segment_id = 0) 
	for(i 1 
	    length(segData) 
	    when(segData[i] 
		(segDataFinal[++segment_id] = segData[i])
	    )
	) 
	(ready_to_process = t) 
	list(ready_to_process segDataFinal)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Draw_Handle(seg_table group_dbid prop_name msize layer) 
    let((result seg_info circle_dbid tmp_objects seg_cnt
	    pi dx dy handle_x handle_y
	    halfway_angle
	) 
	(pi = (defMathConstants('mymathconst)->PI)) 
	(seg_cnt = 0) 
	case(prop_name 
	    ("TBX_SHAPEUTILS_VERTEX_ID" 
		for(i 1 
		    length(seg_table) 
		    (seg_info = seg_table[i]) 
		    when((seg_info->isRegular) 
			++seg_cnt 
			(result = (axlDBCreateCircle 
				list((seg_info->startXY) msize) 0.0 layer
			    )) 
			when(result 
			    (circle_dbid = caar(result)) 
			    (tmp_objects = cons(circle_dbid tmp_objects)) 
			    (axlDBAddProp circle_dbid 
				list(list(prop_name 
					sprintf(nil "%d" seg_cnt)
				    )
				)
			    ) 
			    (axlDBAddGroupObjects group_dbid circle_dbid)
			)
		    )
		)
	    ) 
	    ("TBX_SHAPEUTILS_ARC_ID" 
		for(i 1 
		    length(seg_table) 
		    (seg_info = seg_table[i]) 
		    when((seg_info->isRegular) 
			++seg_cnt 
			when(((seg_info->segType) == "arc") 
			    if((seg_info->isCircle) then 
				(halfway_angle = ((seg_info->startAngle) + 180.0)) else 
				if((seg_info->isClockwise) then 
				    (halfway_angle = ((seg_info->startAngle) - ((seg_info->sectorAngle) / 2.0))) else 
				    (halfway_angle = ((seg_info->startAngle) + ((seg_info->sectorAngle) / 2.0)))
				)
			    ) 
			    (dx = (cos(((halfway_angle / 360.0) * 2.0 * pi)) * (seg_info->radius))) 
			    (dy = (sin(((halfway_angle / 360.0) * 2.0 * pi)) * (seg_info->radius))) 
			    (handle_x = (car((seg_info->centerXY)) + dx))
			    (handle_y = (cadr((seg_info->centerXY)) + dy)) 
			    (result = (axlDBCreateCircle 
				    list((handle_x:handle_y) msize) 0.0 layer
				)) 
			    when(result 
				(circle_dbid = caar(result)) 
				(tmp_objects = cons(circle_dbid tmp_objects)) 
				(axlDBAddProp circle_dbid 
				    list(list(prop_name 
					    sprintf(nil "%d" seg_cnt)
					)
				    )
				) 
				(axlDBAddGroupObjects group_dbid circle_dbid)
			    )
			)
		    )
		)
	    )
	)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Draw_Secondary_Segment(seg_info) 
    let((rpath result line_cur tmp_seg) 
	if(((seg_info->segType) == "arc") then 
	    if(((seg_info->isCircle) || (seg_info->forceCircle)) then 
		(rpath = (axlPathStartCircle 
			list((seg_info->centerXY) 
			    (seg_info->radius)
			) 0.0
		    )) else 
		(rpath = (axlPathStart 
			list((seg_info->startXY)) 0.0
		    ))
		(rpath = (axlPathArcCenter rpath 0.0 
			(seg_info->endXY) 
			(seg_info->isClockwise)
			(seg_info->centerXY)
		    ))
	    ) else 
	    (rpath = (axlPathStart 
		    list((seg_info->startXY) 
			(seg_info->endXY)
		    ) 0.0
		))
	) 
	(result = (axlDBCreatePath rpath 
		(tbx_shapeutils_data->tmpLayer2)
	    )) 
	when(result 
	    (line_cur = caar(result)) 
	    (tmp_seg = car((line_cur->segments)))
	) tmp_seg
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Edit_Popup(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_SHAPEUTILS_ADVEDIT_Edit_Popup_Done
		    ) 
		    list("Specify Offset" 
			'TBX_SHAPEUTILS_ADVEDIT_Edit_Specify_Offset
		    ) 
		    list("Next" 
			'TBX_SHAPEUTILS_ADVEDIT_Edit_Popup_Next
		    ) 
		    list("Oops" 
			'TBX_SHAPEUTILS_ADVEDIT_Edit_Popup_Oops
		    ) 
		    list("Cancel" 
			'TBX_SHAPEUTILS_ADVEDIT_Edit_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Edit_Popup_Cancel() 
    (axlDBTransactionRollback 
	(tbx_shapeutils_data->transMark)
    ) 
    (axlDBTransactionCommit 
	(tbx_shapeutils_data->transMark)
    ) 
    TBX_SHAPEUTILS_ADVEDIT_Clear_Groups() 
    (axlClearDynamics)
    (axlCancelEnterFun) 
    (axlUIPopupSet nil) 
    TBX_SHAPEUTILS_Shadow_Mode(nil) t
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Edit_Popup_Done() 
    let((group_dbid) 
	(axlDBTransactionCommit 
	    (tbx_shapeutils_data->transMark)
	) 
	(group_dbid = car((axlSelectByName "GROUP" "TBX_SHAPEUTILS_SEGMENT"))) 
	when(group_dbid 
	    (tbx_shapeutils_data->adveditCurSegTable = TBX_SHAPEUTILS_ADVEDIT_Get_Segment_Info((group_dbid->groupMembers))) 
	    TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("final" 
		(tbx_shapeutils_data->adveditCurSegTable) 
		(tbx_shapeutils_data->adveditObjectInfo) 
		(tbx_shapeutils_data->formId)
	    )
	) 
	(axlFinishEnterFun)
	(axlUIPopupSet nil) 
	(axlClearDynamics) 
	TBX_SHAPEUTILS_Shadow_Mode(nil)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Edit_Popup_Next() 
    let((group_dbid) 
	(axlDBTransactionCommit 
	    (tbx_shapeutils_data->transMark)
	) 
	(axlClearDynamics) 
	(axlFinishEnterFun) 
	(axlUIPopupSet nil)
	(group_dbid = car((axlSelectByName "GROUP" "TBX_SHAPEUTILS_SEGMENT"))) 
	when(group_dbid 
	    (tbx_shapeutils_data->adveditCurSegTable = TBX_SHAPEUTILS_ADVEDIT_Get_Segment_Info((group_dbid->groupMembers))) 
	    TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("final" 
		(tbx_shapeutils_data->adveditCurSegTable) 
		(tbx_shapeutils_data->adveditObjectInfo) 
		(tbx_shapeutils_data->formId)
	    )
	) 
	TBX_SHAPEUTILS_Shadow_Mode(nil) 
	(axlShell "tbx shapeutils advedit")
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Edit_Popup_Oops() 
    let((cmd off_x off_y dest_x dest_y
	    group_dbid result
	) 
	when(((axlFormGetField 
		    (tbx_shapeutils_data->formId) "stretch"
		) && ((tbx_shapeutils_data->runTime)->waitForPick)) 
	    (off_x = (axlMKSConvert "1.0 MM" 
		    car((axlDBGetDesignUnits))
		)) 
	    (off_y = 0.0) 
	    (dest_x = (car(((tbx_shapeutils_data->runTime)->sourcePick)) + off_x)) 
	    (dest_y = (cadr(((tbx_shapeutils_data->runTime)->sourcePick)) + off_y))
	    ((tbx_shapeutils_data->runTime)->destinationPick = (dest_x:dest_y)) 
	    (cmd = sprintf(nil "pick %f  %f" dest_x dest_y)) 
	    (axlShell cmd)
	) 
	(result = (axlDBTransactionOops 
		(tbx_shapeutils_data->transMark)
	    )) 
	if(result then 
	    (axlClearDynamics) 
	    (group_dbid = car((axlSelectByName "GROUP" "TBX_SHAPEUTILS_SEGMENT"))) 
	    when(group_dbid 
		(tbx_shapeutils_data->adveditCurSegTable = TBX_SHAPEUTILS_ADVEDIT_Get_Segment_Info((group_dbid->groupMembers))) 
		TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
		    (tbx_shapeutils_data->adveditCurSegTable) 
		    (tbx_shapeutils_data->adveditObjectInfo) 
		    (tbx_shapeutils_data->formId)
		)
	    )
	    (axlVisibleUpdate t) 
	    printf("Pick or drag new window to select\n") else 
	    (axlClearDynamics) 
	    (axlFinishEnterFun)
	    (axlUIPopupSet nil) 
	    TBX_SHAPEUTILS_Shadow_Mode(nil) 
	    (axlVisibleUpdate t) 
	    (axlShell "tbx shapeutils advedit") t
	)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Edit_Shape() 
    let((loop event selected_object bBox start_pick
	    group_dbid seg_id trim_to_user_window result round_off_radius_value
	    id_list eventMask
	) 
	(axlEventSetStartPopup 
	    'TBX_SHAPEUTILS_ADVEDIT_Edit_Popup
	) 
	(loop = t) 
	(eventMask = list('STARTDRAG 
		'STOPDRAG 
		'PICK
	    )) 
	printf("Pick or drag window to select\n")
	while(loop 
	    if((((axlFormGetField 
			    (tbx_shapeutils_data->formId) "stretch"
			) || (axlFormGetField 
			    (tbx_shapeutils_data->formId) "cut"
			)) && (axlFormGetField 
			(tbx_shapeutils_data->formId) "snap_to_grid"
		    )) then 
		(event = (axlEnterEvent eventMask nil t)) else 
		(event = (axlEnterEvent eventMask nil nil))
	    ) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(STARTDRAG t 
		    (axlAddSimpleRbandDynamics 
			(event->xy) "box" ?origin 
			(0.0:0.0)
		    ) 
		    (start_pick = (event->xy))
		) 
		(STOPDRAG 
		    (bBox = list(start_pick 
			    (event->xy)
			)) 
		    if((axlFormGetField 
			    (tbx_shapeutils_data->formId) "trim_to_user_window"
			) then 
			(trim_to_user_window = t) else 
			(trim_to_user_window = nil)
		    ) 
		    (round_off_radius_value = (axlFormGetField 
			    (tbx_shapeutils_data->formId) "round_off_radius_value"
			)) 
		    case(((tbx_shapeutils_data->runTime)->action) 
			("stretch" 
			    unless(((tbx_shapeutils_data->runTime)->waitForPick) 
				(group_dbid = car((axlSelectByName "GROUP" "TBX_SHAPEUTILS_SEGMENT"))) 
				(result = TBX_SHAPEUTILS_ADVEDIT_Stretch_By_Box((group_dbid->groupMembers) bBox trim_to_user_window)) 
				when(car(result) 
				    (axlDBTransactionMark 
					(tbx_shapeutils_data->transMark)
				    ) 
				    (tbx_shapeutils_data->adveditCurSegTable = cadr(result)) 
				    ((tbx_shapeutils_data->runTime)->sourcePick = TBX_SHAPEUTILS_ADVEDIT_Get_Stretch_Dynamic_Origin((tbx_shapeutils_data->adveditCurSegTable))) 
				    ((tbx_shapeutils_data->runTime)->selectType = "box")
				    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
					    (tbx_shapeutils_data->adveditCurSegTable) 
					    (tbx_shapeutils_data->adveditObjectInfo) 
					    (tbx_shapeutils_data->formId)
					)) 
				    TBX_SHAPEUTILS_ADVEDIT_MOVE_Build_Dynamics(((tbx_shapeutils_data->runTime)->sourcePick) 
					((tbx_shapeutils_data->runTime)->selectType)
				    ) 
				    ((tbx_shapeutils_data->runTime)->waitForPick = t) 
				    TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("stretch_wait") 
				    (eventMask = list('PICK))
				    printf("Pick destination\n")
				)
			    )
			) 
			("cut" 
			    (group_dbid = car((axlSelectByName "GROUP" "TBX_SHAPEUTILS_SEGMENT"))) 
			    when(group_dbid 
				(result = TBX_SHAPEUTILS_ADVEDIT_Cut_By_Box((group_dbid->groupMembers) bBox trim_to_user_window)) 
				when(car(result) 
				    (axlDBTransactionMark 
					(tbx_shapeutils_data->transMark)
				    ) 
				    (tbx_shapeutils_data->adveditCurSegTable = cadr(result)) 
				    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
					    (tbx_shapeutils_data->adveditCurSegTable) 
					    (tbx_shapeutils_data->adveditObjectInfo) 
					    (tbx_shapeutils_data->formId)
					))
				)
			    ) 
			    printf("Pick or drag window to select\n")
			) 
			("round_off_vertex" 
			    (group_dbid = car((axlSelectByName "GROUP" "TBX_SHAPEUTILS_SEGMENT"))) 
			    (id_list = TBX_SHAPEUTILS_ADVEDIT_Get_Selected_Object_Ids("vertex" "box" bBox)) 
			    when((group_dbid && id_list) 
				(tbx_shapeutils_data->adveditCurSegTable = TBX_SHAPEUTILS_ADVEDIT_Get_Segment_Info((group_dbid->groupMembers))) 
				(result = TBX_SHAPEUTILS_ADVEDIT_Round_Off_Vertex((tbx_shapeutils_data->adveditCurSegTable) id_list round_off_radius_value)) 
				when(car(result) 
				    (axlDBTransactionMark 
					(tbx_shapeutils_data->transMark)
				    ) 
				    (tbx_shapeutils_data->adveditCurSegTable = cadr(result)) 
				    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
					    (tbx_shapeutils_data->adveditCurSegTable) 
					    (tbx_shapeutils_data->adveditObjectInfo) 
					    (tbx_shapeutils_data->formId)
					))
				)
			    )
			) 
			("change_round_off_vertex" 
			    (group_dbid = car((axlSelectByName "GROUP" "TBX_SHAPEUTILS_SEGMENT"))) 
			    (id_list = TBX_SHAPEUTILS_ADVEDIT_Get_Selected_Object_Ids("arc" "box" bBox)) 
			    when((group_dbid && id_list) 
				(tbx_shapeutils_data->adveditCurSegTable = TBX_SHAPEUTILS_ADVEDIT_Get_Segment_Info((group_dbid->groupMembers))) 
				(result = TBX_SHAPEUTILS_ADVEDIT_Change_Round_Off_Vertex((tbx_shapeutils_data->adveditCurSegTable) id_list round_off_radius_value)) 
				when(car(result) 
				    (axlDBTransactionMark 
					(tbx_shapeutils_data->transMark)
				    ) 
				    (tbx_shapeutils_data->adveditCurSegTable = cadr(result)) 
				    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
					    (tbx_shapeutils_data->adveditCurSegTable) 
					    (tbx_shapeutils_data->adveditObjectInfo) 
					    (tbx_shapeutils_data->formId)
					))
				)
			    )
			)
			("modify_arc" 
			    printf("Warning: Selecting several objects not supported in this mode. Use pick to select an individual segment\n")
			)
		    )
		    (bBox = nil)
		) 
		(PICK 
		    if((axlFormGetField 
			    (tbx_shapeutils_data->formId) "trim_to_user_window"
			) then 
			(trim_to_user_window = t) else 
			(trim_to_user_window = nil)
		    ) 
		    (round_off_radius_value = (axlFormGetField 
			    (tbx_shapeutils_data->formId) "round_off_radius_value"
			)) 
		    case(((tbx_shapeutils_data->runTime)->action) 
			("stretch" 
			    cond((!((tbx_shapeutils_data->runTime)->waitForPick) 
				    (group_dbid = car((axlSelectByName "GROUP" "TBX_SHAPEUTILS_SEGMENT"))) 
				    (id_list = TBX_SHAPEUTILS_ADVEDIT_Get_Selected_Object_Ids("vertex" "pick" 
					    (event->xySnap)
					)) 
				    when((group_dbid && id_list) 
					printf(" Move mode: Selecting user pick %L, waiting for destination pick.........\n" 
					    (event->xy)
					) 
					(axlDBTransactionMark 
					    (tbx_shapeutils_data->transMark)
					) 
					((tbx_shapeutils_data->runTime)->sourcePick = cadar(id_list)) 
					((tbx_shapeutils_data->runTime)->selectType = "pick")
					(tbx_shapeutils_data->adveditCurSegTable = TBX_SHAPEUTILS_ADVEDIT_Get_Segment_Info((group_dbid->groupMembers))) 
					(result = TBX_SHAPEUTILS_ADVEDIT_Stretch_By_Pick((tbx_shapeutils_data->adveditCurSegTable) 
						caar(id_list)
					    )) 
					(tbx_shapeutils_data->adveditCurSegTable = cadr(result)) 
					(tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
						(tbx_shapeutils_data->adveditCurSegTable) 
						(tbx_shapeutils_data->adveditObjectInfo) 
						(tbx_shapeutils_data->formId)
					    )) 
					TBX_SHAPEUTILS_ADVEDIT_MOVE_Build_Dynamics(((tbx_shapeutils_data->runTime)->sourcePick) 
					    ((tbx_shapeutils_data->runTime)->selectType)
					)
					((tbx_shapeutils_data->runTime)->waitForPick = t) 
					TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("stretch_wait") 
					(eventMask = list('PICK)) 
					printf("Pick destination\n")
				    )
				) 
				(((tbx_shapeutils_data->runTime)->waitForPick) 
				    ((tbx_shapeutils_data->runTime)->destinationPick = (event->xySnap)) 
				    (result = TBX_SHAPEUTILS_ADVEDIT_Stretch_Offset_Data(((tbx_shapeutils_data->runTime)->selectType) 
					    (tbx_shapeutils_data->adveditCurSegTable)
					)) 
				    (tbx_shapeutils_data->adveditCurSegTable = cadr(result)) 
				    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
					    (tbx_shapeutils_data->adveditCurSegTable) 
					    (tbx_shapeutils_data->adveditObjectInfo) 
					    (tbx_shapeutils_data->formId)
					))
				    TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("stretch_init") 
				    (tbx_shapeutils_data->runTime = ncons(nil)) 
				    ((tbx_shapeutils_data->runTime)->action = "stretch") 
				    (eventMask = list('STARTDRAG 
					    'STOPDRAG 
					    'PICK
					)) 
				    printf("Pick or drag window to select\n")
				)
			    )
			) 
			("cut" 
			    (group_dbid = car((axlSelectByName "GROUP" "TBX_SHAPEUTILS_SEGMENT"))) 
			    (id_list = TBX_SHAPEUTILS_ADVEDIT_Get_Selected_Object_Ids("vertex" "pick" 
				    (event->xy)
				)) 
			    when((group_dbid && id_list) 
				(axlDBTransactionMark 
				    (tbx_shapeutils_data->transMark)
				) 
				(tbx_shapeutils_data->adveditCurSegTable = TBX_SHAPEUTILS_ADVEDIT_Get_Segment_Info((group_dbid->groupMembers))) 
				(result = TBX_SHAPEUTILS_ADVEDIT_Cut_By_Pick((tbx_shapeutils_data->adveditCurSegTable) 
					caar(id_list)
				    )) 
				(tbx_shapeutils_data->adveditCurSegTable = cadr(result))
				(tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
					(tbx_shapeutils_data->adveditCurSegTable) 
					(tbx_shapeutils_data->adveditObjectInfo) 
					(tbx_shapeutils_data->formId)
				    ))
			    ) 
			    printf("Pick or drag window to select\n")
			) 
			("round_off_vertex" 
			    (group_dbid = car((axlSelectByName "GROUP" "TBX_SHAPEUTILS_SEGMENT"))) 
			    (id_list = TBX_SHAPEUTILS_ADVEDIT_Get_Selected_Object_Ids("vertex" "pick" 
				    (event->xy)
				)) 
			    when(group_dbid 
				(tbx_shapeutils_data->adveditCurSegTable = TBX_SHAPEUTILS_ADVEDIT_Get_Segment_Info((group_dbid->groupMembers))) 
				(result = TBX_SHAPEUTILS_ADVEDIT_Round_Off_Vertex((tbx_shapeutils_data->adveditCurSegTable) id_list round_off_radius_value)) 
				when(car(result) 
				    (axlDBTransactionMark 
					(tbx_shapeutils_data->transMark)
				    ) 
				    (tbx_shapeutils_data->adveditCurSegTable = cadr(result)) 
				    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
					    (tbx_shapeutils_data->adveditCurSegTable) 
					    (tbx_shapeutils_data->adveditObjectInfo) 
					    (tbx_shapeutils_data->formId)
					))
				)
			    ) 
			    printf("Pick or drag window to select\n")
			) 
			("change_round_off_vertex" 
			    (group_dbid = car((axlSelectByName "GROUP" "TBX_SHAPEUTILS_SEGMENT"))) 
			    (id_list = TBX_SHAPEUTILS_ADVEDIT_Get_Selected_Object_Ids("arc" "pick" 
				    (event->xy)
				)) 
			    when((group_dbid && id_list) 
				(tbx_shapeutils_data->adveditCurSegTable = TBX_SHAPEUTILS_ADVEDIT_Get_Segment_Info((group_dbid->groupMembers))) 
				(result = TBX_SHAPEUTILS_ADVEDIT_Change_Round_Off_Vertex((tbx_shapeutils_data->adveditCurSegTable) id_list round_off_radius_value)) 
				when(car(result) 
				    (axlDBTransactionMark 
					(tbx_shapeutils_data->transMark)
				    ) 
				    (tbx_shapeutils_data->adveditCurSegTable = cadr(result)) 
				    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
					    (tbx_shapeutils_data->adveditCurSegTable) 
					    (tbx_shapeutils_data->adveditObjectInfo) 
					    (tbx_shapeutils_data->formId)
					))
				)
			    ) 
			    printf("Pick or drag window to select\n")
			)
			("modify_arc" 
			    cond((!((tbx_shapeutils_data->runTime)->waitForPick) 
				    (group_dbid = car((axlSelectByName "GROUP" "TBX_SHAPEUTILS_SEGMENT"))) 
				    (id_list = TBX_SHAPEUTILS_ADVEDIT_Get_Selected_Object_Ids("arc" "pick" 
					    (event->xySnap)
					)) 
				    when((group_dbid && id_list) 
					(seg_id = caar(id_list)) 
					printf("Modify arc mode.....\n") 
					TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("modify_arc_wait") 
					(tbx_shapeutils_data->adveditCurSegTable = TBX_SHAPEUTILS_ADVEDIT_Get_Segment_Info((group_dbid->groupMembers)))
					(axlDBTransactionMark 
					    (tbx_shapeutils_data->transMark)
					) 
					((tbx_shapeutils_data->adveditCurSegTable)[seg_id]->width = (axlMKSConvert "0.1 MM" 
						car((axlDBGetDesignUnits))
					    )) 
					(axlFormSetField 
					    (tbx_shapeutils_data->formId) "center_x" 
					    car(((tbx_shapeutils_data->adveditCurSegTable)[seg_id]->centerXY))
					) 
					(axlFormSetField 
					    (tbx_shapeutils_data->formId) "center_y" 
					    cadr(((tbx_shapeutils_data->adveditCurSegTable)[seg_id]->centerXY))
					) 
					(axlFormSetField 
					    (tbx_shapeutils_data->formId) "arc_radius" 
					    ((tbx_shapeutils_data->adveditCurSegTable)[seg_id]->radius)
					)
					((tbx_shapeutils_data->runTime)->arcCenterX = car(((tbx_shapeutils_data->adveditCurSegTable)[seg_id]->centerXY))) 
					((tbx_shapeutils_data->runTime)->arcCenterY = cadr(((tbx_shapeutils_data->adveditCurSegTable)[seg_id]->centerXY))) 
					((tbx_shapeutils_data->runTime)->arcRadius = ((tbx_shapeutils_data->adveditCurSegTable)[seg_id]->radius)) 
					((tbx_shapeutils_data->runTime)->arcId = seg_id) 
					(tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
						(tbx_shapeutils_data->adveditCurSegTable) 
						(tbx_shapeutils_data->adveditObjectInfo) 
						(tbx_shapeutils_data->formId)
					    ))
					((tbx_shapeutils_data->runTime)->waitForPick = t) 
					printf("Adjust settings in options panel, use (anywhere) left mouse click to confirm\n")
				    )
				) 
				(((tbx_shapeutils_data->runTime)->waitForPick) 
				    ((tbx_shapeutils_data->adveditCurSegTable)[seg_id]->width = 0.0) 
				    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
					    (tbx_shapeutils_data->adveditCurSegTable) 
					    (tbx_shapeutils_data->adveditObjectInfo) 
					    (tbx_shapeutils_data->formId)
					)) 
				    TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("modify_arc_init") 
				    (tbx_shapeutils_data->runTime = ncons(nil))
				    ((tbx_shapeutils_data->runTime)->action = "modify_arc") 
				    printf("Pick arc to select\n")
				)
			    )
			)
		    )
		) 
		(DONE 
		    (loop = nil)
		)
		(CANCEL 
		    (loop = nil)
		)
	    )
	) 
	(axlEventSetStartPopup) selected_object
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Edit_Specify_Offset() 
    let((offset_str off_x off_y dest_x dest_y
	    arr cmd
	) 
	if(((axlFormGetField 
		    (tbx_shapeutils_data->formId) "stretch"
		) && ((tbx_shapeutils_data->runTime)->waitForPick)) then 
	    (offset_str = (axlEnterString ?prompts 
		    list("Specify X and Y offset:")
		)) 
	    when(offset_str 
		(arr = parseString(offset_str)) 
		if(((length(arr) == 2) && atof(car(arr)) && atof(cadr(arr))) then 
		    (off_x = atof(car(arr))) 
		    (off_y = atof(cadr(arr))) 
		    (dest_x = (car(((tbx_shapeutils_data->runTime)->sourcePick)) + off_x))
		    (dest_y = (cadr(((tbx_shapeutils_data->runTime)->sourcePick)) + off_y)) 
		    (cmd = sprintf(nil "pick %f  %f" dest_x dest_y)) 
		    (axlShell cmd)
		)
	    ) else
	    printf("Function not available in this mode")
	) t
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Filter_Points(isec_list prev_info cur_info radius_value) 
    let((need_angle_filter ref_xy isec_angle vertex_angle angle_diff
	    skip_point isec_list_filtered
	) 
	when(((prev_info->segType) == "arc") 
	    (need_angle_filter = t) 
	    (ref_xy = (prev_info->centerXY))
	) 
	when(((cur_info->segType) == "arc") 
	    (need_angle_filter = t) 
	    (ref_xy = (cur_info->centerXY))
	) 
	foreach(isec isec_list 
	    (skip_point = nil) 
	    when(need_angle_filter 
		(isec_angle = car(TBX_GEOM_Get_Vector_Info(isec ref_xy))) 
		(vertex_angle = car(TBX_GEOM_Get_Vector_Info((cur_info->startXY) ref_xy))) 
		(angle_diff = (round(abs((isec_angle - vertex_angle))) * 1.0)) 
		when(((angle_diff == 180.0) || (angle_diff == 0.0)) 
		    (skip_point = t)
		)
	    ) 
	    when((!skip_point && (atof((axlGeo2Str 
				(axlDistance isec 
				    (cur_info->startXY)
				)
			    )
			) > atof((axlGeo2Str radius_value)))) 
		(isec_list_filtered = cons(isec isec_list_filtered))
	    )
	) isec_list_filtered
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Get_Cute_Angle_Range(cur_seg_info prev_seg_info) 
    let((prev_angle cur_angle prev_angle_inverse angle_diff cute_angle
	    angle_range info arc_is_clockwise
	) 
	(prev_angle = TBX_GEOM_Get_Tangent_Angle(prev_seg_info "end")) 
	(cur_angle = TBX_GEOM_Get_Tangent_Angle(cur_seg_info "start")) 
	(angle_diff = (round((prev_angle - cur_angle)) * 1.0)) 
	when((angle_diff < 0.0) 
	    (angle_diff = (angle_diff + 360.0))
	)
	(prev_angle_inverse = (prev_angle + 180)) 
	when((prev_angle_inverse >= 360.0) 
	    (prev_angle_inverse = (prev_angle_inverse - 360.0))
	) 
	(cute_angle = abs((prev_angle_inverse - cur_angle))) 
	when((cute_angle > 180.0) 
	    (cute_angle = (360.0 - cute_angle))
	) 
	cond(((angle_diff == 0.0) 
		(angle_range = nil)
	    ) 
	    ((angle_diff < 180.0) 
		(angle_range = list(prev_angle_inverse cur_angle)) 
		(arc_is_clockwise = t)
	    ) 
	    ((angle_diff > 180.0) 
		(angle_range = list(cur_angle prev_angle_inverse)) 
		(arc_is_clockwise = nil)
	    ) 
	    ((angle_diff == 180.0) 
		when(((cur_seg_info->segType) == "arc") 
		    if((cur_seg_info->isClockwise) then 
			(cur_angle = (cur_angle - 45.0)) else 
			(cur_angle = (cur_angle + 45.0))
		    )
		) 
		when(((prev_seg_info->segType) == "arc") 
		    if((prev_seg_info->isClockwise) then 
			(prev_angle_inverse = (prev_angle_inverse + 45.0)) else 
			(prev_angle_inverse = (prev_angle_inverse - 45.0))
		    )
		) 
		if((cur_seg_info->isClockwise) then 
		    (angle_range = list(cur_angle prev_angle_inverse)) 
		    (arc_is_clockwise = nil) else
		    (angle_range = list(prev_angle_inverse cur_angle)) 
		    (arc_is_clockwise = t)
		)
	    )
	)
	when((angle_range && (car(angle_range) < 0.0)) 
	    (angle_range = list((car(angle_range) + 360.0) 
		    (cadr(angle_range) + 360.0)
		))
	) 
	when((angle_range && (cadr(angle_range) < car(angle_range))) 
	    (angle_range = list(car(angle_range) 
		    (cadr(angle_range) + 360.0)
		))
	) 
	(info = list(angle_range arc_is_clockwise)) info
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Get_Normal_Projection(pt seg_info pt_on_segment projection_same_angle) 
    let((base_seg tmp_seg tmp_info tmp_angle tmp_x
	    tmp_y isec_list projection_list projection_xy pi
	    pt_angle isec_angle
	) 
	(pi = (defMathConstants('mymathconst)->PI)) 
	if(TBX_GEOM_Point_On_Segment(pt seg_info nil) then 
	    (projection_xy = pt) else 
	    (base_seg = TBX_SHAPEUTILS_ADVEDIT_Draw_Secondary_Segment(seg_info))
	    if(((seg_info->segType) == "arc") then 
		(tmp_info = list(nil 
			'segType "line" 
			'startXY pt
			'endXY 
			(seg_info->centerXY)
		    )) else 
		(tmp_angle = car(TBX_GEOM_Get_Vector_Info((seg_info->endXY) 
			    (seg_info->startXY)
			)
		    ))
		(tmp_angle = (tmp_angle + 90.0)) 
		(tmp_x = (car(pt) + (cos(((tmp_angle / 360.0) * 2 * pi)) * (axlMKSConvert "1.0 MM" 
				car((axlDBGetDesignUnits))
			    )))) 
		(tmp_y = (cadr(pt) + (sin(((tmp_angle / 360.0) * 2 * pi)) * (axlMKSConvert "1.0 MM" 
				car((axlDBGetDesignUnits))
			    )))) 
		(tmp_info = list(nil 
			'segType "line" 
			'startXY pt
			'endXY 
			(tmp_x:tmp_y)
		    ))
	    ) 
	    (tmp_seg = TBX_SHAPEUTILS_ADVEDIT_Draw_Secondary_Segment(tmp_info)) 
	    when(tmp_seg 
		(isec_list = (_axlFindIntersectionPoint base_seg tmp_seg)) 
		when(((seg_info->segType) == "arc") 
		    (pt_angle = car(TBX_GEOM_Get_Vector_Info(pt 
				(seg_info->centerXY)
			    )
			))
		) 
		when(car(isec_list) 
		    foreach(isec isec_list 
			cond((((seg_info->segType) == "arc") 
				(isec_angle = car(TBX_GEOM_Get_Vector_Info(isec 
					    (seg_info->centerXY)
					)
				    )) 
				if(pt_on_segment then 
				    when(TBX_GEOM_Point_On_Segment(isec seg_info t) 
					when(((projection_same_angle && pt_angle && isec_angle && zerop(round(abs((pt_angle - isec_angle))))) || !projection_same_angle) 
					    (projection_list = cons(list((axlDistance isec pt) isec) projection_list))
					)
				    ) else 
				    when(((projection_same_angle && pt_angle && isec_angle && zerop(round(abs((pt_angle - isec_angle))))) || !projection_same_angle) 
					(projection_list = cons(list((axlDistance isec pt) isec) projection_list))
				    )
				)
			    ) 
			    (((seg_info->segType) == "line") 
				when(((pt_on_segment && TBX_GEOM_Point_On_Segment(isec seg_info t)) || 
					!pt_on_segment) 
				    (projection_list = cons(list((axlDistance isec pt) isec) projection_list))
				)
			    )
			)
		    ) 
		    when(projection_list 
			(projection_list = sortcar(projection_list 
				'lessp
			    )) 
			(projection_xy = cadar(projection_list))
		    )
		) 
		(axlDeleteObject 
		    list(base_seg tmp_seg)
		)
	    )
	) projection_xy
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Get_Round_Off_Direction(cur_seg_info prev_seg_info) 
    let((prev_angle cur_angle angle_diff arc_is_clockwise result) 
	(prev_angle = TBX_GEOM_Get_Tangent_Angle(prev_seg_info "end")) 
	(cur_angle = TBX_GEOM_Get_Tangent_Angle(cur_seg_info "start")) 
	(angle_diff = (round((prev_angle - cur_angle)) * 1.0)) 
	when((angle_diff < 0.0) 
	    (angle_diff = (angle_diff + 360.0))
	)
	cond(((angle_diff == 0.0) 
		(result = list(nil nil))
	    ) 
	    ((angle_diff > 180.0) 
		(arc_is_clockwise = nil) 
		(result = list(t arc_is_clockwise))
	    ) 
	    ((angle_diff < 180.0) 
		(arc_is_clockwise = t) 
		(result = list(t arc_is_clockwise))
	    ) 
	    ((angle_diff == 180.0) 
		cond((((cur_seg_info->segType) == "arc") 
			if((cur_seg_info->isClockwise) then 
			    (arc_is_clockwise = nil) else 
			    (arc_is_clockwise = t)
			)
		    ) 
		    (((prev_seg_info->segType) == "arc") 
			if((prev_seg_info->isClockwise) then 
			    (arc_is_clockwise = nil) else 
			    (arc_is_clockwise = t)
			)
		    ) 
		    (t t 
			(result = list(nil nil))
		    )
		) 
		(result = list(t arc_is_clockwise))
	    )
	) result
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Get_Segment_Info(arg_list) 
    let((segData segDataNew seg_info segment_id shape_dbid
	    tmp_path_list tmp_seg a_info
	) 
	(segData = makeTable("seg_data_table" nil)) 
	cond(((((car(arg_list)->objType) == "shape") || ((car(arg_list)->objType) == "polygon")) 
		(shape_dbid = car(arg_list)) 
		(segment_id = 0) 
		foreach(seg 
		    (shape_dbid->segments) 
		    (segData[++segment_id] = seg)
		)
	    ) 
	    (((car(arg_list)->objType) == "path") 
		(tmp_path_list = arg_list) 
		foreach(tmp_path tmp_path_list 
		    (tmp_seg = car((tmp_path->segments))) 
		    (segment_id = atoi(((tmp_path->prop)->TBX_SHAPEUTILS_SEGMENT_ID))) 
		    (segData[segment_id] = tmp_seg)
		)
	    )
	) 
	(segDataNew = makeTable("seg_data_new_table" nil)) 
	for(i 1 
	    length(segData) 
	    (tmp_seg = segData[i]) 
	    (seg_info = ncons(nil))
	    (seg_info->startXY = car((tmp_seg->startEnd))) 
	    (seg_info->endXY = cadr((tmp_seg->startEnd))) 
	    (seg_info->width = (tmp_seg->width)) 
	    (seg_info->isRegular = t) 
	    if(((segData[i]->objType) == "arc") then 
		(seg_info->segType = "arc") 
		(seg_info->centerXY = (tmp_seg->xy)) 
		(seg_info->radius = (tmp_seg->radius))
		(seg_info->isCircle = (tmp_seg->isCircle)) 
		(seg_info->isClockwise = (tmp_seg->isClockwise)) 
		if((seg_info->isCircle) then 
		    (seg_info->startAngle = car(TBX_GEOM_Get_Vector_Info((seg_info->startXY) 
				(seg_info->centerXY)
			    )
			)) 
		    (seg_info->sectorAngle = 360.0) 
		    if((seg_info->isClockwise) then 
			(seg_info->endAngle = ((seg_info->startAngle) - 360.0)) else 
			(seg_info->endAngle = ((seg_info->startAngle) + 360.0))
		    )
		    else 
		    (a_info = TBX_GEOM_Get_Arc_Angles(car((tmp_seg->startEnd)) 
			    cadr((tmp_seg->startEnd)) 
			    (tmp_seg->xy) 
			    (tmp_seg->isClockwise) nil
			)) 
		    (seg_info->startAngle = (a_info->startAngle)) 
		    (seg_info->endAngle = (a_info->endAngle)) 
		    (seg_info->sectorAngle = (a_info->sectorAngle))
		) else 
		(seg_info->segType = "line")
	    )
	    (segDataNew[i] = seg_info)
	)
	segDataNew
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Get_Selected_Object_Ids(obj_type select_type arg) 
    let((group_dbid group_name prop_name obj_id obj_center
	    result_list user_pick user_window
	) 
	cond(((obj_type == "vertex") 
		(group_name = "TBX_SHAPEUTILS_VERTEX") 
		(prop_name = 'TBX_SHAPEUTILS_VERTEX_ID)
	    ) 
	    ((obj_type == "arc") 
		(group_name = "TBX_SHAPEUTILS_ARC") 
		(prop_name = 'TBX_SHAPEUTILS_ARC_ID)
	    )
	) 
	(group_dbid = car((axlSelectByName "GROUP" group_name))) 
	when(group_dbid 
	    foreach(mem 
		(group_dbid->groupMembers) 
		cond(((select_type == "pick") 
			(user_pick = arg) 
			when((axlIsPointInsideBox user_pick 
				(mem->bBox)
			    ) 
			    (obj_id = atoi(get((mem->prop) prop_name))) 
			    (obj_center = (car((mem->segments))->xy)) 
			    (result_list = cons(list(obj_id obj_center) result_list))
			)
		    ) 
		    ((select_type == "box") 
			(user_window = arg) 
			when((axlIsPointInsideBox 
				(car((mem->segments))->xy) user_window
			    ) 
			    (obj_id = atoi(get((mem->prop) prop_name))) 
			    (obj_center = (car((mem->segments))->xy)) 
			    (result_list = cons(list(obj_id obj_center) result_list))
			)
		    )
		)
	    )
	) 
	(result_list = sortcar(result_list 
		'lessp
	    ))
	result_list
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Get_Shape_Info(odbid) 
    let((arr obj_type class_name subclass_name net_name
	    void_poly void_poly_list boundary_poly fill_style obj_parent
	    shape_info void_edit result shape_dbid
	) 
	if(((odbid->objType) == "polygon") then 
	    (obj_type = "polygon") 
	    if((((odbid->parent)->objType) == "shape") then 
		(void_edit = t) 
		if(((odbid->parent)->shapeBoundary) then 
		    (shape_dbid = ((odbid->parent)->shapeBoundary)) else 
		    (shape_dbid = (odbid->parent))
		) 
		(void_poly = car((axlPolyFromDB odbid)))
		foreach(vd 
		    (shape_dbid->voids) 
		    (result = (axlPolyOperation 
			    list(void_poly) 
			    (axlPolyFromDB vd) 
			    'AND
			)) 
		    if(car(result) then t else 
			(void_poly_list = cons(car((axlPolyFromDB vd)) void_poly_list))
		    )
		) 
		(boundary_poly = car((axlPolyFromDB shape_dbid ?holes nil))) else 
		(shape_dbid = odbid) 
		(boundary_poly = car((axlPolyFromDB odbid ?holes nil)))
	    ) else
	    (shape_dbid = odbid) 
	    foreach(vd 
		(shape_dbid->voids) 
		(void_poly_list = cons(car((axlPolyFromDB vd)) void_poly_list))
	    ) 
	    (boundary_poly = car((axlPolyFromDB shape_dbid ?holes nil)))
	) 
	(arr = parseString((shape_dbid->layer) "/")) 
	(class_name = car(arr)) 
	(subclass_name = cadr(arr))
	(net_name = ((shape_dbid->net)->name)) 
	when(((shape_dbid->objType) == "shape") 
	    if((class_name == "BOUNDARY") then 
		(obj_type = "dynamic_shape") 
		(class_name = (axlMapClassName "ETCH")) else
		(obj_type = "static_shape") 
		when(((car(arr) == "ETCH") || (car(arr) == "CONDUCTOR")) 
		    (class_name = (axlMapClassName "ETCH"))
		)
	    ) 
	    (fill_style = (shape_dbid->fill))
	) 
	when((((shape_dbid->parent)->objType) == "symbol") 
	    (obj_parent = (shape_dbid->parent))
	) 
	(shape_info = ncons(nil)) 
	(shape_info->dataType = obj_type)
	(shape_info->netName = net_name) 
	(shape_info->className = class_name) 
	(shape_info->subclassName = subclass_name) 
	(shape_info->parentId = obj_parent) 
	(shape_info->fillStyle = fill_style)
	(shape_info->outlinePoly = boundary_poly) 
	(shape_info->voidPolyList = void_poly_list) 
	(shape_info->voidEdit = void_edit) 
	(shape_info->parentGroups = (shape_dbid->parentGroups)) 
	(axlDeleteObject shape_dbid)
	shape_info shape_info
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Get_Stretch_Dynamic_Origin(seg_table) 
    let((seg_info dyn_cursor_origin) 
	for(i 1 
	    length(seg_table) 
	    (seg_info = seg_table[i]) 
	    when((!dyn_cursor_origin && (seg_info->isDynamic)) 
		(dyn_cursor_origin = (seg_info->startXY))
	    )
	) dyn_cursor_origin
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Init_Secondary_Graphics(shape_info) 
    let((result) 
	when((shape_info->voidEdit) 
	    (result = (axlDBCreateShape 
		    (shape_info->outlinePoly) nil 
		    (tbx_shapeutils_data->tmpLayer2)
		)) 
	    (axlHighlightObject 
		car(result)
	    )
	) 
	foreach(vp 
	    (shape_info->voidPolyList) 
	    (result = (axlDBCreateShape vp nil 
		    (tbx_shapeutils_data->tmpLayer2)
		)) 
	    (axlHighlightObject 
		car(result)
	    )
	)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Init_Temp_Graphics(form_handle) 
    let((layer seg_table tmp_objects result msize
	    rpath seg_dbid seg_info segment_type seg_cnt
	    start_xy end_xy vertex_group_id segment_group_id arc_group_id
	) 
	TBX_SHAPEUTILS_ADVEDIT_Clear_Groups() 
	(msize = (axlFormGetField form_handle "handle_size")) 
	(seg_table = (tbx_shapeutils_data->adveditCurSegTable)) 
	(layer = (tbx_shapeutils_data->tmpLayer))
	(arc_group_id = (axlDBCreateGroup "TBX_SHAPEUTILS_ARC" "generic" nil)) 
	(vertex_group_id = (axlDBCreateGroup "TBX_SHAPEUTILS_VERTEX" "generic" nil)) 
	(segment_group_id = (axlDBCreateGroup "TBX_SHAPEUTILS_SEGMENT" "generic" nil)) 
	cond((((((tbx_shapeutils_data->runTime)->action) == "stretch") || (((tbx_shapeutils_data->runTime)->action) == "cut") || (((tbx_shapeutils_data->runTime)->action) == "round_off_vertex")) 
		TBX_SHAPEUTILS_ADVEDIT_Draw_Handle(seg_table vertex_group_id "TBX_SHAPEUTILS_VERTEX_ID" msize layer)
	    ) 
	    (((((tbx_shapeutils_data->runTime)->action) == "change_round_off_vertex") || (((tbx_shapeutils_data->runTime)->action) == "modify_arc")) 
		TBX_SHAPEUTILS_ADVEDIT_Draw_Handle(seg_table arc_group_id "TBX_SHAPEUTILS_ARC_ID" msize layer)
	    )
	) 
	(tmp_objects = list())
	(seg_cnt = 0) 
	for(i 1 
	    length(seg_table) 
	    (seg_info = seg_table[i]) 
	    (start_xy = (seg_info->startXY))
	    (end_xy = (seg_info->endXY)) 
	    (segment_type = (seg_info->segType)) 
	    cond(((segment_type == "line") 
		    (rpath = (axlPathStart 
			    list(start_xy end_xy) 
			    (seg_info->width)
			))
		) 
		(((segment_type == "arc") && !(seg_info->isCircle)) 
		    (rpath = (axlPathStart 
			    list(start_xy) 
			    (seg_info->width)
			)) 
		    (rpath = (axlPathArcCenter rpath 
			    (seg_info->width) end_xy 
			    (seg_info->isClockwise)
			    (seg_info->centerXY)
			))
		) 
		(((segment_type == "arc") && (seg_info->isCircle)) 
		    (rpath = (axlPathStart 
			    list(start_xy) 
			    (seg_info->width)
			)) 
		    (rpath = (axlPathArcCenter rpath 
			    (seg_info->width) end_xy 
			    (seg_info->isClockwise)
			    (seg_info->centerXY)
			))
		)
	    ) 
	    (result = (axlDBCreatePath rpath layer)) 
	    when(result 
		(seg_dbid = caar(result)) 
		(tmp_objects = cons(seg_dbid tmp_objects)) 
		++seg_cnt 
		(axlDBAddProp seg_dbid 
		    list(list("TBX_SHAPEUTILS_SEGMENT_ID" 
			    sprintf(nil "%d" seg_cnt)
			)
		    )
		)
		(axlDBAddGroupObjects segment_group_id seg_dbid)
	    )
	) 
	(axlDBRefreshId nil) tmp_objects
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_MOVE_Build_Dynamics(dyn_cursor_origin selection_type) 
    let((seg_table seg_info dpath off_x off_y) 
	(seg_table = (tbx_shapeutils_data->adveditCurSegTable)) 
	for(i 1 
	    length(seg_table) 
	    (seg_info = seg_table[i]) 
	    when((seg_info->isDynamic) 
		cond((((seg_info->segType) == "line") 
			(dpath = (axlPathStart 
				list((seg_info->startXY) 
				    (seg_info->endXY)
				) 
				(seg_info->width)
			    ))
		    ) 
		    (((seg_info->segType) == "arc") 
			(dpath = (axlPathStart 
				list((seg_info->startXY)) 
				(seg_info->width)
			    )) 
			(dpath = (axlPathArcCenter dpath 
				(seg_info->width) 
				(seg_info->endXY) 
				(seg_info->isClockwise)
				(seg_info->centerXY)
			    ))
		    )
		) 
		(axlAddSimpleMoveDynamics dyn_cursor_origin dpath "path" ?ref_point
		    (0:0)
		)
	    )
	    when((seg_info->stretchStart) 
		case(selection_type 
		    ("pick" 
			(off_x = 0.0) 
			(off_y = 0.0)
		    ) 
		    ("box" 
			(off_x = (car((seg_info->startXY)) - car(dyn_cursor_origin))) 
			(off_y = (cadr((seg_info->startXY)) - cadr(dyn_cursor_origin)))
		    )
		) 
		(axlAddSimpleRbandDynamics 
		    (seg_info->startXY) "directline" ?origin 
		    (seg_info->startXY)
		    ?var_point 
		    (off_x:off_y)
		)
	    ) 
	    when((seg_info->stretchEnd) 
		case(selection_type 
		    ("pick" 
			(off_x = 0.0) 
			(off_y = 0.0)
		    ) 
		    ("box" 
			(off_x = (car((seg_info->endXY)) - car(dyn_cursor_origin))) 
			(off_y = (cadr((seg_info->endXY)) - cadr(dyn_cursor_origin)))
		    )
		) 
		(axlAddSimpleRbandDynamics 
		    (seg_info->endXY) "directline" ?origin 
		    (seg_info->endXY)
		    ?var_point 
		    (off_x:off_y)
		)
	    )
	) t
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Modify_Arc_Param(form_handle) 
    let((center_x center_y radius result success) 
	(center_x = (axlFormGetField form_handle "center_x")) 
	(center_y = (axlFormGetField form_handle "center_y")) 
	(radius = (axlFormGetField form_handle "arc_radius")) 
	(result = TBX_SHAPEUTILS_ADVEDIT_Modify_Validate_Param((tbx_shapeutils_data->adveditCurSegTable) 
		((tbx_shapeutils_data->runTime)->arcId) center_x center_y radius
	    ))
	if(car(result) then 
	    ((tbx_shapeutils_data->runTime)->arcCenterX = center_x) 
	    ((tbx_shapeutils_data->runTime)->arcCenterY = center_y) 
	    ((tbx_shapeutils_data->runTime)->arcRadius = radius)
	    (tbx_shapeutils_data->adveditCurSegTable = cadr(result)) 
	    (axlDBTransactionMark 
		(tbx_shapeutils_data->transMark)
	    ) 
	    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Update_Graphics("tmp" 
		    (tbx_shapeutils_data->adveditCurSegTable) 
		    (tbx_shapeutils_data->adveditObjectInfo) form_handle
		)) 
	    (success = t) else
	    printf("Invalid params specified. Change settings\n") 
	    (axlFormSetField form_handle "center_x" 
		((tbx_shapeutils_data->runTime)->arcCenterX)
	    ) 
	    (axlFormSetField form_handle "center_y" 
		((tbx_shapeutils_data->runTime)->arcCenterY)
	    ) 
	    (axlFormSetField form_handle "arc_radius" 
		((tbx_shapeutils_data->runTime)->arcRadius)
	    ) 
	    (success = nil)
	) success
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Modify_Validate_Param(segData cur_id center_x center_y radius) 
    let((prev_id next_id prev_info other_id cur_info
	    next_info other_info segDataNew ok_modify result
	    pi new_start_x new_start_y new_start new_end
	    isec_list next_seg prev_seg cur_seg other_seg
	) 
	(pi = (defMathConstants('mymathconst)->PI)) 
	cond(((segData[cur_id]->isCircle) 
		(segData[cur_id]->centerXY = (center_x:center_y)) 
		(segData[cur_id]->radius = radius) 
		(new_start_x = (center_x + (cos((((segData[cur_id]->startAngle) / 360.0) * 2 * pi)) * radius))) 
		(new_start_y = (center_y + (sin((((segData[cur_id]->startAngle) / 360.0) * 2 * pi)) * radius)))
		(segData[cur_id]->startXY = (new_start_x:new_start_y)) 
		(segData[cur_id]->endXY = (new_start_x:new_start_y)) 
		(segDataNew = segData) 
		(ok_modify = t)
	    ) 
	    ((length(segData) == 2) 
		if(onep(cur_id) then 
		    (other_id = 2) else 
		    (other_id = 1)
		) 
		(cur_info = copy(segData[cur_id])) 
		(other_info = copy(segData[other_id])) 
		(cur_info->centerXY = (center_x:center_y))
		(cur_info->radius = radius) 
		(cur_info->forceCircle = t) 
		when(((other_info->segType) == "arc") 
		    (other_info->forceCircle = t)
		) 
		(cur_seg = TBX_SHAPEUTILS_ADVEDIT_Draw_Secondary_Segment(cur_info)) 
		(other_seg = TBX_SHAPEUTILS_ADVEDIT_Draw_Secondary_Segment(other_info))
		(isec_list = (_axlFindIntersectionPoint cur_seg other_seg)) 
		if((length(isec_list) == 2) then 
		    (isec_list = TBX_GEOM_Sort_Intersection(isec_list other_info "end")) 
		    (new_start = car(isec_list)) 
		    (new_end = cadr(isec_list))
		    (segData[cur_id]->startXY = new_start) 
		    (segData[cur_id]->endXY = new_end) 
		    (segData[cur_id]->centerXY = (center_x:center_y)) 
		    (segData[cur_id]->radius = radius) 
		    (segData[other_id]->startXY = new_end)
		    (segData[other_id]->endXY = new_start) 
		    (segDataNew = segData) 
		    (ok_modify = t) 
		    (axlDeleteObject 
			list(cur_seg other_seg)
		    ) else
		    (axlDeleteObject 
			list(cur_seg other_seg)
		    ) 
		    (segDataNew = segData) 
		    (ok_modify = nil)
		)
	    ) 
	    (t 
		if(onep(cur_id) then 
		    (prev_id = length(segData)) else 
		    (prev_id = (cur_id - 1))
		) 
		if((cur_id == length(segData)) then 
		    (next_id = 1) else 
		    (next_id = (cur_id + 1))
		) 
		(prev_info = copy(segData[prev_id])) 
		(cur_info = copy(segData[cur_id]))
		(next_info = copy(segData[next_id])) 
		when(((prev_info->segType) == "arc") 
		    (prev_info->forceCircle = t)
		) 
		when(((next_info->segType) == "arc") 
		    (next_info->forceCircle = t)
		) 
		(cur_info->centerXY = (center_x:center_y)) 
		(cur_info->radius = radius)
		(cur_info->forceCircle = t) 
		(prev_seg = TBX_SHAPEUTILS_ADVEDIT_Draw_Secondary_Segment(prev_info)) 
		(cur_seg = TBX_SHAPEUTILS_ADVEDIT_Draw_Secondary_Segment(cur_info)) 
		(next_seg = TBX_SHAPEUTILS_ADVEDIT_Draw_Secondary_Segment(next_info)) 
		(isec_list = (_axlFindIntersectionPoint prev_seg cur_seg))
		when(car(isec_list) 
		    (isec_list = TBX_GEOM_Sort_Intersection(isec_list prev_info "start")) 
		    when((((axlGeo2Str 
				    car(isec_list)
				) != (axlGeo2Str 
				    (prev_info->startXY)
				)) && ((axlGeo2Str 
				    car(isec_list)
				) != (axlGeo2Str 
				    (prev_info->endXY)
				))) 
			(new_start = car(isec_list))
		    )
		) 
		(isec_list = (_axlFindIntersectionPoint next_seg cur_seg)) 
		when(car(isec_list) 
		    (isec_list = TBX_GEOM_Sort_Intersection(isec_list next_info "end")) 
		    when((((axlGeo2Str 
				    car(isec_list)
				) != (axlGeo2Str 
				    (next_info->startXY)
				)) && ((axlGeo2Str 
				    car(isec_list)
				) != (axlGeo2Str 
				    (next_info->endXY)
				))) 
			(new_end = car(isec_list))
		    )
		) 
		when((new_start && new_end && ((axlGeo2Str new_start) != 
			    (axlGeo2Str new_end))) 
		    (segData[prev_id]->endXY = new_start) 
		    (segData[cur_id]->startXY = new_start) 
		    (segData[cur_id]->endXY = new_end) 
		    (segData[cur_id]->centerXY = (center_x:center_y))
		    (segData[cur_id]->radius = radius) 
		    (segData[next_id]->startXY = new_end) 
		    (segDataNew = segData) 
		    (ok_modify = t)
		) 
		(axlDeleteObject 
		    list(prev_seg cur_seg next_seg)
		)
	    )
	) 
	(result = list(ok_modify segDataNew)) result
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_OpenMinistatus() 
    let((fid FORM_FILE units record) 
	(FORM_FILE = TBX_FORM_Get_Name((tbx_shapeutils_data->licCheck) "shapeutils_advedit_mini")) 
	(fid = (axlMiniStatusLoad 
		gensym("tbxshapeutilsadveditmini") FORM_FILE 
		'TBX_SHAPEUTILS_ADVEDIT_Callback
	    )) 
	(tbx_shapeutils_data->formId = fid) 
	TBX_FORM_Init_Header(fid nil 
	    (tbx_shapeutils_data->licCheck) nil
	)
	(record = "shapeutils|advedit") 
	(units = car((axlDBGetDesignUnits))) 
	(axlFormSetField fid "stretch" 
	    TBX_SESSION_Get_Param(record "stretch" t)
	) 
	(axlFormSetField fid "cut" 
	    TBX_SESSION_Get_Param(record "cut" nil)
	) 
	(axlFormSetField fid "snap_to_grid" 
	    TBX_SESSION_Get_Param(record "snap_to_grid" nil)
	)
	(axlFormSetField fid "trim_to_user_window" 
	    TBX_SESSION_Get_Param(record "trim_to_user_window" t)
	) 
	(axlFormSetField fid "round_off_vertex" 
	    TBX_SESSION_Get_Param(record "round_off_vertex" nil)
	) 
	(axlFormSetField fid "change_round_off_vertex" 
	    TBX_SESSION_Get_Param(record "change_round_off_vertex" nil)
	) 
	(axlFormSetField fid "modify_arc" 
	    TBX_SESSION_Get_Param(record "modify_arc" nil)
	) 
	(axlFormSetField fid "display_skeleton" 
	    TBX_SESSION_Get_Param(record "display_skeleton" nil)
	)
	cond((((units == "microns") || (units == "millimeters") || (units == "centimeters")) 
		(axlFormSetField fid "handle_size" 
		    TBX_SESSION_Get_Param(record "handle_size" 
			(axlMKSConvert "0.123 MM" units) t
		    )
		) 
		(axlFormSetField fid "round_off_radius_value" 
		    TBX_SESSION_Get_Param(record "round_off_radius_value" 
			(axlMKSConvert "1.0 MM" units) t
		    )
		) 
		(axlFormSetField fid "center_x_incr" 
		    TBX_SESSION_Get_Param(record "center_x_incr" 
			(axlMKSConvert "1.0 MM" units) t
		    )
		) 
		(axlFormSetField fid "center_y_incr" 
		    TBX_SESSION_Get_Param(record "center_y_incr" 
			(axlMKSConvert "1.0 MM" units) t
		    )
		)
		(axlFormSetField fid "arc_radius_incr" 
		    TBX_SESSION_Get_Param(record "arc_radius_incr" 
			(axlMKSConvert "1.0 MM" units) t
		    )
		)
	    ) 
	    (t 
		(axlFormSetField fid "handle_size" 
		    TBX_SESSION_Get_Param(record "handle_size" 
			(axlMKSConvert "4.1 MILS" units) t
		    )
		) 
		(axlFormSetField fid "round_off_radius_value" 
		    TBX_SESSION_Get_Param(record "round_off_radius_value" 
			(axlMKSConvert "40.0 MILS" units) t
		    )
		) 
		(axlFormSetField fid "center_x_incr" 
		    TBX_SESSION_Get_Param(record "center_x_incr" 
			(axlMKSConvert "40.0 MILS" units) t
		    )
		) 
		(axlFormSetField fid "center_y_incr" 
		    TBX_SESSION_Get_Param(record "center_y_incr" 
			(axlMKSConvert "40.0 MILS" units) t
		    )
		)
		(axlFormSetField fid "arc_radius_incr" 
		    TBX_SESSION_Get_Param(record "arc_radius_incr" 
			(axlMKSConvert "40.0 MILS" units) t
		    )
		)
	    )
	) 
	cond(((axlFormGetField fid "stretch") 
		((tbx_shapeutils_data->runTime)->action = "stretch") 
		TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("stretch_init")
	    ) 
	    ((axlFormGetField fid "cut") 
		((tbx_shapeutils_data->runTime)->action = "cut") 
		TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("cut")
	    ) 
	    ((axlFormGetField fid "round_off_vertex") 
		((tbx_shapeutils_data->runTime)->action = "round_off_vertex") 
		TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("round_off_vertex")
	    ) 
	    ((axlFormGetField fid "change_round_off_vertex") 
		((tbx_shapeutils_data->runTime)->action = "change_round_off_vertex") 
		TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("change_round_off_vertex")
	    ) 
	    ((axlFormGetField fid "modify_arc") 
		((tbx_shapeutils_data->runTime)->action = "modify_arc_init") 
		TBX_SHAPEUTILS_ADVEDIT_Control_Ministatus("modify_arc_init")
	    )
	) 
	(axlFormDisplay fid) 
	TBX_FORM_Delete((tbx_shapeutils_data->licCheck) FORM_FILE)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Round_Off_Vertex(segData id_list radius_value) 
    let((segDataMod segDataFinal insertAt seg_info segment_id
	    cur_seg_id prev_seg_id prev_end_new cur_start_new isec_list
	    tmp_list new_arc_center result arc_is_clockwise cur_threshold
	    prev_threshold min_threshold cur_info prev_info
	) 
	(segDataMod = makeTable("seg_data_mod_table" nil)) 
	(insertAt = makeTable("insert_at_table" nil)) 
	for(i 1 
	    length(segData) 
	    (segDataMod[i] = copy(segData[i]))
	) 
	foreach(entry id_list 
	    (cur_seg_id = car(entry)) 
	    if(onep(cur_seg_id) then 
		(prev_seg_id = length(segData)) else 
		(prev_seg_id = (cur_seg_id - 1))
	    ) 
	    (cur_info = copy(segDataMod[cur_seg_id]))
	    (prev_info = copy(segDataMod[prev_seg_id])) 
	    if(((prev_info->segType) == "arc") then 
		(prev_threshold = (prev_info->radius)) else 
		(prev_threshold = abs((axlDistance 
			    (prev_info->startXY) 
			    (prev_info->endXY)
			)
		    ))
	    ) 
	    if(((cur_info->segType) == "arc") then 
		(cur_threshold = (cur_info->radius)) else 
		(cur_threshold = abs((axlDistance 
			    (cur_info->startXY) 
			    (cur_info->endXY)
			)
		    ))
	    ) 
	    (min_threshold = min(prev_threshold cur_threshold)) 
	    if((radius_value > min_threshold) then 
		printf("Warning: Radius value too large for selected vertex. Choose a smaller value\n") else 
		(result = TBX_SHAPEUTILS_ADVEDIT_Get_Round_Off_Direction(cur_info prev_info))
		(isec_list = TBX_SHAPEUTILS_ADVEDIT_Calculate_Offset_Intersections(cur_info prev_info radius_value)) 
		(isec_list = TBX_SHAPEUTILS_ADVEDIT_Filter_Points(isec_list prev_info cur_info radius_value)) 
		when((car(result) && isec_list) 
		    (arc_is_clockwise = cadr(result)) 
		    (tmp_list = list()) 
		    (prev_end_new = nil) 
		    (cur_start_new = nil)
		    foreach(isec isec_list 
			(prev_end_new = TBX_SHAPEUTILS_ADVEDIT_Get_Normal_Projection(isec prev_info t t)) 
			(cur_start_new = TBX_SHAPEUTILS_ADVEDIT_Get_Normal_Projection(isec cur_info t t)) 
			when((prev_end_new && cur_start_new) 
			    (tmp_list = cons(list((axlDistance isec 
					    (cur_info->startXY)
					) isec prev_end_new cur_start_new
				    ) tmp_list
				))
			)
		    ) 
		    when(tmp_list 
			(tmp_list = sortcar(tmp_list 
				'lessp
			    )) 
			(result = car(tmp_list)) 
			(new_arc_center = cadr(result)) 
			(prev_end_new = caddr(result))
			(cur_start_new = nth(3 result)) 
			(segDataMod[prev_seg_id]->endXY = prev_end_new) 
			(segDataMod[cur_seg_id]->startXY = cur_start_new) 
			(seg_info = ncons(nil)) 
			(seg_info->width = 0.0)
			(seg_info->segType = "arc") 
			(seg_info->isRegular = t) 
			(seg_info->startXY = prev_end_new) 
			(seg_info->endXY = cur_start_new) 
			(seg_info->radius = radius_value)
			(seg_info->isClockwise = arc_is_clockwise) 
			(seg_info->isCircle = nil) 
			(seg_info->centerXY = new_arc_center) 
			(insertAt[cur_seg_id] = seg_info)
		    )
		)
	    )
	)
	(segDataFinal = makeTable("seg_data_final_table" nil)) 
	(segment_id = 0) 
	for(i 1 
	    length(segDataMod) 
	    when(insertAt[i] 
		(segDataFinal[++segment_id] = TBX_SHAPEUTILS_ADVEDIT_Update_Arc_Angles(insertAt[i]))
	    ) 
	    if(((segDataMod[i]->segType) == "arc") then 
		(segDataFinal[++segment_id] = TBX_SHAPEUTILS_ADVEDIT_Update_Arc_Angles(segDataMod[i])) else 
		(segDataFinal[++segment_id] = copy(segDataMod[i]))
	    )
	) 
	list(t segDataFinal)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Round_To_Database(seg_info) 
    let((start_xy end_xy center_xy) 
	(start_xy = parseString((axlGeo2Str 
		    (seg_info->startXY)
		)
	    )) 
	(end_xy = parseString((axlGeo2Str 
		    (seg_info->endXY)
		)
	    )) 
	(seg_info->startXY = list(atof(car(start_xy)) 
		atof(cadr(start_xy))
	    )) 
	(seg_info->endXY = list(atof(car(end_xy)) 
		atof(cadr(end_xy))
	    ))
	when(((seg_info->segType) == "arc") 
	    (center_xy = parseString((axlGeo2Str 
			(seg_info->centerXY)
		    )
		)) 
	    (seg_info->centerXY = list(atof(car(center_xy)) 
		    atof(cadr(center_xy))
		)) 
	    (seg_info->radius = atof((axlGeo2Str 
			(seg_info->radius)
		    )
		)) 
	    when((seg_info->startAngle) 
		(seg_info->startAngle = atof((axlGeo2Str 
			    (seg_info->startAngle)
			)
		    ))
	    )
	    when((seg_info->endAngle) 
		(seg_info->endAngle = atof((axlGeo2Str 
			    (seg_info->endAngle)
			)
		    ))
	    ) 
	    when((seg_info->sectorAngle) 
		(seg_info->sectorAngle = atof((axlGeo2Str 
			    (seg_info->sectorAngle)
			)
		    ))
	    )
	) seg_info
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Select_Popup(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_SHAPEUTILS_ADVEDIT_Select_Popup_Done
		    ) 
		    list("Cancel" 
			'TBX_SHAPEUTILS_ADVEDIT_Select_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Select_Popup_Cancel() 
    (axlCancelEnterFun) 
    (axlUIPopupSet nil) 
    (axlClearDynamics) 
    TBX_SHAPEUTILS_Shadow_Mode(nil)
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Select_Popup_Done() 
    (axlFinishEnterFun) 
    (axlUIPopupSet nil) 
    (axlClearDynamics) 
    TBX_SHAPEUTILS_Shadow_Mode(nil)
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Select_Shape_or_Void() 
    let((eventMask loop event selected_object ff_enable
	    ff_on record
	) 
	(axlEventSetStartPopup 
	    'TBX_SHAPEUTILS_ADVEDIT_Select_Popup
	) 
	(eventMask = list('PICK)) 
	(loop = t) 
	printf("Pick source shape...\n")
	(axlClearSelSet) 
	(record = "shapeutils|advedit") 
	(ff_enable = TBX_SESSION_Get_Param(record "ff_enable" 
		list("noall" "boundary_shapes" "shapes" "voids")
	    )) 
	(ff_on = TBX_SESSION_Get_Param(record "ff_on" 
		list("all")
	    )) 
	(axlSetFindFilter ?enabled ff_enable ?onButtons ff_on)
	while(loop 
	    (event = (axlEnterEvent eventMask nil nil)) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(PICK 
		    (selected_object = nil) 
		    (axlSingleSelectPoint 
			(event->xy)
		    ) 
		    if((axlGetSelSet) then 
			(selected_object = car((axlGetSelSet))) 
			(axlClearSelSet) 
			(loop = nil)
			(axlFinishEnterFun) 
			(axlUIPopupSet nil) 
			(axlClearDynamics) else 
			printf("Nothing selected\n")
		    )
		) 
		(DONE 
		    (loop = nil) 
		    (axlFinishEnterFun) 
		    (axlClearDynamics)
		) 
		(CANCEL 
		    (loop = nil) 
		    (axlCancelEnterFun) 
		    (axlClearDynamics)
		)
	    )
	) 
	(axlEventSetStartPopup) selected_object
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Stretch_By_Box(tmp_path_list user_box trim_to_user_window) 
    let((box_ll box_ur box_path segment_id intersection_list
	    i1 i2 seg_info rpath inside_count
	    outside_count isec_once_count isec_twice_count isec_multi_count segData
	    segDataNew result tmp_seg start_xy end_xy
	    xy_cnt xy_list first_id last_id base_info
	    ready_to_process
	) 
	(box_ll = car(user_box)) 
	(box_ur = cadr(user_box)) 
	(rpath = (axlPathStart 
		list((car(box_ll):cadr(box_ll)) 
		    (car(box_ur):cadr(box_ll)) 
		    (car(box_ur):cadr(box_ur)) 
		    (car(box_ll):cadr(box_ur)) 
		    (car(box_ll):cadr(box_ll))
		) 0.0
	    )) 
	(result = (axlDBCreatePath rpath 
		(tbx_shapeutils_data->tmpLayer)
	    ))
	when(result 
	    (box_path = caar(result))
	) 
	(segData = makeTable("seg_data_table" nil)) 
	(segDataNew = makeTable("seg_data_new_table" nil)) 
	(inside_count = 0) 
	(outside_count = 0)
	(isec_once_count = 0) 
	(isec_twice_count = 0) 
	(isec_multi_count = 0) 
	foreach(tmp_path tmp_path_list 
	    (tmp_seg = car((tmp_path->segments))) 
	    (segment_id = atoi(((tmp_path->prop)->TBX_SHAPEUTILS_SEGMENT_ID))) 
	    (segData[segment_id] = tmp_seg)
	) 
	(segment_id = 0)
	for(i 1 
	    length(segData) 
	    (tmp_seg = segData[i]) 
	    (intersection_list = list())
	    (base_info = ncons(nil)) 
	    (base_info->oldId = i) 
	    (base_info->width = (tmp_seg->width)) 
	    (base_info->segType = "line") 
	    (base_info->startXY = car((tmp_seg->startEnd)))
	    (base_info->endXY = cadr((tmp_seg->startEnd))) 
	    when(((tmp_seg->objType) == "arc") 
		(base_info->segType = "arc") 
		(base_info->radius = (tmp_seg->radius)) 
		(base_info->isClockwise = (tmp_seg->isClockwise)) 
		(base_info->isCircle = (tmp_seg->isCircle))
		(base_info->centerXY = (tmp_seg->xy))
	    ) 
	    if(TBX_SHAPEUTILS_Is_Object_Inside_Box(tmp_seg user_box) then 
		++inside_count 
		(seg_info = copy(base_info)) 
		(seg_info->startXY = car((tmp_seg->startEnd)))
		(seg_info->endXY = cadr((tmp_seg->startEnd))) 
		(seg_info->isDynamic = t) 
		(segDataNew[++segment_id] = seg_info) else 
		(intersection_list = TBX_SHAPEUTILS_Find_Box_Intersection(tmp_seg box_path))
		(intersection_list = TBX_GEOM_Sort_Intersection(intersection_list base_info "start")) 
		cond((zerop(length(intersection_list)) 
			++outside_count 
			(seg_info = copy(base_info)) 
			(seg_info->startXY = car((tmp_seg->startEnd))) 
			(seg_info->endXY = cadr((tmp_seg->startEnd)))
			(seg_info->isRegular = t) 
			(segDataNew[++segment_id] = seg_info)
		    ) 
		    (onep(length(intersection_list)) 
			++isec_once_count 
			(start_xy = car((tmp_seg->startEnd))) 
			(i1 = car(intersection_list)) 
			(end_xy = cadr((tmp_seg->startEnd)))
			if(trim_to_user_window then 
			    cond(((axlIsPointInsideBox start_xy user_box) 
				    (seg_info = copy(base_info)) 
				    (seg_info->startXY = start_xy) 
				    (seg_info->endXY = i1) 
				    (seg_info->isDynamic = t)
				    (seg_info->stretchEnd = t) 
				    (segDataNew[++segment_id] = seg_info) 
				    (seg_info = copy(base_info)) 
				    (seg_info->startXY = i1) 
				    (seg_info->endXY = end_xy)
				    (seg_info->isRegular = t) 
				    (segDataNew[++segment_id] = seg_info)
				) 
				((axlIsPointInsideBox end_xy user_box) 
				    (seg_info = copy(base_info)) 
				    (seg_info->startXY = start_xy) 
				    (seg_info->endXY = i1) 
				    (seg_info->isRegular = t)
				    (segDataNew[++segment_id] = seg_info) 
				    (seg_info = copy(base_info)) 
				    (seg_info->startXY = i1) 
				    (seg_info->endXY = end_xy) 
				    (seg_info->isDynamic = t)
				    (seg_info->stretchStart = t) 
				    (segDataNew[++segment_id] = seg_info)
				)
			    ) else 
			    if((axlIsPointInsideBox start_xy user_box) then 
				(seg_info = copy(base_info)) 
				(seg_info->startXY = start_xy) 
				(seg_info->endXY = end_xy)
				(seg_info->isDynamic = t) 
				(seg_info->stretchEnd = t) 
				(segDataNew[++segment_id] = seg_info) else 
				(seg_info = copy(base_info))
				(seg_info->startXY = start_xy) 
				(seg_info->endXY = end_xy) 
				(seg_info->isDynamic = t) 
				(seg_info->stretchStart = t) 
				(segDataNew[++segment_id] = seg_info)
			    )
			)
		    ) 
		    ((length(intersection_list) == 2) 
			++isec_twice_count 
			(start_xy = car((tmp_seg->startEnd))) 
			(i1 = car(intersection_list)) 
			(i2 = cadr(intersection_list))
			(end_xy = cadr((tmp_seg->startEnd))) 
			if(trim_to_user_window then 
			    if((axlIsPointInsideBox start_xy user_box) then 
				(seg_info = copy(base_info)) 
				(seg_info->startXY = start_xy) 
				(seg_info->endXY = i1)
				(seg_info->isDynamic = t) 
				(seg_info->stretchEnd = t) 
				(segDataNew[++segment_id] = seg_info) 
				(seg_info = copy(base_info)) 
				(seg_info->startXY = i1)
				(seg_info->endXY = i2) 
				(seg_info->isRegular = t) 
				(segDataNew[++segment_id] = seg_info) 
				(seg_info = copy(base_info)) 
				(seg_info->startXY = i2)
				(seg_info->endXY = end_xy) 
				(seg_info->isDynamic = t) 
				(seg_info->stretchStart = t) 
				(segDataNew[++segment_id] = seg_info) else
				(seg_info = copy(base_info)) 
				(seg_info->startXY = start_xy) 
				(seg_info->endXY = i1) 
				(seg_info->isRegular = t) 
				(segDataNew[++segment_id] = seg_info)
				(seg_info = copy(base_info)) 
				(seg_info->startXY = i1) 
				(seg_info->endXY = i2) 
				(seg_info->isDynamic = t) 
				(seg_info->stretchStart = t)
				(seg_info->stretchEnd = t) 
				(segDataNew[++segment_id] = seg_info) 
				(seg_info = copy(base_info)) 
				(seg_info->startXY = i2) 
				(seg_info->endXY = end_xy)
				(seg_info->isRegular = t) 
				(segDataNew[++segment_id] = seg_info)
			    ) else 
			    if((axlIsPointInsideBox start_xy user_box) then 
				(seg_info = copy(base_info)) 
				(seg_info->startXY = start_xy) 
				(seg_info->endXY = end_xy)
				(seg_info->isDynamic = t) 
				(segDataNew[++segment_id] = seg_info) else 
				(seg_info = copy(base_info)) 
				(seg_info->startXY = start_xy)
				(seg_info->endXY = end_xy) 
				(seg_info->isDynamic = t) 
				(seg_info->stretchStart = t) 
				(seg_info->stretchEnd = t) 
				(segDataNew[++segment_id] = seg_info)
			    )
			)
		    ) 
		    ((length(intersection_list) > 2) 
			++isec_multi_count 
			(xy_list = cons(car((tmp_seg->startEnd)) intersection_list)) 
			(xy_list = append1(xy_list 
				cadr((tmp_seg->startEnd))
			    )) 
			(start_xy = car(xy_list))
			(end_xy = (lastelem xy_list)) 
			(xy_cnt = length(xy_list)) 
			if(trim_to_user_window then 
			    if((axlIsPointInsideBox start_xy user_box) then 
				(first_id = (segment_id + 1)) 
				for(n 0 
				    (xy_cnt - 2) 
				    if(zerop(mod(n 2)) then 
					(seg_info = copy(base_info)) 
					(seg_info->startXY = nth(n xy_list)) 
					(seg_info->endXY = nth((n + 1) xy_list))
					(seg_info->isDynamic = t) 
					(seg_info->stretchStart = t) 
					(seg_info->stretchEnd = t) 
					(segDataNew[++segment_id] = seg_info) else
					(seg_info = copy(base_info)) 
					(seg_info->startXY = nth(n xy_list)) 
					(seg_info->endXY = nth((n + 1) xy_list)) 
					(seg_info->isRegular = t) 
					(segDataNew[++segment_id] = seg_info)
				    )
				) 
				(last_id = segment_id)
				(segDataNew[first_id]->stretchStart = nil) else 
				for(n 0 
				    (xy_cnt - 2) 
				    if(zerop(mod(n 2)) then 
					(seg_info = copy(base_info)) 
					(seg_info->startXY = nth(n xy_list)) 
					(seg_info->endXY = nth((n + 1) xy_list))
					(seg_info->isRegular = t) 
					(segDataNew[++segment_id] = seg_info) else 
					(seg_info = copy(base_info)) 
					(seg_info->startXY = nth(n xy_list))
					(seg_info->endXY = nth((n + 1) xy_list)) 
					(seg_info->isDynamic = t) 
					(seg_info->stretchStart = t) 
					(seg_info->stretchEnd = t) 
					(segDataNew[++segment_id] = seg_info)
				    )
				) 
				(last_id = segment_id) 
				when((axlIsPointInsideBox 
					(segDataNew[last_id]->endXY) user_box
				    ) 
				    (segDataNew[last_id]->stretchEnd = nil)
				)
			    ) else 
			    (seg_info = copy(base_info))
			    (seg_info->startXY = start_xy) 
			    (seg_info->endXY = end_xy) 
			    (seg_info->isDynamic = t) 
			    (seg_info->stretchStart = t) 
			    (seg_info->stretchEnd = t)
			    when((axlIsPointInsideBox start_xy user_box) 
				(seg_info->stretchStart = nil)
			    ) 
			    when((axlIsPointInsideBox end_xy user_box) 
				(seg_info->stretchEnd = nil)
			    ) 
			    (segDataNew[++segment_id] = seg_info)
			)
		    )
		)
	    )
	) 
	(axlDeleteObject box_path) 
	(axlDBRefreshId nil) 
	for(i 1 
	    length(segDataNew) 
	    when(((segDataNew[i]->segType) == "arc") 
		(segDataNew[i] = TBX_SHAPEUTILS_ADVEDIT_Update_Arc_Angles(segDataNew[i]))
	    )
	) 
	if(((inside_count > 0) || (isec_once_count > 0) || (isec_twice_count > 0) || (isec_multi_count > 0)) then 
	    (ready_to_process = t) else 
	    (ready_to_process = nil)
	)
	list(ready_to_process segDataNew)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Stretch_By_Pick(segData cur_vertex_id) 
    let((prev_vertex_id cleanRecord ready_to_process) 
	(cleanRecord = lambda((info) 
		remprop(info 
		    'isClockwise
		) 
		remprop(info 
		    'radius
		) 
		remprop(info 
		    'centerXY
		) 
		remprop(info 
		    'isCircle
		)
	    )) 
	if(onep(cur_vertex_id) then 
	    (prev_vertex_id = length(segData)) else 
	    (prev_vertex_id = (cur_vertex_id - 1))
	) 
	(segData[prev_vertex_id]->segType = "line") 
	(segData[prev_vertex_id]->isRegular = nil)
	(segData[prev_vertex_id]->stretchStart = t) 
	funcall(cleanRecord 
	    segData[prev_vertex_id]
	) 
	(segData[cur_vertex_id]->segType = "line") 
	(segData[cur_vertex_id]->isRegular = nil) 
	(segData[cur_vertex_id]->stretchEnd = t)
	funcall(cleanRecord 
	    segData[cur_vertex_id]
	) 
	(ready_to_process = t) 
	list(ready_to_process segData)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Stretch_Offset_Data(mode seg_table) 
    let((segDataNew seg_info dyn_off_x dyn_off_y dyn_off_xy
	    cnt add_info addOffset cleanRecord new_end
	    new_start new_center tmp_info ready_to_process
	) 
	(addOffset = lambda((xy off_xy) 
		let((new_x new_y) 
		    (new_x = (car(xy) + car(off_xy))) 
		    (new_y = (cadr(xy) + cadr(off_xy))) 
		    (new_x:new_y)
		)
	    )) 
	(cleanRecord = lambda((info) 
		remprop(info 
		    'isClockwise
		) 
		remprop(info 
		    'radius
		) 
		remprop(info 
		    'centerXY
		) 
		remprop(info 
		    'isCircle
		)
	    )) 
	(segDataNew = makeTable("seg_data_new_table" nil)) 
	(cnt = 0)
	when((((tbx_shapeutils_data->runTime)->sourcePick) && ((tbx_shapeutils_data->runTime)->destinationPick)) 
	    (dyn_off_x = (car(((tbx_shapeutils_data->runTime)->destinationPick)) - car(((tbx_shapeutils_data->runTime)->sourcePick)))) 
	    (dyn_off_y = (cadr(((tbx_shapeutils_data->runTime)->destinationPick)) - cadr(((tbx_shapeutils_data->runTime)->sourcePick)))) 
	    (dyn_off_xy = (dyn_off_x:dyn_off_y))
	) 
	cond(((mode == "pick") 
		for(i 1 
		    length(seg_table) 
		    (seg_info = copy(seg_table[i])) 
		    when((seg_table[i]->stretchStart) 
			(seg_info->startXY = (seg_info->startXY)) 
			(seg_info->endXY = funcall(addOffset 
				(seg_info->endXY) dyn_off_xy
			    )) 
			(seg_info->segType = "line") 
			(seg_info->isDynamic = nil)
			(seg_info->isRegular = t) 
			funcall(cleanRecord seg_info)
		    )
		    when((seg_table[i]->stretchEnd) 
			(seg_info->startXY = funcall(addOffset 
				(seg_info->startXY) dyn_off_xy
			    )) 
			(seg_info->endXY = (seg_info->endXY)) 
			(seg_info->segType = "line") 
			(seg_info->isDynamic = nil)
			(seg_info->isRegular = t) 
			funcall(cleanRecord seg_info)
		    ) 
		    (segDataNew[++cnt] = seg_info)
		)
	    ) 
	    ((mode == "box") 
		for(i 1 
		    length(seg_table) 
		    (seg_info = seg_table[i]) 
		    if((seg_info->isDynamic) then 
			(new_start = funcall(addOffset 
				(seg_info->startXY) dyn_off_xy
			    )) 
			(new_end = funcall(addOffset 
				(seg_info->endXY) dyn_off_xy
			    )) 
			when(((seg_info->segType) == "arc") 
			    (new_center = funcall(addOffset 
				    (seg_info->centerXY) dyn_off_xy
				))
			)
			when((seg_info->stretchStart) 
			    (tmp_info = copy(seg_info)) 
			    (tmp_info->startXY = (seg_info->startXY)) 
			    (tmp_info->endXY = new_start) 
			    (tmp_info->segType = "line")
			    (tmp_info->isDynamic = nil) 
			    (tmp_info->isRegular = t) 
			    funcall(cleanRecord tmp_info) 
			    (segDataNew[++cnt] = tmp_info)
			) 
			(tmp_info = copy(seg_info)) 
			(tmp_info->startXY = new_start) 
			(tmp_info->endXY = new_end) 
			(tmp_info->isDynamic = nil)
			(tmp_info->isRegular = t) 
			when(((seg_info->segType) == "arc") 
			    (tmp_info->centerXY = new_center)
			) 
			(segDataNew[++cnt] = tmp_info) 
			when((seg_info->stretchEnd) 
			    (tmp_info = copy(seg_info)) 
			    (tmp_info->startXY = new_end) 
			    (tmp_info->endXY = (seg_info->endXY)) 
			    (tmp_info->segType = "line")
			    (tmp_info->isDynamic = nil) 
			    (tmp_info->isRegular = t) 
			    funcall(cleanRecord tmp_info) 
			    (segDataNew[++cnt] = tmp_info)
			) else
			(tmp_info = copy(seg_info)) 
			(segDataNew[++cnt] = tmp_info)
		    )
		)
	    )
	) 
	for(i 1 
	    length(segDataNew) 
	    when(((segDataNew[i]->segType) == "arc") 
		(add_info = TBX_GEOM_Get_Arc_Angles((segDataNew[i]->startXY) 
			(segDataNew[i]->endXY) 
			(segDataNew[i]->centerXY) 
			(segDataNew[i]->isClockwise) nil
		    )) 
		(segDataNew[i]->startAngle = (add_info->startAngle)) 
		(segDataNew[i]->endAngle = (add_info->endAngle)) 
		(segDataNew[i]->sectorAngle = (add_info->sectorAngle))
	    )
	) 
	(ready_to_process = t) 
	list(ready_to_process segDataNew)
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Update_Arc_Angles(seg_info) 
    let((add_info) 
	(seg_info = copy(seg_info)) 
	(add_info = TBX_GEOM_Get_Arc_Angles((seg_info->startXY) 
		(seg_info->endXY) 
		(seg_info->centerXY) 
		(seg_info->isClockwise) nil
	    )) 
	(seg_info->startAngle = (add_info->startAngle)) 
	(seg_info->endAngle = (add_info->endAngle))
	(seg_info->sectorAngle = (add_info->sectorAngle)) seg_info
    )
)
procedure(TBX_SHAPEUTILS_ADVEDIT_Update_Graphics(mode seg_table shape_info form_handle) 
    let((layer tmp_objects result rpath seg_dbid
	    seg_info seg_cnt start_xy end_xy segment_group_id
	    vertex_group_id arc_group_id msize o_shape
	) 
	TBX_SHAPEUTILS_ADVEDIT_Clear_Groups() 
	(msize = (axlFormGetField form_handle "handle_size")) 
	if((mode == "tmp") then 
	    (layer = (tbx_shapeutils_data->tmpLayer)) 
	    (arc_group_id = (axlDBCreateGroup "TBX_SHAPEUTILS_ARC" "generic" nil)) 
	    (vertex_group_id = (axlDBCreateGroup "TBX_SHAPEUTILS_VERTEX" "generic" nil))
	    (segment_group_id = (axlDBCreateGroup "TBX_SHAPEUTILS_SEGMENT" "generic" nil)) else 
	    if(((shape_info->dataType) == "dynamic_shape") then 
		(layer = strcat("BOUNDARY/" 
			(shape_info->subclassName)
		    )) else 
		(layer = strcat((shape_info->className) "/" 
			(shape_info->subclassName)
		    ))
	    )
	) 
	(seg_cnt = 0)
	(tmp_objects = list()) 
	(axlClearDynamics) 
	when((mode == "tmp") 
	    cond((((((tbx_shapeutils_data->runTime)->action) == "stretch") || (((tbx_shapeutils_data->runTime)->action) == "cut") || (((tbx_shapeutils_data->runTime)->action) == "round_off_vertex")) 
		    TBX_SHAPEUTILS_ADVEDIT_Draw_Handle(seg_table vertex_group_id "TBX_SHAPEUTILS_VERTEX_ID" msize layer)
		) 
		(((((tbx_shapeutils_data->runTime)->action) == "change_round_off_vertex") || (((tbx_shapeutils_data->runTime)->action) == "modify_arc")) 
		    TBX_SHAPEUTILS_ADVEDIT_Draw_Handle(seg_table arc_group_id "TBX_SHAPEUTILS_ARC_ID" msize layer)
		)
	    )
	) 
	for(i 1 
	    length(seg_table) 
	    (seg_info = seg_table[i]) 
	    (start_xy = (seg_info->startXY))
	    (end_xy = (seg_info->endXY)) 
	    cond(((mode == "final") 
		    (tmp_objects = nil) 
		    unless(rpath 
			(rpath = (axlPathStart 
				list(start_xy) 0.0
			    ))
		    ) 
		    cond((((seg_info->segType) == "line") 
			    (rpath = (axlPathLine rpath 0.0 end_xy))
			) 
			(((seg_info->segType) == "arc") 
			    if((seg_info->centerXY) then 
				(rpath = (axlPathArcCenter rpath 0.0 end_xy 
					(seg_info->isClockwise)
					(seg_info->centerXY)
				    )) else 
				(rpath = (axlPathArcRadius rpath 0.0 
					(seg_info->endXY) 
					(seg_info->isClockwise)
					nil 
					(seg_info->radius)
				    ))
			    )
			)
		    )
		) 
		(((mode == "tmp") && (seg_info->isRegular)) 
		    cond((((seg_info->segType) == "line") 
			    (rpath = (axlPathStart 
				    list(start_xy end_xy) 
				    (seg_info->width)
				))
			) 
			(((seg_info->segType) == "arc") 
			    (rpath = (axlPathStart 
				    list(start_xy) 
				    (seg_info->width)
				)) 
			    if((seg_info->centerXY) then 
				(rpath = (axlPathArcCenter rpath 
					(seg_info->width) end_xy 
					(seg_info->isClockwise)
					(seg_info->centerXY)
				    )) else 
				(rpath = (axlPathArcRadius rpath 
					(seg_info->width) 
					(seg_info->endXY) 
					(seg_info->isClockwise)
					nil 
					(seg_info->radius)
				    ))
			    )
			)
		    ) 
		    (result = (axlDBCreatePath rpath layer)) 
		    when(result 
			(seg_dbid = caar(result)) 
			(tmp_objects = cons(seg_dbid tmp_objects)) 
			++seg_cnt 
			(axlDBAddProp seg_dbid 
			    list(list("TBX_SHAPEUTILS_SEGMENT_ID" 
				    sprintf(nil "%d" seg_cnt)
				)
			    )
			)
			(axlDBAddGroupObjects segment_group_id seg_dbid)
		    )
		)
	    )
	) 
	when((mode == "final") 
	    (result = TBX_SHAPEUTILS_ADVEDIT_Create_Shape(rpath layer shape_info)) 
	    if(result then 
		(tmp_objects = nil) 
		foreach(grp 
		    (shape_info->parentGroups) 
		    (axlDBAddGroupObjects grp 
			car(result)
		    )
		) else
		(axlUIConfirm "Warning: Shape could not have been generated.\nRestoring original shape.") 
		(o_shape = (axlDBCreateOpenShape 
			(shape_info->outlinePoly) 
			(shape_info->fillStyle) layer 
			(shape_info->netName)
			(shape_info->parentId)
		    )) 
		foreach(vp 
		    (shape_info->voidPolyList) 
		    (axlDBCreateVoid o_shape vp)
		) 
		(axlDBCreateCloseShape o_shape)
	    )
	)
	(axlDBRefreshId nil) tmp_objects
    )
)
procedure(TBX_SHAPEUTILS_Boolean_Break_Poly(poly_a poly_b tmp_layer) 
    let((poly_a_ll poly_a_ur poly_b_ll poly_b_ur rpath
	    cut_x cut_y_bot cut_y_top poly_list cut_y
	    cut_x_left cut_x_right result line_dbid width
	    height
	) 
	(poly_a_ll = car((poly_a->bBox))) 
	(poly_a_ur = cadr((poly_a->bBox))) 
	(poly_b_ll = car((poly_b->bBox))) 
	(poly_b_ur = cadr((poly_b->bBox)))
	(width = abs((car(poly_b_ur) - car(poly_b_ll)))) 
	(height = abs((cadr(poly_b_ur) - cadr(poly_b_ll)))) 
	if(t then 
	    (cut_x = (car(poly_b_ll) + (width / 2.0))) 
	    (cut_y_bot = (cadr(poly_a_ll) - (axlMKSConvert "0.1 MM" 
			car((axlDBGetDesignUnits))
		    ))) 
	    (cut_y_top = (cadr(poly_a_ur) + (axlMKSConvert "0.1 MM" 
			car((axlDBGetDesignUnits))
		    )))
	    (rpath = (axlPathStart 
		    list((cut_x:cut_y_bot) 
			(cut_x:cut_y_top)
		    ) 0.0
		)) else 
	    (cut_y = (cadr(poly_b_ll) + (height / 2.0))) 
	    (cut_x_left = (car(poly_a_ll) - (axlMKSConvert "0.1 MM" 
			car((axlDBGetDesignUnits))
		    ))) 
	    (cut_x_right = (car(poly_a_ur) + (axlMKSConvert "0.1 MM" 
			car((axlDBGetDesignUnits))
		    )))
	    (rpath = (axlPathStart 
		    list((cut_x_left:cut_y) 
			(cut_x_right:cut_y)
		    ) 0.0
		))
	) 
	(result = (axlDBCreatePath rpath tmp_layer)) 
	when(result 
	    (line_dbid = caar(result)) 
	    (poly_list = (axlPolyOperation poly_a 
		    car((axlPolyFromDB line_dbid)) 
		    'ANDNOT
		))
	)
	poly_list
    )
)
procedure(TBX_SHAPEUTILS_Boolean_Cache_Param(form_handle) 
    let((rec session_param) 
	(rec = "shapeutils|boolean") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "or_operation") 
	    stringToSymbol("or_operation")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "and_operation") 
	    stringToSymbol("and_operation")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "andnot_operation") 
	    stringToSymbol("andnot_operation")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "xor_operation") 
	    stringToSymbol("xor_operation")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "shape_mode") 
	    stringToSymbol("shape_mode")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "oversize_first") 
	    stringToSymbol("oversize_first")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "oversize_second") 
	    stringToSymbol("oversize_second")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "break_poly") 
	    stringToSymbol("break_poly")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "copy_result") 
	    stringToSymbol("copy_result")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "class") 
	    stringToSymbol("class")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "subclass") 
	    stringToSymbol("subclass")
	)
	putprop(session_param[rec] 
	    (axlDBControl 
		'activeLayer
	    ) 
	    stringToSymbol("active_layer")
	) 
	putprop(session_param[rec] 
	    car((axlDBGetDesignUnits)) 
	    stringToSymbol("units")
	) t
    )
)
procedure(TBX_SHAPEUTILS_Boolean_Callback(form_handle) 
    case((form_handle->curField) 
	("shape_mode" t) 
	("copy_result" 
	    if((form_handle->curValue) then 
		(axlFormSetFieldEditable form_handle "class" t) 
		(axlFormSetFieldEditable form_handle "subclass" t) 
		(axlFormSetFieldEditable form_handle "subcolor" t)
		(axlFormSetFieldEditable form_handle "toggle_destination_layer" t) else 
		(axlFormSetFieldEditable form_handle "class" nil) 
		(axlFormSetFieldEditable form_handle "subclass" nil) 
		(axlFormSetFieldEditable form_handle "subcolor" nil)
		(axlFormSetFieldEditable form_handle "toggle_destination_layer" nil)
	    )
	) 
	("toggle_destination_layer" 
	    if(!(tbx_shapeutils_data->visList) then 
		(tbx_shapeutils_data->visList = (axlVisibleGet)) 
		(axlVisibleDesign nil) 
		(axlFormSetField form_handle "subcolor" t)
		(axlVisibleLayer 
		    (axlDBControl 
			'activeLayer
		    ) t
		) else 
		(axlFormSetField form_handle "subcolor" nil) 
		(axlVisibleSet 
		    (tbx_shapeutils_data->visList)
		) 
		(tbx_shapeutils_data->visList = nil)
	    ) 
	    (axlVisibleUpdate t)
	)
    )
)
procedure(TBX_SHAPEUTILS_Boolean_Check_Overlap(poly_a poly_b) 
    let((return_value result_AND result_ANDNOT) 
	(result_AND = car((axlPolyOperation poly_a poly_b 
		    'AND
		)
	    )) 
	when(result_AND 
	    (return_value = "partial") 
	    (result_ANDNOT = car((axlPolyOperation poly_b poly_a 
			'ANDNOT
		    )
		)) 
	    unless(result_ANDNOT 
		(return_value = "full")
	    )
	) return_value
    )
)
procedure(TBX_SHAPEUTILS_Boolean_Get_Object_Info(odbid oversize) 
    let((arr obj_type class_name subclass_name net_name
	    info shape_fill shape_parent layer_display
	) 
	cond(((((odbid->objType) == "shape") || ((odbid->objType) == "polygon")) 
		(arr = parseString((odbid->layer) "/")) 
		(subclass_name = cadr(arr)) 
		if((car(arr) == "BOUNDARY") then 
		    (obj_type = "dynamic_shape") 
		    (class_name = (axlMapClassName "BOUNDARY")) 
		    (layer_display = strcat((axlMapClassName "ETCH") "/" subclass_name))
		    else 
		    (obj_type = "static_shape") 
		    if(((car(arr) == "ETCH") || (car(arr) == "CONDUCTOR")) then 
			(class_name = (axlMapClassName "ETCH")) else 
			(class_name = car(arr))
		    ) 
		    (layer_display = strcat(class_name "/" subclass_name))
		) 
		if((odbid->net) then 
		    (net_name = ((odbid->net)->name)) else 
		    (net_name = nil)
		)
		(shape_fill = (odbid->fill)) 
		when(((type(shape_fill) == 'list) && (length(shape_fill) >= 1)) 
		    printf("Warning: Boolean operations not supported for hatch shapes. Changing type to solid filled\n") 
		    (shape_fill = t)
		) 
		if((((odbid->parent)->objType) == "symbol") then 
		    (shape_parent = (odbid->parent)) else 
		    (shape_parent = nil)
		) 
		(info = ncons(nil)) 
		(info->objType = obj_type)
		(info->className = class_name) 
		(info->subclassName = subclass_name) 
		(info->layerDisplay = layer_display) 
		(info->netName = net_name) 
		(info->polyData = (axlPolyFromDB odbid ?holes t))
		(info->polyDataBoundary = (axlPolyFromDB odbid ?holes nil)) 
		(info->fillStyle = shape_fill) 
		(info->parent = shape_parent) 
		(info->parentGroups = (odbid->parentGroups))
	    ) 
	    (((odbid->objType) == "path") 
		(info = ncons(nil)) 
		(info->objType = "path") 
		(info->layerDisplay = (odbid->layer)) 
		(info->polyData = TBX_DBCORE_Poly_From_Line((odbid->segments) t 
			'ROUND
		    ))
		(info->polyDataBoundary = (info->polyData))
	    ) 
	    ((((odbid->objType) == "line") || ((odbid->objType) == "arc")) 
		(info = ncons(nil)) 
		(info->objType = (odbid->objType)) 
		(info->layerDisplay = (odbid->layer)) 
		(info->polyData = TBX_DBCORE_Poly_From_Line(list(odbid) t 
			'ROUND
		    ))
		(info->polyDataBoundary = (info->polyData))
	    ) 
	    (((odbid->objType) == "text") 
		if((((axlGetParam 
				strcat("paramTextBlock:" 
				    (odbid->textBlock)
				)
			    )->photoWidth) > 0.0) then 
		    (info = ncons(nil)) 
		    (info->objType = "text") 
		    (info->layerDisplay = (odbid->layer))
		    (info->polyData = TBX_DBCORE_Poly_From_Text(odbid 
			    (tbx_shapeutils_data->tmpLayer)
			)) 
		    (info->polyDataBoundary = (info->polyData)) else 
		    printf("Warning: Photo width must be greater than 0.0, pick second object again")
		)
	    ) 
	    ((((odbid->objType) == "pin") || ((odbid->objType) == "via")) 
		(info = ncons(nil)) 
		(info->objType = (odbid->objType)) 
		(info->layerDisplay = nil) 
		(info->polyData = TBX_DBCORE_Poly_From_Padstack(odbid))
		(info->polyDataBoundary = (info->polyData))
	    )
	) 
	when((info->polyData) 
	    (info->polyData = (axlPolyExpand 
		    (info->polyData) oversize 
		    'NONE
		))
	) 
	when((info->polyDataBoundary) 
	    (info->polyDataBoundary = (axlPolyExpand 
		    (info->polyDataBoundary) oversize 
		    'NONE
		))
	) info
    )
)
procedure(TBX_SHAPEUTILS_Boolean_OpenMinistatus() 
    let((fid FORM_FILE record design_units) 
	(FORM_FILE = TBX_FORM_Get_Name((tbx_shapeutils_data->licCheck) "shapeutils_boolean_mini")) 
	(fid = (axlMiniStatusLoad 
		gensym("tbxshapeutilsbooleanmini") FORM_FILE 
		'TBX_SHAPEUTILS_Boolean_Callback
	    )) 
	(tbx_shapeutils_data->formId = fid) 
	(record = "shapeutils|boolean")
	(design_units = car((axlDBGetDesignUnits))) 
	TBX_FORM_Init_Header(fid nil 
	    (tbx_shapeutils_data->licCheck) nil
	) 
	(axlFormSetField fid "or_operation" 
	    TBX_SESSION_Get_Param(record "or_operation" t)
	) 
	(axlFormSetField fid "and_operation" 
	    TBX_SESSION_Get_Param(record "and_operation" nil)
	) 
	(axlFormSetField fid "andnot_operation" 
	    TBX_SESSION_Get_Param(record "andnot_operation" nil)
	)
	(axlFormSetField fid "xor_operation" 
	    TBX_SESSION_Get_Param(record "xor_operation" nil)
	) 
	(axlFormSetField fid "oversize_first" 
	    TBX_SESSION_Get_Param(record "oversize_first" 
		(axlMKSConvert "0.0 MM" design_units) t
	    )
	) 
	(axlFormSetField fid "oversize_second" 
	    TBX_SESSION_Get_Param(record "oversize_second" 
		(axlMKSConvert "0.0 MM" design_units) t
	    )
	) 
	(axlFormSetField fid "shape_mode" 
	    TBX_SESSION_Get_Param(record "shape_mode" "include_manual_voids")
	) 
	(axlFormSetField fid "break_poly" 
	    TBX_SESSION_Get_Param(record "shape_mode" nil)
	)
	(axlFormSetField fid "copy_result" 
	    TBX_SESSION_Get_Param(record "copy_result" nil)
	) 
	(axlDBControl 
	    'activeLayer 
	    TBX_SESSION_Get_Param(record "active_layer" "DRAWING FORMAT/OUTLINE")
	) 
	unless((axlFormGetField fid "copy_result") 
	    (axlFormSetFieldEditable fid "class" nil) 
	    (axlFormSetFieldEditable fid "subclass" nil) 
	    (axlFormSetFieldEditable fid "subcolor" nil) 
	    (axlFormSetFieldEditable fid "toggle_destination_layer" nil)
	) 
	(axlFormDisplay fid) 
	TBX_FORM_Delete((tbx_shapeutils_data->licCheck) FORM_FILE)
    )
)
procedure(TBX_SHAPEUTILS_Boolean_Popup(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_SHAPEUTILS_Boolean_Popup_Done
		    ) 
		    list("Oops" 
			'TBX_SHAPEUTILS_Boolean_Popup_Oops
		    ) 
		    list("Cancel" 
			'TBX_SHAPEUTILS_Boolean_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_SHAPEUTILS_Boolean_Popup_Cancel() 
    (axlDBTransactionOops 
	(tbx_shapeutils_data->transMark)
    ) 
    (axlDBTransactionCommit 
	(tbx_shapeutils_data->transMark)
    ) 
    (axlCancelEnterFun) 
    (axlUIPopupSet nil)
    (axlClearDynamics)
)
procedure(TBX_SHAPEUTILS_Boolean_Popup_Done() 
    when(((tbx_shapeutils_data->boolFirstElement) && !(tbx_shapeutils_data->boolSecondElement)) 
	(axlDBTransactionOops 
	    (tbx_shapeutils_data->transMark)
	)
    ) 
    (axlDBTransactionCommit 
	(tbx_shapeutils_data->transMark)
    ) 
    (axlFinishEnterFun) 
    (axlUIPopupSet nil)
    (axlClearDynamics)
)
procedure(TBX_SHAPEUTILS_Boolean_Popup_Oops() 
    (axlDBTransactionOops 
	(tbx_shapeutils_data->transMark)
    ) 
    (tbx_shapeutils_data->boolFirstElement = nil) 
    printf("Oops: Select source shape again to continue ..\n") 
    (axlClearSelSet)
    (axlSetFindFilter ?enabled 
	(tbx_shapeutils_data->boolFFenFirst) ?onButtons 
	(tbx_shapeutils_data->boolFFonFirst)
    ) 
    (axlFormSetFieldEditable 
	(tbx_shapeutils_data->formId) "or_operation" t
    ) 
    (axlFormSetFieldEditable 
	(tbx_shapeutils_data->formId) "and_operation" t
    ) 
    (axlFormSetFieldEditable 
	(tbx_shapeutils_data->formId) "andnot_operation" t
    ) 
    (axlFormSetFieldEditable 
	(tbx_shapeutils_data->formId) "xor_operation" t
    )
    (axlFormSetFieldEditable 
	(tbx_shapeutils_data->formId) "shape_mode" t
    )
)
procedure(TBX_SHAPEUTILS_Boolean_Process_Data(first_object second_object operation dest_layer break_poly
	boundary_only
    ) 
    let((first_poly_list second_poly_list or_list and_list shape_layer
	    shape_net shape_parent poly_a_list poly_b_list tmp_list
	    result break_list result_poly_list hole_poly_list result_list
	    rpoly shape_list
	) 
	(first_poly_list = (first_object->polyData)) 
	(second_poly_list = (second_object->polyData)) 
	when(boundary_only 
	    (first_poly_list = (first_object->polyDataBoundary)) 
	    (second_poly_list = (second_object->polyDataBoundary))
	) 
	if(dest_layer then 
	    (shape_layer = dest_layer) 
	    (shape_parent = nil) 
	    (shape_net = nil)
	    else 
	    (shape_layer = strcat((first_object->className) "/" 
		    (first_object->subclassName)
		)) 
	    (shape_parent = (first_object->parent)) 
	    (shape_net = (first_object->netName))
	)
	when(((operation == "xor") && ((first_object->className) == "BOUNDARY")) 
	    printf("Warning: XOR operations on dynamic shapes are not supported. The void for the intersection area would get lost.\nChanging shape type to static.\n") 
	    (shape_layer = strcat((axlMapClassName "ETCH") "/" 
		    (first_object->subclassName)
		))
	) 
	when(axlGetVariable("FLW_DEBUG") 
	    (axlDBCreateShape 
		car(first_poly_list) t 
		(tbx_shapeutils_data->tmpLayer)
	    )
	) 
	when(axlGetVariable("FLW_DEBUG") 
	    (axlDBCreateShape 
		car(second_poly_list) t 
		(tbx_shapeutils_data->tmpLayer)
	    )
	) 
	case(operation 
	    ("or" 
		(result_poly_list = (axlPolyOperation first_poly_list second_poly_list 
			'OR
		    ))
	    ) 
	    ("and" 
		(result_poly_list = (axlPolyOperation first_poly_list second_poly_list 
			'AND
		    ))
	    ) 
	    ("andnot" 
		(result_poly_list = (axlPolyOperation first_poly_list second_poly_list 
			'ANDNOT
		    ))
	    ) 
	    ("xor" 
		(or_list = (axlPolyOperation first_poly_list second_poly_list 
			'OR
		    )) 
		(and_list = (axlPolyOperation first_poly_list second_poly_list 
			'AND
		    )) 
		(result_poly_list = (axlPolyOperation or_list and_list 
			'ANDNOT
		    ))
	    )
	) 
	if(break_poly then 
	    foreach(poly result_poly_list 
		(hole_poly_list = list()) 
		foreach(hole 
		    (poly->holes) 
		    (hole_poly_list = cons(car((axlPolyFromHole hole)) hole_poly_list))
		) 
		(result = (axlDBCreateShape poly t 
			(tbx_shapeutils_data->tmpLayer) nil
			nil
		    ))
		(rpoly = car((axlPolyFromDB 
			    car(result) ?holes nil
			)
		    )) 
		(poly_a_list = list(rpoly)) 
		(poly_b_list = hole_poly_list) 
		foreach(poly_b poly_b_list 
		    (tmp_list = nil) 
		    foreach(poly_a poly_a_list 
			(result = TBX_SHAPEUTILS_Boolean_Check_Overlap(poly_a poly_b)) 
			cond(((result == "full") 
				(break_list = TBX_SHAPEUTILS_Boolean_Break_Poly(poly_a poly_b 
					(tbx_shapeutils_data->tmpLayer)
				    )) 
				(tmp_list = nconc(break_list tmp_list))
			    ) 
			    ((!result || (result == "partial")) 
				(tmp_list = cons(poly_a tmp_list))
			    )
			)
		    ) 
		    (poly_a_list = tmp_list)
		) 
		(result_list = (axlPolyOperation poly_a_list poly_b_list 
			'ANDNOT
		    ))
		foreach(p result_list 
		    (result = (axlDBCreateShape p 
			    (first_object->fillStyle) shape_layer shape_net
			    shape_parent
			)) 
		    when(result 
			(shape_list = cons(car(result) shape_list))
		    )
		)
	    ) else 
	    foreach(p result_poly_list 
		(result = (axlDBCreateShape p 
			(first_object->fillStyle) shape_layer shape_net
			shape_parent
		    )) 
		when(result 
		    (shape_list = cons(car(result) shape_list))
		)
	    )
	)
	when(dest_layer 
	    (result = (axlDBCreateShape 
		    car((first_object->polyData)) 
		    (first_object->fillStyle) 
		    strcat((first_object->className) "/" 
			(first_object->subclassName)
		    ) 
		    (first_object->netName)
		    (first_object->parent)
		)) 
	    when(result 
		(shape_list = cons(car(result) shape_list))
	    )
	) 
	foreach(grp 
	    (first_object->parentGroups) 
	    (axlDBAddGroupObjects grp shape_list)
	) t
    )
)
procedure(TBX_SHAPEUTILS_Boolean_Start() 
    let((eventMask loop event first_element second_element
	    shape_operation dest_layer break_poly boundary_only oversize
	) 
	(axlEventSetStartPopup 
	    'TBX_SHAPEUTILS_Boolean_Popup
	) 
	(eventMask = list('PICK)) 
	(loop = t) 
	(tbx_shapeutils_data->transMark = (axlDBTransactionStart))
	(tbx_shapeutils_data->boolFirstElement = nil) 
	(tbx_shapeutils_data->boolSecondElement = nil) 
	printf("Pick source shape...\n") 
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    (tbx_shapeutils_data->boolFFenFirst) ?onButtons 
	    (tbx_shapeutils_data->boolFFonFirst)
	)
	while(loop 
	    (event = (axlEnterEvent eventMask nil nil)) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(PICK 
		    if(!(tbx_shapeutils_data->boolFirstElement) then 
			(axlDBTransactionMark 
			    (tbx_shapeutils_data->transMark)
			) 
			(axlSingleSelectPoint 
			    (event->xy)
			) 
			if(car((axlGetSelSet)) then 
			    (oversize = (axlFormGetField 
				    (tbx_shapeutils_data->formId) "oversize_first"
				)) 
			    (axlFormSetFieldEditable 
				(tbx_shapeutils_data->formId) "or_operation" nil
			    ) 
			    (axlFormSetFieldEditable 
				(tbx_shapeutils_data->formId) "and_operation" nil
			    )
			    (axlFormSetFieldEditable 
				(tbx_shapeutils_data->formId) "andnot_operation" nil
			    ) 
			    (axlFormSetFieldEditable 
				(tbx_shapeutils_data->formId) "xor_operation" nil
			    ) 
			    (axlFormSetFieldEditable 
				(tbx_shapeutils_data->formId) "shape_mode" nil
			    ) 
			    (first_element = car((axlGetSelSet))) 
			    (tbx_shapeutils_data->boolFirstInfo = TBX_SHAPEUTILS_Boolean_Get_Object_Info(first_element oversize))
			    if(((tbx_shapeutils_data->boolFirstInfo)->polyDataBoundary) then 
				(tbx_shapeutils_data->boolFirstElement = t) 
				printf("Moving shape data to memory...\n") 
				(axlDeleteObject first_element)
				(axlDBCreateShape 
				    car(((tbx_shapeutils_data->boolFirstInfo)->polyDataBoundary)) nil 
				    (tbx_shapeutils_data->tmpLayer)
				) 
				(axlDBRefreshId nil) 
				printf("Pick second object to continue...\n") 
				(axlClearSelSet) 
				(axlSetFindFilter ?enabled 
				    (tbx_shapeutils_data->boolFFenSecond) ?onButtons 
				    (tbx_shapeutils_data->boolFFonSecond)
				)
				else 
				printf("Warning: Invalid data for first object\n")
			    ) else 
			    printf("Nothing selected. Pick source shape again...\n")
			)
			(axlClearSelSet) else 
			(axlSingleSelectPoint 
			    (event->xy)
			) 
			if(car((axlGetSelSet)) then 
			    (second_element = car((axlGetSelSet))) 
			    (oversize = (axlFormGetField 
				    (tbx_shapeutils_data->formId) "oversize_second"
				)) 
			    (tbx_shapeutils_data->boolSecondInfo = TBX_SHAPEUTILS_Boolean_Get_Object_Info(second_element oversize))
			    if(((tbx_shapeutils_data->boolSecondInfo)->polyDataBoundary) then 
				(tbx_shapeutils_data->boolSecondElement = t) 
				cond(((axlFormGetField 
					    (tbx_shapeutils_data->formId) "copy_result"
					) t
				    ) 
				    ((((tbx_shapeutils_data->boolFirstInfo)->layerDisplay) == ((tbx_shapeutils_data->boolSecondInfo)->layerDisplay)) 
					when(((((tbx_shapeutils_data->boolSecondInfo)->objType) == "dynamic_shape") || (((tbx_shapeutils_data->boolSecondInfo)->objType) == "static_shape") || (((tbx_shapeutils_data->boolSecondInfo)->objType) == "text")) 
					    (axlDeleteObject second_element)
					)
				    ) 
				    (t t)
				) 
				cond(((axlFormGetField 
					    (tbx_shapeutils_data->formId) "or_operation"
					) 
					(shape_operation = "or")
				    ) 
				    ((axlFormGetField 
					    (tbx_shapeutils_data->formId) "and_operation"
					) 
					(shape_operation = "and")
				    ) 
				    ((axlFormGetField 
					    (tbx_shapeutils_data->formId) "andnot_operation"
					) 
					(shape_operation = "andnot")
				    ) 
				    ((axlFormGetField 
					    (tbx_shapeutils_data->formId) "xor_operation"
					) 
					(shape_operation = "xor")
				    ) 
				    (t 
					(shape_operation = "or")
				    )
				)
				if((axlFormGetField 
					(tbx_shapeutils_data->formId) "copy_result"
				    ) then 
				    (dest_layer = (axlDBControl 
					    'activeLayer
					)) else 
				    (dest_layer = nil)
				) 
				if((axlFormGetField 
					(tbx_shapeutils_data->formId) "break_poly"
				    ) then 
				    (break_poly = t) else 
				    (break_poly = nil)
				) 
				if(((axlFormGetField 
					    (tbx_shapeutils_data->formId) "shape_mode"
					) == "boundary_only") then 
				    (boundary_only = t) else 
				    (boundary_only = nil)
				) 
				TBX_SHAPEUTILS_Boolean_Process_Data((tbx_shapeutils_data->boolFirstInfo) 
				    (tbx_shapeutils_data->boolSecondInfo) shape_operation dest_layer break_poly
				    boundary_only
				) 
				if(isCallable('axlDeleteByLayer) then 
				    (axlDeleteByLayer 
					(tbx_shapeutils_data->tmpLayer) 
					'fixed
				    ) else 
				    TBX_UTIL_Clean_Layer((tbx_shapeutils_data->tmpLayer))
				)
				printf("Pick next source shape to continue...\n") 
				(tbx_shapeutils_data->boolFirstElement = nil) 
				(tbx_shapeutils_data->boolSecondElement = nil) 
				(axlFormSetFieldEditable 
				    (tbx_shapeutils_data->formId) "or_operation" t
				) 
				(axlFormSetFieldEditable 
				    (tbx_shapeutils_data->formId) "and_operation" t
				)
				(axlFormSetFieldEditable 
				    (tbx_shapeutils_data->formId) "andnot_operation" t
				) 
				(axlFormSetFieldEditable 
				    (tbx_shapeutils_data->formId) "xor_operation" t
				) 
				(axlFormSetFieldEditable 
				    (tbx_shapeutils_data->formId) "shape_mode" t
				) 
				(axlClearSelSet) 
				(axlSetFindFilter ?enabled 
				    (tbx_shapeutils_data->boolFFenFirst) ?onButtons 
				    (tbx_shapeutils_data->boolFFonFirst)
				)
				else 
				printf("Warning: Invalid data for second object\n")
			    ) else 
			    printf("Nothing selected. Pick second object again...\n")
			) 
			(axlClearSelSet)
		    )
		) 
		(DONE 
		    (loop = nil)
		) 
		(CANCEL 
		    (loop = nil)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure((TBX_SHAPEUTILS_Clean_Layer layer_list \@optional ff_items) 
    let((orgvis ff_en_orig ff_on_orig) 
	(orgvis = (axlVisibleGet)) 
	(ff_en_orig = cons("noall" 
		(axlGetFindFilter nil)
	    )) 
	(ff_on_orig = (axlGetFindFilter t)) 
	(axlVisibleDesign nil)
	(axlVisibleUpdate nil) 
	foreach(lyr layer_list 
	    when((axlIsLayer lyr) 
		(axlVisibleLayer lyr t)
	    )
	) 
	if(ff_items then 
	    (axlClearSelSet) 
	    (axlSetFindFilter ?enabled 
		cons("noall" ff_items) ?onButtons 
		list("all")
	    ) 
	    (axlAddSelectAll)
	    when((axlGetSelSet) 
		(axlDeleteObject 
		    (axlGetSelSet)
		)
	    ) else 
	    if(isCallable('axlDeleteByLayer) then 
		(axlDeleteByLayer layer_list 
		    'fixed
		) else 
		TBX_UTIL_Clean_Layer(layer_list)
	    )
	) 
	(axlClearSelSet) 
	(axlVisibleSet orgvis)
	(axlSetFindFilter ?enabled ff_en_orig ?onButtons ff_on_orig) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_SHAPEUTILS_Cleanup() 
    let((param) 
	(param = param) 
	(axlCloseFindFilter) 
	(axlFormClose 
	    (tbx_shapeutils_data->formId)
	) 
	(axlClearSelSet)
	TBX_SHAPEUTILS_Clean_Layer(list((tbx_shapeutils_data->tmpLayer) 
		(tbx_shapeutils_data->tmpLayer2)
	    )
	) 
	unless(((tbx_shapeutils_data->envInfo)->displayNoHiliteFont) 
	    (axlUnsetVariable "display_nohilitefont")
	) 
	(axlDBControl 
	    'activeLayer 
	    (tbx_shapeutils_data->activeLayerLast)
	)
    )
)
procedure(TBX_SHAPEUTILS_Find_Box_Intersection(seg box_path) 
    let((intersection_list result add_info) 
	when(((seg->objType) == "arc") 
	    (add_info = TBX_GEOM_Get_Arc_Angles(car((seg->startEnd)) 
		    cadr((seg->startEnd)) 
		    (seg->xy) 
		    (seg->isClockwise) nil
		)) 
	    (add_info->startXY = car((seg->startEnd))) 
	    (add_info->endXY = cadr((seg->startEnd))) 
	    (add_info->centerXY = (seg->xy))
	    (add_info->radius = (seg->radius)) 
	    (add_info->isClockwise = (seg->isClockwise)) 
	    (add_info->isCircle = (seg->isCircle))
	) 
	foreach(box_seg 
	    (box_path->segments) 
	    (result = TBX_SHAPEUTILS_Find_Intersection(seg box_seg add_info)) 
	    foreach(isec result 
		(intersection_list = cons(isec intersection_list))
	    )
	) intersection_list
    )
)
procedure(TBX_SHAPEUTILS_Find_Intersection(seg_a seg_b arc_info) 
    let((intersection_list result) 
	(result = (_axlFindIntersectionPoint seg_a seg_b)) 
	when(car(result) 
	    foreach(isec result 
		cond((((seg_a->objType) == "line") 
			when((TBX_GEOM_Point_on_Line(isec 
				    (seg_a->startEnd) t
				) && TBX_GEOM_Point_on_Line(isec 
				    (seg_b->startEnd) t
				)) 
			    (intersection_list = cons(isec intersection_list))
			)
		    ) 
		    (((seg_a->objType) == "arc") 
			when((TBX_GEOM_Point_on_Arc(isec arc_info t) && 
				TBX_GEOM_Point_on_Line(isec 
				    (seg_b->startEnd) t
				)) 
			    (intersection_list = cons(isec intersection_list))
			)
		    )
		)
	    )
	) intersection_list
    )
)
procedure(TBX_SHAPEUTILS_Get_Shape_Center(shape) 
    let((poly box box_ll box_ur x_ll
	    y_ll x_ur y_ur x_center y_center
	    pt_center
	) 
	if(isCallable('_fseGetPolygonCenter) then 
	    (poly = car((axlPolyFromDB shape ?holes t))) 
	    (pt_center = (_fseGetPolygonCenter poly)) else
	    (box = (shape->bBox)) 
	    (box_ll = car(box)) 
	    (box_ur = cadr(box)) 
	    (x_ll = car(box_ll)) 
	    (y_ll = cadr(box_ll))
	    (x_ur = car(box_ur)) 
	    (y_ur = cadr(box_ur)) 
	    (x_center = (x_ll + ((x_ur - x_ll) / 2))) 
	    (y_center = (y_ll + ((y_ur - y_ll) / 2))) 
	    (pt_center = (x_center:y_center))
	) pt_center
    )
)
procedure(TBX_SHAPEUTILS_Init() 
    let((mth size_info_msg size_popup_data tmp_layer all_colors
	    color_rgb color_id param tmp_layer_2 env_info
	) 
	(mth = 'const) 
	defMathConstants(mth) 
	(size_info_msg = makeTable("size_info_msg_table" nil)) 
	(size_info_msg["ignore_voids"] = "All voids will be removed")
	(size_info_msg["as_defined"] = "Voids will be retained, but not modified at all") 
	(size_info_msg["even_processing"] = "When the shape boundary is expanded, voids will be expanded as well (and vice versa)") 
	(size_info_msg["odd_processing"] = "When the shape boundary is expanded, voids will be contracted (and vice versa)") 
	(size_info_msg["scale_voids"] = "Voids will be scaled also") 
	(size_popup_data = makeTable("size_popup_data_table" nil))
	(size_popup_data["expand"] = list(list("Ignore voids" "ignore_voids") 
		list("Keep as defined" "as_defined") 
		list("Odd Processing" "odd_processing") 
		list("Even Processing" "even_processing")
	    )) 
	(size_popup_data["scale"] = list(list("Ignore voids" "ignore_voids") 
		list("Scale voids" "scale_voids")
	    )) 
	(tmp_layer = "MANUFACTURING/TMP_DRAFTING") 
	unless((axlIsLayer tmp_layer) 
	    (axlLayerCreateNonConductor tmp_layer)
	) 
	cond((((axlColorGet 
			'background
		    ) == list(0 0 0)) 
		(color_rgb = list(255 255 255))
	    ) 
	    (t 
		(color_rgb = list(255 0 0))
	    )
	)
	(all_colors = (axlColorGet 
		'all
	    )) 
	for(i 0 
	    (length(all_colors) - 1) 
	    when((nth(i all_colors) == color_rgb) 
		(color_id = (i + 1))
	    )
	) 
	when(color_id 
	    (param = (axlLayerGet tmp_layer)) 
	    (param->color = color_id) 
	    (axlLayerSet param)
	) 
	(axlVisibleLayer tmp_layer t) 
	(axlVisibleUpdate t)
	(tmp_layer_2 = "MANUFACTURING/TMP_DRAFTING2") 
	unless((axlIsLayer tmp_layer_2) 
	    (axlLayerCreateNonConductor tmp_layer_2)
	) 
	unless((axlDBGetPropDictEntry "TBX_SHAPEUTILS_VERTEX_ID") 
	    (axlDBCreatePropDictEntry "TBX_SHAPEUTILS_VERTEX_ID" "STRING" 
		list("lines")
	    )
	) 
	unless((axlDBGetPropDictEntry "TBX_SHAPEUTILS_ARC_ID") 
	    (axlDBCreatePropDictEntry "TBX_SHAPEUTILS_ARC_ID" "STRING" 
		list("lines")
	    )
	) 
	unless((axlDBGetPropDictEntry "TBX_SHAPEUTILS_SEGMENT_ID") 
	    (axlDBCreatePropDictEntry "TBX_SHAPEUTILS_SEGMENT_ID" "STRING" 
		list("lines")
	    )
	)
	(env_info = ncons(nil)) 
	if(axlGetVariable("display_nohilitefont") then 
	    (env_info->displayNoHiliteFont = t) else 
	    (env_info->displayNoHiliteFont = nil)
	    (axlSetVariable "display_nohilitefont" t)
	) 
	unless(boundp('tbx_shapeutils_data) 
	    iliDefstruct('defstruct(tbx_shapeutils_data_struct boolFFenFirst boolFFonFirst boolFFenSecond boolFFonSecond
			boolFirstInfo boolSecondInfo boolFirstElement boolSecondElement sizeFFen
			sizeFFon sizeInfoMsg sizePopup adveditObjectInfo adveditCurSegTable
			prioShapes prioInfo licCheck tmpLayer tmpLayer2
			visList PI transMark formId runTime
			envInfo activeLayerLast
		    )
	    ) 
	    defvar(tbx_shapeutils_data nil)
	) 
	if(!tbx_shapeutils_data then 
	    (tbx_shapeutils_data = (make_tbx_shapeutils_data_struct ?boolFFenFirst 
		    list("noall" "boundary_shapes" "shapes") ?boolFFonFirst 
		    list("all")
		    ?boolFFenSecond 
		    list("noall" "boundary_shapes" "shapes" "lines" "clines"
			"clinesegs" "linesegs" "text" "pins" "vias"
		    ) ?boolFFonSecond 
		    list("all") ?boolFirstElement
		    nil ?boolSecondElement nil ?boolFirstInfo 
		    ncons(nil)
		    ?boolSecondInfo 
		    ncons(nil) ?sizeFFen 
		    list("noall" "boundary_shapes" "shapes") ?sizeFFon
		    list("all") ?sizePopup size_popup_data ?sizeInfoMsg size_info_msg
		    ?adveditObjectInfo nil ?adveditCurSegTable nil ?prioShapes
		    nil ?prioInfo nil ?licCheck nil
		    ?tmpLayer tmp_layer ?tmpLayer2 tmp_layer_2 ?visList
		    nil ?PI 
		    (const.PI) ?transMark nil
		    ?formId nil ?runTime 
		    ncons(nil) ?envInfo
		    env_info ?activeLayerLast nil
		)) else 
	    (tbx_shapeutils_data->boolFFenFirst = list("noall" "boundary_shapes" "shapes"))
	    (tbx_shapeutils_data->boolFFonFirst = list("all")) 
	    (tbx_shapeutils_data->boolFFenSecond = list("noall" "boundary_shapes" "shapes" "lines" "clines"
		    "clinesegs" "linesegs" "text" "pins" "vias"
		)) 
	    (tbx_shapeutils_data->boolFFonSecond = list("all")) 
	    (tbx_shapeutils_data->boolFirstElement = nil) 
	    (tbx_shapeutils_data->boolSecondElement = nil)
	    (tbx_shapeutils_data->boolFirstInfo = ncons(nil)) 
	    (tbx_shapeutils_data->boolSecondInfo = ncons(nil)) 
	    (tbx_shapeutils_data->sizeFFen = list("noall" "boundary_shapes" "shapes")) 
	    (tbx_shapeutils_data->sizeFFon = list("all")) 
	    (tbx_shapeutils_data->sizePopup = size_popup_data)
	    (tbx_shapeutils_data->sizeInfoMsg = size_info_msg) 
	    (tbx_shapeutils_data->adveditObjectInfo = nil) 
	    (tbx_shapeutils_data->adveditCurSegTable = nil) 
	    (tbx_shapeutils_data->prioShapes = nil) 
	    (tbx_shapeutils_data->prioInfo = nil)
	    (tbx_shapeutils_data->licCheck = nil) 
	    (tbx_shapeutils_data->tmpLayer = tmp_layer) 
	    (tbx_shapeutils_data->tmpLayer2 = tmp_layer_2) 
	    (tbx_shapeutils_data->visList = nil) 
	    (tbx_shapeutils_data->PI = (const.PI))
	    (tbx_shapeutils_data->transMark = nil) 
	    (tbx_shapeutils_data->formId = nil) 
	    (tbx_shapeutils_data->runTime = ncons(nil)) 
	    (tbx_shapeutils_data->envInfo = env_info) 
	    (tbx_shapeutils_data->activeLayerLast = nil)
	)
    )
)
procedure(TBX_SHAPEUTILS_Is_Object_Inside_Box(odbid bBox) 
    let((tmp_box_ll tmp_box_ur is_inside) 
	case((odbid->objType) 
	    ("line" 
		when(((axlIsPointInsideBox 
			    car((odbid->startEnd)) bBox
			) && (axlIsPointInsideBox 
			    cadr((odbid->startEnd)) bBox
			)) 
		    (is_inside = t)
		)
	    ) 
	    ("arc" 
		(tmp_box_ll = car((odbid->bBox))) 
		(tmp_box_ur = cadr((odbid->bBox))) 
		when(((axlIsPointInsideBox tmp_box_ll bBox) && 
			(axlIsPointInsideBox tmp_box_ur bBox)) 
		    (is_inside = t)
		)
	    ) 
	    (t 
		printf("Unknown object type: %L\n" 
		    (odbid->objType)
		) 
		(is_inside = nil)
	    )
	) is_inside
    )
)
procedure(TBX_SHAPEUTILS_Main(arg) 
    let((lic_check_result info_file FC_FEATURE FC_VERSION SUB_VERSION
	    design_type VERSION_STR port odbid form_handle
	) 
	(FC_FEATURE = "SHAPEUTILS") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Shape Utilities %s (C)2017" FC_VERSION))
	(VERSION_STR = VERSION_STR) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./shapeutils_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Shape Operation information:\n") 
		fprintf(port "============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "  boolean  : Performs boolean operations on shapes\n") 
		fprintf(port "  scale    : Performs scale operations on shapes\n") 
		fprintf(port "  oversize : Performs expand/contract operations on shapes\n")
		fprintf(port "  advedit  : Performs advanced edit operations on shapes\n") 
		fprintf(port "\n") 
		fprintf(port "Environment variables:\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Shape Operation: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    (arg 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    printf("For additional help enter: 'tbx help shapeutils' in console window\n") 
		    TBX_SHAPEUTILS_Init() 
		    (tbx_shapeutils_data->licCheck = lic_check_result) 
		    (tbx_shapeutils_data->activeLayerLast = (axlDBControl 
			    'activeLayer
			))
		    (design_type = upperCase((axlDesignType t))) 
		    if(((design_type == "SHAPE") || (design_type == "FLASH")) then 
			(axlUIConfirm 
			    sprintf(nil "Shape Utilties not supported in symbol drawings of type %L" design_type) 
			    'warn
			) else 
			case(lowerCase(arg) 
			    ("boolean" 
				TBX_SHAPEUTILS_Clean_Layer(list((tbx_shapeutils_data->tmpLayer) 
					(tbx_shapeutils_data->tmpLayer2)
				    )
				) 
				TBX_SHAPEUTILS_Boolean_OpenMinistatus() 
				(axlAutoOpenFindFilter) 
				(axlVisibleLayer 
				    (tbx_shapeutils_data->tmpLayer) t
				)
				TBX_SHAPEUTILS_Boolean_Start() 
				TBX_SHAPEUTILS_Boolean_Cache_Param((tbx_shapeutils_data->formId)) 
				TBX_SHAPEUTILS_Cleanup()
			    ) 
			    ("size" 
				TBX_SHAPEUTILS_Clean_Layer(list((tbx_shapeutils_data->tmpLayer) 
					(tbx_shapeutils_data->tmpLayer2)
				    )
				) 
				TBX_SHAPEUTILS_Size_OpenMinistatus() 
				(axlAutoOpenFindFilter) 
				TBX_SHAPEUTILS_Size_Start()
				TBX_SHAPEUTILS_Size_Cache_Param((tbx_shapeutils_data->formId)) 
				TBX_SHAPEUTILS_Cleanup()
			    ) 
			    ("roundrec" 
				TBX_SHAPEUTILS_Clean_Layer(list((tbx_shapeutils_data->tmpLayer) 
					(tbx_shapeutils_data->tmpLayer2)
				    )
				) 
				TBX_SHAPEUTILS_Roundrec_OpenMinistatus() 
				(axlAutoOpenFindFilter) 
				TBX_SHAPEUTILS_Roundrec_Start()
				TBX_SHAPEUTILS_Roundrec_Cache_Param((tbx_shapeutils_data->formId)) 
				TBX_SHAPEUTILS_Cleanup()
			    ) 
			    ("advedit" 
				TBX_SHAPEUTILS_Clean_Layer(list((tbx_shapeutils_data->tmpLayer) 
					(tbx_shapeutils_data->tmpLayer2)
				    )
				) 
				TBX_SHAPEUTILS_Shadow_Mode(nil) 
				(axlDBControl 
				    'activeLayer 
				    TBX_SESSION_Get_Param("shapeutils|advedit" "active_layer" 
					strcat((axlMapClassName "ETCH") "/TOP")
				    )
				) 
				(axlVisibleUpdate t)
				(odbid = TBX_SHAPEUTILS_ADVEDIT_Select_Shape_or_Void()) 
				when(odbid 
				    (axlDBControl 
					'activeLayer 
					(tbx_shapeutils_data->tmpLayer)
				    ) 
				    TBX_SHAPEUTILS_Shadow_Mode(t) 
				    TBX_SHAPEUTILS_ADVEDIT_OpenMinistatus() 
				    (axlAutoOpenFindFilter)
				    (tbx_shapeutils_data->transMark = (axlDBTransactionStart)) 
				    (tbx_shapeutils_data->adveditCurSegTable = TBX_SHAPEUTILS_ADVEDIT_Get_Segment_Info(list(odbid))) 
				    (tbx_shapeutils_data->adveditObjectInfo = TBX_SHAPEUTILS_ADVEDIT_Get_Shape_Info(odbid)) 
				    TBX_SHAPEUTILS_ADVEDIT_Init_Secondary_Graphics((tbx_shapeutils_data->adveditObjectInfo)) 
				    (axlVisibleLayer 
					(tbx_shapeutils_data->tmpLayer) t
				    )
				    (axlVisibleLayer 
					(tbx_shapeutils_data->tmpLayer2) nil
				    ) 
				    (tbx_shapeutils_data->tmpObjects = TBX_SHAPEUTILS_ADVEDIT_Init_Temp_Graphics((tbx_shapeutils_data->formId))) 
				    TBX_SHAPEUTILS_ADVEDIT_Edit_Shape() 
				    TBX_SHAPEUTILS_ADVEDIT_Clear_Groups() 
				    TBX_SHAPEUTILS_ADVEDIT_Cache_Param((tbx_shapeutils_data->formId))
				    TBX_SHAPEUTILS_Cleanup()
				)
			    )
			    ("prio" 
				TBX_SHAPEUTILS_Clean_Layer(list((tbx_shapeutils_data->tmpLayer)) 
				    list("text")
				) 
				(form_handle = TBX_SHAPEUTILS_PRIO_OpenMinistatus()) 
				(tbx_shapeutils_data->formId = form_handle) 
				(axlAutoOpenFindFilter)
				TBX_SHAPEUTILS_PRIO_Start(form_handle) 
				TBX_SHAPEUTILS_Clean_Layer(list((tbx_shapeutils_data->tmpLayer)) 
				    list("text")
				)
			    ) 
			    (t t)
			)
		    )
		)
	    )
	)
    )
)
procedure(TBX_SHAPEUTILS_PRIO_Callback(form_handle) 
    let((shape text_list text_dbid text_block text_orient
	    cur_text
	) 
	case((form_handle->curField) 
	    ("text_block" 
		(text_block = sprintf(nil "%d" 
			(form_handle->curValue)
		    )) 
		foreach(entry 
		    (tbx_shapeutils_data->prioInfo) 
		    (shape = caddr(entry)) 
		    (text_list = setof(x 
			    (axlDBGetAttachedText shape) 
			    ((x->layer) == (tbx_shapeutils_data->tmpLayer))
			)) 
		    when(car(text_list) 
			(text_dbid = car(text_list)) 
			(cur_text = (text_dbid->text)) 
			(text_orient = (axlTextOrientationCopy text_dbid)) 
			(text_orient->textBlock = text_block)
			(axlDBChangeText text_dbid cur_text text_orient)
		    )
		)
	    ) 
	    ("highest_prio" t) 
	    ("increase_prio" t) 
	    ("decrease_prio" t)
	    ("lowest_prio" t) 
	    ("compact_view" 
		TBX_SHAPEUTILS_PRIO_Update_Text_Labels(form_handle 
		    (tbx_shapeutils_data->prioInfo) 
		    (tbx_shapeutils_data->tmpLayer)
		)
	    )
	)
    )
)
procedure(TBX_SHAPEUTILS_PRIO_Change(shape_dbid form_handle prio_info) 
    let((cnt match_index tmp_list tmp_id) 
	cond(((axlFormGetField form_handle "highest_prio") 
		(axlShapeRaisePriority shape_dbid)
	    ) 
	    ((axlFormGetField form_handle "lowest_prio") 
		foreach(entry prio_info 
		    if((caddr(entry) != shape_dbid) then 
			(axlShapeRaisePriority 
			    caddr(entry)
			) else t
		    )
		)
	    ) 
	    ((axlFormGetField form_handle "increase_prio") 
		(cnt = 0) 
		foreach(entry prio_info 
		    when((caddr(entry) == shape_dbid) 
			(match_index = cnt) 
			(axlShapeRaisePriority 
			    caddr(entry)
			)
		    ) 
		    ++cnt
		) 
		when(match_index 
		    (match_index = (match_index + 2)) 
		    (tmp_list = nthcdr(match_index prio_info)) 
		    foreach(entry tmp_list 
			(axlShapeRaisePriority 
			    caddr(entry)
			)
		    )
		)
	    ) 
	    ((axlFormGetField form_handle "decrease_prio") 
		(cnt = 0) 
		foreach(entry prio_info 
		    when((caddr(entry) == shape_dbid) 
			(match_index = cnt)
		    ) 
		    ++cnt
		) 
		when(match_index 
		    (tmp_id = (match_index - 1)) 
		    (tmp_list = nth(tmp_id prio_info)) 
		    when(tmp_list 
			(axlShapeRaisePriority 
			    caddr(tmp_list)
			)
		    ) 
		    (tmp_id = (match_index + 1))
		    (tmp_list = nthcdr(tmp_id prio_info)) 
		    foreach(entry tmp_list 
			(axlShapeRaisePriority 
			    caddr(entry)
			)
		    )
		)
	    )
	) 
	(axlDBRefreshId nil) t
    )
)
procedure(TBX_SHAPEUTILS_PRIO_Enable_Form(form_handle mode) 
    if(mode then 
	(axlFormSetFieldEditable form_handle "highest_prio" t) 
	(axlFormSetFieldEditable form_handle "increase_prio" t) 
	(axlFormSetFieldEditable form_handle "decrease_prio" t)
	(axlFormSetFieldEditable form_handle "lowest_prio" t) 
	(axlFormSetFieldEditable form_handle "text_block" t) 
	(axlFormSetFieldEditable form_handle "compact_view" t) 
	(axlFormSetFieldEditable form_handle "update_shapes" t) else
	(axlFormSetFieldEditable form_handle "highest_prio" nil) 
	(axlFormSetFieldEditable form_handle "increase_prio" nil) 
	(axlFormSetFieldEditable form_handle "decrease_prio" nil) 
	(axlFormSetFieldEditable form_handle "lowest_prio" nil) 
	(axlFormSetFieldEditable form_handle "text_block" nil)
	(axlFormSetFieldEditable form_handle "compact_view" nil) 
	(axlFormSetFieldEditable form_handle "update_shapes" nil)
    )
)
procedure(TBX_SHAPEUTILS_PRIO_Get_Priority_Info(shape_list) 
    let((prio_id tmp_data shape_data) 
	foreach(shp shape_list 
	    (tmp_data = cons(list((shp->priority) shp) tmp_data))
	) 
	(tmp_data = sortcar(tmp_data 
		'lessp
	    )) 
	(prio_id = 0) 
	foreach(entry tmp_data 
	    (shape_data = cons(list(car(entry) 
			++prio_id 
			cadr(entry)
		    ) shape_data
		))
	)
	(shape_data = reverse(shape_data)) shape_data
    )
)
procedure(TBX_SHAPEUTILS_PRIO_OpenMinistatus() 
    let((fid FORM_FILE) 
	(FORM_FILE = TBX_FORM_Get_Name((tbx_shapeutils_data->licCheck) "shapeutils_prio_mini")) 
	(fid = (axlMiniStatusLoad 
		gensym("tbxshapeutilspriomini") FORM_FILE 
		'TBX_SHAPEUTILS_PRIO_Callback
	    )) 
	TBX_FORM_Init_Header(fid nil 
	    (tbx_shapeutils_data->licCheck) nil
	) 
	(axlFormSetField fid "highest_prio" t)
	(axlFormSetField fid "update_shapes" t) 
	(axlFormSetField fid "text_block" 2) 
	(axlFormDisplay fid) 
	TBX_FORM_Delete((tbx_shapeutils_data->licCheck) FORM_FILE) fid
    )
)
procedure(TBX_SHAPEUTILS_PRIO_Popup_Cancel() 
    (axlDBTransactionRollback 
	(tbx_shapeutils_data->transMark)
    ) 
    (axlCancelEnterFun) 
    (axlUIPopupSet nil) 
    (axlClearDynamics)
)
procedure(TBX_SHAPEUTILS_PRIO_Popup_Complete_Selection() 
    ((tbx_shapeutils_data->runTime)->pickShapeMode = nil) 
    (axlDBTransactionCommit 
	(tbx_shapeutils_data->transMark)
    ) 
    (tbx_shapeutils_data->transMark = (axlDBTransactionStart)) 
    printf("Select shape to change priority\n")
    (axlClearSelSet) 
    (tbx_shapeutils_data->prioInfo = TBX_SHAPEUTILS_PRIO_Get_Priority_Info((tbx_shapeutils_data->prioShapes))) 
    TBX_SHAPEUTILS_PRIO_Enable_Form((tbx_shapeutils_data->formId) t) 
    (axlEventSetStartPopup 
	'TBX_SHAPEUTILS_PRIO_Regular_Popup
    )
)
procedure(TBX_SHAPEUTILS_PRIO_Popup_Done() 
    (axlDBTransactionCommit 
	(tbx_shapeutils_data->transMark)
    ) 
    (axlFinishEnterFun) 
    (axlUIPopupSet nil) 
    (axlClearDynamics)
)
procedure(TBX_SHAPEUTILS_PRIO_Popup_Oops() 
    (axlDBTransactionOops 
	(tbx_shapeutils_data->transMark)
    ) 
    if(((tbx_shapeutils_data->runTime)->pickShapeMode) then 
	(tbx_shapeutils_data->prioShapes = cdr((tbx_shapeutils_data->prioShapes))) else t
    )
)
procedure(TBX_SHAPEUTILS_PRIO_Regular_Popup(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_SHAPEUTILS_PRIO_Popup_Done
		    ) 
		    list("Oops" 
			'TBX_SHAPEUTILS_PRIO_Popup_Oops
		    ) 
		    list("Cancel" 
			'TBX_SHAPEUTILS_PRIO_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_SHAPEUTILS_PRIO_Start(form_handle) 
    let((eventMask loop event odbid shape_prio
	    myorient text_block pick_msg prioedit_msg cur_msg
	    bbox xy_ll xy_ur offset sel_set
	) 
	(axlEventSetStartPopup 
	    'TBX_SHAPEUTILS_PRIO_Start_Popup
	) 
	(eventMask = list('PICK)) 
	(loop = t) 
	(tbx_shapeutils_data->transMark = (axlDBTransactionStart))
	(pick_msg = "Select shapes by subsequent picks first, then use RMB - Complete to enter priority edit mode") 
	(prioedit_msg = "Select a shape to change the priority") 
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    list("noall" "boundary_shapes" "shapes") ?onButtons 
	    list("all")
	) 
	((tbx_shapeutils_data->runTime)->pickShapeMode = t)
	TBX_SHAPEUTILS_PRIO_Enable_Form(form_handle nil) 
	(cur_msg = pick_msg) 
	(offset = (axlMKSConvert "0.1 MM" 
		car((axlDBGetDesignUnits))
	    )) 
	while(loop 
	    printf("%s\n" cur_msg) 
	    (event = (axlEnterEvent eventMask nil nil)) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(PICK 
		    cond((((tbx_shapeutils_data->runTime)->pickShapeMode) 
			    (xy_ll = ((car((event->xy)) - offset):(cadr((event->xy)) - offset))) 
			    (xy_ur = ((car((event->xy)) + offset):(cadr((event->xy)) + offset))) 
			    (bbox = list(xy_ll xy_ur)) 
			    (axlSingleSelectBox bbox)
			    (sel_set = setof(x 
				    (axlGetSelSet) 
				    !memq(x 
					    (tbx_shapeutils_data->prioShapes)
					)
				)) 
			    when(car(sel_set) 
				if((car(sel_set)->shapeIsBoundary) then 
				    (axlDBTransactionMark 
					(tbx_shapeutils_data->transMark)
				    ) 
				    (odbid = car(sel_set)) 
				    unless((axlIsVisibleLayer 
					    (odbid->layer)
					) 
					(axlVisibleLayer 
					    (odbid->layer) t
					) 
					(axlVisibleUpdate t)
				    )
				    (tbx_shapeutils_data->prioShapes = cons(odbid 
					    (tbx_shapeutils_data->prioShapes)
					)) 
				    (shape_prio = sprintf(nil "%L" 
					    (odbid->priority)
					)) 
				    (text_block = sprintf(nil "%d" 
					    (axlFormGetField form_handle "text_block")
					)) 
				    (myorient = (make_axlTextOrientation ?textBlock text_block ?rotation 0.0
					    ?mirrored nil ?justify "center"
					)) 
				    (axlDBCreateText shape_prio 
					(event->xy) myorient 
					(tbx_shapeutils_data->tmpLayer)
					odbid
				    )
				    else 
				    printf("Info: Ignoring static shape...\n")
				) 
				(axlClearSelSet)
			    ) 
			    (cur_msg = pick_msg)
			) 
			(t 
			    (axlSingleSelectPoint 
				(event->xy)
			    ) 
			    if((car((axlGetSelSet)) && memq(car((axlGetSelSet)) 
					(tbx_shapeutils_data->prioShapes)
				    )) then 
				(axlDBTransactionMark 
				    (tbx_shapeutils_data->transMark)
				) 
				TBX_SHAPEUTILS_PRIO_Change(car((axlGetSelSet)) form_handle 
				    (tbx_shapeutils_data->prioInfo)
				) 
				(tbx_shapeutils_data->prioInfo = TBX_SHAPEUTILS_PRIO_Get_Priority_Info((tbx_shapeutils_data->prioShapes)))
				(axlDBRefreshId nil) 
				TBX_SHAPEUTILS_PRIO_Update_Text_Labels(form_handle 
				    (tbx_shapeutils_data->prioInfo) 
				    (tbx_shapeutils_data->tmpLayer)
				) 
				when((axlFormGetField form_handle "update_shapes") 
				    (axlShapeDynamicUpdate nil t) 
				    (axlVisibleUpdate t)
				) 
				(axlDBRefreshId nil) 
				(axlClearSelSet)
				else 
				printf("Invalid selection\n")
			    ) 
			    (cur_msg = prioedit_msg)
			)
		    )
		) 
		(DONE 
		    (loop = nil)
		) 
		(CANCEL 
		    (loop = nil)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_SHAPEUTILS_PRIO_Start_Popup(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_SHAPEUTILS_PRIO_Popup_Done
		    ) 
		    list("Complete selection" 
			'TBX_SHAPEUTILS_PRIO_Popup_Complete_Selection
		    ) 
		    list("Oops" 
			'TBX_SHAPEUTILS_PRIO_Popup_Oops
		    ) 
		    list("Cancel" 
			'TBX_SHAPEUTILS_PRIO_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_SHAPEUTILS_PRIO_Update_Text_Labels(form_handle prio_info tmp_layer) 
    let((index prio_id shape text_list text_dbid) 
	if((axlFormGetField form_handle "compact_view") then 
	    (index = 1) else 
	    (index = 0)
	) 
	foreach(entry prio_info 
	    (prio_id = nth(index entry)) 
	    (shape = caddr(entry)) 
	    (text_list = setof(x 
		    (axlDBGetAttachedText shape) 
		    ((x->layer) == tmp_layer)
		))
	    when(car(text_list) 
		(text_dbid = car(text_list)) 
		(axlDBChangeText text_dbid 
		    sprintf(nil "%L" prio_id)
		)
	    )
	)
    )
)
procedure(TBX_SHAPEUTILS_Poly_From_Text(txt_dbid tmp_layer) 
    let((seg_poly_list poly_info line_path text_param result) 
	(text_param = (axlGetParam 
		sprintf(nil "paramTextBlock:%s" 
		    (txt_dbid->textBlock)
		)
	    )) 
	if(((text_param->photoWidth) > 0.0) then 
	    foreach(char_entry 
		(axlText2Lines txt_dbid) 
		foreach(rpath char_entry 
		    (result = (axlDBCreatePath rpath tmp_layer)) 
		    (line_path = caar(result)) 
		    foreach(seg 
			(line_path->segments) 
			(seg_poly_list = cons(car((axlPolyFromDB seg ?endCapType 
					'ROUND
				    )
				) seg_poly_list
			    ))
		    )
		    (axlDeleteObject line_path)
		)
	    ) 
	    if(onep(length(seg_poly_list)) then 
		(poly_info = seg_poly_list) else 
		(poly_info = (axlPolyOperation 
			cdr(seg_poly_list) 
			list(car(seg_poly_list)) 
			'OR
		    ))
	    ) 
	    (axlVisibleUpdate nil)
	    else 
	    printf("Warning: Text line width is 0.0\n")
	) poly_info
    )
)
procedure(TBX_SHAPEUTILS_Roundrec_Cache_Param(form_handle) 
    let((rec session_param) 
	(rec = "shapeutils|roundrec") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	putprop(session_param[rec] 
	    (axlDBControl 
		'activeLayer
	    ) 
	    stringToSymbol("active_layer")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "shape_width") 
	    stringToSymbol("shape_width")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "shape_height") 
	    stringToSymbol("shape_height")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "corner_radius") 
	    stringToSymbol("corner_radius")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "center_to_pick") 
	    stringToSymbol("center_to_pick")
	) 
	putprop(session_param[rec] 
	    car((axlDBGetDesignUnits)) 
	    stringToSymbol("units")
	)
	t
    )
)
procedure(TBX_SHAPEUTILS_Roundrec_Callback(form_handle) 
    let((width height) 
	case((form_handle->curField) 
	    ("center_to_pick" 
		when((form_handle->curValue) 
		    (width = (axlFormGetField form_handle "shape_width")) 
		    (height = (axlFormGetField form_handle "shape_height")) 
		    (width = abs(width)) 
		    (height = abs(height))
		    (axlFormSetField form_handle "shape_width" width) 
		    (axlFormSetField form_handle "shape_height" height)
		)
	    )
	)
    )
)
procedure(TBX_SHAPEUTILS_Roundrec_Draw_Rectangle(xy width height radius center_to_pick
	layer
    ) 
    let((r_path pt_list factor x1 x2
	    x3 x4 y1 y2 y3
	    y4
	) 
	if((radius == 0.0) then 
	    if(center_to_pick then 
		(width = abs(width)) 
		(height = abs(height)) 
		(x1 = (car(xy) - (width / 2)))
		(y1 = (cadr(xy) - (height / 2))) else 
		(x1 = car(xy)) 
		(y1 = cadr(xy))
	    ) 
	    cond(((((width >= 0.0) && (height >= 0.0)) || ((width < 0.0) && (height < 0.0))) 
		    (x2 = x1) 
		    (y2 = (y1 + height)) 
		    (x3 = (x2 + width)) 
		    (y3 = y2)
		    (x4 = x3) 
		    (y4 = (y3 - height)) 
		    (pt_list = list((x1:y1) 
			    (x2:y2) 
			    (x3:y3) 
			    (x4:y4) 
			    (x1:y1)
			))
		) 
		((((width >= 0.0) && (height < 0.0)) || ((width < 0.0) && (height >= 0.0))) 
		    (x2 = (x1 + width)) 
		    (y2 = y1) 
		    (x3 = x2) 
		    (y3 = (y2 + height))
		    (x4 = (x3 - width)) 
		    (y4 = y3) 
		    (pt_list = list((x1:y1) 
			    (x2:y2) 
			    (x3:y3) 
			    (x4:y4) 
			    (x1:y1)
			))
		) 
		(t 
		    (pt_list = nil)
		)
	    ) 
	    when(pt_list 
		(r_path = (axlPathStart pt_list 0.0)) 
		(axlDBCreateShape r_path t layer)
	    )
	    else 
	    if(center_to_pick then 
		(width = abs(width)) 
		(height = abs(height)) 
		(x1 = (car(xy) - (width / 2)))
		(y1 = (cadr(xy) - (height / 2))) else 
		(x1 = car(xy)) 
		(y1 = cadr(xy))
	    ) 
	    cond(((((width >= 0.0) && (height >= 0.0)) || ((width < 0.0) && (height < 0.0))) 
		    (x2 = x1) 
		    (y2 = (y1 + height)) 
		    (x3 = (x2 + width)) 
		    (y3 = y2)
		    (x4 = x3) 
		    (y4 = (y3 - height)) 
		    (factor = 1.0) 
		    when(((width < 0.0) && (height < 0.0)) 
			(factor = -1.0)
		    ) 
		    (r_path = (axlPathStart 
			    list(((x1 + (radius * factor)):y1)) 0.0
			))
		    (r_path = (axlPathArcRadius r_path 0.0 
			    (x1:(y1 + (radius * factor))) t
			    nil radius
			)) 
		    when((radius < (abs(height) / 2.0)) 
			(r_path = (axlPathLine r_path 0.0 
				(x2:(y2 - (radius * factor)))
			    ))
		    ) 
		    (r_path = (axlPathArcRadius r_path 0.0 
			    ((x2 + (radius * factor)):y2) t
			    nil radius
			)) 
		    when((radius < (abs(width) / 2.0)) 
			(r_path = (axlPathLine r_path 0.0 
				((x3 - (radius * factor)):y3)
			    ))
		    ) 
		    (r_path = (axlPathArcRadius r_path 0.0 
			    (x3:(y3 - (radius * factor))) t
			    nil radius
			))
		    when((radius < (abs(height) / 2.0)) 
			(r_path = (axlPathLine r_path 0.0 
				(x4:(y4 + (radius * factor)))
			    ))
		    ) 
		    (r_path = (axlPathArcRadius r_path 0.0 
			    ((x4 - (radius * factor)):y4) t
			    nil radius
			)) 
		    when((radius < (abs(width) / 2.0)) 
			(r_path = (axlPathLine r_path 0.0 
				((x1 + (radius * factor)):y1)
			    ))
		    ) 
		    (axlDBCreateShape r_path t layer)
		) 
		((((width >= 0.0) && (height < 0.0)) || ((width < 0.0) && (height >= 0.0))) 
		    (x2 = (x1 + width)) 
		    (y2 = y1) 
		    (x3 = x2) 
		    (y3 = (y2 + height))
		    (x4 = (x3 - width)) 
		    (y4 = y3) 
		    (factor = 1.0) 
		    when(((width < 0.0) && (height >= 0.0)) 
			(factor = -1.0)
		    ) 
		    (r_path = (axlPathStart 
			    list((x1:(y1 - (radius * factor)))) 0.0
			))
		    (r_path = (axlPathArcRadius r_path 0.0 
			    ((x1 + (radius * factor)):y1) t
			    nil radius
			)) 
		    when((radius < (abs(width) / 2.0)) 
			(r_path = (axlPathLine r_path 0.0 
				((x2 - (radius * factor)):y2)
			    ))
		    ) 
		    (r_path = (axlPathArcRadius r_path 0.0 
			    (x2:(y2 - (radius * factor))) t
			    nil radius
			)) 
		    when((radius < (abs(height) / 2.0)) 
			(r_path = (axlPathLine r_path 0.0 
				(x3:(y3 + (radius * factor)))
			    ))
		    ) 
		    (r_path = (axlPathArcRadius r_path 0.0 
			    ((x3 - (radius * factor)):y3) t
			    nil radius
			))
		    when((radius < (abs(width) / 2.0)) 
			(r_path = (axlPathLine r_path 0.0 
				((x4 + (radius * factor)):y4)
			    ))
		    ) 
		    (r_path = (axlPathArcRadius r_path 0.0 
			    (x4:(y4 + (radius * factor))) t
			    nil radius
			)) 
		    when((radius < (abs(height) / 2.0)) 
			(r_path = (axlPathLine r_path 0.0 
				(x1:(y1 - (radius * factor)))
			    ))
		    ) 
		    (axlDBCreateShape r_path t layer)
		) 
		(t 
		    (pt_list = nil)
		)
	    )
	)
    )
)
procedure(TBX_SHAPEUTILS_Roundrec_OpenMinistatus() 
    let((fid FORM_FILE record design_units) 
	(FORM_FILE = TBX_FORM_Get_Name((tbx_shapeutils_data->licCheck) "shapeutils_roundrec_mini")) 
	(fid = (axlMiniStatusLoad 
		gensym("tbxshapeutilsroundrecmini") FORM_FILE 
		'TBX_SHAPEUTILS_Roundrec_Callback
	    )) 
	(tbx_shapeutils_data->formId = fid) 
	(record = "shapeutils|roundrec")
	(design_units = car((axlDBGetDesignUnits))) 
	TBX_FORM_Init_Header(fid nil 
	    (tbx_shapeutils_data->licCheck) nil
	) 
	(axlFormSetField fid "shape_width" 
	    TBX_SESSION_Get_Param(record "shape_width" 
		(axlMKSConvert "1.0 MM" design_units) t
	    )
	) 
	(axlFormSetField fid "shape_height" 
	    TBX_SESSION_Get_Param(record "shape_height" 
		(axlMKSConvert "1.0 MM" design_units) t
	    )
	) 
	(axlFormSetField fid "corner_radius" 
	    TBX_SESSION_Get_Param(record "corner_radius" 0.0 t)
	)
	(axlFormSetField fid "center_to_pick" 
	    TBX_SESSION_Get_Param(record "center_to_pick" t)
	) 
	(axlFormDisplay fid) 
	TBX_FORM_Delete((tbx_shapeutils_data->licCheck) FORM_FILE)
    )
)
procedure(TBX_SHAPEUTILS_Roundrec_Popup(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_SHAPEUTILS_Roundrec_Popup_Done
		    ) 
		    list("Oops" 
			'TBX_SHAPEUTILS_Roundrec_Popup_Oops
		    ) 
		    list("Cancel" 
			'TBX_SHAPEUTILS_Roundrec_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_SHAPEUTILS_Roundrec_Popup_Cancel() 
    (axlDBTransactionRollback 
	(tbx_shapeutils_data->transMark)
    ) 
    (axlCancelEnterFun) 
    (axlUIPopupSet nil) 
    (axlClearDynamics)
)
procedure(TBX_SHAPEUTILS_Roundrec_Popup_Done() 
    (axlDBTransactionCommit 
	(tbx_shapeutils_data->transMark)
    ) 
    (axlFinishEnterFun) 
    (axlUIPopupSet nil) 
    (axlClearDynamics)
)
procedure(TBX_SHAPEUTILS_Roundrec_Popup_Oops() 
    (axlDBTransactionOops 
	(tbx_shapeutils_data->transMark)
    )
)
procedure(TBX_SHAPEUTILS_Roundrec_Start() 
    let((eventMask loop event xy width
	    height radius center_to_pick layer
	) 
	(axlEventSetStartPopup 
	    'TBX_SHAPEUTILS_Roundrec_Popup
	) 
	(eventMask = list('PICK)) 
	(loop = t) 
	(tbx_shapeutils_data->transMark = (axlDBTransactionStart))
	printf("Pick location ...\n") 
	while(loop 
	    (event = (axlEnterEvent eventMask nil nil)) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(PICK 
		    (axlDBTransactionMark 
			(tbx_shapeutils_data->transMark)
		    ) 
		    (xy = (event->xy)) 
		    (width = (axlFormGetField 
			    (tbx_shapeutils_data->formId) "shape_width"
			)) 
		    (height = (axlFormGetField 
			    (tbx_shapeutils_data->formId) "shape_height"
			))
		    (radius = (axlFormGetField 
			    (tbx_shapeutils_data->formId) "corner_radius"
			)) 
		    (layer = (axlDBControl 
			    'activeLayer
			)) 
		    (center_to_pick = nil) 
		    when((axlFormGetField 
			    (tbx_shapeutils_data->formId) "center_to_pick"
			) 
			(center_to_pick = t)
		    ) 
		    if(((radius > (abs(width) / 2.0)) || (radius > (abs(height) / 2.0))) then 
			printf("Warning: Radius must not be exceed width/2.0 nor height/2.0. Change value\n") else 
			TBX_SHAPEUTILS_Roundrec_Draw_Rectangle(xy width height radius center_to_pick
			    layer
			)
		    )
		) 
		(DONE 
		    (loop = nil)
		) 
		(CANCEL 
		    (loop = nil)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_SHAPEUTILS_Shadow_Mode(onoff) 
    if(onoff then 
	(axlColorShadowSet 
	    'mode t
	) 
	(axlColorShadowSet 
	    'highlighted t
	) 
	(axlColorShadowSet 
	    'activeLayer nil
	)
	else 
	(axlColorShadowSet 
	    'mode nil
	)
    ) 
    (axlVisibleUpdate t)
)
procedure(TBX_SHAPEUTILS_Size_Cache_Param(form_handle) 
    let((rec session_param) 
	(rec = "shapeutils|size") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "contract_mode") 
	    stringToSymbol("contract_mode")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "expand_mode") 
	    stringToSymbol("expand_mode")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "scale_mode") 
	    stringToSymbol("scale_mode")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "offset_value") 
	    stringToSymbol("offset_value")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "scale_value") 
	    stringToSymbol("scale_value")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "void_mode") 
	    stringToSymbol("void_mode")
	)
	putprop(session_param[rec] 
	    car((axlDBGetDesignUnits)) 
	    stringToSymbol("units")
	) t
    )
)
procedure(TBX_SHAPEUTILS_Size_Callback(form_handle) 
    case((form_handle->curField) 
	("contract_mode" 
	    when((form_handle->curValue) 
		(axlFormSetFieldEditable form_handle "offset_value" t) 
		(axlFormSetFieldEditable form_handle "scale_value" nil)
	    ) 
	    (axlFormBuildPopup form_handle "void_mode" 
		(tbx_shapeutils_data->sizePopup)["expand"]
	    )
	) 
	("expand_mode" 
	    when((form_handle->curValue) 
		(axlFormSetFieldEditable form_handle "offset_value" t) 
		(axlFormSetFieldEditable form_handle "scale_value" nil)
	    ) 
	    (axlFormBuildPopup form_handle "void_mode" 
		(tbx_shapeutils_data->sizePopup)["expand"]
	    )
	) 
	("scale_mode" 
	    when((form_handle->curValue) 
		(axlFormSetFieldEditable form_handle "offset_value" nil) 
		(axlFormSetFieldEditable form_handle "scale_value" t)
	    ) 
	    (axlFormBuildPopup form_handle "void_mode" 
		(tbx_shapeutils_data->sizePopup)["scale"]
	    )
	) 
	("void_mode" 
	    case((form_handle->curValue) 
		("ignore_voids" 
		    (axlFormSetField form_handle "msg_info_string" 
			(tbx_shapeutils_data->sizeInfoMsg)["ignore_voids"]
		    )
		) 
		("as_defined" 
		    (axlFormSetField form_handle "msg_info_string" 
			(tbx_shapeutils_data->sizeInfoMsg)["as_defined"]
		    )
		) 
		("odd_processing" 
		    (axlFormSetField form_handle "msg_info_string" 
			(tbx_shapeutils_data->sizeInfoMsg)["odd_processing"]
		    )
		) 
		("even_processing" 
		    (axlFormSetField form_handle "msg_info_string" 
			(tbx_shapeutils_data->sizeInfoMsg)["even_processing"]
		    )
		)
		("scale_voids" 
		    (axlFormSetField form_handle "msg_info_string" 
			(tbx_shapeutils_data->sizeInfoMsg)["scale_voids"]
		    )
		) 
		(t 
		    printf("Unknown argument for shape_mode in Callback: %L\n" 
			(form_handle->curValue)
		    )
		)
	    )
	)
    )
)
procedure(TBX_SHAPEUTILS_Size_Expand_Shape(shape direction offset void_mode) 
    let((arr class_name net_name subclass_name boundary_offset
	    void_offset shape_poly boundary_poly boundary_poly_exp hole_poly_list
	    hole_poly_list_exp tmp_list shape_fill shape_parent parent_groups
	    result shape_list
	) 
	(arr = parseString((shape->layer) "/")) 
	(class_name = car(arr)) 
	(subclass_name = cadr(arr)) 
	(shape_fill = (shape->fill))
	if((((shape->parent)->objType) == "symbol") then 
	    (shape_parent = (shape->parent)) else 
	    (shape_parent = nil)
	) 
	if((shape->net) then 
	    (net_name = ((shape->net)->name)) else 
	    (net_name = nil)
	) 
	if((void_mode == "ignore_voids") then 
	    (boundary_poly = car((axlPolyFromDB shape ?holes nil))) else 
	    (hole_poly_list = list())
	    (shape_poly = car((axlPolyFromDB shape ?holes t))) 
	    foreach(h 
		(shape_poly->holes) 
		(tmp_list = (axlPolyFromHole h)) 
		foreach(hp tmp_list 
		    (hole_poly_list = cons(hp hole_poly_list))
		)
	    ) 
	    (boundary_poly = car((axlPolyFromDB shape ?holes nil)))
	) 
	(parent_groups = (shape->parentGroups)) 
	(axlDeleteObject shape)
	if((direction == "plus") then 
	    (boundary_offset = offset) else 
	    (boundary_offset = (-1.0 * offset))
	) 
	case(void_mode 
	    ("as_defined" 
		(void_offset = 0)
	    ) 
	    ("even_processing" 
		(void_offset = boundary_offset)
	    ) 
	    ("odd_processing" 
		(void_offset = (-1.0 * boundary_offset))
	    )
	) 
	(boundary_poly_exp = car((axlPolyExpand 
		    list(boundary_poly) boundary_offset 
		    'NONE
		)
	    )) 
	if(((void_mode == "even_processing") || (void_mode == "odd_processing")) then 
	    (hole_poly_list_exp = (axlPolyExpand hole_poly_list void_offset 
		    'NONE
		)) else 
	    (hole_poly_list_exp = hole_poly_list)
	) 
	foreach(p 
	    (axlPolyOperation 
		list(boundary_poly_exp) hole_poly_list_exp 
		'ANDNOT
	    ) 
	    (result = (axlDBCreateShape p shape_fill 
		    strcat(class_name "/" subclass_name) net_name
		    shape_parent
		)) 
	    when(result 
		(shape_list = cons(car(result) shape_list))
	    )
	)
	foreach(grp parent_groups 
	    (axlDBAddGroupObjects grp shape_list)
	)
    )
)
procedure(TBX_SHAPEUTILS_Size_OpenMinistatus() 
    let((fid FORM_FILE record) 
	(FORM_FILE = TBX_FORM_Get_Name((tbx_shapeutils_data->licCheck) "shapeutils_size_mini")) 
	(fid = (axlMiniStatusLoad 
		gensym("tbxshapeutilssizemini") FORM_FILE 
		'TBX_SHAPEUTILS_Size_Callback
	    )) 
	(tbx_shapeutils_data->formId = fid) 
	(record = "shapeutils|size")
	TBX_FORM_Init_Header(fid nil 
	    (tbx_shapeutils_data->licCheck) nil
	) 
	(axlFormSetField fid "contract_mode" 
	    TBX_SESSION_Get_Param(record "contract_mode" t)
	) 
	(axlFormSetField fid "expand_mode" 
	    TBX_SESSION_Get_Param(record "expand_mode" nil)
	) 
	(axlFormSetField fid "scale_mode" 
	    TBX_SESSION_Get_Param(record "scale_mode" nil)
	) 
	(axlFormSetField fid "offset_value" 
	    TBX_SESSION_Get_Param(record "offset_value" 0.0 t)
	)
	(axlFormSetField fid "scale_value" 
	    TBX_SESSION_Get_Param(record "scale_value" 1.0)
	) 
	if(((axlFormGetField fid "contract_mode") || 
		(axlFormGetField fid "expand_mode")) then 
	    (axlFormBuildPopup fid "void_mode" 
		(tbx_shapeutils_data->sizePopup)["expand"]
	    ) 
	    (axlFormSetFieldEditable fid "offset_value" t) 
	    (axlFormSetFieldEditable fid "scale_value" nil)
	    else 
	    (axlFormBuildPopup fid "void_mode" 
		(tbx_shapeutils_data->sizePopup)["scale"]
	    ) 
	    (axlFormSetFieldEditable fid "offset_value" nil) 
	    (axlFormSetFieldEditable fid "scale_value" t)
	) 
	(axlFormSetField fid "void_mode" 
	    TBX_SESSION_Get_Param(record "void_mode" "ignore_voids")
	) 
	(axlFormDisplay fid) 
	TBX_FORM_Delete((tbx_shapeutils_data->licCheck) FORM_FILE)
    )
)
procedure(TBX_SHAPEUTILS_Size_Popup(event) 
    let((popup) 
	(event = event) 
	(popup = (axlUIPopupDefine nil 
		list(list("Done" 
			'TBX_SHAPEUTILS_Size_Popup_Done
		    ) 
		    list("Oops" 
			'TBX_SHAPEUTILS_Size_Popup_Oops
		    ) 
		    list("Cancel" 
			'TBX_SHAPEUTILS_Size_Popup_Cancel
		    )
		)
	    )) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_SHAPEUTILS_Size_Popup_Cancel() 
    (axlDBTransactionRollback 
	(tbx_shapeutils_data->transMark)
    ) 
    (axlCancelEnterFun) 
    (axlUIPopupSet nil) 
    (axlClearDynamics)
)
procedure(TBX_SHAPEUTILS_Size_Popup_Done() 
    (axlDBTransactionCommit 
	(tbx_shapeutils_data->transMark)
    ) 
    (axlFinishEnterFun) 
    (axlUIPopupSet nil) 
    (axlClearDynamics)
)
procedure(TBX_SHAPEUTILS_Size_Popup_Oops() 
    (axlDBTransactionOops 
	(tbx_shapeutils_data->transMark)
    )
)
procedure(TBX_SHAPEUTILS_Size_Scale_Poly(seg_list scale_value shape_center) 
    let((new_data prop_list start_x start_y end_x
	    end_y radius arc_center_x arc_center_y ref_x
	    ref_y r_path
	) 
	(ref_x = car(shape_center)) 
	(ref_y = cadr(shape_center)) 
	foreach(item seg_list 
	    cond((((item->objType) == "line") 
		    (start_x = caar((item->startEnd))) 
		    (start_y = cadar((item->startEnd))) 
		    (end_x = caadr((item->startEnd))) 
		    (end_y = cadadr((item->startEnd)))
		    (start_x = (ref_x + ((start_x - ref_x) * scale_value))) 
		    (start_y = (ref_y + ((start_y - ref_y) * scale_value))) 
		    (end_x = (ref_x + ((end_x - ref_x) * scale_value))) 
		    (end_y = (ref_y + ((end_y - ref_y) * scale_value))) 
		    (prop_list = list(nil 
			    'type "line" 
			    'start 
			    (start_x:start_y)
			    'end 
			    (end_x:end_y) 
			    'width 
			    (item->width)
			))
		    (new_data = cons(prop_list new_data))
		) 
		(((item->objType) == "arc") 
		    (start_x = caar((item->startEnd))) 
		    (start_y = cadar((item->startEnd))) 
		    (end_x = caadr((item->startEnd))) 
		    (end_y = cadadr((item->startEnd)))
		    (radius = (item->radius)) 
		    (arc_center_x = car((item->xy))) 
		    (arc_center_y = cadr((item->xy))) 
		    (start_x = (ref_x + ((start_x - ref_x) * scale_value))) 
		    (start_y = (ref_y + ((start_y - ref_y) * scale_value)))
		    (end_x = (ref_x + ((end_x - ref_x) * scale_value))) 
		    (end_y = (ref_y + ((end_y - ref_y) * scale_value))) 
		    (radius = (radius * scale_value)) 
		    (arc_center_x = (ref_x + ((arc_center_x - ref_x) * scale_value))) 
		    (arc_center_y = (ref_y + ((arc_center_y - ref_y) * scale_value)))
		    (prop_list = list(nil 
			    'type "arc" 
			    'start 
			    (start_x:start_y)
			    'end 
			    (end_x:end_y) 
			    'radius radius 
			    'width
			    (item->width) 
			    'center 
			    (arc_center_x:arc_center_y) 
			    'isClockwise 
			    (item->isClockwise)
			    'isCircle 
			    (item->isCircle)
			)) 
		    (new_data = cons(prop_list new_data))
		) 
		(t t)
	    )
	) 
	(new_data = reverse(new_data))
	foreach(item new_data 
	    if(((get(item 
			    'type
			) == "arc") && get(item 
			'isCircle
		    )) then 
		(r_path = (axlPathStartCircle 
			list(get(item 
				'center
			    ) 
			    get(item 
				'radius
			    )
			) 
			get(item 
			    'width
			)
		    )) else 
		unless(r_path 
		    (r_path = (axlPathStart 
			    list(get(item 
				    'start
				)
			    )
			))
		)
		cond(((get(item 
				'type
			    ) == "line") 
			(r_path = (axlPathLine r_path 
				get(item 
				    'width
				) 
				get(item 
				    'end
				)
			    ))
		    ) 
		    ((get(item 
				'type
			    ) == "arc") 
			(r_path = (axlPathArcCenter r_path 
				get(item 
				    'width
				) 
				get(item 
				    'end
				) 
				get(item 
				    'isClockwise
				)
				get(item 
				    'center
				)
			    ))
		    ) 
		    (t t)
		)
	    )
	) r_path
    )
)
procedure(TBX_SHAPEUTILS_Size_Scale_Shape(shape scale_value void_mode) 
    let((arr class_name net_name subclass_name shape_fill
	    parent_id shape_center boundary_path void_path_list void_path
	    o_shape result parent_groups
	) 
	(shape_fill = (shape->fill)) 
	if((((shape->parent)->objType) == "symbol") then 
	    (parent_id = (shape->parent)) else 
	    (parent_id = nil)
	) 
	(arr = parseString((shape->layer) "/")) 
	(class_name = car(arr))
	(subclass_name = cadr(arr)) 
	if((shape->net) then 
	    (net_name = ((shape->net)->name)) else 
	    (net_name = nil)
	) 
	(shape_center = TBX_SHAPEUTILS_Get_Shape_Center(shape)) 
	(boundary_path = TBX_SHAPEUTILS_Size_Scale_Poly((shape->segments) scale_value shape_center)) 
	if((void_mode == "ignore_voids") then 
	    (void_path_list = list()) else 
	    foreach(vd 
		(shape->voids) 
		(void_path = TBX_SHAPEUTILS_Size_Scale_Poly((vd->segments) scale_value shape_center)) 
		(void_path_list = cons(void_path void_path_list))
	    )
	)
	(parent_groups = (shape->parentGroups)) 
	(axlDeleteObject shape) 
	(o_shape = (axlDBCreateOpenShape boundary_path shape_fill 
		strcat(class_name "/" subclass_name) net_name
		parent_id
	    )) 
	foreach(r_path void_path_list 
	    (axlDBCreateVoid o_shape r_path)
	) 
	(result = (axlDBCreateCloseShape o_shape))
	when(result 
	    foreach(grp parent_groups 
		(axlDBAddGroupObjects grp 
		    car(result)
		)
	    )
	) t
    )
)
procedure(TBX_SHAPEUTILS_Size_Start() 
    let((eventMask loop event void_mode offset_value
	    scale_value
	) 
	(axlEventSetStartPopup 
	    'TBX_SHAPEUTILS_Size_Popup
	) 
	(eventMask = list('PICK)) 
	(loop = t) 
	(tbx_shapeutils_data->transMark = (axlDBTransactionStart))
	printf("Pick source shape...\n") 
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    (tbx_shapeutils_data->sizeFFen) ?onButtons 
	    (tbx_shapeutils_data->sizeFFon)
	) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil nil)) 
	    (axlClearDynamics) 
	    caseq((event->type) 
		(PICK 
		    (axlDBTransactionMark 
			(tbx_shapeutils_data->transMark)
		    ) 
		    (axlSingleSelectPoint 
			(event->xy)
		    ) 
		    (void_mode = (axlFormGetField 
			    (tbx_shapeutils_data->formId) "void_mode"
			)) 
		    (scale_value = (axlFormGetField 
			    (tbx_shapeutils_data->formId) "scale_value"
			))
		    when((axlGetSelSet) 
			cond(((axlFormGetField 
				    (tbx_shapeutils_data->formId) "contract_mode"
				) 
				(offset_value = (axlFormGetField 
					(tbx_shapeutils_data->formId) "offset_value"
				    )) 
				TBX_SHAPEUTILS_Size_Expand_Shape(car((axlGetSelSet)) "minus" offset_value void_mode)
			    ) 
			    ((axlFormGetField 
				    (tbx_shapeutils_data->formId) "expand_mode"
				) 
				(offset_value = (axlFormGetField 
					(tbx_shapeutils_data->formId) "offset_value"
				    )) 
				TBX_SHAPEUTILS_Size_Expand_Shape(car((axlGetSelSet)) "plus" offset_value void_mode)
			    ) 
			    ((axlFormGetField 
				    (tbx_shapeutils_data->formId) "scale_mode"
				) 
				(scale_value = (axlFormGetField 
					(tbx_shapeutils_data->formId) "scale_value"
				    )) 
				TBX_SHAPEUTILS_Size_Scale_Shape(car((axlGetSelSet)) scale_value void_mode)
			    )
			)
		    ) 
		    (axlClearSelSet)
		) 
		(DONE 
		    (loop = nil)
		) 
		(CANCEL 
		    (loop = nil)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_SHIELDGEN_Add_Shield_Via(xy via_name) 
    let((shield_item etch_shapes net_names cur_net_name result) 
	(shield_item = TBX_SHIELDGEN_Select_Shield(xy)) 
	if(shield_item then 
	    if(((shield_item->objType) == "symbol") then 
		(etch_shapes = setof(es 
			(shield_item->etchChildren) 
			(((es->objType) == "shape") && (es->net))
		    )) else 
		(etch_shapes = setof(es 
			(shield_item->groupMembers) 
			(((es->objType) == "shape") && (es->net))
		    ))
	    ) 
	    (net_names = mapcar(lambda((x) 
			((x->net)->name)
		    ) etch_shapes
		)) 
	    (net_names = sort(net_names nil))
	    (cur_net_name = car(net_names)) 
	    (axlDBTransactionMark 
		(tbx_shieldgen_global->transMark)
	    ) 
	    unless(cur_net_name 
		printf("Warning: No net name detected for shield. Adding dummy via at %L.\n" xy)
	    ) 
	    if(((shield_item->objType) == "symbol") then 
		(result = (axlDBCreateVia via_name xy cur_net_name nil
			0.0 shield_item
		    )) else 
		(result = (axlDBCreateVia via_name xy cur_net_name nil
			0.0 nil
		    ))
		when(car(result) 
		    (axlDBAddGroupObjects shield_item 
			car(result)
		    )
		)
	    ) else
	    printf("No valid shield detected near %L. Adjust visibility if necessary.\n" xy)
	) t
    )
)
procedure(TBX_SHIELDGEN_Cache_Param(form_handle) 
    let((rec session_param field_list) 
	(rec = "shieldgen") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	(field_list = list("shield_mode" "rectangle_width" "rectangle_height" "direction" "path_offset"
		"net_name" "create_shapes" "shape_width" "shape_type" "create_vias"
		"via_gap" "via_path_offset" "via_initial_offset" "via_name" "create_mask"
		"mask_side" "create_symbol" "snap_grid" "grid_value"
	    ))
	foreach(fn field_list 
	    putprop(session_param[rec] 
		(axlFormGetField form_handle fn) 
		stringToSymbol(fn)
	    )
	) 
	putprop(session_param[rec] 
	    car((axlDBGetDesignUnits)) 
	    stringToSymbol("units")
	) 
	putprop(session_param[rec] 
	    (tbx_shieldgen_global->etchLayersGeneric) 
	    stringToSymbol("etch_layers")
	) t
    )
)
procedure(TBX_SHIELDGEN_Calculate_Path(master_path direction path_offset via_path_offset) 
    let((rpath path_poly offset boundary_poly) 
	(boundary_poly = car((axlPolyFromDB master_path))) 
	(path_offset = abs(path_offset)) 
	case(direction 
	    ("outside" 
		(offset = (path_offset + via_path_offset))
	    ) 
	    ("centric" 
		(offset = (0.0 + via_path_offset))
	    ) 
	    ("inside" 
		(offset = ((- path_offset) + via_path_offset))
	    )
	) 
	(path_poly = car((axlPolyExpand boundary_poly offset 
		    'NONE
		)
	    ))
	(rpath = TBX_DBCORE_Rpath_From_Poly(path_poly)) rpath
    )
)
procedure(TBX_SHIELDGEN_Calculate_Shield_Polygon(master_path direction path_offset shape_width mode) 
    let((outer_poly inner_poly ring_poly w_half result
	    boundary_poly
	) 
	(boundary_poly = car((axlPolyFromDB master_path))) 
	(path_offset = abs(path_offset)) 
	(shape_width = abs(shape_width)) 
	(w_half = (shape_width / 2.0))
	case(direction 
	    ("outside" 
		(outer_poly = car((axlPolyExpand boundary_poly 
			    (path_offset + w_half) 
			    'NONE
			)
		    )) 
		(inner_poly = car((axlPolyExpand boundary_poly 
			    (path_offset - w_half) 
			    'NONE
			)
		    ))
	    ) 
	    ("centric" 
		(outer_poly = car((axlPolyExpand boundary_poly 
			    (0.0 + w_half) 
			    'NONE
			)
		    )) 
		(inner_poly = car((axlPolyExpand boundary_poly 
			    (0.0 - w_half) 
			    'NONE
			)
		    ))
	    ) 
	    ("inside" 
		(outer_poly = car((axlPolyExpand boundary_poly 
			    ((- path_offset) + w_half) 
			    'NONE
			)
		    )) 
		(inner_poly = car((axlPolyExpand boundary_poly 
			    ((- path_offset) - w_half) 
			    'NONE
			)
		    ))
	    )
	) 
	when((outer_poly && inner_poly) 
	    case(mode 
		("boundary" 
		    (result = list(outer_poly inner_poly))
		) 
		("decompose" 
		    (result = list(TBX_DBCORE_Rpath_From_Poly(outer_poly) 
			    TBX_DBCORE_Rpath_From_Poly(inner_poly)
			))
		) 
		("regular" 
		    (result = car((axlPolyOperation outer_poly inner_poly 
				'ANDNOT
			    )
			))
		) 
		("split" 
		    (ring_poly = car((axlPolyOperation outer_poly inner_poly 
				'ANDNOT
			    )
			)) 
		    when(ring_poly 
			(result = TBX_SHIELDGEN_Split_Polygon(ring_poly 
				((tbx_shieldgen_global->layer)->tmp)
			    ))
		    )
		)
	    )
	) result
    )
)
procedure(TBX_SHIELDGEN_Calculate_Via_Locations(lo_rpath via_gap initial_offset) 
    let((PI rseg_list start_xy end_xy center_xy
	    radius is_clockwise is_circle arc_angle seg_length
	    via_xy all_locations cur_locations cur_endpoints rpath_list
	    arc_vec line_vec spin_vec size_vec cur_offset
	    cur_offset_angle stub_length stub_angle tmp_data dist
	    first_via_xy last_via_xy tmp_flag path_start_xy path_end_xy
	) 
	(PI = (defMathConstants('mymathconst)->PI)) 
	if((type(lo_rpath) == '_axlPath) then 
	    (rpath_list = list(lo_rpath)) else 
	    (rpath_list = lo_rpath)
	) 
	foreach(rpath rpath_list 
	    (cur_locations = nil) 
	    (cur_endpoints = nil) 
	    (rseg_list = (axlPathGetPathSegs rpath))
	    (start_xy = (axlPathSegGetEndPoint 
		    car(rseg_list)
		)) 
	    if(!cur_offset then 
		(cur_offset = initial_offset) else 
		(tmp_data = mapcar(lambda((x) 
			    (axlDistance x start_xy)
			) all_locations
		    ))
		(tmp_data = sort(tmp_data 
			'lessp
		    )) 
		(dist = car(tmp_data)) 
		when(dist 
		    if((dist < via_gap) then 
			(cur_offset = (via_gap - dist)) else 
			(cur_offset = 0.0)
		    )
		)
	    ) 
	    (cur_endpoints = cons(start_xy cur_endpoints)) 
	    foreach(rseg 
		cdr(rseg_list) 
		(end_xy = (axlPathSegGetEndPoint rseg)) 
		(center_xy = (axlPathSegGetArcCenter rseg)) 
		if(center_xy then 
		    (is_clockwise = (axlPathSegGetArcClockwise rseg)) 
		    when(((axlGeo2Str start_xy) == 
			    (axlGeo2Str end_xy)) 
			(is_circle = t)
		    ) 
		    (arc_vec = TBX_MATH_Get_Vector(center_xy start_xy))
		    (arc_angle = TBX_GEOM_Get_Arc_Spin_Angle(start_xy end_xy center_xy is_clockwise is_circle)) 
		    (radius = (axlDistance center_xy start_xy)) 
		    (seg_length = ((2.0 * PI * radius * abs(arc_angle)) / 360.0)) else 
		    (line_vec = TBX_MATH_Get_Vector(start_xy end_xy))
		    (seg_length = (axlDistance start_xy end_xy))
		)
		if((cur_offset > seg_length) then 
		    (cur_offset = (cur_offset - seg_length)) else 
		    while((cur_offset <= seg_length) 
			(via_xy = nil) 
			if(center_xy then 
			    (cur_offset_angle = ((cur_offset / seg_length) * arc_angle)) 
			    (spin_vec = TBX_MATH_Transform_Vector(arc_vec ?angle cur_offset_angle)) 
			    (via_xy = TBX_MATH_Add_Vector(center_xy 
				    list(spin_vec)
				))
			    (stub_angle = (abs(arc_angle) - abs(cur_offset_angle))) 
			    (stub_length = abs(((stub_angle / arc_angle) * seg_length))) else 
			    (size_vec = TBX_MATH_Transform_Vector(line_vec ?size cur_offset)) 
			    (via_xy = TBX_MATH_Add_Vector(start_xy 
				    list(size_vec)
				))
			    (stub_length = (seg_length - cur_offset))
			) 
			when(via_xy 
			    (cur_locations = cons(via_xy cur_locations))
			) 
			(cur_offset = (cur_offset + via_gap))
		    )
		    if((stub_length < via_gap) then 
			(cur_offset = (via_gap - stub_length)) else 
			(cur_offset = 0.0)
		    )
		) 
		(start_xy = end_xy) 
		(cur_endpoints = cons(start_xy cur_endpoints))
	    ) 
	    (cur_endpoints = reverse(cur_endpoints))
	    when((cur_endpoints && !tmp_flag) 
		TBX_SHIELDGEN_Mark_Points(cur_endpoints) 
		(tmp_flag = t)
	    ) 
	    when((length(cur_locations) >= 2) 
		(last_via_xy = car(cur_locations)) 
		(first_via_xy = (lastelem cur_locations)) 
		(path_start_xy = car(cur_endpoints)) 
		(path_end_xy = (lastelem cur_endpoints))
		if(((axlGeo2Str path_start_xy) == 
			(axlGeo2Str path_end_xy)) then 
		    when(((axlDistance last_via_xy first_via_xy) < 
			    (0.9 * via_gap)) 
			(cur_locations = cdr(cur_locations))
		    ) else 
		    (tmp_data = mapcar(lambda((x) 
				(axlDistance x last_via_xy)
			    ) all_locations
			))
		    (tmp_data = sort(tmp_data 
			    'lessp
			)) 
		    (dist = car(tmp_data)) 
		    when((dist && (dist < (0.9 * via_gap))) 
			(cur_locations = cdr(cur_locations))
		    )
		)
	    ) 
	    (cur_locations = reverse(cur_locations)) 
	    when(cur_locations 
		(all_locations = nconc(all_locations cur_locations))
	    )
	) all_locations
    )
)
procedure(TBX_SHIELDGEN_Callback(form_handle) 
    let((result msg) 
	TBX_SHIELDGEN_Cache_Param(form_handle) 
	case((form_handle->curField) 
	    ("shield_mode" 
		TBX_SHIELDGEN_Init_Next() 
		TBX_SHIELDGEN_Update_Form(form_handle) 
		TBX_SHIELDGEN_Update_Dynamics(form_handle) 
		TBX_SHIELDGEN_Update_Mask(form_handle)
	    ) 
	    ("shield_mode_tip" 
		(msg = nil) 
		case((axlFormGetField form_handle "shield_mode") 
		    ("select_boundary" 
			(msg = "Select a shape (e.g. Design Outline, Route Keepin) along which a shield shall be created.")
		    ) 
		    ("draw_rectangle" 
			(msg = "Draw a rectangle boundary for shield generation.")
		    ) 
		    ("place_rectangle" 
			(msg = "Specifies rectangle boundary with given width and height for shield generation.")
		    ) 
		    ("derive_from_line" 
			(msg = "In this mode you can select construction lines from etch or non-etch layers from which a shield will be created. Vias (if enabled) will be created along center path of segments. ") 
			(msg = sprintf(nil "%sNote: For shape creation selected segments must have width greater than 0." msg))
		    )
		    ("cut_mask" 
			(msg = "In this mode you can cut existing mask shapes by box with given width and height. Note: The procedure will only process existing mask shapes that belong to a shield symbol/group. ") 
			(msg = sprintf(nil "%s Pay attention to \"Create Mask\" option while generating the shield." msg))
		    ) 
		    ("delete_shield" 
			(msg = "Deletes a shield from database.")
		    ) 
		    ("add_shield_via" 
			(msg = "Adds a via to a shield  symbol/group. If no shield was detected near pick location, the operation will fail.")
		    ) 
		    ("delete_shield_via" 
			(msg = "Deletes via from shield. Only vias which belong to a shield symbol/group will be processed.")
		    )
		) 
		when(msg 
		    (axlUIConfirm msg)
		)
	    ) 
	    ("rectangle_width" 
		TBX_SHIELDGEN_Update_Dynamics(form_handle)
	    ) 
	    ("rectangle_height" 
		TBX_SHIELDGEN_Update_Dynamics(form_handle)
	    )
	    ("snap_grid" 
		TBX_SHIELDGEN_Update_Mask(form_handle) 
		TBX_SHIELDGEN_Update_Form(form_handle) 
		when((form_handle->curValue) 
		    TBX_DBDISPLAY_Canvas_Grid('setGrid 
			(axlFormGetField form_handle "grid_value")
		    )
		)
	    ) 
	    ("grid_value" 
		when((axlFormGetField form_handle "snap_grid") 
		    TBX_DBDISPLAY_Canvas_Grid('setGrid 
			(form_handle->curValue)
		    )
		)
	    ) 
	    ("direction" 
		TBX_SHIELDGEN_Update_Form(form_handle) 
		TBX_SHIELDGEN_Update_Dynamics(form_handle)
	    ) 
	    ("path_offset" 
		TBX_SHIELDGEN_Update_Dynamics(form_handle)
	    ) 
	    ("path_offset_tip" 
		(msg = "Specifies the clearance from specified boundary to center path of the ring.") 
		(axlUIConfirm msg)
	    )
	    ("net_name" t) 
	    ("browse_net" 
		(axlClearSelSet) 
		(result = (axlUIDataBrowse 
			'NET 
			list('RETRIEVE_NAME) "Select net" t
		    )) 
		when(result 
		    (axlFormSetField form_handle "net_name" 
			car(result)
		    )
		)
	    ) 
	    ("create_shapes" 
		TBX_SHIELDGEN_Update_Form(form_handle) 
		TBX_SHIELDGEN_Update_Dynamics(form_handle)
	    ) 
	    ("shape_width" 
		TBX_SHIELDGEN_Update_Dynamics(form_handle)
	    ) 
	    ("specify_layers" 
		(tbx_shieldgen_global->etchLayersGeneric = TBX_FORM_Specify_Etch_Layers((tbx_shieldgen_global->etchLayersGeneric)))
	    )
	    ("create_vias" 
		TBX_SHIELDGEN_Update_Form(form_handle) 
		TBX_SHIELDGEN_Update_Dynamics(form_handle)
	    ) 
	    ("via_gap" 
		TBX_SHIELDGEN_Update_Dynamics(form_handle)
	    ) 
	    ("via_gap_tip" 
		(msg = "Specifies center to center clearance between vias.") 
		(axlUIConfirm msg)
	    ) 
	    ("via_path_offset" 
		TBX_SHIELDGEN_Update_Dynamics(form_handle)
	    ) 
	    ("via_path_offset_tip" 
		(msg = "Specifies relative offset from center path of the ring. Value can be positive or negative. For positve value via path will expand from center path.") 
		(axlUIConfirm msg)
	    )
	    ("via_initial_offset" 
		TBX_SHIELDGEN_Update_Dynamics(form_handle)
	    ) 
	    ("via_initial_offset_tip" 
		(msg = "Specifies the intial offset from polygon starting point at which the first via will be placed. Can be used to tune via locations inside the shield.") 
		(axlUIConfirm msg)
	    ) 
	    ("via_name" t) 
	    ("browse_via" 
		(axlClearSelSet) 
		(result = (axlUIDataBrowse 
			'PADSTACK 
			'(EXAMINE_DATABASE EXAMINE_LIBRARY RETRIEVE_NAME) "Select a padstack" t
		    )) 
		when(result 
		    (axlFormSetField form_handle "via_name" 
			car(result)
		    )
		)
	    ) 
	    ("create_symbol" t)
	    ("create_symbol_tip" 
		(msg = "By default a group object will be created for ring shapes and vias (Find Filter Groups).  If enabled a mechanical symbol will be created instead.") 
		(axlUIConfirm msg)
	    ) 
	    ("apply" 
		(axlDBTransactionMark 
		    (tbx_shieldgen_global->transMark)
		) 
		TBX_SHIELDGEN_Generate_Shield(form_handle) 
		TBX_SHIELDGEN_Init_Next()
	    ) 
	    ("done" 
		(axlFinishEnterFun)
	    ) 
	    ("myhelp" 
		TBX_HELP_Launch("shieldgen")
	    ) 
	    (t t)
	)
    )
)
procedure((TBX_SHIELDGEN_Create_Shapes poly_data shape_layers net_name parent_dbid
	\@optional offset
    ) 
    let((poly_list result attach_dbid shape_list) 
	(poly_list = poly_data) 
	when(((parent_dbid->objType) == "symbol") 
	    when(offset 
		(poly_list = (axlPolyOffset poly_data offset t))
	    ) 
	    (attach_dbid = parent_dbid)
	) 
	foreach(lyr shape_layers 
	    foreach(pl poly_list 
		(result = (axlDBCreateShape pl t lyr net_name
			attach_dbid
		    )) 
		when(car(result) 
		    (shape_list = cons(car(result) shape_list))
		)
	    )
	) 
	when(((parent_dbid->objType) == "group") 
	    (axlDBAddGroupObjects parent_dbid shape_list)
	)
	t
    )
)
procedure(TBX_SHIELDGEN_Create_Symbol_Definition() 
    let((symdef_names symdef free_id cnt symbol_name
	    min_size def_extents
	) 
	(min_size = (axlMKSConvert "100.0 MILS" 
		car((axlDBGetDesignUnits))
	    )) 
	(def_extents = list(((- min_size):(- min_size)) 
		(min_size:min_size)
	    )) 
	(symdef_names = mapcar(lambda((x) 
		    (x->name)
		) 
		(axlSelectByName "SYMTYPE" "SHIELDGEN*" t)
	    )) 
	(cnt = 1)
	while((!free_id && (cnt <= 1000)) 
	    unless(rexMatchList(sprintf(nil "^SHIELDGEN_%d" cnt) symdef_names) 
		(free_id = cnt)
	    ) 
	    ++cnt
	) 
	if(free_id then 
	    (symbol_name = sprintf(nil "SHIELDGEN_%d" free_id)) 
	    (symdef = (axlDBCreateSymDefSkeleton 
		    list(symbol_name "mechanical") def_extents
		)) else
	    printf("Error: Cannot derive next free group\n")
	) 
	(axlClearSelSet) symdef
    )
)
procedure((TBX_SHIELDGEN_Create_Vias pt_list padstack_name net_name parent_dbid
	\@optional offset
    ) 
    let((attach_dbid via_list result) 
	when(((parent_dbid->objType) == "symbol") 
	    when(offset 
		(pt_list = TBX_GEOM_Add_Offset(pt_list offset))
	    ) 
	    (attach_dbid = parent_dbid)
	) 
	foreach(pt pt_list 
	    (result = (axlDBCreateVia padstack_name pt net_name nil
		    0.0 attach_dbid
		)) 
	    when(car(result) 
		(via_list = cons(car(result) via_list))
	    )
	) 
	when(((parent_dbid->objType) == "group") 
	    (axlDBAddGroupObjects parent_dbid via_list)
	) t
    )
)
procedure(TBX_SHIELDGEN_Cut_Mask(xy width height side) 
    let((mask_layers user_box h_half w_half cut_poly
	    shield_item mask_shapes cur_layer mask_poly poly_data
	    result
	) 
	(w_half = (width / 2.0)) 
	(h_half = (height / 2.0)) 
	case(side 
	    ("top" 
		(mask_layers = list(((tbx_shieldgen_global->layer)->smTop) 
			((tbx_shieldgen_global->layer)->pmTop)
		    ))
	    ) 
	    ("bottom" 
		(mask_layers = list(((tbx_shieldgen_global->layer)->smBottom) 
			((tbx_shieldgen_global->layer)->pmBottom)
		    ))
	    ) 
	    ("both" 
		(mask_layers = list(((tbx_shieldgen_global->layer)->smTop) 
			((tbx_shieldgen_global->layer)->pmTop) 
			((tbx_shieldgen_global->layer)->smBottom) 
			((tbx_shieldgen_global->layer)->pmBottom)
		    ))
	    )
	) 
	(user_box = list(((car(xy) - w_half):(cadr(xy) - h_half)) 
		((car(xy) + w_half):(cadr(xy) + h_half))
	    ))
	(cut_poly = TBX_DBCORE_Poly_From_Box(user_box)) 
	(shield_item = TBX_SHIELDGEN_Select_Shield(user_box)) 
	when(shield_item 
	    if(((shield_item->objType) == "symbol") then 
		(mask_shapes = setof(m 
			(shield_item->children) 
			(((m->objType) == "shape") && member((m->layer) mask_layers))
		    )) else 
		(mask_shapes = setof(m 
			(shield_item->groupMembers) 
			(((m->objType) == "shape") && member((m->layer) mask_layers))
		    ))
	    ) 
	    (axlDBTransactionMark 
		(tbx_shieldgen_global->transMark)
	    ) 
	    foreach(mshp mask_shapes 
		(cur_layer = (mshp->layer)) 
		(mask_poly = car((axlPolyFromDB mshp))) 
		(poly_data = (axlPolyOperation mask_poly cut_poly 
			'ANDNOT
		    ))
		when(car(poly_data) 
		    if(((shield_item->objType) == "symbol") then 
			foreach(pl poly_data 
			    (axlDBCreateShape pl t cur_layer nil
				shield_item
			    )
			) else 
			foreach(pl poly_data 
			    (result = (axlDBCreateShape pl t cur_layer nil
				    nil
				)) 
			    when(car(result) 
				(axlDBAddGroupObjects shield_item 
				    car(result)
				)
			    )
			)
		    )
		) 
		(axlDeleteObject mshp)
	    )
	)
    )
)
procedure(TBX_SHIELDGEN_Delete(elem) 
    let((a) 
	(a = a) 
	when(rexMatchp("^SHIELDGEN_" 
		upperCase((elem->name))
	    ) 
	    cond((((elem->objType) == "group") 
		    (axlDeleteObject 
			(elem->groupMembers)
		    ) 
		    (axlDBDisbandGroup elem)
		) 
		(((elem->objType) == "symbol") 
		    (axlDeleteObject elem)
		)
	    )
	) 
	(axlDBRefreshId nil) t
    )
)
procedure(TBX_SHIELDGEN_Delete_Shield_Via(lo_arg) 
    let((shield_item via_items) 
	(shield_item = TBX_SHIELDGEN_Select_Shield(lo_arg)) 
	if(shield_item then 
	    (axlClearSelSet) 
	    (axlSetFindFilter ?enabled 
		list("noall" "vias") ?onButtons 
		list("all")
	    ) 
	    if((isBoxp lo_arg) then 
		(axlSingleSelectBox lo_arg) else 
		(axlSingleSelectPoint lo_arg)
	    )
	    (via_items = (axlGetSelSet)) 
	    when((axlGetSelSet) 
		(axlClearSelSet) 
		(axlDBTransactionMark 
		    (tbx_shieldgen_global->transMark)
		) 
		(axlDeleteObject via_items) 
		(axlDBRefreshId shield_item)
	    ) else 
	    printf("No valid shield detected near %L. Adjust visibility if necessary.\n" lo_arg)
	) t
    )
)
procedure(TBX_SHIELDGEN_Event_Loop(form_handle) 
    let((loop event start_pick bBox) 
	(loop = t) 
	(axlEventSetStartPopup 
	    'TBX_SHIELDGEN_Popup_Callback
	) 
	(tbx_shieldgen_global->transMark = (axlDBTransactionStart)) 
	(axlClearSelSet)
	while(loop 
	    (event = (axlEnterEvent 
		    ((tbx_shieldgen_global->event)->mask) nil 
		    ((tbx_shieldgen_global->event)->snapGrid)
		)) 
	    caseq((event->type) 
		(PICK 
		    unless(((tbx_shieldgen_global->runTime)->ok2Apply) 
			TBX_SHIELDGEN_Event_Validate(form_handle 
			    (event->xySnap) 
			    (event->type)
			) 
			TBX_SHIELDGEN_Update_Dynamics(form_handle)
		    )
		) 
		(PICK_TOGGLE 
		    unless(((tbx_shieldgen_global->runTime)->ok2Apply) 
			TBX_SHIELDGEN_Event_Validate(form_handle 
			    (event->xySnap) 
			    (event->type)
			) 
			TBX_SHIELDGEN_Update_Dynamics(form_handle)
		    )
		) 
		(STARTDRAG 
		    (axlAddSimpleRbandDynamics 
			(event->xySnap) "box" ?origin 
			(0.0:0.0)
		    ) 
		    (start_pick = (event->xySnap))
		) 
		(STOPDRAG 
		    (bBox = list(start_pick 
			    (event->xySnap)
			)) 
		    (axlClearDynamics) 
		    (start_pick = nil) 
		    unless(((tbx_shieldgen_global->runTime)->ok2Apply) 
			TBX_SHIELDGEN_Event_Validate(form_handle bBox 
			    (event->type)
			) 
			TBX_SHIELDGEN_Update_Dynamics(form_handle)
		    )
		)
		(STARTDRAG_TOGGLE 
		    (axlAddSimpleRbandDynamics 
			(event->xySnap) "box" ?origin 
			(0.0:0.0)
		    ) 
		    (start_pick = (event->xySnap))
		) 
		(STOPDRAG_TOGGLE 
		    (bBox = list(start_pick 
			    (event->xySnap)
			)) 
		    (axlClearDynamics) 
		    (start_pick = nil) 
		    unless(((tbx_shieldgen_global->runTime)->ok2Apply) 
			TBX_SHIELDGEN_Event_Validate(form_handle bBox 
			    (event->type)
			) 
			TBX_SHIELDGEN_Update_Dynamics(form_handle)
		    )
		) 
		(DONE 
		    (axlFormClose form_handle) 
		    (axlDBTransactionCommit 
			(tbx_shieldgen_global->transMark)
		    ) 
		    (loop = nil)
		) 
		(CANCEL 
		    cond((((tbx_shieldgen_global->event)->maskChange) 
			    ((tbx_shieldgen_global->event)->maskChange = nil)
			) 
			(((tbx_shieldgen_global->runTime)->initNext) 
			    ((tbx_shieldgen_global->runTime)->initNext = nil) 
			    TBX_SHIELDGEN_Update_Dynamics(form_handle)
			) 
			(t 
			    (loop = nil) 
			    (axlFormClose form_handle)
			)
		    )
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_SHIELDGEN_Event_Validate(form_handle arg event_type) 
    let((shp shield_mode box_width box_height mask_side
	    item via_name
	) 
	(shield_mode = (axlFormGetField form_handle "shield_mode")) 
	(box_width = (axlFormGetField form_handle "rectangle_width")) 
	(box_height = (axlFormGetField form_handle "rectangle_height")) 
	(via_name = (axlFormGetField form_handle "via_name"))
	(mask_side = (axlFormGetField form_handle "mask_side")) 
	cond(((shield_mode == "select_boundary") 
		(axlSetFindFilter ?enabled 
		    list("noall" "boundary_shapes" "shapes") ?onButtons 
		    list("all")
		) 
		(axlClearSelSet) 
		if((isBoxp arg) then 
		    (axlSingleSelectBox arg) else 
		    (axlSingleSelectPoint arg)
		) 
		when((axlGetSelSet) 
		    (shp = car((axlGetSelSet))) 
		    (axlClearSelSet) 
		    ((tbx_shieldgen_global->runTime)->boundaryShape = shp) 
		    ((tbx_shieldgen_global->runTime)->ok2Apply = t)
		)
	    ) 
	    (((shield_mode == "draw_rectangle") && !((tbx_shieldgen_global->runTime)->userBox)) 
		((tbx_shieldgen_global->runTime)->userBox = TBX_UTIL_Normalize_Box(arg)) 
		((tbx_shieldgen_global->runTime)->ok2Apply = t)
	    ) 
	    (((shield_mode == "place_rectangle") && !((tbx_shieldgen_global->runTime)->userPick)) 
		((tbx_shieldgen_global->runTime)->userPick = arg) 
		((tbx_shieldgen_global->runTime)->ok2Apply = t)
	    ) 
	    (((shield_mode == "derive_from_line") && ((tbx_shieldgen_global->runTime)->selectMode)) 
		(axlSetFindFilter ?enabled 
		    list("noall" "clines" "lines") ?onButtons 
		    list("all")
		) 
		cond((((event_type == 'PICK) || (event_type == 'STOPDRAG)) 
			if((isBoxp arg) then 
			    (axlAddSelectBox arg) else 
			    (axlAddSelectPoint arg)
			)
		    ) 
		    (((event_type == 'PICK_TOGGLE) || (event_type == 'STOPDRAG_TOGGLE)) 
			if((isBoxp arg) then 
			    (axlSubSelectBox arg) else 
			    (axlSubSelectPoint arg)
			)
		    )
		)
	    ) 
	    ((shield_mode == "cut_mask") 
		(axlDBRefreshId nil) 
		TBX_SHIELDGEN_Cut_Mask(arg box_width box_height mask_side)
	    )
	    ((shield_mode == "add_shield_via") 
		(axlDBRefreshId nil) 
		if((via_name && (via_name != "")) then 
		    TBX_SHIELDGEN_Add_Shield_Via(arg via_name) else 
		    printf("Specify valid via first.\n")
		)
	    ) 
	    ((shield_mode == "delete_shield_via") 
		(axlDBRefreshId nil) 
		TBX_SHIELDGEN_Delete_Shield_Via(arg)
	    ) 
	    ((shield_mode == "delete_shield") 
		(axlSetFindFilter ?enabled 
		    list("noall" "groups" "symbols") ?onButtons 
		    list("groups" "symbols")
		) 
		(axlClearSelSet) 
		(axlSingleSelectPoint arg) 
		(item = car((axlGetSelSet)))
		when(item 
		    (axlDBTransactionMark 
			(tbx_shieldgen_global->transMark)
		    ) 
		    TBX_SHIELDGEN_Delete(item)
		)
	    ) 
	    (t 
		((tbx_shieldgen_global->runTime)->boundaryShape = nil) 
		((tbx_shieldgen_global->runTime)->userBox = nil) 
		((tbx_shieldgen_global->runTime)->userPick = nil)
	    )
	)
    )
)
procedure(TBX_SHIELDGEN_Generate_Shield(form_handle) 
    let((rpath_via symbol_margin cur_extents via_path_offset via_gap
	    location_list via_initial_offset via_name direction path_offset
	    shape_width create_symbol symbol_origin group_dbid symdef
	    rect_width rect_height rpath mask_side net_name
	    shape_type shape_layers shape_class line_poly tmp_data
	    rpath_list creation_mode create_shapes create_vias create_mask
	    mask_layers syminst result center_path_data ref_path
	    shield_poly_data first_seg last_seg ref_poly
	) 
	(creation_mode = (axlFormGetField form_handle "shield_mode")) 
	(create_shapes = (axlFormGetField form_handle "create_shapes")) 
	(create_vias = (axlFormGetField form_handle "create_vias")) 
	(create_mask = (axlFormGetField form_handle "create_mask"))
	(create_symbol = (axlFormGetField form_handle "create_symbol")) 
	(rect_width = (axlFormGetField form_handle "rectangle_width")) 
	(rect_height = (axlFormGetField form_handle "rectangle_height")) 
	(direction = (axlFormGetField form_handle "direction")) 
	(path_offset = (axlFormGetField form_handle "path_offset"))
	(net_name = (axlFormGetField form_handle "net_name")) 
	(shape_width = (axlFormGetField form_handle "shape_width")) 
	(shape_type = (axlFormGetField form_handle "shape_type")) 
	(via_path_offset = (axlFormGetField form_handle "via_path_offset")) 
	(via_gap = (axlFormGetField form_handle "via_gap"))
	(via_initial_offset = (axlFormGetField form_handle "via_initial_offset")) 
	(via_name = (axlFormGetField form_handle "via_name")) 
	(mask_side = (axlFormGetField form_handle "mask_side")) 
	cond((!((tbx_shieldgen_global->runTime)->ok2Apply) 
		printf("Please provide appropriate input.\n")
	    ) 
	    ((create_vias && (!via_name || (via_name == ""))) 
		printf("Specify padstack to be used.\n")
	    ) 
	    (t 
		(axlClearDynamics) 
		(axlDeleteByLayer 
		    ((tbx_shieldgen_global->layer)->tmp)
		) 
		cond((((creation_mode == "select_boundary") && ((tbx_shieldgen_global->runTime)->boundaryShape)) 
			(ref_path = (axlDB2Path 
				((tbx_shieldgen_global->runTime)->boundaryShape)
			    )) 
			(shield_poly_data = TBX_SHIELDGEN_Calculate_Shield_Polygon(ref_path direction path_offset shape_width "split")) 
			(rpath_via = TBX_SHIELDGEN_Calculate_Path(ref_path direction path_offset via_path_offset)) 
			(location_list = TBX_SHIELDGEN_Calculate_Via_Locations(rpath_via via_gap via_initial_offset))
			(center_path_data = list(TBX_SHIELDGEN_Calculate_Path(ref_path direction path_offset 0.0)))
		    ) 
		    (((creation_mode == "draw_rectangle") && ((tbx_shieldgen_global->runTime)->userBox)) 
			(ref_poly = TBX_DBCORE_Poly_From_Box(((tbx_shieldgen_global->runTime)->userBox))) 
			(ref_path = TBX_DBCORE_Rpath_From_Poly(ref_poly)) 
			(shield_poly_data = TBX_SHIELDGEN_Calculate_Shield_Polygon(ref_path direction path_offset shape_width "split")) 
			(rpath_via = TBX_SHIELDGEN_Calculate_Path(ref_path direction path_offset via_path_offset))
			(location_list = TBX_SHIELDGEN_Calculate_Via_Locations(rpath_via via_gap via_initial_offset)) 
			(center_path_data = list(TBX_SHIELDGEN_Calculate_Path(ref_path direction path_offset 0.0)))
		    ) 
		    (((creation_mode == "place_rectangle") && ((tbx_shieldgen_global->runTime)->userPick)) 
			(rpath = (axlPathStart 
				list((0.0:0.0) 
				    (rect_width:0.0) 
				    (rect_width:rect_height) 
				    (0.0:rect_height) 
				    (0.0:0.0)
				) 0.0
			    )) 
			(ref_path = (axlPathOffset rpath 
				((tbx_shieldgen_global->runTime)->userPick)
			    )) 
			(shield_poly_data = TBX_SHIELDGEN_Calculate_Shield_Polygon(ref_path direction path_offset shape_width "split")) 
			(rpath_via = TBX_SHIELDGEN_Calculate_Path(ref_path direction path_offset via_path_offset))
			(location_list = TBX_SHIELDGEN_Calculate_Via_Locations(rpath_via via_gap via_initial_offset)) 
			(center_path_data = list(TBX_SHIELDGEN_Calculate_Path(ref_path direction path_offset 0.0)))
		    ) 
		    (((creation_mode == "derive_from_line") && ((tbx_shieldgen_global->runTime)->pathObjects)) 
			foreach(pth 
			    ((tbx_shieldgen_global->runTime)->pathObjects) 
			    (line_poly = car(TBX_DBCORE_Poly_From_Line((pth->segments) t 
					'ROUND
				    )
				)) 
			    (first_seg = car((pth->segments))) 
			    (last_seg = (lastelem 
				    (pth->segments)
				))
			    if(((axlGeo2Str 
					car((first_seg->startEnd))
				    ) == (axlGeo2Str 
					cadr((last_seg->startEnd))
				    )) then 
				(shield_poly_data = nconc(shield_poly_data 
					TBX_SHIELDGEN_Split_Polygon(line_poly 
					    ((tbx_shieldgen_global->layer)->tmp)
					)
				    )) else 
				(shield_poly_data = nconc(shield_poly_data 
					list(line_poly)
				    ))
			    )
			) 
			(tmp_data = mapcar(lambda((x) 
				    list((axlDBGetLength x) 
					(axlDB2Path x)
				    )
				) 
				((tbx_shieldgen_global->runTime)->pathObjects)
			    )) 
			(tmp_data = sortcar(tmp_data 
				'greaterp
			    )) 
			(rpath_list = mapcar(lambda((x) 
				    cadr(x)
				) tmp_data
			    ))
			(location_list = TBX_SHIELDGEN_Calculate_Via_Locations(rpath_list via_gap via_initial_offset)) 
			(result = mapcar(lambda((x) 
				    car(TBX_DBCORE_Copy_Rpath(x 0.0 nil))
				) rpath_list
			    )) 
			(center_path_data = result)
		    ) 
		    (t t)
		) 
		when(create_shapes 
		    (shape_layers = TBX_UTIL_Resolve_Etch_Layers((tbx_shieldgen_global->etchLayersGeneric))) 
		    if((shape_type == "static") then 
			(shape_class = (axlMapClassName "ETCH")) else 
			(shape_class = (axlMapClassName "BOUNDARY"))
		    ) 
		    (shape_layers = mapcar(lambda((x) 
				strcat(shape_class "/" x)
			    ) shape_layers
			))
		)
		when(create_mask 
		    case(mask_side 
			("top" 
			    (mask_layers = list(((tbx_shieldgen_global->layer)->smTop) 
				    ((tbx_shieldgen_global->layer)->pmTop)
				))
			) 
			("bottom" 
			    (mask_layers = list(((tbx_shieldgen_global->layer)->smBottom) 
				    ((tbx_shieldgen_global->layer)->pmBottom)
				))
			) 
			("both" 
			    (mask_layers = list(((tbx_shieldgen_global->layer)->smTop) 
				    ((tbx_shieldgen_global->layer)->pmTop) 
				    ((tbx_shieldgen_global->layer)->smBottom) 
				    ((tbx_shieldgen_global->layer)->pmBottom)
				))
			)
		    )
		) 
		when(((tbx_shieldgen_global->runTime)->pathObjects) 
		    (axlDeleteObject 
			setof(x 
			    ((tbx_shieldgen_global->runTime)->pathObjects) 
			    (x->isEtch)
			)
		    )
		) 
		when((shield_poly_data || location_list) 
		    if(create_symbol then 
			(cur_extents = TBX_UTIL_Get_Extents(shield_poly_data ?margin symbol_margin)) 
			(symbol_origin = TBX_UTIL_Get_Box_Center(cur_extents)) 
			(symdef = TBX_SHIELDGEN_Create_Symbol_Definition())
			(result = (axlDBCreateSymbol 
				list((symdef->name) "MECHANICAL") symbol_origin nil 0.0
			    )) 
			when(car(result) 
			    (syminst = car(result))
			) 
			when((create_shapes && shield_poly_data) 
			    TBX_SHIELDGEN_Create_Shapes(shield_poly_data shape_layers net_name syminst)
			) 
			when((create_mask && shield_poly_data) 
			    TBX_SHIELDGEN_Create_Shapes(shield_poly_data mask_layers nil syminst)
			) 
			when((create_vias && location_list) 
			    TBX_SHIELDGEN_Create_Vias(location_list via_name net_name syminst)
			)
			when(center_path_data 
			    foreach(rp center_path_data 
				(axlDBCreatePath rp 
				    ((tbx_shieldgen_global->layer)->shieldPath) nil syminst
				)
			    )
			) else 
			(group_dbid = TBX_SHIELDGEN_Get_Next_Group()) 
			when((create_shapes && shield_poly_data) 
			    TBX_SHIELDGEN_Create_Shapes(shield_poly_data shape_layers net_name group_dbid)
			) 
			when((create_mask && shield_poly_data) 
			    TBX_SHIELDGEN_Create_Shapes(shield_poly_data mask_layers nil group_dbid)
			)
			when((create_vias && location_list) 
			    TBX_SHIELDGEN_Create_Vias(location_list via_name net_name group_dbid)
			) 
			when(center_path_data 
			    foreach(rp center_path_data 
				(result = (axlDBCreatePath rp 
					((tbx_shieldgen_global->layer)->shieldPath) nil nil
				    )) 
				when(car(result) 
				    (axlDBAddGroupObjects group_dbid 
					car(result)
				    )
				)
			    )
			)
		    )
		)
	    )
	) t
    )
)
procedure(TBX_SHIELDGEN_Get_Next_Group() 
    let((group_list group_name_list free_id group_dbid cnt) 
	(group_list = (axlSelectByName "GROUP" "SHIELDGEN_*" t)) 
	(group_name_list = mapcar(lambda((x) 
		    upperCase((x->name))
		) group_list
	    )) 
	(cnt = 1) 
	while((!free_id && (cnt <= 1000)) 
	    unless(rexMatchList(sprintf(nil "^SHIELDGEN_%d" cnt) group_name_list) 
		(free_id = cnt)
	    ) 
	    ++cnt
	)
	if(free_id then 
	    (group_dbid = (axlDBCreateGroup 
		    sprintf(nil "SHIELDGEN_%d" free_id) "generic" nil
		)) else 
	    printf("Error: Cannot derive next free group\n")
	    (group_dbid = nil)
	) 
	(axlClearSelSet) group_dbid
    )
)
procedure(TBX_SHIELDGEN_Init() 
    let((tmp_layer shieldpath_layer pm_layer_top pm_layer_bottom sm_layer_top
	    sm_layer_bottom layer_dpl cfg layer_name main_color
	    alt_color via_marker_size factor design_type
	) 
	(tmp_layer = strcat((axlMapClassName "MANUFACTURING") "/TBX_TMP")) 
	(shieldpath_layer = strcat((axlMapClassName "PACKAGE GEOMETRY") "/SHIELDGEN_PATH")) 
	(pm_layer_top = strcat((axlMapClassName "PACKAGE GEOMETRY") "/SHIELDGEN_PASTE_TOP")) 
	(pm_layer_bottom = strcat((axlMapClassName "PACKAGE GEOMETRY") "/SHIELDGEN_PASTE_BOTTOM"))
	(sm_layer_top = strcat((axlMapClassName "PACKAGE GEOMETRY") "/SOLDERMASK_TOP")) 
	(sm_layer_bottom = strcat((axlMapClassName "PACKAGE GEOMETRY") "/SOLDERMASK_BOTTOM")) 
	(factor = 1.0) 
	(design_type = upperCase((axlDesignType t))) 
	when(((design_type == "MCM") || (design_type == "SIP")) 
	    (factor = 4.0)
	)
	(via_marker_size = (TBX_UTIL_Smart_Convert("0.6 MM" "24.0 MILS") / factor)) 
	(cfg = list(list(tmp_layer 
		    list(255 255 255) 
		    list(255 0 0)
		) 
		list(shieldpath_layer 
		    list(255 0 255) 
		    list(0 0 255)
		) 
		list(pm_layer_top 
		    list(0 255 255) nil
		) 
		list(pm_layer_bottom 
		    list(0 127 255) nil
		) 
		list(sm_layer_top nil nil)
		list(sm_layer_bottom nil nil)
	    )) 
	foreach(entry cfg 
	    (layer_name = car(entry)) 
	    (main_color = cadr(entry)) 
	    (alt_color = caddr(entry))
	    unless((axlIsLayer layer_name) 
		(axlLayerCreateNonConductor layer_name) 
		TBX_DBDISPLAY_Set_Layer_Color(layer_name main_color alt_color)
	    ) 
	    (axlVisibleLayer layer_name t)
	) 
	(axlDeleteByLayer tmp_layer) 
	(axlVisibleUpdate t)
	unless(boundp('tbx_shieldgen_global) 
	    iliDefstruct('defstruct(tbx_shieldgen_global_struct formId licCheck transMark etchLayersGeneric
			event runTime layer viaMarkerSize
		    )
	    ) 
	    defvar(tbx_shieldgen_global nil)
	) 
	(layer_dpl = list(nil 
		'tmp tmp_layer 
		'shieldPath shieldpath_layer
		'pmTop pm_layer_top 
		'pmBottom pm_layer_bottom 
		'smTop
		sm_layer_top 
		'smBottom sm_layer_bottom
	    )) 
	if(!tbx_shieldgen_global then 
	    (tbx_shieldgen_global = (make_tbx_shieldgen_global_struct ?formId nil ?licCheck nil
		    ?transMark nil ?etchLayersGeneric nil ?layer
		    layer_dpl ?event 
		    ncons(nil) ?runTime 
		    ncons(nil)
		    ?viaMarkerSize via_marker_size
		)) else 
	    (tbx_shieldgen_global->formId = nil)
	    (tbx_shieldgen_global->licCheck = nil) 
	    (tbx_shieldgen_global->transMark = nil) 
	    (tbx_shieldgen_global->etchLayersGeneric = nil) 
	    (tbx_shieldgen_global->layer = layer_dpl) 
	    (tbx_shieldgen_global->event = ncons(nil))
	    (tbx_shieldgen_global->runTime = ncons(nil)) 
	    (tbx_shieldgen_global->viaMarkerSize = via_marker_size)
	)
    )
)
procedure(TBX_SHIELDGEN_Init_Form(form_handle) 
    let((factor design_type cfg def_rect_size def_ring_width
	    def_path_offset def_via_gap design_precision field_name default_value
	    unit_convert def_grid_value via_list def_via_name def_net_name
	    gnd_candidates name_list
	) 
	(factor = 1.0) 
	(design_type = upperCase((axlDesignType t))) 
	when(((design_type == "MCM") || (design_type == "SIP")) 
	    (factor = 4.0)
	) 
	(def_rect_size = (TBX_UTIL_Smart_Convert("50.0 MM" "2000.0 MILS") / factor))
	(def_path_offset = (TBX_UTIL_Smart_Convert("2.54 MM" "100.0 MILS") / factor)) 
	(def_ring_width = (TBX_UTIL_Smart_Convert("2.0  MM" "80.0  MILS") / factor)) 
	(def_via_gap = (TBX_UTIL_Smart_Convert("2.54 MM" "100.0  MILS") / factor)) 
	(def_grid_value = (TBX_UTIL_Smart_Convert("2.54 MM" "100.0  MILS") / factor)) 
	(via_list = (axlGetAllViaList))
	when(via_list 
	    (def_via_name = (car(via_list)->name))
	) 
	(gnd_candidates = (axlSelectByName "NET" "*GND*" t)) 
	when(gnd_candidates 
	    (name_list = mapcar(lambda((x) 
			(x->name)
		    ) gnd_candidates
		)) 
	    (name_list = sort(name_list nil)) 
	    (def_net_name = car(name_list))
	) 
	(cfg = list(list("shield_mode" "select_boundary" nil) 
		list("rectangle_width" def_rect_size t) 
		list("rectangle_height" def_rect_size t) 
		list("direction" "inside" nil) 
		list("path_offset" def_path_offset t)
		list("net_name" def_net_name nil) 
		list("create_shapes" t nil) 
		list("shape_width" def_ring_width t) 
		list("shape_type" "static" nil) 
		list("create_vias" t nil)
		list("via_gap" def_via_gap t) 
		list("via_path_offset" 0.0 t) 
		list("via_initial_offset" 0.0 t) 
		list("via_name" def_via_name nil) 
		list("create_mask" nil nil)
		list("mask_side" "top" nil) 
		list("create_symbol" nil nil) 
		list("snap_grid" nil nil) 
		list("grid_value" def_grid_value t)
	    )) 
	(design_precision = cadr((axlDBGetDesignUnits)))
	foreach(entry cfg 
	    (field_name = car(entry)) 
	    (default_value = cadr(entry)) 
	    (unit_convert = caddr(entry))
	    (axlFormSetField form_handle field_name 
		TBX_SESSION_Get_Param("shieldgen" field_name default_value unit_convert)
	    ) 
	    when(unit_convert 
		(axlFormSetDecimal form_handle field_name design_precision)
	    )
	)
    )
)
procedure(TBX_SHIELDGEN_Init_Next() 
    let((form_handle shield_mode) 
	(axlClearSelSet) 
	(axlClearDynamics) 
	(axlDeleteByLayer 
	    ((tbx_shieldgen_global->layer)->tmp)
	) 
	(form_handle = (tbx_shieldgen_global->formId))
	(shield_mode = (axlFormGetField form_handle "shield_mode")) 
	case(shield_mode 
	    ("select_boundary" 
		printf("Select a shape boundary along which a shield will be created.\n")
	    ) 
	    ("draw_rectangle" 
		printf("Draw rectangluar shield outline.\n")
	    ) 
	    ("place_rectangle" 
		printf("Place rectangle shield outline.\n")
	    ) 
	    ("derive_from_line" 
		printf("Select (c)line segements first, then choose RMB - Complete to continue.\n") 
		printf("While selecting you may use CTRL to deselect items.\n")
	    )
	    ("cut_mask" 
		printf("Hover over shield. Use LMB to cut mask with given size. You may adjust cut size by adjusting width and height in the form.\n")
	    ) 
	    ("add_shield_via" 
		printf("Add via to shield.\n")
	    ) 
	    ("delete_shield_via" 
		printf("Delete via from shield.\n")
	    ) 
	    ("delete_shield" 
		printf("Delete shield mode.\n")
	    )
	) 
	((tbx_shieldgen_global->runTime)->ok2Apply = nil) 
	((tbx_shieldgen_global->runTime)->boundaryShape = nil) 
	((tbx_shieldgen_global->runTime)->userBox = nil)
	((tbx_shieldgen_global->runTime)->userPick = nil) 
	((tbx_shieldgen_global->runTime)->pathObjects = nil) 
	((tbx_shieldgen_global->runTime)->initNext = t) 
	(axlCancelEnterFun)
    )
)
procedure((TBX_SHIELDGEN_Main \@optional arg) 
    let((lic_check_result FORM_FILE fid FC_VERSION FC_FEATURE
	    SUB_VERSION VERSION_STR info_file port ok_start_app
	) 
	(FC_FEATURE = "SHIELDGEN") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Shield Generator %s (C)2017" FC_VERSION))
	(ok_start_app = t) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./shieldgen_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Shield Generator nformation:\n") 
		fprintf(port "====================================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Shield Generator: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION) 
		(ok_start_app = nil)
	    )
	) 
	when(ok_start_app 
	    (lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
	    when(lic_check_result 
		(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "shieldgen_main")) 
		unless(boundp('tbxGndRingMainHandle) 
		    defvar(tbxGndRingMainHandle nil)
		) 
		(fid = (axlFormCreate 
			'tbxGndRingMainHandle FORM_FILE 
			'(e outer) 
			'TBX_SHIELDGEN_Callback
			t nil
		    )) 
		when(fid 
		    TBX_SHIELDGEN_Init() 
		    (tbx_shieldgen_global->formId = fid) 
		    (tbx_shieldgen_global->licCheck = lic_check_result) 
		    (tbx_shieldgen_global->gridParam = TBX_DBDISPLAY_Canvas_Grid('getGrid))
		    TBX_FORM_Init_Header(fid "" lic_check_result VERSION_STR) 
		    (tbx_shieldgen_global->etchLayersGeneric = TBX_SESSION_Get_Param("shieldgen" "etch_layers" 
			    list((axlConductorTopLayer)) nil
			)) 
		    TBX_SHIELDGEN_Init_Form(fid) 
		    TBX_SHIELDGEN_Init_Next() 
		    TBX_SHIELDGEN_Update_Form(fid)
		    TBX_SHIELDGEN_Update_Dynamics(fid) 
		    TBX_SHIELDGEN_Update_Mask(fid) 
		    (axlFormDisplay fid) 
		    TBX_SHIELDGEN_Event_Loop(fid) 
		    (axlClearDynamics)
		    (axlVisibleUpdate t) 
		    (axlDeleteByLayer 
			((tbx_shieldgen_global->layer)->tmp)
		    ) 
		    TBX_FORM_Delete(lic_check_result FORM_FILE) 
		    TBX_DBDISPLAY_Canvas_Grid('setGrid 
			(tbx_shieldgen_global->gridParam)
		    )
		)
	    )
	)
    )
)
procedure(TBX_SHIELDGEN_Mark_Points(pt_list) 
    let((txt_orient id) 
	(txt_orient = (make_axlTextOrientation ?textBlock "1" ?rotation 0.0
		?mirrored nil ?justify "left"
	    )) 
	(id = 0) 
	(pt_list = reverse(cdr(reverse(pt_list)))) 
	foreach(pt pt_list 
	    (axlDBCreateText 
		sprintf(nil "%d" 
		    ++id
		) pt txt_orient 
		((tbx_shieldgen_global->layer)->tmp)
		nil
	    )
	)
	t
    )
)
procedure(TBX_SHIELDGEN_Popup_Callback(event) 
    let((popup shield_mode form_handle) 
	(event = event) 
	(form_handle = (tbx_shieldgen_global->formId)) 
	(shield_mode = (axlFormGetField form_handle "shield_mode")) 
	cond(((shield_mode == "derive_from_line") 
		(popup = (axlUIPopupDefine nil 
			list(list("Complete" 
				'TBX_SHIELDGEN_RMB_Complete
			    ) 
			    list("Next" 
				'TBX_SHIELDGEN_RMB_Next
			    ) 
			    list("Done" 
				'TBX_SHIELDGEN_RMB_Done
			    ) 
			    list("Oops" 
				'TBX_SHIELDGEN_RMB_Oops
			    ) 
			    list("Cancel" 
				'TBX_SHIELDGEN_RMB_Cancel
			    )
			)
		    ))
	    ) 
	    ((shield_mode == "cut_mask") 
		(popup = (axlUIPopupDefine nil 
			list(list("Swap" 
				'TBX_SHIELDGEN_RMB_Swap
			    ) 
			    list("Next" 
				'TBX_SHIELDGEN_RMB_Next
			    ) 
			    list("Done" 
				'TBX_SHIELDGEN_RMB_Done
			    ) 
			    list("Oops" 
				'TBX_SHIELDGEN_RMB_Oops
			    ) 
			    list("Cancel" 
				'TBX_SHIELDGEN_RMB_Cancel
			    )
			)
		    ))
	    ) 
	    (t 
		(popup = (axlUIPopupDefine nil 
			list(list("Next" 
				'TBX_SHIELDGEN_RMB_Next
			    ) 
			    list("Done" 
				'TBX_SHIELDGEN_RMB_Done
			    ) 
			    list("Oops" 
				'TBX_SHIELDGEN_RMB_Oops
			    ) 
			    list("Cancel" 
				'TBX_SHIELDGEN_RMB_Cancel
			    )
			)
		    ))
	    )
	)
	(axlUIPopupSet popup)
    )
)
procedure(TBX_SHIELDGEN_RMB_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_SHIELDGEN_RMB_Complete() 
    ((tbx_shieldgen_global->runTime)->selectMode = nil) 
    if((axlGetSelSet) then 
	((tbx_shieldgen_global->runTime)->pathObjects = (axlGetSelSet)) 
	((tbx_shieldgen_global->runTime)->ok2Apply = t) 
	(axlClearSelSet)
	TBX_SHIELDGEN_Update_Dynamics((tbx_shieldgen_global->formId)) else 
	printf("Nothing selected\n")
    )
)
procedure(TBX_SHIELDGEN_RMB_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_SHIELDGEN_RMB_Next() 
    TBX_SHIELDGEN_Init_Next()
)
procedure(TBX_SHIELDGEN_RMB_Oops() 
    (axlDBTransactionOops 
	(tbx_shieldgen_global->transMark)
    ) 
    TBX_SHIELDGEN_Init_Next() 
    TBX_SHIELDGEN_Update_Dynamics((tbx_shieldgen_global->formId)) t
)
procedure(TBX_SHIELDGEN_RMB_Swap() 
    let((form_handle cur_width cur_height) 
	(form_handle = (tbx_shieldgen_global->formId)) 
	(cur_width = (axlFormGetField form_handle "rectangle_width")) 
	(cur_height = (axlFormGetField form_handle "rectangle_height")) 
	(axlFormSetField form_handle "rectangle_width" cur_height)
	(axlFormSetField form_handle "rectangle_height" cur_width) 
	TBX_SHIELDGEN_Update_Dynamics(form_handle)
    )
)
procedure(TBX_SHIELDGEN_Select_Shield(lo_arg) 
    let((shield_object) 
	(axlSetFindFilter ?enabled 
	    list("noall" "groups" "symbols") ?onButtons 
	    list("groups" "symbols")
	) 
	(axlClearSelSet) 
	if((isBoxp lo_arg) then 
	    (axlSingleSelectBox lo_arg) else 
	    (axlSingleSelectPoint lo_arg)
	) 
	when((axlGetSelSet) 
	    (shield_object = car((axlGetSelSet)))
	)
	(axlClearSelSet) shield_object
    )
)
procedure(TBX_SHIELDGEN_Split_Polygon(poly tmp_layer) 
    let((design_units poly_ll poly_ur rpath cut_x
	    cut_y_bot cut_y_top poly_list width cut_width
	    line_dbid result cut_poly polys_left_side polys_right_side
	    poly_center and_polys final_polys
	) 
	(design_units = car((axlDBGetDesignUnits))) 
	(cut_width = (axlMKSConvert "0.05 MM" design_units)) 
	(poly_ll = car((poly->bBox))) 
	(poly_ur = cadr((poly->bBox)))
	(width = abs((car(poly_ur) - car(poly_ll)))) 
	(cut_x = (car(poly_ll) + (width / 2.0))) 
	(cut_y_bot = (cadr(poly_ll) - (axlMKSConvert "0.1 MM" design_units))) 
	(cut_y_top = (cadr(poly_ur) + (axlMKSConvert "0.1 MM" design_units))) 
	(rpath = (axlPathStart 
		list((cut_x:cut_y_bot) 
		    (cut_x:cut_y_top)
		) 0.0
	    ))
	(result = (axlDBCreatePath rpath tmp_layer)) 
	when(result 
	    (line_dbid = caar(result)) 
	    (poly_list = (axlPolyOperation poly 
		    car((axlPolyFromDB line_dbid)) 
		    'ANDNOT
		)) 
	    foreach(pl poly_list 
		(poly_center = TBX_UTIL_Get_Box_Center((pl->bBox))) 
		cond(((car(poly_center) <= cut_x) 
			(polys_left_side = cons(pl polys_left_side))
		    ) 
		    (t 
			(polys_right_side = cons(pl polys_right_side))
		    )
		)
	    ) 
	    (axlDeleteObject line_dbid)
	) 
	(rpath = (axlPathStart 
		list((cut_x:cut_y_bot) 
		    (cut_x:cut_y_top)
		) cut_width
	    )) 
	(cut_poly = car((axlPolyFromDB rpath ?line2poly t))) 
	when((polys_left_side && polys_right_side && cut_poly) 
	    (and_polys = (axlPolyOperation poly cut_poly 
		    'AND
		)) 
	    when(car(and_polys) 
		(result = (axlPolyOperation and_polys polys_right_side 
			'OR
		    )) 
		(final_polys = nconc(polys_left_side result))
	    )
	)
	final_polys
    )
)
procedure(TBX_SHIELDGEN_Update_Dynamics(form_handle) 
    let((direction path_offset shape_width via_path_offset via_gap
	    rpath_via location_list via_initial_offset via_marker_radius creation_mode
	    result rect_width rect_height rpath rpath_list
	    tmp_data w_half h_half tmp_polys shield_poly_data
	    seg_list ref_path
	) 
	(rect_width = (axlFormGetField form_handle "rectangle_width")) 
	(rect_height = (axlFormGetField form_handle "rectangle_height")) 
	(direction = (axlFormGetField form_handle "direction")) 
	(path_offset = (axlFormGetField form_handle "path_offset"))
	(shape_width = (axlFormGetField form_handle "shape_width")) 
	(via_path_offset = (axlFormGetField form_handle "via_path_offset")) 
	(via_gap = (axlFormGetField form_handle "via_gap")) 
	(via_initial_offset = (axlFormGetField form_handle "via_initial_offset")) 
	(creation_mode = (axlFormGetField form_handle "shield_mode"))
	(via_marker_radius = (tbx_shieldgen_global->viaMarkerSize)) 
	(axlClearDynamics) 
	(axlDeleteByLayer 
	    ((tbx_shieldgen_global->layer)->tmp)
	) 
	cond((((creation_mode == "select_boundary") && ((tbx_shieldgen_global->runTime)->boundaryShape)) 
		(ref_path = (axlDB2Path 
			((tbx_shieldgen_global->runTime)->boundaryShape)
		    )) 
		(shield_poly_data = TBX_SHIELDGEN_Calculate_Shield_Polygon(ref_path direction path_offset shape_width "boundary")) 
		(rpath_via = TBX_SHIELDGEN_Calculate_Path(ref_path direction path_offset via_path_offset)) 
		(location_list = TBX_SHIELDGEN_Calculate_Via_Locations(rpath_via via_gap via_initial_offset))
	    ) 
	    (((creation_mode == "draw_rectangle") && ((tbx_shieldgen_global->runTime)->userBox)) 
		(result = (axlDBCreateRectangle 
			((tbx_shieldgen_global->runTime)->userBox) nil 
			((tbx_shieldgen_global->layer)->tmp)
		    )) 
		when(car(result) 
		    (ref_path = car(result)) 
		    (shield_poly_data = TBX_SHIELDGEN_Calculate_Shield_Polygon(ref_path direction path_offset shape_width "boundary")) 
		    (rpath_via = TBX_SHIELDGEN_Calculate_Path(ref_path direction path_offset via_path_offset)) 
		    (location_list = TBX_SHIELDGEN_Calculate_Via_Locations(rpath_via via_gap via_initial_offset))
		)
	    ) 
	    ((creation_mode == "place_rectangle") 
		if(!((tbx_shieldgen_global->runTime)->userPick) then 
		    (rpath = (axlPathStart 
			    list((0.0:0.0) 
				(rect_width:0.0) 
				(rect_width:rect_height) 
				(0.0:rect_height) 
				(0.0:0.0)
			    ) 0.0
			)) 
		    (axlAddSimpleMoveDynamics 
			(0:0) rpath "path"
		    ) else
		    (rpath = (axlPathStart 
			    list((0.0:0.0) 
				(rect_width:0.0) 
				(rect_width:rect_height) 
				(0.0:rect_height) 
				(0.0:0.0)
			    ) 0.0
			)) 
		    (ref_path = (axlPathOffset rpath 
			    ((tbx_shieldgen_global->runTime)->userPick)
			)) 
		    (result = (axlDBCreateShape ref_path nil 
			    ((tbx_shieldgen_global->layer)->tmp)
			)) 
		    (shield_poly_data = TBX_SHIELDGEN_Calculate_Shield_Polygon(ref_path direction path_offset shape_width "boundary")) 
		    (rpath_via = TBX_SHIELDGEN_Calculate_Path(ref_path direction path_offset via_path_offset))
		    (location_list = TBX_SHIELDGEN_Calculate_Via_Locations(rpath_via via_gap via_initial_offset))
		)
	    ) 
	    (((creation_mode == "derive_from_line") && ((tbx_shieldgen_global->runTime)->pathObjects)) 
		(seg_list = mapcan(lambda((x) 
			    (x->segments)
			) 
			((tbx_shieldgen_global->runTime)->pathObjects)
		    )) 
		(tmp_polys = TBX_DBCORE_Poly_From_Line(seg_list t 
			'ROUND
		    )) 
		foreach(pl tmp_polys 
		    (shield_poly_data = cons(TBX_DBCORE_Rpath_From_Poly(pl) shield_poly_data)) 
		    foreach(hpl 
			(pl->holes) 
			(shield_poly_data = cons(TBX_DBCORE_Rpath_From_Poly(hpl) shield_poly_data))
		    )
		) 
		(axlDBRefreshId nil)
		(tmp_data = mapcar(lambda((x) 
			    list((axlDBGetLength x) 
				(axlDB2Path x)
			    )
			) 
			((tbx_shieldgen_global->runTime)->pathObjects)
		    )) 
		(tmp_data = sortcar(tmp_data 
			'greaterp
		    )) 
		(rpath_list = mapcar(lambda((x) 
			    cadr(x)
			) tmp_data
		    )) 
		(location_list = TBX_SHIELDGEN_Calculate_Via_Locations(rpath_list via_gap via_initial_offset))
	    ) 
	    ((creation_mode == "cut_mask") 
		(w_half = (rect_width / 2.0)) 
		(h_half = (rect_height / 2.0)) 
		(rpath = (axlPathStart 
			list(((- w_half):(- h_half)) 
			    (w_half:(- h_half)) 
			    (w_half:h_half) 
			    ((- w_half):h_half) 
			    ((- w_half):(- h_half))
			) 0.0
		    )) 
		(axlAddSimpleMoveDynamics 
		    (0:0) rpath "path"
		)
	    )
	    ((creation_mode == "add_shield_via") 
		(w_half = via_marker_radius) 
		(h_half = via_marker_radius) 
		(rpath = (axlPathStart 
			list(((- w_half):(- h_half)) 
			    (w_half:(- h_half)) 
			    (w_half:h_half) 
			    ((- w_half):h_half) 
			    ((- w_half):(- h_half))
			) 0.0
		    )) 
		(axlAddSimpleMoveDynamics 
		    (0:0) rpath "path"
		)
	    ) 
	    (t t)
	) 
	when((axlFormGetField form_handle "create_shapes") 
	    foreach(pl shield_poly_data 
		(axlDBCreateShape pl nil 
		    ((tbx_shieldgen_global->layer)->tmp)
		)
	    )
	)
	when((axlFormGetField form_handle "create_vias") 
	    foreach(pt location_list 
		(axlDBCreateCircle 
		    list(pt via_marker_radius) 0.0 
		    ((tbx_shieldgen_global->layer)->tmp)
		)
	    )
	) 
	when(((tbx_shieldgen_global->runTime)->pathObjects) 
	    (axlEraseObject 
		((tbx_shieldgen_global->runTime)->pathObjects)
	    )
	)
    )
)
procedure(TBX_SHIELDGEN_Update_Form(form_handle) 
    let((shield_mode) 
	(shield_mode = (axlFormGetField form_handle "shield_mode")) 
	(axlFormSetFieldEditable form_handle "rectangle_width" t) 
	(axlFormSetFieldEditable form_handle "rectangle_height" t) 
	(axlFormSetFieldEditable form_handle "direction" t)
	(axlFormSetFieldEditable form_handle "path_offset" t) 
	(axlFormSetFieldEditable form_handle "net_name" t) 
	(axlFormSetFieldEditable form_handle "create_shapes" t) 
	(axlFormSetFieldEditable form_handle "shape_width" t) 
	(axlFormSetFieldEditable form_handle "shape_type" t)
	(axlFormSetFieldEditable form_handle "specify_layers" t) 
	(axlFormSetFieldEditable form_handle "create_vias" t) 
	(axlFormSetFieldEditable form_handle "via_gap" t) 
	(axlFormSetFieldEditable form_handle "via_path_offset" t) 
	(axlFormSetFieldEditable form_handle "via_initial_offset" t)
	(axlFormSetFieldEditable form_handle "via_name" t) 
	(axlFormSetFieldEditable form_handle "create_mask" t) 
	(axlFormSetFieldEditable form_handle "mask_side" t) 
	(axlFormSetFieldEditable form_handle "create_symbol" t) 
	(axlFormSetFieldEditable form_handle "snap_grid" t)
	(axlFormSetFieldEditable form_handle "grid_value" t) 
	unless((axlFormGetField form_handle "snap_grid") 
	    (axlFormSetFieldEditable form_handle "grid_value" nil)
	) 
	unless((axlFormGetField form_handle "create_vias") 
	    (axlFormSetFieldEditable form_handle "via_gap" nil) 
	    (axlFormSetFieldEditable form_handle "via_path_offset" nil) 
	    (axlFormSetFieldEditable form_handle "via_initial_offset" nil) 
	    (axlFormSetFieldEditable form_handle "via_name" nil)
	) 
	unless((axlFormGetField form_handle "create_shapes") 
	    (axlFormSetFieldEditable form_handle "shape_width" nil) 
	    (axlFormSetFieldEditable form_handle "shape_type" nil) 
	    (axlFormSetFieldEditable form_handle "specify_layers" nil)
	) 
	when(((axlFormGetField form_handle "direction") == "centric") 
	    (axlFormSetFieldEditable form_handle "path_offset" nil)
	)
	cond((((shield_mode == "select_boundary") || (shield_mode == "draw_rectangle")) 
		(axlFormSetFieldEditable form_handle "rectangle_width" nil) 
		(axlFormSetFieldEditable form_handle "rectangle_height" nil)
	    ) 
	    ((shield_mode == "derive_from_line") 
		(axlFormSetFieldEditable form_handle "rectangle_width" nil) 
		(axlFormSetFieldEditable form_handle "rectangle_height" nil) 
		(axlFormSetFieldEditable form_handle "direction" nil) 
		(axlFormSetFieldEditable form_handle "path_offset" nil)
		(axlFormSetFieldEditable form_handle "shape_width" nil)
	    ) 
	    (((shield_mode == "cut_mask") || (shield_mode == "delete_shield") || (shield_mode == "add_shield_via") || (shield_mode == "delete_shield_via")) 
		(axlFormSetFieldEditable form_handle "rectangle_width" nil) 
		(axlFormSetFieldEditable form_handle "rectangle_height" nil) 
		(axlFormSetFieldEditable form_handle "direction" nil) 
		(axlFormSetFieldEditable form_handle "path_offset" nil)
		(axlFormSetFieldEditable form_handle "net_name" nil) 
		(axlFormSetFieldEditable form_handle "create_shapes" nil) 
		(axlFormSetFieldEditable form_handle "shape_width" nil) 
		(axlFormSetFieldEditable form_handle "shape_type" nil) 
		(axlFormSetFieldEditable form_handle "specify_layers" nil)
		(axlFormSetFieldEditable form_handle "create_vias" nil) 
		(axlFormSetFieldEditable form_handle "via_gap" nil) 
		(axlFormSetFieldEditable form_handle "via_path_offset" nil) 
		(axlFormSetFieldEditable form_handle "via_initial_offset" nil) 
		(axlFormSetFieldEditable form_handle "via_name" nil)
		(axlFormSetFieldEditable form_handle "create_mask" nil) 
		(axlFormSetFieldEditable form_handle "mask_side" nil) 
		(axlFormSetFieldEditable form_handle "create_symbol" nil) 
		when((shield_mode == "cut_mask") 
		    (axlFormSetFieldEditable form_handle "rectangle_width" t) 
		    (axlFormSetFieldEditable form_handle "rectangle_height" t) 
		    (axlFormSetFieldEditable form_handle "mask_side" t)
		) 
		when((shield_mode == "add_shield_via") 
		    (axlFormSetFieldEditable form_handle "via_name" t) 
		    (axlDBControl 
			'activeLayer 
			((tbx_shieldgen_global->layer)->shieldPath)
		    )
		)
	    )
	) 
	when(member(upperCase((axlDesignType t)) 
		list("PACKAGE" "MECHANICAL")
	    ) 
	    (axlFormSetFieldEditable form_handle "shape_type" nil) 
	    (axlFormSetField form_handle "shape_type" "static")
	)
    )
)
procedure(TBX_SHIELDGEN_Update_Mask(form_handle) 
    let((event_mask creation_mode) 
	(creation_mode = (axlFormGetField form_handle "shield_mode")) 
	case(creation_mode 
	    ("select_boundary" 
		(event_mask = list('PICK 
			'STARTDRAG 
			'STOPDRAG
		    ))
	    ) 
	    ("draw_rectangle" 
		(event_mask = list('STARTDRAG 
			'STOPDRAG
		    ))
	    ) 
	    ("place_rectangle" 
		(event_mask = list('PICK))
	    ) 
	    ("derive_from_line" 
		(event_mask = list('PICK 
			'PICK_TOGGLE 
			'STARTDRAG 
			'STOPDRAG 
			'STARTDRAG_TOGGLE
			'STOPDRAG_TOGGLE
		    )) 
		((tbx_shieldgen_global->runTime)->selectMode = t)
	    )
	    ("cut_mask" 
		(event_mask = list('PICK))
	    ) 
	    ("add_shield_via" 
		(event_mask = list('PICK))
	    ) 
	    ("delete_shield_via" 
		(event_mask = list('PICK 
			'STARTDRAG 
			'STOPDRAG
		    ))
	    ) 
	    ("delete_shield" 
		(event_mask = list('PICK))
	    )
	) 
	((tbx_shieldgen_global->event)->mask = event_mask) 
	if((axlFormGetField form_handle "snap_grid") then 
	    ((tbx_shieldgen_global->event)->snapGrid = t) else 
	    ((tbx_shieldgen_global->event)->snapGrid = nil)
	)
	((tbx_shieldgen_global->event)->maskChange = t) 
	(axlCancelEnterFun)
    )
)
procedure(TBX_SHIELDROUTE_AddConnectMode_Process() 
    let((poly_base_structure_list param_set group_name cline_start_xy cline_end_xy
	    seg_poly_stack pad_poly_stack result last_dbid shield_items
	) 
	when((length(((tbx_shieldroute_data->runTime)->xyStack)) >= 2) 
	    (cline_start_xy = (lastelem 
		    ((tbx_shieldroute_data->runTime)->xyStack)
		)) 
	    (cline_end_xy = car(((tbx_shieldroute_data->runTime)->xyStack))) 
	    when(((axlGeo2Str cline_start_xy) != 
		    (axlGeo2Str cline_end_xy)) 
		foreach(rp 
		    ((tbx_shieldroute_data->runTime)->rpathStack) 
		    (result = (axlDBCreatePath rp 
			    (axlDBControl 
				'activeLayer
			    )
			)) 
		    when(result 
			(last_dbid = caar(result))
		    )
		) 
		when(last_dbid 
		    (axlDBAddGroupObjects 
			(tbx_shieldroute_data->activeGroup) last_dbid
		    )
		) 
		(pad_poly_stack = TBX_SHIELDROUTE_Get_Padstack_Polygons(list(cline_start_xy cline_end_xy) 
			(axlDBControl 
			    'activeLayer
			)
		    )) 
		(seg_poly_stack = ((tbx_shieldroute_data->runTime)->segPolyStack))
		(poly_base_structure_list = TBX_SHIELDROUTE_Get_Structure_Polygon(seg_poly_stack pad_poly_stack)) 
		(param_set = TBX_SHIELDROUTE_Derive_Params((axlDBControl 
			    'activeLayer
			) 
			(tbx_shieldroute_data->Formid)
		    )) 
		(group_name = upperCase(((tbx_shieldroute_data->activeGroup)->name))) 
		((tbx_shieldroute_data->shieldParam)[group_name] = param_set) 
		(shield_items = TBX_SHIELDROUTE_Create_Shield_Structure(poly_base_structure_list param_set))
		when(shield_items 
		    (axlDBAddGroupObjects 
			(tbx_shieldroute_data->activeGroup) shield_items
		    )
		) 
		foreach(tmp 
		    ((tbx_shieldroute_data->runTime)->tmpStack) 
		    (axlDeleteObject tmp) 
		    (axlDBRefreshId nil)
		) 
		(tbx_shieldroute_data->runTime = ncons(nil)) 
		(axlClearDynamics)
	    )
	) t
    )
)
procedure(TBX_SHIELDROUTE_AddConnectMode_Sketch_Path(event_xy event_xy_snap) 
    let((oversize result cur_xy path_info terminate
	    rpath cline_color prm
	) 
	if(!((tbx_shieldroute_data->runTime)->xyStack) then 
	    (tbx_shieldroute_data->activeGroup = TBX_SHIELDROUTE_Get_Next_Group()) 
	    (oversize = TBX_SHIELDROUTE_Get_Oversize((tbx_shieldroute_data->Formid))) 
	    if(oversize then 
		(result = TBX_SHIELDROUTE_Snap_To_Object(event_xy event_xy_snap)) 
		((tbx_shieldroute_data->runTime)->xyStack = list(car(result))) 
		(prm = (axlLayerGet 
			(axlDBControl 
			    'activeLayer
			)
		    ))
		(cline_color = (prm->color)) 
		(prm = (axlLayerGet 
			(tbx_shieldroute_data->tmpLineLayer)
		    )) 
		(prm->color = cline_color) 
		(axlLayerSet prm) 
		(axlVisibleUpdate t)
		TBX_SHIELDROUTE_Build_Dynamics((tbx_shieldroute_data->Formid)) else 
		(axlUIConfirm "Specify parameters before proceeding")
	    )
	    (terminate = nil) else 
	    (result = TBX_SHIELDROUTE_Snap_To_Object(event_xy event_xy_snap)) 
	    (cur_xy = car(result)) 
	    (rpath = (axlEnterPath ?points 
		    list(car(((tbx_shieldroute_data->runTime)->xyStack)) cur_xy)
		))
	    when(rpath 
		(oversize = TBX_SHIELDROUTE_Get_Oversize((tbx_shieldroute_data->Formid))) 
		(path_info = TBX_SHIELDROUTE_Route_Tmp_Path(rpath 
			(axlFormGetField 
			    (tbx_shieldroute_data->Formid) "line_width"
			) oversize
		    )) 
		when(path_info 
		    ((tbx_shieldroute_data->runTime)->rpathStack = cons(car(path_info) 
			    ((tbx_shieldroute_data->runTime)->rpathStack)
			)) 
		    ((tbx_shieldroute_data->runTime)->segPolyStack = cons(cadr(path_info) 
			    ((tbx_shieldroute_data->runTime)->segPolyStack)
			)) 
		    ((tbx_shieldroute_data->runTime)->tmpStack = cons(caddr(path_info) 
			    ((tbx_shieldroute_data->runTime)->tmpStack)
			))
		)
	    ) 
	    ((tbx_shieldroute_data->runTime)->xyStack = cons(cur_xy 
		    ((tbx_shieldroute_data->runTime)->xyStack)
		)) 
	    if(cadr(result) then 
		(terminate = t) else 
		TBX_SHIELDROUTE_Build_Dynamics((tbx_shieldroute_data->Formid))
		(terminate = nil)
	    )
	) terminate
    )
)
procedure(TBX_SHIELDROUTE_Adv_Export_Settings(advParams output_file) 
    let((port prm) 
	(port = outfile(output_file "w")) 
	if(port then 
	    fprintf(port "( %L\n" 
		car((axlDBGetDesignUnits))
	    ) 
	    foreach(entry advParams 
		cond((((entry->type) == "global") 
			fprintf(port "   (type  %L   net  %L   viaEnableDRC  %L  viaDRCSameNet  %L)\n" 
			    (entry->type) 
			    (entry->net) 
			    (entry->viaEnableDRC)
			    (entry->viaDRCSameNet)
			)
		    ) 
		    (((entry->type) == "side") 
			fprintf(port "   (type  %L   enable  %L   gap  %L   width  %L   style  %L)\n" 
			    (entry->type) 
			    (entry->enable) 
			    (entry->gap)
			    (entry->width) 
			    (entry->style)
			)
		    ) 
		    (((entry->type) == "tandem") 
			fprintf(port "   (type  %L   enable  %L   gap  %L   width  %L   style  %L   layer %L)\n" 
			    (entry->type) 
			    (entry->enable) 
			    (entry->gap)
			    (entry->width) 
			    (entry->style) 
			    (entry->layer)
			)
		    ) 
		    (((entry->type) == "via_ring") 
			(prm = copy(entry)) 
			(prm->viaStackOffset = parseString((prm->viaStackOffset))) 
			(prm->viaStackOffset = mapcar(lambda((x) 
				    atof(x)
				) 
				(prm->viaStackOffset)
			    )) 
			fprintf(port "   (type  %L   name  %L   padstacks  %L   ringOffset  %L   viaGap  %L   viaInitialOffset %L   viaStackOffset  %L   viaAlign  %L viaAlignAngle %L)\n" 
			    (prm->type) 
			    (prm->name) 
			    (prm->padstacks)
			    (prm->ringOffset) 
			    (prm->viaGap) 
			    (prm->viaInitialOffset) 
			    (prm->viaStackOffset) 
			    (prm->viaAlign)
			    (prm->viaAlignAngle)
			)
		    )
		)
	    ) 
	    fprintf(port ")\n")
	    close(port) else 
	    printf("Error: Cannot open file %L  for write access\n" output_file)
	) t
    )
)
procedure(TBX_SHIELDROUTE_Adv_Import_Settings(input_file) 
    let((port data adv_params config_units design_units
	    prm value_list
	) 
	(design_units = car((axlDBGetDesignUnits))) 
	(port = infile(input_file)) 
	if(port then 
	    (data = car(lineread(port))) 
	    close(port) 
	    (config_units = car(data))
	    (data = cdr(data)) 
	    foreach(entry data 
		(prm = copy(entry)) 
		(prm = cons(nil prm)) 
		(value_list = nil)
		cond(((((prm->type) == "side") || ((prm->type) == "tandem")) 
			when((prm->width) 
			    (prm->width = (axlMKSConvert 
				    (prm->width) config_units design_units
				))
			) 
			if(((prm->gap) && numberp((prm->gap)) && ((prm->gap) >= 0.0)) then 
			    (prm->gap = (axlMKSConvert 
				    (prm->gap) config_units design_units
				)) else 
			    (prm->gap = "NA")
			)
		    ) 
		    (((prm->type) == "via_ring") 
			when((prm->ringOffset) 
			    (prm->ringOffset = (axlMKSConvert 
				    (prm->ringOffset) config_units design_units
				))
			) 
			when((prm->viaGap) 
			    (prm->viaGap = (axlMKSConvert 
				    (prm->viaGap) config_units design_units
				))
			) 
			when((prm->viaInitialOffset) 
			    (prm->viaInitialOffset = (axlMKSConvert 
				    (prm->viaInitialOffset) config_units design_units
				))
			) 
			if((prm->viaStackOffset) then 
			    cond((numberp((prm->viaStackOffset)) 
				    (value_list = list((prm->viaStackOffset)))
				) 
				((listp((prm->viaStackOffset)) && (length((prm->viaStackOffset)) >= 1)) 
				    (value_list = (prm->viaStackOffset))
				)
			    ) 
			    when(value_list 
				(value_list = mapcar(lambda((x) 
					    (axlMKSConvert x config_units design_units)
					) value_list
				    )) 
				(prm->viaStackOffset = buildString(mapcar(lambda((x) 
						sprintf(nil "%L" x)
					    ) value_list
					) " "
				    ))
			    ) else
			    (prm->viaStackOffset = "")
			)
		    ) 
		    (t t)
		) 
		(adv_params = cons(prm adv_params))
	    ) 
	    when(adv_params 
		(adv_params = TBX_SHIELDROUTE_Adv_Synchronize(adv_params))
	    ) else 
	    printf("Error: Cannot open file %L  for  read access\n" input_file)
	) adv_params
    )
)
procedure(TBX_SHIELDROUTE_Adv_Synchronize(adv_params) 
    let((prm_template side_prm global_prm tandem_prm tmp_prm
	    design_layers new_params via_prms
	) 
	(design_layers = mapcar(lambda((x) 
		    upperCase(x)
		) 
		(axlSubclassRoute)
	    )) 
	(design_layers = append1(design_layers "SOLDERMASK_BOTTOM")) 
	(design_layers = cons("SOLDERMASK_TOP" design_layers)) 
	(prm_template = list(nil 
		'type "tandem" 
		'enable nil
		'style 
		(tbx_shieldroute_data->defaultValue)["adv_tandem_style"] 
		'width 
		(tbx_shieldroute_data->defaultValue)["adv_tandem_width"] 
		'gap
		"NA"
	    ))
	(tandem_prm = makeTable("tandem_prm_data" nil)) 
	foreach(prm adv_params 
	    cond((((prm->type) == "side") 
		    (side_prm = copy(prm))
		) 
		(((prm->type) == "global") 
		    (global_prm = copy(prm))
		) 
		(((prm->type) == "tandem") 
		    when((prm->layer) 
			(tandem_prm[upperCase((prm->layer))] = copy(prm))
		    )
		) 
		(((prm->type) == "via_ring") 
		    (via_prms = cons(copy(prm) via_prms))
		)
	    )
	) 
	foreach(lyr tandem_prm 
	    unless(member(lyr design_layers) 
		remove(lyr tandem_prm)
	    )
	) 
	foreach(lyr design_layers 
	    if(tandem_prm[lyr] then 
		(tmp_prm = copy(tandem_prm[lyr])) else 
		(tmp_prm = copy(prm_template))
		(tmp_prm->layer = lyr)
	    ) 
	    (new_params = cons(tmp_prm new_params))
	) 
	unless(side_prm 
	    (side_prm = list(nil 
		    'type "side" 
		    'enable nil
		    'style 
		    (tbx_shieldroute_data->defaultValue)["adv_side_style"] 
		    'width 
		    (tbx_shieldroute_data->defaultValue)["adv_side_width"] 
		    'gap
		    (tbx_shieldroute_data->defaultValue)["adv_side_gap"]
		))
	)
	unless(global_prm 
	    (global_prm = list(nil 
		    'type "global" 
		    'net ""
		))
	) 
	(new_params = cons(side_prm new_params)) 
	(new_params = cons(global_prm new_params)) 
	(new_params = nconc(new_params via_prms)) new_params
    )
)
procedure(TBX_SHIELDROUTE_Advanced_Params() 
    let((FORM_FILE fid) 
	(FORM_FILE = TBX_FORM_Get_Name((tbx_shieldroute_data->licCheck) "shieldroute_adv")) 
	(fid = (axlFormCreate 
		gensym() FORM_FILE 
		'(e outer) 
		'TBX_SHIELDROUTE_Advanced_Params_Callback
		t
	    )) 
	TBX_FORM_Init_Header(fid "Licensed for: " 
	    (tbx_shieldroute_data->licCheck) 
	    (tbx_shieldroute_data->versionStr)
	) 
	(axlFormDisplay fid)
	TBX_SHIELDROUTE_Init_Form("advanced" fid) 
	TBX_SHIELDROUTE_Update_Form(fid "adv_side_shield") 
	TBX_SHIELDROUTE_Update_Form(fid "adv_via_param") 
	(axlFormGridUpdate fid "grid") 
	(axlFormGridEvents fid "grid" 
	    list('cellselect 
		'change 
		'mrowselect
	    )
	)
	TBX_FORM_Delete((tbx_shieldroute_data->licCheck) FORM_FILE)
    )
)
procedure(TBX_SHIELDROUTE_Advanced_Params_Callback(form_handle) 
    let((selected_rows cell col_nr value output_file
	    input_file result ring_name via_name msg
	    tmp_list first_match
	) 
	case((form_handle->curField) 
	    ("grid" 
		(selected_rows = (axlFormGridSelected form_handle "grid")) 
		caseq((form_handle->event) 
		    (change 
			(col_nr = (form_handle->col)) 
			(value = (axlFormGetField form_handle "grid")) 
			foreach(rw selected_rows 
			    if(onep(col_nr) then 
				(cell = (axlFormGridNewCell)) 
				(cell->col = col_nr) 
				(cell->row = rw)
				(cell->value = nil) 
				(cell->check = value) 
				(axlFormSetField form_handle "grid" cell) 
				(axlFormGridUpdate form_handle "grid") else
				(cell = (axlFormGridNewCell)) 
				(cell->col = col_nr) 
				(cell->row = rw) 
				(cell->value = value) 
				(axlFormSetField form_handle "grid" cell)
				(axlFormGridUpdate form_handle "grid")
			    )
			)
		    )
		)
	    ) 
	    ("adv_enable_side_shield" 
		TBX_SHIELDROUTE_Update_Form(form_handle "adv_side_shield")
	    ) 
	    ("adv_side_style" 
		TBX_SHIELDROUTE_Update_Form(form_handle "adv_side_shield")
	    ) 
	    ("adv_side_gap" 
		(axlFormSetField form_handle "adv_side_gap" 
		    TBX_SHIELDROUTE_Validate_Gap((form_handle->curValue) t)
		) 
		TBX_SHIELDROUTE_Update_Form(form_handle "adv_side_shield")
	    )
	    ("adv_ring_list" 
		(ring_name = (axlFormGetField form_handle "adv_ring_list")) 
		(axlFormListDeleteAll form_handle "adv_via_list") 
		(axlFormListAddItem form_handle "adv_via_list" 
		    ((tbx_shieldroute_data->advTmpParams)[ring_name]->padstacks) -1
		) 
		(axlFormSetField form_handle "adv_ring_offset" 
		    ((tbx_shieldroute_data->advTmpParams)[ring_name]->ringOffset)
		)
		(axlFormSetField form_handle "adv_via_gap" 
		    ((tbx_shieldroute_data->advTmpParams)[ring_name]->viaGap)
		) 
		(axlFormSetField form_handle "adv_via_initial_offset" 
		    ((tbx_shieldroute_data->advTmpParams)[ring_name]->viaInitialOffset)
		) 
		(axlFormSetField form_handle "adv_via_stack_offset" 
		    ((tbx_shieldroute_data->advTmpParams)[ring_name]->viaStackOffset)
		) 
		(axlFormSetField form_handle "adv_via_align" 
		    ((tbx_shieldroute_data->advTmpParams)[ring_name]->viaAlign)
		) 
		TBX_SHIELDROUTE_Update_Form(form_handle "adv_via_param")
	    ) 
	    ("adv_add_ring" 
		(ring_name = (axlEnterString ?prompts 
			list("Enter new ring name:")
		    )) 
		when((stringp(ring_name) && (ring_name != "")) 
		    (ring_name = upperCase(ring_name)) 
		    if((tbx_shieldroute_data->advTmpParams)[ring_name] then 
			printf("Warning: Name already exists.\n") else 
			(axlFormListAddItem form_handle "adv_ring_list" ring_name -1)
			((tbx_shieldroute_data->advTmpParams)[ring_name] = copy((tbx_shieldroute_data->advTmpParams)[""])) 
			((tbx_shieldroute_data->advTmpParams)[ring_name]->name = ring_name)
		    )
		) 
		TBX_SHIELDROUTE_Update_Form(form_handle "adv_via_param")
	    ) 
	    ("adv_delete_ring" 
		(ring_name = (axlFormGetField form_handle "adv_ring_list")) 
		(axlFormListDeleteItem form_handle "adv_ring_list" ring_name) 
		remove(ring_name 
		    (tbx_shieldroute_data->advTmpParams)
		) 
		when((length((tbx_shieldroute_data->advTmpParams)) > 0) 
		    (axlFormListSelect form_handle "adv_ring_list" 0) 
		    (ring_name = (axlFormGetField form_handle "adv_ring_list")) 
		    (axlFormListDeleteAll form_handle "adv_via_list") 
		    (axlFormListAddItem form_handle "adv_via_list" 
			((tbx_shieldroute_data->advTmpParams)[ring_name]->padstacks) -1
		    )
		    (axlFormSetField form_handle "adv_ring_offset" 
			((tbx_shieldroute_data->advTmpParams)[ring_name]->ringOffset)
		    ) 
		    (axlFormSetField form_handle "adv_via_gap" 
			((tbx_shieldroute_data->advTmpParams)[ring_name]->viaGap)
		    ) 
		    (axlFormSetField form_handle "adv_via_initial_offset" 
			((tbx_shieldroute_data->advTmpParams)[ring_name]->viaInitialOffset)
		    ) 
		    (axlFormSetField form_handle "adv_via_stack_offset" 
			((tbx_shieldroute_data->advTmpParams)[ring_name]->viaStackOffset)
		    ) 
		    (axlFormSetField form_handle "adv_via_align" 
			((tbx_shieldroute_data->advTmpParams)[ring_name]->viaAlign)
		    )
		)
		TBX_SHIELDROUTE_Update_Form(form_handle "adv_via_param")
	    ) 
	    ("adv_add_via_to_list" 
		(ring_name = (axlFormGetField form_handle "adv_ring_list")) 
		if((ring_name && (ring_name != "")) then 
		    (via_name = car((axlUIDataBrowse 
				'PADSTACK 
				'(RETRIEVE_NAME) "Select via padstack" t
			    )
			)) 
		    when(via_name 
			(axlFormListAddItem form_handle "adv_via_list" via_name -1) 
			((tbx_shieldroute_data->advTmpParams)[ring_name]->padstacks = append1(((tbx_shieldroute_data->advTmpParams)[ring_name]->padstacks) via_name))
		    ) else
		    printf("Select a ring item first before specifying vias.\n")
		) 
		TBX_SHIELDROUTE_Update_Form(form_handle "adv_via_param")
	    ) 
	    ("adv_delete_via_from_list" 
		(ring_name = (axlFormGetField form_handle "adv_ring_list")) 
		if((ring_name && (ring_name != "")) then 
		    (via_name = (axlFormGetField form_handle "adv_via_list")) 
		    when((via_name && (via_name != "")) 
			(axlFormListDeleteItem form_handle "adv_via_list" via_name) 
			(tmp_list = nil) 
			(first_match = nil) 
			foreach(v 
			    ((tbx_shieldroute_data->advTmpParams)[ring_name]->padstacks) 
			    if(((v == via_name) && !first_match) then 
				(first_match = t) else 
				(tmp_list = cons(v tmp_list))
			    )
			)
			(tmp_list = reverse(tmp_list)) 
			((tbx_shieldroute_data->advTmpParams)[ring_name]->padstacks = tmp_list)
		    ) else
		    printf("Select a ring item first.\n")
		) 
		TBX_SHIELDROUTE_Update_Form(form_handle "adv_via_param")
	    )
	    ("adv_via_move_up" 
		(ring_name = (axlFormGetField form_handle "adv_ring_list")) 
		(via_name = (axlFormGetField form_handle "adv_via_list")) 
		when((ring_name && via_name) 
		    ((tbx_shieldroute_data->advTmpParams)[ring_name]->padstacks = TBX_UTIL_List_Move_Item(((tbx_shieldroute_data->advTmpParams)[ring_name]->padstacks) via_name "up")) 
		    (axlFormListDeleteAll form_handle "adv_via_list") 
		    (axlFormListAddItem form_handle "adv_via_list" 
			((tbx_shieldroute_data->advTmpParams)[ring_name]->padstacks) -1
		    ) 
		    (axlFormListSelect form_handle "adv_via_list" via_name)
		)
	    ) 
	    ("adv_via_move_down" 
		(ring_name = (axlFormGetField form_handle "adv_ring_list")) 
		(via_name = (axlFormGetField form_handle "adv_via_list")) 
		when((ring_name && via_name) 
		    ((tbx_shieldroute_data->advTmpParams)[ring_name]->padstacks = TBX_UTIL_List_Move_Item(((tbx_shieldroute_data->advTmpParams)[ring_name]->padstacks) via_name "down")) 
		    (axlFormListDeleteAll form_handle "adv_via_list") 
		    (axlFormListAddItem form_handle "adv_via_list" 
			((tbx_shieldroute_data->advTmpParams)[ring_name]->padstacks) -1
		    ) 
		    (axlFormListSelect form_handle "adv_via_list" via_name)
		)
	    ) 
	    ("adv_ring_offset" 
		(ring_name = (axlFormGetField form_handle "adv_ring_list")) 
		((tbx_shieldroute_data->advTmpParams)[ring_name]->ringOffset = (form_handle->curValue))
	    ) 
	    ("adv_via_gap" 
		(ring_name = (axlFormGetField form_handle "adv_ring_list")) 
		((tbx_shieldroute_data->advTmpParams)[ring_name]->viaGap = (form_handle->curValue))
	    ) 
	    ("adv_via_initial_offset" 
		(ring_name = (axlFormGetField form_handle "adv_ring_list")) 
		((tbx_shieldroute_data->advTmpParams)[ring_name]->viaInitialOffset = (form_handle->curValue))
	    )
	    ("adv_via_stack_offset" 
		(ring_name = (axlFormGetField form_handle "adv_ring_list")) 
		((tbx_shieldroute_data->advTmpParams)[ring_name]->viaStackOffset = (form_handle->curValue))
	    ) 
	    ("adv_via_align" 
		(ring_name = (axlFormGetField form_handle "adv_ring_list")) 
		((tbx_shieldroute_data->advTmpParams)[ring_name]->viaAlign = (form_handle->curValue)) 
		TBX_SHIELDROUTE_Update_Form(form_handle "adv_via_param")
	    ) 
	    ("adv_via_align_angle" 
		(ring_name = (axlFormGetField form_handle "adv_ring_list")) 
		((tbx_shieldroute_data->advTmpParams)[ring_name]->viaAlignAngle = (form_handle->curValue)) 
		TBX_SHIELDROUTE_Update_Form(form_handle "adv_via_param")
	    ) 
	    ("adv_save_settings" 
		(output_file = (axlDMFileBrowse "ALLEGRO_TEXT" t)) 
		when(output_file 
		    (tbx_shieldroute_data->advParams = TBX_SHIELDROUTE_Get_Advanced_Params(form_handle)) 
		    TBX_SHIELDROUTE_Adv_Export_Settings((tbx_shieldroute_data->advParams) output_file)
		)
	    ) 
	    ("adv_load_settings" 
		(input_file = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
		when(input_file 
		    (tbx_shieldroute_data->advParams = TBX_SHIELDROUTE_Adv_Import_Settings(input_file)) 
		    TBX_SHIELDROUTE_Init_Form("advanced" form_handle) 
		    TBX_SHIELDROUTE_Update_Form(form_handle "adv_side_shield") 
		    TBX_SHIELDROUTE_Update_Form(form_handle "adv_via_param")
		    (axlFormGridUpdate form_handle "grid") 
		    (axlFormGridEvents form_handle "grid" 
			list('cellselect 
			    'change 
			    'mrowselect
			)
		    )
		)
	    )
	    ("adv_browse_net" 
		(result = (axlUIDataBrowse 
			'NET 
			list('RETRIEVE_NAME) "Select net" t
		    )) 
		when(result 
		    (axlFormSetField form_handle "adv_shape_net" 
			car(result)
		    )
		)
	    ) 
	    ("adv_via_enable_drc" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "adv_via_drc_same_net" t) else 
		    (axlFormSetFieldEditable form_handle "adv_via_drc_same_net" nil)
		)
	    ) 
	    ("adv_via_enable_drc_mini_help" 
		(msg = "Only applies to via pattern generation. If enabled only vias not causing a DRC will be created. You may distinguish between standard physical/spacing and same net DRC.") 
		(msg = strcat(msg "\nNote: Application does not modify constraint modes.")) 
		(axlUIConfirm msg)
	    ) 
	    ("adv_via_initial_offset_mini_help" 
		(msg = "This value specifies the offset for the first via to be generated on the path and can be used for tuning purposes. The default is 0.0 which means that the first via will be generated at the starting point of the path. ") 
		(msg = strcat(msg "Refer to text labels on Mfg/TMP_DRAFTING  which indicate vertices and path orientation.")) 
		(axlUIConfirm msg)
	    ) 
	    ("adv_via_stack_offset_mini_help" 
		(msg = "This parameter specifies the distance for the vias inside a stack. A stack is formed when two more padstacks have been specified for a given ring. ") 
		(msg = strcat(msg "An empty value is identical to 0.0, vias from stack will be placed on top of each other. Mutliple values can be specified if asymmetrical spacings are required. ")) 
		(msg = strcat(msg "\nFor example a value \"0.35 0.45\" defines a gap of 0.35 from first to second via and a gap of 0.45 from second to third via in the stack.")) 
		(msg = strcat(msg "\nNote:\n1) In Contour mode the sum of all inner gap values must be smaller than main via gap."))
		(msg = strcat(msg "\n2) DRC may occur if stacking rules (e.g. Pad-Pad Connect) were not defined accordingly.")) 
		(axlUIConfirm msg)
	    )
	    ("adv_via_align_mini_help" 
		(msg = "This parameter specifies the alignment of the vias inside a stack. A stack is formed when two more padstacks have been specified for a given ring. ") 
		(msg = strcat(msg "The default value is \"Contour\"  which means that all vias from the stack follow the path of the shield structure.")) 
		(msg = strcat(msg "\nIf \"Inwards\" or \"Outwards\" is selected the second, third and following vias of the stack will be created on a path perpendicular to the contour.")) 
		(msg = strcat(msg "\nWhen choosing one of the staggering options vias will be arranged in a staggered pattern. The offset value then specifies the distance of the staggered via to the ring center."))
		(axlUIConfirm msg)
	    ) 
	    ("adv_via_align_angle_mini_help" 
		(msg = "The angle parameter only applies in case of \"Inwards\" or \"Outwards\" alignment when multiple padstacks have been specified for a given ring. The default values is 90.0 degrees which creates a perpendicular stub. ") 
		(msg = strcat(msg "Value can be changed between 0 and 180 degrees.")) 
		(axlUIConfirm msg)
	    ) 
	    ("adv_done" 
		(tbx_shieldroute_data->advParams = TBX_SHIELDROUTE_Get_Advanced_Params(form_handle)) 
		(axlFormClose form_handle) 
		TBX_SHIELDROUTE_Update_Form((tbx_shieldroute_data->Formid) "shield_mode") 
		TBX_SHIELDROUTE_Update_Form((tbx_shieldroute_data->Formid) "add_connect_opt")
	    ) 
	    ("adv_cancel" 
		(axlFormClose form_handle)
	    ) 
	    ("my_help" 
		(axlShell "tbx help shieldroute")
	    )
	    (t t)
	)
    )
)
procedure(TBX_SHIELDROUTE_Break_Poly(poly_a poly_b tmp_layer) 
    let((poly_a_ll poly_a_ur poly_b_ll poly_b_ur rpath
	    cut_x cut_y_bot cut_y_top poly_list cut_y
	    cut_x_left cut_x_right result line_dbid width
	    height
	) 
	(poly_a_ll = car((poly_a->bBox))) 
	(poly_a_ur = cadr((poly_a->bBox))) 
	(poly_b_ll = car((poly_b->bBox))) 
	(poly_b_ur = cadr((poly_b->bBox)))
	(width = abs((car(poly_b_ur) - car(poly_b_ll)))) 
	(height = abs((cadr(poly_b_ur) - cadr(poly_b_ll)))) 
	if(t then 
	    (cut_x = (car(poly_b_ll) + (width / 2.0))) 
	    (cut_y_bot = (cadr(poly_a_ll) - (axlMKSConvert "0.1 MM" 
			car((axlDBGetDesignUnits))
		    ))) 
	    (cut_y_top = (cadr(poly_a_ur) + (axlMKSConvert "0.1 MM" 
			car((axlDBGetDesignUnits))
		    )))
	    (rpath = (axlPathStart 
		    list((cut_x:cut_y_bot) 
			(cut_x:cut_y_top)
		    ) 0.0
		)) else 
	    (cut_y = (cadr(poly_b_ll) + (height / 2.0))) 
	    (cut_x_left = (car(poly_a_ll) - (axlMKSConvert "0.1 MM" 
			car((axlDBGetDesignUnits))
		    ))) 
	    (cut_x_right = (car(poly_a_ur) + (axlMKSConvert "0.1 MM" 
			car((axlDBGetDesignUnits))
		    )))
	    (rpath = (axlPathStart 
		    list((cut_x_left:cut_y) 
			(cut_x_right:cut_y)
		    ) 0.0
		))
	) 
	(result = (axlDBCreatePath rpath tmp_layer)) 
	when(result 
	    (line_dbid = caar(result)) 
	    (poly_list = (axlPolyOperation poly_a 
		    car((axlPolyFromDB line_dbid)) 
		    'ANDNOT
		)) 
	    (axlDeleteObject line_dbid)
	)
	poly_list
    )
)
procedure(TBX_SHIELDROUTE_Build_Dynamics(form_handle) 
    let((line_width oversize last_xy) 
	when(((tbx_shieldroute_data->runTime)->xyStack) 
	    (last_xy = car(((tbx_shieldroute_data->runTime)->xyStack))) 
	    (line_width = (axlFormGetField form_handle "line_width")) 
	    (axlClearDynamics) 
	    (oversize = TBX_SHIELDROUTE_Get_Oversize(form_handle))
	    (axlAddSimpleRbandDynamics last_xy "path" ?width 
		(line_width + (2 * oversize))
		?color 
		(tbx_shieldroute_data->tmpShapeLayer)
	    ) 
	    (axlAddSimpleRbandDynamics last_xy "path" ?width line_width
		?color 
		(tbx_shieldroute_data->tmpLineLayer)
	    )
	) t
    )
)
procedure(TBX_SHIELDROUTE_Cache_Param(form_handle) 
    let((rec session_param gap_value) 
	(rec = "shieldroute") 
	(session_param = eval('tbx_session_param)) 
	(session_param[rec] = ncons(nil)) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "use_default_params") 
	    stringToSymbol("use_default_params")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "create_tandem_shield") 
	    stringToSymbol("create_tandem_shield")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "tandem_width") 
	    stringToSymbol("tandem_width")
	) 
	foreach(fn 
	    list("tandem_gap" "side_gap") 
	    (gap_value = (axlFormGetField form_handle fn)) 
	    if((gap_value && (type(gap_value) == 'string) && atof(gap_value) && (atof(gap_value) > 0.0)) then 
		putprop(session_param[rec] 
		    atof(gap_value) 
		    stringToSymbol(fn)
		) else 
		putprop(session_param[rec] "NA" 
		    stringToSymbol(fn)
		)
	    )
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "create_side_shield") 
	    stringToSymbol("create_side_shield")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "side_width") 
	    stringToSymbol("side_width")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "shape_style") 
	    stringToSymbol("shape_style")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "shape_net") 
	    stringToSymbol("shape_net")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "use_advanced_params") 
	    stringToSymbol("use_advanced_params")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "keepout_void_all_pads") 
	    stringToSymbol("keepout_void_all_pads")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "add_connect") 
	    stringToSymbol("add_connect")
	)
	putprop(session_param[rec] 
	    (axlDBControl 
		'activeLayer
	    ) 
	    stringToSymbol("active_layer")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "lock_mode") 
	    stringToSymbol("lock_mode")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "lock_angle") 
	    stringToSymbol("lock_angle")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "corner_size") 
	    stringToSymbol("corner_size")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "corner_mode") 
	    stringToSymbol("corner_mode")
	)
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "line_width") 
	    stringToSymbol("line_width")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "select_cline") 
	    stringToSymbol("select_cline")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "update_shield") 
	    stringToSymbol("update_shield")
	) 
	putprop(session_param[rec] 
	    (axlFormGetField form_handle "delete_shield") 
	    stringToSymbol("delete_shield")
	) 
	putprop(session_param[rec] 
	    car((axlDBGetDesignUnits)) 
	    stringToSymbol("units")
	)
	t
    )
)
procedure(TBX_SHIELDROUTE_Calculate_Stub_Locations(xy distance_values direction orient_angle seg_data
	poly_clockwise
    ) 
    let((tan_vec pt_list size size_vec new_loc
	    spin_angle orient_vec
	) 
	(tan_vec = TBX_SHIELDROUTE_Get_Polygon_Tangent_Vector(xy seg_data poly_clockwise)) 
	if(poly_clockwise then 
	    if((direction == "outwards") then 
		(spin_angle = orient_angle) else 
		(spin_angle = (- orient_angle))
	    ) else 
	    if((direction == "outwards") then 
		(spin_angle = (- orient_angle)) else 
		(spin_angle = orient_angle)
	    )
	) 
	(orient_vec = TBX_MATH_Transform_Vector(tan_vec ?angle spin_angle)) 
	(pt_list = list(xy))
	(size = 0.0) 
	foreach(gp distance_values 
	    if((gp == 0.0) then 
		(pt_list = append1(pt_list gp)) else 
		(size = (size + gp))
		(size_vec = TBX_MATH_Transform_Vector(orient_vec ?size size)) 
		(new_loc = TBX_MATH_Add_Vector(xy size_vec)) 
		(pt_list = append1(pt_list new_loc))
	    )
	) pt_list
    )
)
procedure((TBX_SHIELDROUTE_Calculate_Via_Locations rpath main_gap l_stack_gap via_align
	via_align_angle initial_offset \@optional debug_layer
    ) 
    let((PI rseg_list start_xy end_xy center_xy
	    radius is_clockwise is_circle arc_angle seg_length
	    via_xy via_locations arc_vec line_vec spin_vec
	    size_vec cur_offset cur_offset_angle stub_length stub_angle
	    new_loc poly_is_clockwise seg_data pt_list first_xy
	    last_xy via_gap vec_list cur_gap_data contour_gap_list
	    gap_sum gap_diff stagger_gap_list stagger_offset v1
	    v2
	) 
	(PI = (defMathConstants('mymathconst)->PI)) 
	(gap_sum = 0.0) 
	foreach(g l_stack_gap 
	    (gap_sum = (gap_sum + g))
	) 
	(gap_diff = (main_gap - gap_sum))
	when((length(l_stack_gap) > 0) 
	    (contour_gap_list = append1(l_stack_gap gap_diff))
	) 
	(stagger_gap_list = list((main_gap / 2.0) 
		(main_gap / 2.0)
	    )) 
	(cur_gap_data = contour_gap_list) 
	when(((via_align == "stagger_out") || (via_align == "stagger_in") || (via_align == "stagger_both")) 
	    (cur_gap_data = stagger_gap_list) 
	    (stagger_offset = car(l_stack_gap))
	) 
	(poly_is_clockwise = TBX_DBCORE_Is_Poly_Clockwise(rpath debug_layer))
	(rseg_list = (axlPathGetPathSegs rpath)) 
	(start_xy = (axlPathSegGetEndPoint 
		car(rseg_list)
	    )) 
	(cur_offset = initial_offset) 
	(via_locations = tconc(nil nil)) 
	foreach(rseg 
	    cdr(rseg_list) 
	    (end_xy = (axlPathSegGetEndPoint rseg)) 
	    (center_xy = (axlPathSegGetArcCenter rseg)) 
	    if(center_xy then 
		(is_clockwise = (axlPathSegGetArcClockwise rseg)) 
		when(((axlGeo2Str start_xy) == 
			(axlGeo2Str end_xy)) 
		    (is_circle = t)
		) 
		(arc_vec = TBX_MATH_Get_Vector(center_xy start_xy))
		(arc_angle = TBX_GEOM_Get_Arc_Spin_Angle(start_xy end_xy center_xy is_clockwise is_circle)) 
		(radius = (axlDistance center_xy start_xy)) 
		(seg_length = ((2.0 * PI * radius * abs(arc_angle)) / 360.0)) 
		(seg_data = list(start_xy end_xy center_xy is_clockwise)) else
		(line_vec = TBX_MATH_Get_Vector(start_xy end_xy)) 
		(seg_length = (axlDistance start_xy end_xy)) 
		(seg_data = list(start_xy end_xy))
	    )
	    if((cur_offset > seg_length) then 
		(cur_offset = (cur_offset - seg_length)) else 
		while((cur_offset <= seg_length) 
		    (via_xy = nil) 
		    if(center_xy then 
			(cur_offset_angle = ((cur_offset / seg_length) * arc_angle)) 
			(spin_vec = TBX_MATH_Transform_Vector(arc_vec ?angle cur_offset_angle)) 
			(via_xy = TBX_MATH_Add_Vector(center_xy 
				list(spin_vec)
			    ))
			(stub_angle = (abs(arc_angle) - abs(cur_offset_angle))) 
			(stub_length = abs(((stub_angle / arc_angle) * seg_length))) else 
			(size_vec = TBX_MATH_Transform_Vector(line_vec ?size cur_offset)) 
			(via_xy = TBX_MATH_Add_Vector(start_xy 
				list(size_vec)
			    ))
			(stub_length = (seg_length - cur_offset))
		    ) 
		    cond((((length(l_stack_gap) > 0) && exists(x 
				    list("inwards" "outwards") 
				    (x == via_align)
				)) 
			    (via_gap = main_gap) 
			    (pt_list = TBX_SHIELDROUTE_Calculate_Stub_Locations(via_xy l_stack_gap via_align via_align_angle seg_data
				    poly_is_clockwise
				)) 
			    tconc(via_locations pt_list) 
			    (cur_offset = (cur_offset + via_gap))
			) 
			(((length(l_stack_gap) > 0) && (via_align == "contour")) 
			    unless(cur_gap_data 
				(cur_gap_data = contour_gap_list)
			    ) 
			    (via_gap = car(cur_gap_data)) 
			    (cur_gap_data = cdr(cur_gap_data)) 
			    (pt_list = append1(pt_list via_xy))
			    when((length(pt_list) == (length(l_stack_gap) + 1)) 
				tconc(via_locations pt_list) 
				(pt_list = list())
			    ) 
			    (cur_offset = (cur_offset + via_gap))
			) 
			((stagger_offset && exists(x 
				    list("stagger_out" "stagger_in" "stagger_both") 
				    (x == via_align)
				)) 
			    unless(cur_gap_data 
				(cur_gap_data = stagger_gap_list)
			    ) 
			    (via_gap = car(cur_gap_data)) 
			    (cur_gap_data = cdr(cur_gap_data)) 
			    if(onep(length(pt_list)) then 
				cond(((via_align == "stagger_out") 
					(vec_list = list(TBX_SHIELDROUTE_Get_Polygon_Normal_Vector(via_xy seg_data poly_is_clockwise "outwards")))
				    ) 
				    ((via_align == "stagger_in") 
					(vec_list = list(TBX_SHIELDROUTE_Get_Polygon_Normal_Vector(via_xy seg_data poly_is_clockwise "inwards")))
				    ) 
				    ((via_align == "stagger_both") 
					(v1 = TBX_SHIELDROUTE_Get_Polygon_Normal_Vector(via_xy seg_data poly_is_clockwise "inwards")) 
					(v2 = TBX_SHIELDROUTE_Get_Polygon_Normal_Vector(via_xy seg_data poly_is_clockwise "outwards")) 
					(vec_list = list(v1 v2))
				    ) 
				    (t 
					(vec_list = nil)
				    )
				) 
				foreach(v vec_list 
				    (size_vec = TBX_MATH_Transform_Vector(v ?size stagger_offset)) 
				    (new_loc = TBX_MATH_Add_Vector(via_xy size_vec)) 
				    (pt_list = append1(pt_list new_loc))
				) 
				tconc(via_locations pt_list)
				(pt_list = list()) else 
				(pt_list = append1(pt_list via_xy))
			    )
			    (cur_offset = (cur_offset + via_gap))
			) 
			(zerop(length(l_stack_gap)) 
			    (via_gap = main_gap) 
			    (pt_list = list(via_xy)) 
			    tconc(via_locations pt_list) 
			    (cur_offset = (cur_offset + via_gap))
			)
		    )
		)
		if((stub_length < via_gap) then 
		    (cur_offset = (via_gap - stub_length)) else 
		    (cur_offset = 0.0)
		)
	    ) 
	    (start_xy = end_xy)
	)
	(via_locations = cdar(via_locations)) 
	when((length(via_locations) > 1) 
	    (first_xy = caar(via_locations)) 
	    (last_xy = car((lastelem via_locations))) 
	    when(((axlDistance last_xy first_xy) < main_gap) 
		(via_locations = reverse(cdr(reverse(via_locations))))
	    )
	) via_locations
    )
)
procedure(TBX_SHIELDROUTE_Callback(form_handle) 
    let((result active_layer prm cline_color msg) 
	case((form_handle->curField) 
	    ("use_default_params" 
		TBX_SHIELDROUTE_Update_Form(form_handle "shield_mode") 
		TBX_SHIELDROUTE_Update_Form(form_handle "add_connect_opt")
	    ) 
	    ("use_advanced_params" 
		TBX_SHIELDROUTE_Update_Form(form_handle "shield_mode") 
		TBX_SHIELDROUTE_Update_Form(form_handle "add_connect_opt") 
		when(((form_handle->curValue) && !(tbx_shieldroute_data->advParams)) 
		    (axlUIConfirm "Please specify advanced parameters")
		)
	    ) 
	    ("specify_advanced_params" 
		TBX_SHIELDROUTE_Update_Form(form_handle "shield_mode") 
		TBX_SHIELDROUTE_Advanced_Params()
	    ) 
	    ("add_connect" 
		when((form_handle->curValue) 
		    when((tbx_shieldroute_data->transMark) 
			(axlDBTransactionCommit 
			    (tbx_shieldroute_data->transMark)
			) 
			(tbx_shieldroute_data->transMark = (axlDBTransactionStart))
		    ) 
		    (tbx_shieldroute_data->runTime = ncons(nil)) 
		    TBX_SHIELDROUTE_Update_Form(form_handle "run_mode") 
		    TBX_SHIELDROUTE_Update_Form(form_handle "shield_mode")
		    TBX_SHIELDROUTE_Update_Form(form_handle "add_connect_opt") 
		    TBX_SHIELDROUTE_Init_Filter(form_handle)
		)
	    )
	    ("select_cline" 
		when((form_handle->curValue) 
		    when((tbx_shieldroute_data->transMark) 
			(axlDBTransactionCommit 
			    (tbx_shieldroute_data->transMark)
			) 
			(tbx_shieldroute_data->transMark = (axlDBTransactionStart))
		    ) 
		    (tbx_shieldroute_data->runTime = ncons(nil)) 
		    TBX_SHIELDROUTE_Update_Form(form_handle "run_mode") 
		    TBX_SHIELDROUTE_Update_Form(form_handle "shield_mode")
		    TBX_SHIELDROUTE_Update_Form(form_handle "add_connect_opt") 
		    TBX_SHIELDROUTE_Init_Filter(form_handle)
		)
	    ) 
	    ("update_shield" 
		when((form_handle->curValue) 
		    when((tbx_shieldroute_data->transMark) 
			(axlDBTransactionCommit 
			    (tbx_shieldroute_data->transMark)
			) 
			(tbx_shieldroute_data->transMark = (axlDBTransactionStart))
		    ) 
		    (tbx_shieldroute_data->runTime = ncons(nil)) 
		    TBX_SHIELDROUTE_Update_Form(form_handle "run_mode") 
		    TBX_SHIELDROUTE_Update_Form(form_handle "add_connect_opt")
		    TBX_SHIELDROUTE_Init_Filter(form_handle)
		)
	    ) 
	    ("delete_shield" 
		when((form_handle->curValue) 
		    when((tbx_shieldroute_data->transMark) 
			(axlDBTransactionCommit 
			    (tbx_shieldroute_data->transMark)
			) 
			(tbx_shieldroute_data->transMark = (axlDBTransactionStart))
		    ) 
		    (tbx_shieldroute_data->runTime = ncons(nil)) 
		    foreach(lyr 
			(axlSubclassRoute) 
			when((axlIsVisibleLayer 
				strcat((axlMapClassName "ETCH") "/" lyr)
			    ) 
			    (axlVisibleLayer 
				strcat((axlMapClassName "BOUNDARY") "/" lyr) t
			    )
			)
		    ) 
		    TBX_SHIELDROUTE_Update_Form(form_handle "run_mode")
		    TBX_SHIELDROUTE_Update_Form(form_handle "add_connect_opt") 
		    TBX_SHIELDROUTE_Init_Filter(form_handle)
		)
	    ) 
	    ("shape_style" 
		if(((form_handle->curValue) == "Route Keepout") then 
		    (axlFormSetFieldEditable form_handle "shape_net" nil) 
		    (axlFormSetFieldEditable form_handle "browse_net" nil) else
		    (axlFormSetFieldEditable form_handle "shape_net" t) 
		    (axlFormSetFieldEditable form_handle "browse_net" t)
		)
	    ) 
	    ("shape_net" t)
	    ("browse_net" 
		(axlClearSelSet) 
		(result = (axlUIDataBrowse 
			'NET 
			list('RETRIEVE_NAME) "Select net" t
		    )) 
		when(result 
		    (axlFormSetField form_handle "shape_net" 
			car(result)
		    )
		)
	    ) 
	    ("subclass" 
		(active_layer = (axlDBControl 
			'activeLayer
		    )) 
		(axlVisibleLayer active_layer t) 
		(prm = (axlLayerGet active_layer)) 
		(cline_color = (prm->color))
		(prm = (axlLayerGet 
			(tbx_shieldroute_data->tmpLineLayer)
		    )) 
		(prm->color = cline_color) 
		(axlLayerSet prm) 
		(axlVisibleUpdate t)
	    ) 
	    ("lock_mode" 
		if(((form_handle->curValue) == "line") then 
		    (axlFormSetField form_handle "corner_label" "Miter:") else 
		    (axlFormSetField form_handle "corner_label" "Radius")
		) 
		TBX_SHIELDROUTE_Set_Line_Lock(form_handle) 
		TBX_SHIELDROUTE_Build_Dynamics(form_handle)
	    ) 
	    ("lock_angle" 
		case((form_handle->curValue) 
		    ("0" 
			(axlFormSetFieldEditable form_handle "corner_size" nil) 
			(axlFormSetFieldEditable form_handle "corner_mode" nil)
		    ) 
		    ("45" 
			(axlFormSetFieldEditable form_handle "corner_size" t) 
			(axlFormSetFieldEditable form_handle "corner_mode" t)
		    ) 
		    ("90" 
			if(((axlFormGetField form_handle "lock_mode") == "line") then 
			    (axlFormSetFieldEditable form_handle "corner_size" nil) 
			    (axlFormSetFieldEditable form_handle "corner_mode" nil) else
			    (axlFormSetFieldEditable form_handle "corner_size" t) 
			    (axlFormSetFieldEditable form_handle "corner_mode" t)
			)
		    )
		) 
		TBX_SHIELDROUTE_Set_Line_Lock(form_handle) 
		TBX_SHIELDROUTE_Build_Dynamics(form_handle)
	    ) 
	    ("corner_size" 
		TBX_SHIELDROUTE_Set_Line_Lock(form_handle) 
		TBX_SHIELDROUTE_Build_Dynamics(form_handle)
	    )
	    ("corner_mode" 
		TBX_SHIELDROUTE_Set_Line_Lock(form_handle) 
		TBX_SHIELDROUTE_Build_Dynamics(form_handle)
	    ) 
	    ("line_width" 
		TBX_SHIELDROUTE_Build_Dynamics(form_handle)
	    ) 
	    ("tandem_width" 
		TBX_SHIELDROUTE_Build_Dynamics(form_handle)
	    ) 
	    ("tandem_gap" 
		(axlFormSetField form_handle "tandem_gap" 
		    TBX_SHIELDROUTE_Validate_Gap((form_handle->curValue) t)
		) 
		TBX_SHIELDROUTE_Build_Dynamics(form_handle)
	    ) 
	    ("tandem_gap_mini_help" 
		(msg = "The gap value specifes the size of a user-defined void to be generated in the tandem shield along the selected cline structure.") 
		(msg = strcat(msg "\nOnly positive values >= 0 are accepted. Use \"NA\" to generate a solid filled shape without any voids.")) 
		(axlUIConfirm msg)
	    )
	    ("side_width" 
		TBX_SHIELDROUTE_Build_Dynamics(form_handle)
	    ) 
	    ("side_gap" 
		(axlFormSetField form_handle "side_gap" 
		    TBX_SHIELDROUTE_Validate_Gap((form_handle->curValue) t)
		) 
		TBX_SHIELDROUTE_Build_Dynamics(form_handle)
	    ) 
	    ("side_gap_mini_help" 
		(msg = "The gap value specifes the size of a user-defined void to be generated in the side shield along the selected cline structure.") 
		(msg = strcat(msg "\nOnly positive values >= 0 or \"NA\" are accepted.")) 
		(msg = strcat(msg "\n")) 
		(msg = strcat(msg "\n1) For dynamic and static shapess a gap value >= 0 makes only sense as long as net cleareance settings are smaller than specified gap. Otherwise final void may be larger."))
		(msg = strcat(msg "\n")) 
		(msg = strcat(msg "\n2) For dynamic and static shapes \"NA\" makes sense when you rely on shape autovoiding process solely.")) 
		(msg = strcat(msg "\n")) 
		(msg = strcat(msg "\n3) Static shape voiding can be enabled using \"Void static shapes\" option.")) 
		(msg = strcat(msg "\n"))
		(msg = strcat(msg "\n4) A positive value should be always specified for Route Keepouts. Otherwise clines may cause DRC.")) 
		(axlUIConfirm msg)
	    ) 
	    ("void_mini_help" 
		(msg = "Voids all pads in keepout") 
		(msg = strcat(msg "\nIf enabled keepout shapes will be voided for pins and vias. A small overize will be applied to avoid DRC.")) 
		(msg = strcat(msg "\n")) 
		(msg = strcat(msg "\nVoid static shapes"))
		(msg = strcat(msg "\nIf enabled static shapes will be voided with respect to static shape parameter settings, useful to avoid DRC caused by pin/via/clines belonging to different nets.")) 
		(axlUIConfirm msg)
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_SHIELDROUTE_Check_Overlap(poly_a poly_b) 
    let((return_value result_AND result_ANDNOT) 
	(result_AND = car((axlPolyOperation poly_a poly_b 
		    'AND
		)
	    )) 
	when(result_AND 
	    (return_value = "partial") 
	    (result_ANDNOT = car((axlPolyOperation poly_b poly_a 
			'ANDNOT
		    )
		)) 
	    unless(result_ANDNOT 
		(return_value = "full")
	    )
	) return_value
    )
)
procedure(TBX_SHIELDROUTE_Clean_Layer(layer_list) 
    let((orgvis) 
	(orgvis = (axlVisibleGet)) 
	(axlVisibleDesign nil) 
	foreach(lyr layer_list 
	    when((axlIsLayer lyr) 
		(axlVisibleLayer lyr t)
	    )
	) 
	(axlVisibleUpdate t)
	(axlSetFindFilter ?enabled 
	    list("noall" "shapes" "lines" "clines" "clinesegs"
		"text" "dynthemals"
	    ) ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	when((axlGetSelSet) 
	    (axlDeleteObject 
		(axlGetSelSet)
	    )
	) 
	(axlVisibleSet orgvis)
	(axlClearSelSet) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_SHIELDROUTE_Cleanup() 
    let((param var_name var_value) 
	(axlCloseFindFilter) 
	(axlClearSelSet) 
	(axlFormClose 
	    (tbx_shieldroute_data->Formid)
	) 
	TBX_SHIELDROUTE_Clean_Layer(list((tbx_shieldroute_data->tmpShapeLayer) 
		(tbx_shieldroute_data->tmpLineLayer)
	    )
	)
	(param = (axlLayerGet 
		(tbx_shieldroute_data->tmpShapeLayer)
	    )) 
	when(param 
	    (axlDeleteObject param)
	) 
	(param = (axlLayerGet 
		(tbx_shieldroute_data->tmpLineLayer)
	    )) 
	when(param 
	    (axlDeleteObject param)
	) 
	foreach(entry 
	    (tbx_shieldroute_data->envOrg) 
	    (var_name = car(entry)) 
	    (var_value = cadr(entry)) 
	    unless(var_value 
		(var_name = var_name) t
	    )
	)
	(axlSetLineLock ?arcEnable 
	    ((tbx_shieldroute_data->orgLineLock)->arcEnable) ?lockAngle 
	    ((tbx_shieldroute_data->orgLineLock)->lockAngle)
	    ?minRadius 
	    ((tbx_shieldroute_data->orgLineLock)->minRadius) ?length45 
	    ((tbx_shieldroute_data->orgLineLock)->length45) ?fixed45
	    ((tbx_shieldroute_data->orgLineLock)->fixed45) ?lengthRadius 
	    ((tbx_shieldroute_data->orgLineLock)->lenghtRadius) ?fixedRadius 
	    ((tbx_shieldroute_data->orgLineLock)->fixedRadius)
	    ?lockTangent 
	    ((tbx_shieldroute_data->orgLineLock)->lockTangent)
	) 
	(axlLayerPriorityRestoreAll) 
	(axlVisibleUpdate t)
    )
)
procedure(TBX_SHIELDROUTE_Cline_Select(event_xy) 
    let((conn_list) 
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    list("noall" "clines") ?onButtons 
	    list("all")
	) 
	(axlSingleSelectPoint event_xy) 
	when((axlGetSelSet) 
	    unless(((tbx_shieldroute_data->runTime)->activeLayer) 
		((tbx_shieldroute_data->runTime)->activeLayer = (car((axlGetSelSet))->layer))
	    ) 
	    if(((tbx_shieldroute_data->runTime)->tempGroup) then 
		if(((car((axlGetSelSet))->layer) == ((tbx_shieldroute_data->runTime)->activeLayer)) then 
		    ((tbx_shieldroute_data->runTime)->clineList = cons(car((axlGetSelSet)) 
			    ((tbx_shieldroute_data->runTime)->clineList)
			)) else 
		    printf("Warning: Subsequent selections must match layer %L\n" 
			((tbx_shieldroute_data->runTime)->activeLayer)
		    )
		    (axlClearSelSet)
		) else 
		((tbx_shieldroute_data->runTime)->clineList = (axlGetSelSet))
		(conn_list = TBX_SHIELDROUTE_Get_Connected(car((axlGetSelSet)))) 
		(conn_list = setof(x conn_list 
			((x->objType) == "path")
		    )) 
		when(((length(conn_list) > 1) && (axlUIYesNo "Create shield for contiguous cline strcuture?" nil 
			    'no
			)) 
		    ((tbx_shieldroute_data->runTime)->clineList = conn_list)
		)
	    )
	)
	(axlHighlightObject 
	    ((tbx_shieldroute_data->runTime)->clineList)
	) t
    )
)
procedure(TBX_SHIELDROUTE_Copy_Group_Param(shield_param) 
    let((cfg_data ret_table) 
	(ret_table = makeTable("group_param_data" nil)) 
	foreach(gn shield_param 
	    (cfg_data = tconc(nil nil)) 
	    foreach(entry 
		shield_param[gn] 
		tconc(cfg_data 
		    copy(entry)
		)
	    ) 
	    (cfg_data = cdar(cfg_data))
	    (ret_table[gn] = cfg_data)
	) ret_table
    )
)
procedure(TBX_SHIELDROUTE_Create_Shield_Structure(poly_base_structure_list param_set) 
    let((exp_poly_list gap_poly_list poly_list full_layer_name result
	    net_name layer_param_set shield_items allegro_version allegro_release
	    keepout_void_all_pads static_shape_void_all is_conductor_shape cline_width cline_offset
	    sm_top_layer sm_bottom_layer ok2gap min_gap rpath
	    ring_param_set via_path via_stack_offset_list via_locations drc_list
	    drc_list_same_net via_enable_drc via_drc_same_net via_dbid via_drc
	    via_list pt_list cur_via cur_pt
	) 
	(allegro_version = (axlVersion 
		'version
	    )) 
	(allegro_release = (axlVersion 
		'release
	    )) 
	(sm_top_layer = strcat((axlMapClassName "BOARD GEOMETRY") "/SOLDERMASK_TOP")) 
	(sm_bottom_layer = strcat((axlMapClassName "BOARD GEOMETRY") "/SOLDERMASK_BOTTOM"))
	(net_name = "") 
	foreach(entry param_set 
	    cond((((entry->type) == "global") 
		    when((entry->net) 
			(net_name = (entry->net))
		    ) 
		    (via_enable_drc = (entry->viaEnableDRC)) 
		    (via_drc_same_net = (entry->viaDRCSameNet)) 
		    (keepout_void_all_pads = (entry->keepoutVoidAll))
		    (static_shape_void_all = (entry->staticShapeVoidAll))
		) 
		((((entry->type) == "side") || ((entry->type) == "tandem")) 
		    (layer_param_set = cons(entry layer_param_set))
		) 
		(((entry->type) == "via_ring") 
		    (ring_param_set = cons(entry ring_param_set))
		)
	    )
	) 
	foreach(prm layer_param_set 
	    (exp_poly_list = (axlPolyExpand poly_base_structure_list 
		    (prm->width) 
		    'NONE
		)) 
	    (poly_list = exp_poly_list) 
	    (ok2gap = nil)
	    (min_gap = 0.0) 
	    when((numberp((prm->gap)) && ((prm->gap) >= 0.0)) 
		(ok2gap = t) 
		(min_gap = (prm->gap))
	    ) 
	    when((min_gap >= (prm->width)) 
		(ok2gap = nil) 
		printf("Warning: Layer %L, gap value %f is greater than specified width %f, creating solid shape...\n" 
		    (prm->layer) min_gap 
		    (prm->width)
		)
	    ) 
	    when(ok2gap 
		(gap_poly_list = (axlPolyExpand poly_base_structure_list min_gap 
			'NONE
		    )) 
		(poly_list = (axlPolyOperation exp_poly_list gap_poly_list 
			'ANDNOT
		    ))
	    ) 
	    case((prm->style) 
		("Dynamic Shape" 
		    (full_layer_name = strcat("BOUNDARY/" 
			    (prm->layer)
			)) 
		    foreach(poly poly_list 
			(result = (axlDBCreateShape poly t full_layer_name net_name)) 
			when(result 
			    (shield_items = cons(car(result) shield_items))
			)
		    )
		) 
		("Static Shape" 
		    (is_conductor_shape = nil) 
		    cond((((prm->layer) == "SOLDERMASK_TOP") 
			    (full_layer_name = sm_top_layer)
			) 
			(((prm->layer) == "SOLDERMASK_BOTTOM") 
			    (full_layer_name = sm_bottom_layer)
			) 
			(t 
			    (full_layer_name = strcat((axlMapClassName "ETCH") "/" 
				    (prm->layer)
				)) 
			    (is_conductor_shape = t)
			)
		    ) 
		    foreach(poly poly_list 
			(result = (axlDBCreateShape poly t full_layer_name net_name)) 
			when(result 
			    if((is_conductor_shape && static_shape_void_all) then 
				(result = (axlShapeAutoVoid 
					car(result) 
					'fragment
				    )) 
				when(result 
				    foreach(shp result 
					(shield_items = cons(shp shield_items))
				    )
				) else
				(shield_items = cons(car(result) shield_items))
			    )
			)
		    )
		) 
		("Route Keepout" 
		    (full_layer_name = strcat("ROUTE KEEPOUT/" 
			    (prm->layer)
			)) 
		    if(((allegro_version > 16.6) || ((allegro_version == 16.6) && (atoi(substring(allegro_release 2)) > 20))) then t else 
			printf("Info: Splitting across voids on non-voidable keepout shapes\n")
			(poly_list = TBX_SHIELDROUTE_Process_Side_Keepout(poly_list))
		    ) 
		    if(keepout_void_all_pads then 
			foreach(poly poly_list 
			    foreach(shp 
				TBX_SHIELDROUTE_Void_Pads(poly full_layer_name) 
				(shield_items = cons(shp shield_items))
			    )
			) else 
			foreach(poly poly_list 
			    (result = (axlDBCreateShape poly t full_layer_name nil
				    nil
				)) 
			    when(result 
				(shield_items = cons(car(result) shield_items))
			    )
			)
		    )
		) 
		("Cline" 
		    when(((prm->type) == "side") 
			(full_layer_name = strcat((axlMapClassName "ETCH") "/" 
				(prm->layer)
			    )) 
			(cline_width = ((prm->width) - (prm->gap))) 
			(cline_offset = ((prm->gap) + (((prm->width) - (prm->gap)) / 2.0))) 
			(exp_poly_list = (axlPolyExpand poly_base_structure_list cline_offset 
				'NONE
			    ))
			foreach(pl exp_poly_list 
			    (rpath = TBX_DBCORE_Rpath_From_Poly(pl ?width cline_width)) 
			    (result = (axlDBCreatePath rpath full_layer_name net_name)) 
			    when(car(result) 
				foreach(cl 
				    car(result) 
				    (shield_items = cons(cl shield_items))
				)
			    )
			)
		    )
		)
	    )
	) 
	foreach(prm ring_param_set 
	    (exp_poly_list = (axlPolyExpand poly_base_structure_list 
		    (prm->ringOffset) 
		    'NONE
		)) 
	    (via_stack_offset_list = TBX_SHIELDROUTE_Derive_Stack_Offset_Values((prm->viaStackOffset) 
		    length((prm->padstacks))
		)) 
	    foreach(poly exp_poly_list 
		(via_path = TBX_DBCORE_Rpath_From_Poly(poly ?compactArc t)) 
		(via_locations = TBX_SHIELDROUTE_Calculate_Via_Locations(via_path 
			(prm->viaGap) via_stack_offset_list 
			(prm->viaAlign) 
			(prm->viaAlignAngle)
			(prm->viaInitialOffset) 
			(tbx_shieldroute_data->tmpShapeLayer)
		    )) 
		foreach(entry via_locations 
		    (pt_list = entry) 
		    (via_list = (prm->padstacks)) 
		    while(via_list 
			(cur_via = car(via_list)) 
			(cur_pt = car(pt_list)) 
			when((cur_via && cur_pt) 
			    (result = (axlDBCreateVia cur_via cur_pt net_name nil
				    0.0 nil
				)) 
			    (via_dbid = car(result)) 
			    (via_drc = cadr(result)) 
			    when(via_dbid 
				if((via_drc && via_enable_drc) then 
				    (drc_list = (axlDRCItem t via_dbid)) 
				    (drc_list_same_net = setof(x drc_list 
					    (upperCase((x->type)) == "SAME NET CONSTRAINTS")
					)) 
				    cond(((length(drc_list) == length(drc_list_same_net)) 
					    if(via_drc_same_net then 
						(axlDeleteObject via_dbid) else 
						(shield_items = cons(via_dbid shield_items))
					    )
					) 
					(t 
					    (axlDeleteObject via_dbid)
					)
				    )
				    else 
				    (shield_items = cons(via_dbid shield_items))
				)
			    )
			) 
			(via_list = cdr(via_list))
			(pt_list = cdr(pt_list))
		    )
		)
		t
	    )
	) 
	(axlDBAddProp shield_items 
	    list("TBX_SHIELDROUTE_ITEM" "TRUE")
	)
	shield_items
    )
)
procedure(TBX_SHIELDROUTE_Debug() 
    let((port info_file) 
	(info_file = strcat(getWorkingDir() "/shield_route_config_att.txt")) 
	(port = outfile(info_file "w")) 
	fprintf(port "-------------------------\n") 
	fprintf(port "Shield group information\n")
	fprintf(port "-------------------------\n") 
	fprintf(port "Units: %L\n" 
	    car((axlDBGetDesignUnits))
	) 
	foreach(grp 
	    (tbx_shieldroute_data->shieldParam) 
	    fprintf(port "Group: %L\n" grp) 
	    foreach(prm 
		(tbx_shieldroute_data->shieldParam)[grp] 
		fprintf(port "     %L\n" prm)
	    )
	) 
	fprintf(port "-------------------------\n") 
	fprintf(port "Advanced Parameters\n")
	fprintf(port "-------------------------\n") 
	foreach(prm 
	    (tbx_shieldroute_data->advParams) 
	    fprintf(port "     %L\n" prm)
	) 
	fprintf(port ")\n") 
	close(port) 
	(axlUIViewFileCreate info_file "Shield Route: Quick Info" nil)
	when(isFile(info_file) 
	    deleteFile(info_file)
	)
    )
)
procedure(TBX_SHIELDROUTE_Delete_All_Shields() 
    let((group_list) 
	(group_list = TBX_SHIELDROUTE_Select_Group("all" nil)) 
	(tbx_shieldroute_data->tmpParam = TBX_SHIELDROUTE_Copy_Group_Param((tbx_shieldroute_data->shieldParam))) 
	foreach(grp group_list 
	    TBX_SHIELDROUTE_Delete_Shield(grp 
		(tbx_shieldroute_data->shieldParam) t
	    )
	)
    )
)
procedure(TBX_SHIELDROUTE_Delete_Shield(shield_group shieldParam disband_group) 
    let((shield_group_name shield_objects) 
	(shield_group_name = upperCase((shield_group->name))) 
	(shield_objects = mapcan(lambda((x) 
		    when((((x->prop)->TBX_SHIELDROUTE_ITEM) || ((x->objType) == "shape")) 
			list(x)
		    )
		) 
		(shield_group->groupMembers)
	    )) 
	(axlDeleteObject shield_objects) 
	when(disband_group 
	    (axlDBDisbandGroup shield_group) 
	    when(shieldParam[shield_group_name] 
		remove(shield_group_name shieldParam)
	    ) 
	    (axlDBRefreshId nil)
	)
	TBX_SHIELDROUTE_Clean_Layer(list((tbx_shieldroute_data->tmpShapeLayer) 
		(tbx_shieldroute_data->tmpLineLayer)
	    )
	) t
    )
)
procedure(TBX_SHIELDROUTE_Derive_Params(active_layer form_handle) 
    let((layer_param tmp_param layer_name param_set net_name
	    shape_style layer_arr active_layer_id tandem_layers tandem_layer_id
	    oversize gap keepout_void_all_pads static_shape_void_all
	) 
	(active_layer = cadr(parseString(active_layer "/"))) 
	(keepout_void_all_pads = (axlFormGetField form_handle "keepout_void_all_pads")) 
	(static_shape_void_all = (axlFormGetField form_handle "static_shape_void_all")) 
	cond(((axlFormGetField form_handle "use_default_params") 
		(net_name = (axlFormGetField form_handle "shape_net")) 
		(shape_style = (axlFormGetField form_handle "shape_style")) 
		when((axlFormGetField form_handle "create_tandem_shield") 
		    (layer_arr = listToVector((axlSubclassRoute))) 
		    for(i 0 
			(length(layer_arr) - 1) 
			when((layer_arr[i] == active_layer) 
			    (active_layer_id = i)
			)
		    ) 
		    cond((zerop(active_layer_id) 
			    (tandem_layers = list(1))
			) 
			(((length(layer_arr) - 1) == active_layer_id) 
			    (tandem_layers = list((length(layer_arr) - 2)))
			) 
			(t 
			    (tandem_layers = list((active_layer_id - 1) 
				    (active_layer_id + 1)
				))
			)
		    ) 
		    (oversize = (axlFormGetField form_handle "tandem_width"))
		    (gap = TBX_SHIELDROUTE_Validate_Gap((axlFormGetField form_handle "tandem_gap"))) 
		    foreach(i tandem_layers 
			(tandem_layer_id = i) 
			(layer_name = layer_arr[tandem_layer_id]) 
			(layer_param = list(nil 
				'enable t 
				'type "tandem"
				'layer layer_name 
				'width oversize 
				'gap
				gap 
				'style shape_style
			    ))
			(param_set = cons(layer_param param_set))
		    )
		) 
		when((axlFormGetField form_handle "create_side_shield") 
		    (oversize = (axlFormGetField form_handle "side_width")) 
		    (gap = TBX_SHIELDROUTE_Validate_Gap((axlFormGetField form_handle "side_gap"))) 
		    (layer_param = list(nil 
			    'enable t 
			    'type "side"
			    'layer active_layer 
			    'width oversize 
			    'gap
			    gap 
			    'style shape_style
			)) 
		    (param_set = cons(layer_param param_set))
		)
		(param_set = cons(list(nil 
			    'type "global" 
			    'net net_name
			    'keepoutVoidAll keepout_void_all_pads 
			    'staticShapeVoidAll static_shape_void_all
			) param_set
		    ))
	    ) 
	    ((axlFormGetField form_handle "use_advanced_params") 
		foreach(prm 
		    (tbx_shieldroute_data->advParams) 
		    cond((((prm->type) == "side") 
			    when((prm->enable) 
				(tmp_param = copy(prm)) 
				(tmp_param->layer = active_layer) 
				(param_set = cons(tmp_param param_set))
			    )
			) 
			((((prm->type) == "tandem") && ((prm->layer) != active_layer)) 
			    when((prm->enable) 
				(tmp_param = copy(prm)) 
				(param_set = cons(tmp_param param_set))
			    )
			) 
			(((prm->type) == "global") 
			    (tmp_param = copy(prm)) 
			    (param_set = cons(tmp_param param_set))
			) 
			(((prm->type) == "via_ring") 
			    (tmp_param = copy(prm)) 
			    (param_set = cons(tmp_param param_set))
			)
		    )
		) 
		foreach(ps param_set 
		    when(((ps->type) == "global") 
			putprop(ps keepout_void_all_pads 
			    'keepoutVoidAll
			) 
			putprop(ps static_shape_void_all 
			    'staticShapeVoidAll
			)
		    )
		)
	    )
	)
	param_set
    )
)
procedure(TBX_SHIELDROUTE_Derive_Stack_Offset_Values(via_stack_offset_str nr_of_padstacks) 
    let((tmp_list default_gap cur_inner_gap gap_list) 
	when(via_stack_offset_str 
	    (tmp_list = parseString(via_stack_offset_str)) 
	    (tmp_list = mapcar(lambda((x) 
			atof(x)
		    ) tmp_list
		))
	) 
	if((length(tmp_list) > 0) then 
	    (default_gap = (lastelem tmp_list)) else 
	    (default_gap = 0)
	) 
	(gap_list = tconc(nil nil)) 
	when((nr_of_padstacks > 1) 
	    for(i 0 
		(nr_of_padstacks - 2) 
		(cur_inner_gap = nth(i tmp_list)) 
		if(cur_inner_gap then 
		    tconc(gap_list cur_inner_gap) else 
		    tconc(gap_list default_gap)
		)
	    )
	)
	(gap_list = cdar(gap_list)) gap_list
    )
)
procedure(TBX_SHIELDROUTE_Disband_Obsolete_Groups() 
    foreach(grp 
	(axlSelectByName "GROUP" "TBX_SHIELD_*" t) 
	unless((grp->groupMembers) 
	    (axlDBDisbandGroup grp)
	)
    ) 
    (axlClearSelSet) 
    (axlDBRefreshId nil)
)
procedure(TBX_SHIELDROUTE_Event_Loop() 
    let((eventMask loop event result shield_group) 
	(axlEventSetStartPopup 
	    'TBX_SHIELDROUTE_Popup_Callback
	) 
	(eventMask = list('PICK)) 
	(loop = t) 
	(tbx_shieldroute_data->transMark = (axlDBTransactionStart))
	(tbx_shieldroute_data->transMarkPath = (axlDBTransactionStart)) 
	while(loop 
	    (event = (axlEnterEvent eventMask nil t)) 
	    caseq((event->type) 
		(PICK 
		    cond(((axlFormGetField 
				(tbx_shieldroute_data->Formid) "add_connect"
			    ) 
			    (axlDBTransactionMark 
				(tbx_shieldroute_data->transMarkPath)
			    ) 
			    ((tbx_shieldroute_data->runTime)->terminate = TBX_SHIELDROUTE_AddConnectMode_Sketch_Path((event->xy) 
				    (event->xySnap)
				)) 
			    when(((tbx_shieldroute_data->runTime)->terminate) 
				(axlDBTransactionMark 
				    (tbx_shieldroute_data->transMark)
				) 
				TBX_SHIELDROUTE_AddConnectMode_Process() 
				TBX_SHIELDROUTE_Init_Filter((tbx_shieldroute_data->Formid))
			    )
			) 
			((axlFormGetField 
				(tbx_shieldroute_data->Formid) "select_cline"
			    ) 
			    if(((tbx_shieldroute_data->runTime)->paramProbe) then 
				(axlClearSelSet) 
				(axlDehighlightObject 
				    ((tbx_shieldroute_data->runTime)->clineList)
				) 
				(tbx_shieldroute_data->runTime = ncons(nil))
				(result = TBX_SHIELDROUTE_Retrieve_Shieldgroup_Params((event->xy))) 
				when(car(result) 
				    (tbx_shieldroute_data->advParams = cadr(result)) 
				    (axlFormSetField 
					(tbx_shieldroute_data->Formid) "use_advanced_params" t
				    ) 
				    foreach(dpl 
					(tbx_shieldroute_data->advParams) 
					when(((dpl->type) == "global") 
					    (axlFormSetField 
						(tbx_shieldroute_data->Formid) "keepout_void_all_pads" 
						(dpl->keepoutVoidAll)
					    ) 
					    (axlFormSetField 
						(tbx_shieldroute_data->Formid) "static_shape_void_all" 
						(dpl->staticShapeVoidAll)
					    )
					)
				    ) 
				    TBX_SHIELDROUTE_Update_Form((tbx_shieldroute_data->Formid) "shield_mode")
				    remprop('paramProbe 
					(tbx_shieldroute_data->runTime)
				    )
				) 
				(axlClearSelSet) 
				(axlSetFindFilter ?enabled 
				    list("noall" "clines") ?onButtons 
				    list("all")
				) else
				TBX_SHIELDROUTE_Cline_Select((event->xy)) 
				unless(((tbx_shieldroute_data->runTime)->tempGroup) 
				    (axlDBTransactionMark 
					(tbx_shieldroute_data->transMark)
				    ) 
				    TBX_SHIELDROUTE_SelectMode_Process() 
				    TBX_SHIELDROUTE_Init_Filter((tbx_shieldroute_data->Formid))
				)
			    )
			) 
			((axlFormGetField 
				(tbx_shieldroute_data->Formid) "update_shield"
			    ) 
			    (axlDBTransactionMark 
				(tbx_shieldroute_data->transMark)
			    ) 
			    TBX_SHIELDROUTE_Update_Shield((event->xy)) 
			    TBX_SHIELDROUTE_Init_Filter((tbx_shieldroute_data->Formid))
			) 
			((axlFormGetField 
				(tbx_shieldroute_data->Formid) "delete_shield"
			    ) 
			    (axlDBTransactionMark 
				(tbx_shieldroute_data->transMark)
			    ) 
			    (shield_group = car(TBX_SHIELDROUTE_Select_Group("pick_group" 
					(event->xy)
				    )
				)) 
			    when(shield_group 
				(tbx_shieldroute_data->tmpParam = TBX_SHIELDROUTE_Copy_Group_Param((tbx_shieldroute_data->shieldParam))) 
				TBX_SHIELDROUTE_Delete_Shield(shield_group 
				    (tbx_shieldroute_data->shieldParam) t
				)
			    ) 
			    TBX_SHIELDROUTE_Init_Filter((tbx_shieldroute_data->Formid))
			)
		    )
		) 
		(DONE 
		    cond(((axlFormGetField 
				(tbx_shieldroute_data->Formid) "add_connect"
			    ) 
			    when(((tbx_shieldroute_data->runTime)->xyStack) 
				TBX_SHIELDROUTE_AddConnectMode_Process()
			    )
			) 
			((axlFormGetField 
				(tbx_shieldroute_data->Formid) "select_cline"
			    ) 
			    when(((tbx_shieldroute_data->runTime)->clineList) 
				TBX_SHIELDROUTE_SelectMode_Process() 
				(tbx_shieldroute_data->runTime = ncons(nil))
			    )
			)
		    ) 
		    TBX_SHIELDROUTE_Cache_Param((tbx_shieldroute_data->Formid)) 
		    (axlDBTransactionCommit 
			(tbx_shieldroute_data->transMark)
		    ) 
		    (axlUIPopupSet nil)
		    (axlClearDynamics) 
		    (loop = nil) 
		    (axlLayerPriorityRestoreAll) 
		    TBX_SHIELDROUTE_Save_Configuration()
		) 
		(CANCEL 
		    (axlDBTransactionOops 
			(tbx_shieldroute_data->transMark)
		    ) 
		    (axlDBTransactionCommit 
			(tbx_shieldroute_data->transMark)
		    ) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics)
		    (loop = nil) 
		    (axlLayerPriorityRestoreAll)
		)
	    )
	) 
	(axlEventSetStartPopup)
    )
)
procedure(TBX_SHIELDROUTE_Get_Advanced_Params(form_handle) 
    let((adv_info cell config shape_net) 
	(adv_info = list()) 
	for(r 1 
	    (length((axlSubclassRoute)) + 2) 
	    (config = ncons(nil)) 
	    (config->type = "tandem")
	    for(c 1 5 
		caseq(c 
		    (1 
			(cell = (axlFormGridNewCell)) 
			(cell->row = r) 
			(cell->col = c) 
			(config->enable = ((axlFormGridGetCell form_handle "grid" cell)->check))
		    ) 
		    (2 
			(cell = (axlFormGridNewCell)) 
			(cell->row = r) 
			(cell->col = c) 
			(config->layer = ((axlFormGridGetCell form_handle "grid" cell)->value))
		    ) 
		    (3 
			(cell = (axlFormGridNewCell)) 
			(cell->row = r) 
			(cell->col = c) 
			(config->style = ((axlFormGridGetCell form_handle "grid" cell)->value))
		    ) 
		    (4 
			(cell = (axlFormGridNewCell)) 
			(cell->row = r) 
			(cell->col = c) 
			(config->width = ((axlFormGridGetCell form_handle "grid" cell)->value))
		    )
		    (5 
			(cell = (axlFormGridNewCell)) 
			(cell->row = r) 
			(cell->col = c) 
			(config->gap = TBX_SHIELDROUTE_Validate_Gap(((axlFormGridGetCell form_handle "grid" cell)->value)))
		    )
		)
	    ) 
	    (adv_info = cons(config adv_info))
	) 
	(adv_info = reverse(adv_info)) 
	(config = ncons(nil))
	(config->type = "side") 
	(config->enable = (axlFormGetField form_handle "adv_enable_side_shield")) 
	(config->style = (axlFormGetField form_handle "adv_side_style")) 
	(config->width = (axlFormGetField form_handle "adv_side_width")) 
	(config->gap = TBX_SHIELDROUTE_Validate_Gap((axlFormGetField form_handle "adv_side_gap")))
	(adv_info = cons(config adv_info)) 
	(config = ncons(nil)) 
	(config->type = "global") 
	if((axlFormGetField form_handle "adv_shape_net") then 
	    (shape_net = (axlFormGetField form_handle "adv_shape_net")) 
	    rexCompile("^ *") 
	    (shape_net = rexReplace(shape_net "" 0))
	    rexCompile(" *$") 
	    (shape_net = rexReplace(shape_net "" 0)) 
	    (config->net = shape_net) else 
	    (config->net = nil)
	) 
	(config->viaEnableDRC = (axlFormGetField form_handle "adv_via_enable_drc"))
	(config->viaDRCSameNet = (axlFormGetField form_handle "adv_via_drc_same_net")) 
	(adv_info = cons(config adv_info)) 
	foreach(key 
	    (tbx_shieldroute_data->advTmpParams) 
	    when((key != "") 
		(adv_info = append1(adv_info 
			(tbx_shieldroute_data->advTmpParams)[key]
		    ))
	    )
	) adv_info
    )
)
procedure((TBX_SHIELDROUTE_Get_Connected obj \@optional layer_name conn_list) 
    let((list1 list2 result) 
	unless(memq(obj conn_list) 
	    (conn_list = cons(obj conn_list))
	) 
	unless(layer_name 
	    (layer_name = (obj->layer))
	) 
	cond((((obj->objType) == "path") 
		(result = (axlDBGetConnect obj)) 
		(list1 = car(result)) 
		(list2 = cadr(result)) 
		(list1 = nconc(list1 list2))
	    ) 
	    (((obj->objType) == "tee") 
		(list1 = (axlDBGetConnect obj))
	    ) 
	    (((obj->objType) == "via") 
		(list1 = (axlDBGetConnect obj))
	    )
	) 
	(list1 = setof(x list1 
		((((x->objType) == "path") && ((x->layer) == layer_name)) || (((x->objType) == "tee") && ((x->layer) == layer_name)) || ((x->objType) == "via"))
	    ))
	foreach(elem list1 
	    cond((memq(elem conn_list) t) 
		(t 
		    (conn_list = TBX_SHIELDROUTE_Get_Connected(elem layer_name conn_list))
		)
	    )
	) conn_list
    )
)
procedure(TBX_SHIELDROUTE_Get_Next_Group() 
    let((group_list group_name_list free_id group_dbid cnt) 
	(group_list = (axlSelectByName "GROUP" "TBX_SHIELD_*" t)) 
	(group_name_list = mapcar(lambda((x) 
		    upperCase((x->name))
		) group_list
	    )) 
	(cnt = 1) 
	while((!free_id && (cnt <= 1000)) 
	    unless(rexMatchList(sprintf(nil "TBX_SHIELD_%d" cnt) group_name_list) 
		(free_id = cnt)
	    ) 
	    ++cnt
	)
	if(free_id then 
	    (group_dbid = (axlDBCreateGroup 
		    sprintf(nil "TBX_SHIELD_%d" free_id) "generic" nil
		)) else 
	    printf("Error:Cannot derive next free group\n")
	    (group_dbid = nil)
	) 
	(axlClearSelSet) group_dbid
    )
)
procedure(TBX_SHIELDROUTE_Get_Oversize(form_handle) 
    let((oversize side_value tandem_value) 
	cond(((axlFormGetField form_handle "use_default_params") 
		when((axlFormGetField form_handle "create_side_shield") 
		    (side_value = (axlFormGetField form_handle "side_width"))
		) 
		when((axlFormGetField form_handle "create_tandem_shield") 
		    (tandem_value = (axlFormGetField form_handle "tandem_width"))
		)
	    ) 
	    ((axlFormGetField form_handle "use_advanced_params") 
		foreach(entry 
		    (tbx_shieldroute_data->advParams) 
		    when((entry->enable) 
			cond((((entry->type) == "tandem") 
				(tandem_value = (entry->width))
			    ) 
			    (((entry->type) == "side") 
				(side_value = (entry->width))
			    )
			)
		    )
		)
	    )
	) 
	if(side_value then 
	    (oversize = side_value) else 
	    (oversize = tandem_value)
	) oversize
    )
)
procedure(TBX_SHIELDROUTE_Get_Padstack_Polygons(xy_list layer) 
    let((pad_poly_data pad_poly_stack ff_en ff_on) 
	(ff_en = (axlGetFindFilter nil)) 
	(ff_on = (axlGetFindFilter t)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "pins" "vias") ?onButtons 
	    list("all")
	) 
	foreach(xy xy_list 
	    (axlClearSelSet) 
	    (axlSingleSelectPoint xy) 
	    when((axlGetSelSet) 
		(pad_poly_data = (axlPolyFromDB 
			car((axlGetSelSet)) ?layer layer ?padType
			'REGULAR
		    )) 
		when(pad_poly_data 
		    (pad_poly_stack = cons(pad_poly_data pad_poly_stack))
		)
	    )
	)
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    cons("noall" ff_en) ?onButtons ff_on
	) pad_poly_stack
    )
)
procedure(TBX_SHIELDROUTE_Get_Path_Polygon(path_dbid) 
    let((poly_data poly) 
	when(path_dbid 
	    foreach(seg 
		(path_dbid->segments) 
		(poly = car((axlPolyFromDB seg ?endCapType 
			    'ROUND
			)
		    )) 
		(poly_data = cons(poly poly_data))
	    )
	) poly_data
    )
)
procedure(TBX_SHIELDROUTE_Get_Polygon_Normal_Vector(xy seg_data poly_clockwise direction) 
    let((spin_angle norm_vec tan_vec) 
	(tan_vec = TBX_SHIELDROUTE_Get_Polygon_Tangent_Vector(xy seg_data poly_clockwise)) 
	if(poly_clockwise then 
	    if((direction == "outwards") then 
		(spin_angle = 90.0) else 
		(spin_angle = -90.0)
	    ) else 
	    if((direction == "outwards") then 
		(spin_angle = -90.0) else 
		(spin_angle = 90.0)
	    )
	) 
	(norm_vec = TBX_MATH_Transform_Vector(tan_vec ?angle spin_angle)) norm_vec
    )
)
procedure(TBX_SHIELDROUTE_Get_Polygon_Tangent_Vector(xy seg_data poly_clockwise) 
    let((tan_vec center_xy arc_clockwise vec_center_xy spin_angle) 
	if((length(seg_data) == 2) then 
	    (tan_vec = TBX_MATH_Get_Vector(car(seg_data) 
		    cadr(seg_data)
		)) else 
	    (center_xy = caddr(seg_data))
	    (arc_clockwise = nth(3 seg_data)) 
	    (vec_center_xy = TBX_MATH_Get_Vector(center_xy xy)) 
	    cond(((!poly_clockwise && !arc_clockwise) 
		    (spin_angle = 90.0)
		) 
		((!poly_clockwise && arc_clockwise) 
		    (spin_angle = -90.0)
		) 
		((poly_clockwise && !arc_clockwise) 
		    (spin_angle = 90.0)
		) 
		((poly_clockwise && arc_clockwise) 
		    (spin_angle = -90.0)
		)
	    ) 
	    (tan_vec = TBX_MATH_Transform_Vector(vec_center_xy ?angle spin_angle))
	) tan_vec
    )
)
procedure(TBX_SHIELDROUTE_Get_Structure_Polygon(seg_poly_stack pad_poly_stack) 
    let((poly_data poly_data_new) 
	foreach(poly_l seg_poly_stack 
	    (poly_data = append(poly_data poly_l))
	) 
	foreach(poly_l pad_poly_stack 
	    (poly_data = append(poly_data poly_l))
	) 
	if((length(poly_data) >= 2) then 
	    (poly_data_new = (axlPolyOperation 
		    cdr(poly_data) 
		    list(car(poly_data)) 
		    'OR
		)) else 
	    (poly_data_new = poly_data)
	) poly_data_new
    )
)
procedure(TBX_SHIELDROUTE_Init() 
    let((tmp_shape_layer tmp_line_layer bg_color tmp_layer_color default_value
	    prm design_units adv_params tmp_prm design_layers
	    env_org design_type org_line_lock sm_top_layer sm_bottom_layer
	    adv_tmp_params
	) 
	unless((axlDBGetPropDictEntry "TBX_SHIELDROUTE_ITEM") 
	    (axlDBCreatePropDictEntry "TBX_SHIELDROUTE_ITEM" "STRING" 
		list("shapes" "clines" "vias")
	    )
	) 
	(tmp_shape_layer = "MANUFACTURING/TMP_DRAFTING") 
	(tmp_line_layer = "MANUFACTURING/TMP_DRAFTING1") 
	(sm_top_layer = strcat((axlMapClassName "BOARD GEOMETRY") "/SOLDERMASK_TOP"))
	(sm_bottom_layer = strcat((axlMapClassName "BOARD GEOMETRY") "/SOLDERMASK_BOTTOM")) 
	foreach(lyr 
	    list(tmp_shape_layer tmp_line_layer sm_top_layer sm_bottom_layer) 
	    unless((axlIsLayer lyr) 
		(axlLayerCreateNonConductor lyr)
	    )
	) 
	(bg_color = (axlColorGet 
		'background
	    )) 
	cond(((zerop(car(bg_color)) && zerop(cadr(bg_color)) && zerop(caddr(bg_color))) 
		(tmp_layer_color = list(255 255 255))
	    ) 
	    (((car(bg_color) == 255) && (cadr(bg_color) == 255) && (caddr(bg_color) == 255)) 
		(tmp_layer_color = list(255 0 0))
	    ) 
	    (t t)
	) 
	(tmp_layer_color = list(217 217 217))
	(axlColorSet 188 tmp_layer_color) 
	(prm = (axlLayerGet tmp_shape_layer)) 
	(prm->color = 188) 
	(axlLayerSet prm) 
	(axlVisibleLayer tmp_shape_layer t)
	(axlVisibleLayer tmp_line_layer t) 
	(axlVisibleUpdate t) 
	(axlLayerPrioritySaveAll) 
	(axlLayerPriorityClearAll) 
	(axlLayerPrioritySet tmp_line_layer 1)
	(axlLayerPrioritySet tmp_shape_layer 2) 
	(axlVisibleUpdate t) 
	unless(axlGetVariable("DISABLE_OPENGL") 
	    unless(axlGetVariable("STATIC_SHAPES_FILL_SOLID") t 
		(env_org = cons(list("STATIC_SHAPES_FILL_SOLID" nil) env_org))
	    )
	) 
	(default_value = makeTable("default_value_table" nil)) 
	(default_value["use_default_params"] = t)
	(default_value["use_advanced_params"] = nil) 
	(default_value["create_tandem_shield"] = t) 
	(default_value["tandem_gap"] = "NA") 
	(default_value["create_side_shield"] = t) 
	(default_value["shape_style"] = "Dynamic Shape")
	(default_value["keepout_void_all_pads"] = t) 
	(default_value["static_shape_void_all"] = t) 
	(default_value["select_cline"] = t) 
	(default_value["active_layer"] = strcat((axlMapClassName "ETCH") "/TOP")) 
	(default_value["lock_mode"] = "line")
	(default_value["lock_angle"] = "45") 
	(default_value["corner_label"] = "Miter") 
	(default_value["corner_mode"] = "min") 
	(default_value["adv_enable_side_shield"] = t) 
	(default_value["adv_side_style"] = "Dynamic Shape")
	(default_value["adv_tandem_style"] = "Dynamic Shape") 
	(default_value["adv_tandem_gap"] = "NA") 
	(default_value["adv_shape_net"] = "") 
	(default_value["adv_via_align"] = "contour") 
	(default_value["adv_via_align_angle"] = 90.0)
	(default_value["adv_via_stack_offset"] = "") 
	(default_value["adv_via_initial_offset"] = 0.0) 
	(default_value["adv_via_enable_drc"] = nil) 
	(default_value["adv_via_drc_same_net"] = nil) 
	(design_units = lowerCase(car((axlDBGetDesignUnits))))
	(design_type = upperCase((axlDesignType t))) 
	cond((((design_type == "MCM") || (design_type == "SIP")) 
		cond((((design_units == "microns") || (design_units == "millimeters") || (design_units == "centimeters")) 
			(default_value["side_width"] = (axlMKSConvert "0.5 MM" design_units)) 
			(default_value["side_gap"] = (axlMKSConvert "0.15 MM" design_units)) 
			(default_value["adv_side_width"] = (axlMKSConvert "0.5 MM" design_units)) 
			(default_value["adv_side_gap"] = (axlMKSConvert "0.15 MM" design_units))
			(default_value["adv_tandem_width"] = (axlMKSConvert "0.5 MM" design_units)) 
			(default_value["tandem_width"] = (axlMKSConvert "0.5 MM" design_units)) 
			(default_value["corner_size"] = (axlMKSConvert "0.5 MM" design_units)) 
			(default_value["line_width"] = (axlMKSConvert "0.1 MM" design_units)) 
			(default_value["adv_ring_offset"] = (axlMKSConvert "0.5 MM" design_units))
			(default_value["adv_via_gap"] = (axlMKSConvert "0.5 MM" design_units))
		    ) 
		    (t 
			(default_value["side_width"] = (axlMKSConvert "20.0 MILS" design_units)) 
			(default_value["side_gap"] = (axlMKSConvert "6.0 MILS" design_units)) 
			(default_value["adv_side_width"] = (axlMKSConvert "20.0 MILS" design_units)) 
			(default_value["adv_side_gap"] = (axlMKSConvert "6.0 MILS" design_units))
			(default_value["adv_tandem_width"] = (axlMKSConvert "20.0 MILS" design_units)) 
			(default_value["tandem_width"] = (axlMKSConvert "20.0 MILS" design_units)) 
			(default_value["corner_size"] = (axlMKSConvert "20.0 MILS" design_units)) 
			(default_value["line_width"] = (axlMKSConvert "4.0 MILS" design_units)) 
			(default_value["adv_ring_offset"] = (axlMKSConvert "20.0 MILS" design_units))
			(default_value["adv_via_gap"] = (axlMKSConvert "20.0 MILS" design_units))
		    )
		)
	    ) 
	    (t 
		cond((((design_units == "microns") || (design_units == "millimeters") || (design_units == "centimeters")) 
			(default_value["side_width"] = (axlMKSConvert "1.5 MM" design_units)) 
			(default_value["side_gap"] = (axlMKSConvert "0.5 MM" design_units)) 
			(default_value["adv_side_width"] = (axlMKSConvert "1.5 MM" design_units)) 
			(default_value["adv_side_gap"] = (axlMKSConvert "0.5 MM" design_units))
			(default_value["adv_tandem_width"] = (axlMKSConvert "2.0 MM" design_units)) 
			(default_value["tandem_width"] = (axlMKSConvert "2.0 MM" design_units)) 
			(default_value["corner_size"] = (axlMKSConvert "1.0 MM" design_units)) 
			(default_value["line_width"] = (axlMKSConvert "0.25 MM" design_units)) 
			(default_value["adv_ring_offset"] = (axlMKSConvert "1.0 MM" design_units))
			(default_value["adv_via_gap"] = (axlMKSConvert "1.0 MM" design_units))
		    ) 
		    (t 
			(default_value["side_width"] = (axlMKSConvert "60.0 MILS" design_units)) 
			(default_value["side_gap"] = (axlMKSConvert "20.0 MILS" design_units)) 
			(default_value["adv_side_width"] = (axlMKSConvert "60.0 MILS" design_units)) 
			(default_value["adv_side_gap"] = (axlMKSConvert "20.0 MILS" design_units))
			(default_value["adv_tandem_width"] = (axlMKSConvert "80.0 MILS" design_units)) 
			(default_value["tandem_width"] = (axlMKSConvert "80.0 MILS" design_units)) 
			(default_value["corner_size"] = (axlMKSConvert "40.0 MILS" design_units)) 
			(default_value["line_width"] = (axlMKSConvert "10.0 MILS" design_units)) 
			(default_value["adv_ring_offset"] = (axlMKSConvert "40.0 MILS" design_units))
			(default_value["adv_via_gap"] = (axlMKSConvert "40.0 MILS" design_units))
		    )
		)
	    )
	) 
	(tmp_prm = list(nil 
		'type "global" 
		'net 
		default_value["adv_shape_net"]
		'viaEnableDRC 
		default_value["adv_via_enable_drc"] 
		'viaDRCSameNet 
		default_value["adv_via_drc_same_net"]
	    )) 
	(adv_params = cons(tmp_prm adv_params)) 
	(tmp_prm = list(nil 
		'type "side" 
		'enable 
		default_value["adv_enable_side_shield"]
		'style 
		default_value["adv_side_style"] 
		'width 
		default_value["adv_side_width"] 
		'gap
		default_value["adv_side_gap"]
	    ))
	(adv_params = cons(tmp_prm adv_params)) 
	(design_layers = mapcar(lambda((x) 
		    upperCase(x)
		) 
		(axlSubclassRoute)
	    )) 
	(design_layers = append1(design_layers "SOLDERMASK_BOTTOM")) 
	(design_layers = cons("SOLDERMASK_TOP" design_layers)) 
	foreach(lyr design_layers 
	    (tmp_prm = list(nil 
		    'type "tandem" 
		    'enable nil
		    'layer lyr 
		    'style 
		    default_value["adv_tandem_style"] 
		    'width
		    default_value["adv_tandem_width"] 
		    'gap 
		    default_value["adv_tandem_gap"]
		)) 
	    when(((lyr == "SOLDERMASK_TOP") || (lyr == "SOLDERMASK_BOTTOM")) 
		(tmp_prm->style = "Static Shape")
	    ) 
	    (adv_params = cons(tmp_prm adv_params))
	)
	(adv_tmp_params = makeTable("adv_tmp_params_data" nil)) 
	(adv_tmp_params[""] = list(nil 
		'type "via_ring" 
		'name ""
		'ringOffset 
		default_value["adv_ring_offset"] 
		'viaGap 
		default_value["adv_via_gap"] 
		'viaInitialOffset
		default_value["adv_via_initial_offset"] 
		'viaStackOffset 
		default_value["adv_via_stack_offset"] 
		'viaAlign 
		default_value["adv_via_align"]
		'viaAlignAngle 
		default_value["adv_via_align_angle"]
	    )) 
	(org_line_lock = list(nil 
		'arcEnable 
		(axlGetLineLock 
		    'arcEnable
		) 
		'lockAngle 
		(axlGetLineLock 
		    'lockAngle
		)
		'minRadius 
		(axlGetLineLock 
		    'minRadius
		) 
		'length45 
		(axlGetLineLock 
		    'length45
		) 
		'fixed45
		(axlGetLineLock 
		    'fixed45
		) 
		'lengthRadius 
		(axlGetLineLock 
		    'lengthRadius
		) 
		'fixedRadius 
		(axlGetLineLock 
		    'fixedRadius
		)
		'lockTangent 
		(axlGetLineLock 
		    'lockTangent
		)
	    )) 
	unless(boundp('tbx_shieldroute_data) 
	    iliDefstruct('defstruct(tbx_shieldroute_data_struct runTime tmpShapeLayer tmpLineLayer versionStr
			transMark transMarkPath Formid defaultValue shieldParam
			tmpParam advParams envOrg activeGroup licCheck
			orgLineLock advTmpParams
		    )
	    ) 
	    defvar(tbx_shieldroute_data nil)
	) 
	if(!tbx_shieldroute_data then 
	    (tbx_shieldroute_data = (make_tbx_shieldroute_data_struct ?runTime 
		    ncons(nil) ?activeGroup nil
		    ?versionStr nil ?tmpShapeLayer tmp_shape_layer ?tmpLineLayer
		    tmp_line_layer ?transMark nil ?transMarkPath nil
		    ?Formid nil ?defaultValue default_value ?shieldParam
		    nil ?tmpParam nil ?advParams adv_params
		    ?advTmpParams adv_tmp_params ?envOrg env_org ?licCheck
		    nil ?orgLineLock org_line_lock
		)) else 
	    (tbx_shieldroute_data->runTime = ncons(nil))
	    (tbx_shieldroute_data->activeGroup = nil) 
	    (tbx_shieldroute_data->versionStr = nil) 
	    (tbx_shieldroute_data->tmpShapeLayer = tmp_shape_layer) 
	    (tbx_shieldroute_data->tmpLineLayer = tmp_line_layer) 
	    (tbx_shieldroute_data->transMark = nil)
	    (tbx_shieldroute_data->transMarkPath = nil) 
	    (tbx_shieldroute_data->Formid = nil) 
	    (tbx_shieldroute_data->defaultValue = default_value) 
	    (tbx_shieldroute_data->shieldParam = nil) 
	    (tbx_shieldroute_data->tmpParam = nil)
	    (tbx_shieldroute_data->advParams = adv_params) 
	    (tbx_shieldroute_data->advTmpParams = adv_tmp_params) 
	    (tbx_shieldroute_data->envOrg = env_org) 
	    (tbx_shieldroute_data->licCheck = nil) 
	    (tbx_shieldroute_data->orgLineLock = org_line_lock)
	)
    )
)
procedure(TBX_SHIELDROUTE_Init_Filter(form_handle) 
    (axlClearSelSet) 
    (axlClearDynamics) 
    cond(((axlFormGetField form_handle "add_connect") 
	    printf("Interactive shield routing mode.\n") 
	    (axlSetFindFilter ?enabled 
		list("noall") ?onButtons 
		list("all")
	    )
	) 
	((axlFormGetField form_handle "select_cline") 
	    printf("Select clines to create shields for.\n") 
	    (axlSetFindFilter ?enabled 
		list("noall" "clines") ?onButtons 
		list("all")
	    )
	) 
	((axlFormGetField form_handle "update_shield") 
	    printf("Shield update mode.\n") 
	    (axlSetFindFilter ?enabled 
		list("noall" "clines") ?onButtons 
		list("all")
	    )
	) 
	((axlFormGetField form_handle "delete_shield") 
	    printf("Shield delete mode.\n") 
	    (axlSetFindFilter ?enabled 
		list("noall" "groups") ?onButtons 
		list("groups")
	    )
	)
    ) t
)
procedure(TBX_SHIELDROUTE_Init_Form(form_type fh) 
    let((record acc gap_value ring_names first_name) 
	(acc = cadr((axlDBGetDesignUnits))) 
	case(lowerCase(form_type) 
	    ("default" 
		(axlFormSetDecimal fh "tandem_width" acc) 
		(axlFormSetDecimal fh "side_width" acc) 
		(axlFormSetDecimal fh "corner_size" acc) 
		(axlFormSetDecimal fh "line_width" acc)
		(record = "shieldroute") 
		(axlFormSetField fh "use_default_params" 
		    TBX_SESSION_Get_Param(record "use_default_params" 
			(tbx_shieldroute_data->defaultValue)["use_default_params"]
		    )
		) 
		(axlFormSetField fh "create_tandem_shield" 
		    TBX_SESSION_Get_Param(record "create_tandem_shield" 
			(tbx_shieldroute_data->defaultValue)["create_tandem_shield"]
		    )
		) 
		(axlFormSetField fh "tandem_width" 
		    TBX_SESSION_Get_Param(record "tandem_width" 
			(tbx_shieldroute_data->defaultValue)["tandem_width"] t
		    )
		) 
		(gap_value = TBX_SESSION_Get_Param(record "tandem_gap" 
			(tbx_shieldroute_data->defaultValue)["tandem_gap"] t
		    ))
		(axlFormSetField fh "tandem_gap" 
		    TBX_SHIELDROUTE_Validate_Gap(gap_value t)
		) 
		(axlFormSetField fh "create_side_shield" 
		    TBX_SESSION_Get_Param(record "create_side_shield" 
			(tbx_shieldroute_data->defaultValue)["create_side_shield"]
		    )
		) 
		(axlFormSetField fh "side_width" 
		    TBX_SESSION_Get_Param(record "side_width" 
			(tbx_shieldroute_data->defaultValue)["side_width"] t
		    )
		) 
		(axlFormSetField fh "side_gap" 
		    TBX_SESSION_Get_Param(record "side_gap" 
			(tbx_shieldroute_data->defaultValue)["side_gap"] t
		    )
		) 
		(gap_value = TBX_SESSION_Get_Param(record "side_gap" 
			(tbx_shieldroute_data->defaultValue)["side_gap"] t
		    ))
		(axlFormSetField fh "side_gap" 
		    TBX_SHIELDROUTE_Validate_Gap(gap_value t)
		) 
		(axlFormSetField fh "shape_style" 
		    TBX_SESSION_Get_Param(record "shape_style" 
			(tbx_shieldroute_data->defaultValue)["shape_style"]
		    )
		) 
		(axlFormSetField fh "shape_net" 
		    TBX_SESSION_Get_Param(record "shape_net" 
			(tbx_shieldroute_data->defaultValue)["shape_net"]
		    )
		) 
		(axlFormSetField fh "use_advanced_params" 
		    TBX_SESSION_Get_Param(record "use_advanced_params" 
			(tbx_shieldroute_data->defaultValue)["use_advanced_params"]
		    )
		) 
		(axlFormSetField fh "keepout_void_all_pads" 
		    TBX_SESSION_Get_Param(record "keepout_void_all_pads" 
			(tbx_shieldroute_data->defaultValue)["keepout_void_all_pads"]
		    )
		)
		(axlFormSetField fh "static_shape_void_all" 
		    TBX_SESSION_Get_Param(record "static_shape_void_all" 
			(tbx_shieldroute_data->defaultValue)["static_shape_void_all"]
		    )
		) 
		(axlFormSetField fh "add_connect" 
		    TBX_SESSION_Get_Param(record "add_connect" 
			(tbx_shieldroute_data->defaultValue)["add_connect"]
		    )
		) 
		(axlDBControl 
		    'activeLayer 
		    TBX_SESSION_Get_Param(record "active_layer" 
			(tbx_shieldroute_data->defaultValue)["active_layer"]
		    )
		) 
		(axlFormSetField fh "lock_mode" 
		    TBX_SESSION_Get_Param(record "lock_mode" 
			(tbx_shieldroute_data->defaultValue)["lock_mode"]
		    )
		) 
		(axlFormSetField fh "lock_angle" 
		    TBX_SESSION_Get_Param(record "lock_angle" 
			(tbx_shieldroute_data->defaultValue)["lock_angle"]
		    )
		)
		(axlFormSetField fh "corner_size" 
		    TBX_SESSION_Get_Param(record "corner_size" 
			(tbx_shieldroute_data->defaultValue)["corner_size"] t
		    )
		) 
		(axlFormSetField fh "corner_mode" 
		    TBX_SESSION_Get_Param(record "corner_mode" 
			(tbx_shieldroute_data->defaultValue)["corner_mode"]
		    )
		) 
		(axlFormSetField fh "line_width" 
		    TBX_SESSION_Get_Param(record "line_width" 
			(tbx_shieldroute_data->defaultValue)["line_width"] t
		    )
		) 
		(axlFormSetField fh "select_cline" 
		    TBX_SESSION_Get_Param(record "select_cline" 
			(tbx_shieldroute_data->defaultValue)["select_cline"]
		    )
		) 
		(axlFormSetField fh "update_shield" 
		    TBX_SESSION_Get_Param(record "update_shield" 
			(tbx_shieldroute_data->defaultValue)["update_shield"]
		    )
		)
		(axlFormSetField fh "delete_shield" 
		    TBX_SESSION_Get_Param(record "delete_shield" 
			(tbx_shieldroute_data->defaultValue)["delete_shield"]
		    )
		)
	    ) 
	    ("advanced" 
		(axlFormSetDecimal fh "adv_side_width" acc) 
		(axlFormSetDecimal fh "adv_ring_offset" acc) 
		(axlFormSetDecimal fh "adv_via_gap" acc) 
		(axlFormSetDecimal fh "adv_via_initial_offset" acc)
		(axlFormSetField fh "adv_ring_offset" 
		    (tbx_shieldroute_data->defaultValue)["adv_ring_offset"]
		) 
		(axlFormSetField fh "adv_via_gap" 
		    (tbx_shieldroute_data->defaultValue)["adv_via_gap"]
		) 
		(axlFormSetField fh "adv_via_initial_offset" 
		    (tbx_shieldroute_data->defaultValue)["adv_via_initial_offset"]
		) 
		(axlFormSetField fh "adv_via_stack_offset" 
		    (tbx_shieldroute_data->defaultValue)["adv_via_stack_offset"]
		) 
		(axlFormSetField fh "adv_via_align" 
		    (tbx_shieldroute_data->defaultValue)["adv_via_align"]
		)
		(axlFormSetField fh "adv_via_align_angle" 
		    (tbx_shieldroute_data->defaultValue)["adv_via_align_angle"]
		) 
		foreach(prm 
		    (tbx_shieldroute_data->advParams) 
		    when(((prm->type) == "via_ring") 
			((tbx_shieldroute_data->advTmpParams)[(prm->name)] = copy(prm))
		    )
		) 
		foreach(prm 
		    (tbx_shieldroute_data->advParams) 
		    case((prm->type) 
			("side" 
			    (axlFormSetField fh "adv_enable_side_shield" 
				(prm->enable)
			    ) 
			    (axlFormSetField fh "adv_side_style" 
				(prm->style)
			    ) 
			    (axlFormSetField fh "adv_side_width" 
				(prm->width)
			    ) 
			    (axlFormSetField fh "adv_side_gap" 
				TBX_SHIELDROUTE_Validate_Gap((prm->gap) t)
			    )
			) 
			("global" 
			    (axlFormSetField fh "adv_shape_net" 
				(prm->net)
			    ) 
			    (axlFormSetField fh "adv_via_enable_drc" 
				(prm->viaEnableDRC)
			    ) 
			    (axlFormSetField fh "adv_via_drc_same_net" 
				(prm->viaDRCSameNet)
			    )
			) 
			("tandem" t) 
			("via_ring" 
			    (ring_names = cons((prm->name) ring_names))
			)
		    )
		) 
		(axlFormGridReset fh "grid") 
		TBX_SHIELDROUTE_Init_Grid_Cols(fh)
		TBX_SHIELDROUTE_Init_Grid_Rows(fh) 
		when(ring_names 
		    (axlFormListDeleteAll fh "adv_ring_list") 
		    (axlFormListDeleteAll fh "adv_via_list") 
		    (ring_names = sort(ring_names nil)) 
		    (first_name = car(ring_names))
		    (axlFormListAddItem fh "adv_ring_list" ring_names -1) 
		    (axlFormListSelect fh "adv_ring_list" 0) 
		    (axlFormListAddItem fh "adv_via_list" 
			((tbx_shieldroute_data->advTmpParams)[first_name]->padstacks) -1
		    ) 
		    (axlFormSetField fh "adv_ring_offset" 
			((tbx_shieldroute_data->advTmpParams)[first_name]->ringOffset)
		    ) 
		    (axlFormSetField fh "adv_via_gap" 
			((tbx_shieldroute_data->advTmpParams)[first_name]->viaGap)
		    )
		    (axlFormSetField fh "adv_via_initial_offset" 
			((tbx_shieldroute_data->advTmpParams)[first_name]->viaInitialOffset)
		    ) 
		    (axlFormSetField fh "adv_via_stack_offset" 
			((tbx_shieldroute_data->advTmpParams)[first_name]->viaStackOffset)
		    ) 
		    (axlFormSetField fh "adv_via_align" 
			((tbx_shieldroute_data->advTmpParams)[first_name]->viaAlign)
		    ) 
		    (axlFormSetField fh "adv_via_align_angle" 
			((tbx_shieldroute_data->advTmpParams)[first_name]->viaAlignAngle)
		    )
		)
	    )
	)
    )
)
procedure(TBX_SHIELDROUTE_Init_Grid_Cols(form_handle) 
    let((p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'CHECKITEM) 
	(p->colWidth = 4) 
	(p->align = 'center)
	(p->headText = "Enable") 
	(p->scriptLabel = "check_layer") 
	(axlFormGridInsertCol form_handle "grid" p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING)
	(p->colWidth = 10) 
	(p->fieldLength = 255) 
	(p->headText = "Layer") 
	(p->scriptLabel = "layer_name") 
	(axlFormGridInsertCol form_handle "grid" p)
	(p = (make_formGridCol)) 
	(p->fieldType = 'ENUMSET) 
	(p->colWidth = 10) 
	(p->align = 'left) 
	(p->popup = "tandem_style")
	(p->headText = "Style") 
	(p->scriptLabel = "tandem_style") 
	(axlFormGridInsertCol form_handle "grid" p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'REAL)
	(p->colWidth = 6) 
	(p->min = 0.0) 
	(p->max = (axlMKSConvert "100.0 MM" 
		car((axlDBGetDesignUnits))
	    )) 
	(p->decimals = 3) 
	(p->headText = "Width")
	(p->scriptLabel = "tandem_width") 
	(axlFormGridInsertCol form_handle "grid" p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 6)
	(p->popup = "adv_tandem_gap_popup") 
	(p->headText = "Gap") 
	(p->scriptLabel = "tandem_gap") 
	(axlFormGridInsertCol form_handle "grid" p)
    )
)
procedure(TBX_SHIELDROUTE_Init_Grid_Rows(form_handle) 
    (axlFormGridInsertRows form_handle "grid" 0 
	(length((axlSubclassRoute)) + 2)
    ) 
    (axlFormGridSetBatch form_handle "grid" 
	'TBX_SHIELDROUTE_Init_Grid_Rows_CB nil
    )
)
procedure(TBX_SHIELDROUTE_Init_Grid_Rows_CB(pvt_data) 
    let((cell rownum enable shape_style width
	    gap tandem_param layer_name config design_layers
	    no_edit
	) 
	(design_layers = mapcar(lambda((x) 
		    upperCase(x)
		) 
		(axlSubclassRoute)
	    )) 
	(design_layers = append1(design_layers "SOLDERMASK_BOTTOM")) 
	(design_layers = cons("SOLDERMASK_TOP" design_layers)) 
	(pvt_data = pvt_data)
	(tandem_param = makeTable("tandem_param_table" nil)) 
	foreach(entry 
	    (tbx_shieldroute_data->advParams) 
	    when(((entry->type) == "tandem") 
		(config = copy(entry)) 
		(layer_name = (config->layer)) 
		remprop(config 
		    'layer
		) 
		(tandem_param[layer_name] = config)
	    )
	) 
	(rownum = 1) 
	foreach(lyr design_layers 
	    (enable = (tandem_param[lyr]->enable)) 
	    (shape_style = (tandem_param[lyr]->style)) 
	    (width = (tandem_param[lyr]->width))
	    (gap = (tandem_param[lyr]->gap)) 
	    unless(gap 
		(gap = -1.0)
	    ) 
	    (no_edit = nil) 
	    when(((lyr == "SOLDERMASK_TOP") || (lyr == "SOLDERMASK_BOTTOM")) 
		(no_edit = t) 
		(shape_style = "Static Shape")
	    ) 
	    (cell = (axlFormGridNewCell))
	    (cell->col = 1) 
	    (cell->row = rownum) 
	    (cell->check = enable) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell))
	    (cell->col = 2) 
	    (cell->row = rownum) 
	    (cell->value = lyr) 
	    (cell->noEdit = t) 
	    (cell->backColor = 'button)
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 3) 
	    (cell->row = rownum) 
	    (cell->value = shape_style)
	    (cell->noEdit = no_edit) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 4) 
	    (cell->row = rownum)
	    (cell->value = width) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 5) 
	    (cell->row = rownum)
	    (cell->value = TBX_SHIELDROUTE_Validate_Gap(gap t)) 
	    (axlFormGridBatch cell) 
	    rownum++
	)
    )
)
procedure((TBX_SHIELDROUTE_Main \@optional arg) 
    let((lic_check_result info_file FC_FEATURE VERSION_STR FC_VERSION
	    SUB_VERSION port FORM_FILE fid
	) 
	(FC_FEATURE = "SHIELDROUTE") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "02") 
	(VERSION_STR = sprintf(nil "Shield Routing %s (C)2017" FC_VERSION))
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./shieldroute_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Shield Route information:\n") 
		fprintf(port "===============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "  cfginfo  : Reports group configuration from internal database attachment\n") 
		fprintf(port "  delete   : Deletes configuration from database\n") 
		fprintf(port "\n")
		close(port) 
		(axlUIViewFileCreate info_file "Shield Route: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    ((arg && (lowerCase(arg) == "cfginfo")) 
		TBX_SHIELDROUTE_Show_Config()
	    ) 
	    ((arg && (lowerCase(arg) == "delete")) 
		when((axlUIYesNo "Delete configuration from database?" nil 
			'no
		    ) 
		    (axlDeleteAttachment "tbx_shieldroute")
		)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    TBX_SHIELDROUTE_Init() 
		    TBX_UTIL_Migrate("flw_shieldroute" "tbx_shieldroute") 
		    (tbx_shieldroute_data->shieldParam = TBX_SHIELDROUTE_Read_Configuration()) 
		    (tbx_shieldroute_data->versionStr = VERSION_STR)
		    TBX_SHIELDROUTE_Clean_Layer(list((tbx_shieldroute_data->tmpShapeLayer) 
			    (tbx_shieldroute_data->tmpLineLayer)
			)
		    ) 
		    TBX_SHIELDROUTE_Disband_Obsolete_Groups() 
		    if((axlOKToProceed t) then 
			(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "shieldroute_mini")) 
			(fid = (axlMiniStatusLoad 
				gensym() FORM_FILE 
				'TBX_SHIELDROUTE_Callback nil
			    )) 
			(tbx_shieldroute_data->Formid = fid)
			(tbx_shieldroute_data->licCheck = lic_check_result) 
			TBX_FORM_Init_Header(fid nil lic_check_result nil) 
			(axlFormAutoResize fid) 
			TBX_SHIELDROUTE_Init_Form("default" fid) 
			TBX_SHIELDROUTE_Update_Form(fid "shield_mode")
			TBX_SHIELDROUTE_Update_Form(fid "add_connect_opt") 
			TBX_SHIELDROUTE_Set_Line_Lock(fid) 
			(axlFormDisplay fid) 
			TBX_FORM_Delete(lic_check_result FORM_FILE) 
			TBX_SHIELDROUTE_Init_Filter(fid)
			(axlAutoOpenFindFilter) 
			TBX_SHIELDROUTE_Event_Loop() 
			TBX_SHIELDROUTE_Cleanup() else 
			printf("Warning: Finish active command first\n")
		    ) 
		    printf("For additional help enter: 'tbx help shieldroute' in console window\n")
		)
	    )
	)
    )
)
procedure(TBX_SHIELDROUTE_Popup_Callback(event) 
    let((popup form_handle) 
	(event = event) 
	(form_handle = (tbx_shieldroute_data->Formid)) 
	cond(((axlFormGetField form_handle "add_connect") 
		if(((tbx_shieldroute_data->runTime)->xyStack) then 
		    (popup = (axlUIPopupDefine nil 
			    list(list("Done" 
				    'TBX_SHIELDROUTE_RMB_Done
				) 
				list("Toggle" 
				    'TBX_SHIELDROUTE_RMB_Toggle
				) 
				list("Finish" 
				    'TBX_SHIELDROUTE_RMB_Finish
				) 
				list("Oops" 
				    'TBX_SHIELDROUTE_RMB_Oops
				) 
				list("Cancel" 
				    'TBX_SHIELDROUTE_RMB_Cancel
				)
			    )
			)) else 
		    (popup = (axlUIPopupDefine nil 
			    list(list("Done" 
				    'TBX_SHIELDROUTE_RMB_Done
				) 
				list("Cancel" 
				    'TBX_SHIELDROUTE_RMB_Cancel
				)
			    )
			))
		)
	    ) 
	    ((axlFormGetField form_handle "select_cline") 
		(popup = (axlUIPopupDefine nil 
			list(list("Done" 
				'TBX_SHIELDROUTE_RMB_Done
			    ) 
			    list("Clear selection" 
				'TBX_SHIELDROUTE_RMB_Clear
			    ) 
			    list("Temp Group" 
				'TBX_SHIELDROUTE_RMB_Temp_Group
			    ) 
			    list("Complete" 
				'TBX_SHIELDROUTE_RMB_Finish
			    ) 
			    list("Probe" 
				'TBX_SHIELDROUTE_RMB_Probe
			    )
			    list("Oops" 
				'TBX_SHIELDROUTE_RMB_Oops
			    ) 
			    list("Cancel" 
				'TBX_SHIELDROUTE_RMB_Cancel
			    )
			)
		    ))
	    ) 
	    ((axlFormGetField form_handle "update_shield") 
		(popup = (axlUIPopupDefine nil 
			list(list("Update All" 
				'TBX_SHIELDROUTE_Update_All_Shields
			    ) 
			    list("Done" 
				'TBX_SHIELDROUTE_RMB_Done
			    ) 
			    list("Oops" 
				'TBX_SHIELDROUTE_RMB_Oops
			    ) 
			    list("Cancel" 
				'TBX_SHIELDROUTE_RMB_Cancel
			    )
			)
		    ))
	    ) 
	    ((axlFormGetField form_handle "delete_shield") 
		(popup = (axlUIPopupDefine nil 
			list(list("Delete All" 
				'TBX_SHIELDROUTE_Delete_All_Shields
			    ) 
			    list("Done" 
				'TBX_SHIELDROUTE_RMB_Done
			    ) 
			    list("Oops" 
				'TBX_SHIELDROUTE_RMB_Oops
			    ) 
			    list("Cancel" 
				'TBX_SHIELDROUTE_RMB_Cancel
			    )
			)
		    ))
	    )
	) 
	(axlUIPopupSet popup)
    )
)
procedure(TBX_SHIELDROUTE_Process_Side_Keepout(result_poly_list) 
    let((hole_poly_list result rpoly poly_a_list poly_b_list
	    break_list tmp_list result_list
	) 
	foreach(poly result_poly_list 
	    (hole_poly_list = list()) 
	    foreach(hole 
		(poly->holes) 
		(hole_poly_list = cons(car((axlPolyFromHole hole)) hole_poly_list))
	    ) 
	    (result = (axlDBCreateShape poly t 
		    (tbx_shieldroute_data->tmpShapeLayer) nil
		    nil
		))
	    (rpoly = car((axlPolyFromDB 
			car(result) ?holes nil
		    )
		)) 
	    when(result 
		(axlDeleteObject 
		    car(result)
		)
	    ) 
	    (poly_a_list = list(rpoly)) 
	    (poly_b_list = hole_poly_list) 
	    foreach(poly_b poly_b_list 
		(tmp_list = nil) 
		foreach(poly_a poly_a_list 
		    (result = TBX_SHIELDROUTE_Check_Overlap(poly_a poly_b)) 
		    cond(((result == "full") 
			    (break_list = TBX_SHIELDROUTE_Break_Poly(poly_a poly_b 
				    (tbx_shieldroute_data->tmpShapeLayer)
				)) 
			    (tmp_list = cons(car(break_list) tmp_list)) 
			    (tmp_list = cons(cadr(break_list) tmp_list))
			) 
			((!result || (result == "partial")) 
			    (tmp_list = cons(poly_a tmp_list))
			)
		    )
		) 
		(poly_a_list = tmp_list)
	    )
	    (result_list = (axlPolyOperation poly_a_list poly_b_list 
		    'ANDNOT
		))
	) result_list
    )
)
procedure(TBX_SHIELDROUTE_RMB_Cancel() 
    (axlCancelEnterFun)
)
procedure(TBX_SHIELDROUTE_RMB_Clear() 
    let((form_handle) 
	(form_handle = (tbx_shieldroute_data->Formid)) 
	when((axlFormGetField form_handle "select_cline") 
	    (axlClearSelSet) 
	    (axlDehighlightObject 
		((tbx_shieldroute_data->runTime)->clineList)
	    ) 
	    (tbx_shieldroute_data->runTime = ncons(nil))
	)
    )
)
procedure(TBX_SHIELDROUTE_RMB_Done() 
    (axlFinishEnterFun)
)
procedure(TBX_SHIELDROUTE_RMB_Finish() 
    let((form_handle) 
	(form_handle = (tbx_shieldroute_data->Formid)) 
	cond(((axlFormGetField form_handle "add_connect") 
		when(((tbx_shieldroute_data->runTime)->xyStack) 
		    (axlDBTransactionMark 
			(tbx_shieldroute_data->transMark)
		    ) 
		    TBX_SHIELDROUTE_AddConnectMode_Process()
		)
	    ) 
	    ((axlFormGetField form_handle "select_cline") 
		TBX_SHIELDROUTE_SelectMode_Process() 
		(tbx_shieldroute_data->runTime = ncons(nil))
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_SHIELDROUTE_RMB_Oops() 
    let((form_handle partial_tmp_objects) 
	(form_handle = (tbx_shieldroute_data->Formid)) 
	cond(((axlFormGetField form_handle "add_connect") 
		if(zerop(length(((tbx_shieldroute_data->runTime)->xyStack))) then t else 
		    (axlDBTransactionOops 
			(tbx_shieldroute_data->transMarkPath)
		    )
		    (partial_tmp_objects = partial_tmp_objects) 
		    ((tbx_shieldroute_data->runTime)->xyStack = cdr(((tbx_shieldroute_data->runTime)->xyStack))) 
		    when(zerop(length(((tbx_shieldroute_data->runTime)->xyStack))) 
			((tbx_shieldroute_data->runTime)->netName = nil)
		    ) 
		    ((tbx_shieldroute_data->runTime)->rpathStack = cdr(((tbx_shieldroute_data->runTime)->rpathStack))) 
		    ((tbx_shieldroute_data->runTime)->segPolyStack = cdr(((tbx_shieldroute_data->runTime)->segPolyStack)))
		    ((tbx_shieldroute_data->runTime)->tmpStack = cdr(((tbx_shieldroute_data->runTime)->tmpStack))) 
		    (axlClearDynamics) 
		    (axlDBRefreshId nil) 
		    TBX_SHIELDROUTE_Build_Dynamics((tbx_shieldroute_data->Formid))
		)
	    ) 
	    ((axlFormGetField form_handle "select_cline") 
		(axlDBTransactionOops 
		    (tbx_shieldroute_data->transMark)
		) 
		(axlDehighlightObject 
		    ((tbx_shieldroute_data->runTime)->clineList)
		) 
		(tbx_shieldroute_data->runTime = ncons(nil)) 
		(axlClearSelSet)
		(axlClearDynamics)
	    ) 
	    ((axlFormGetField form_handle "update_shield") 
		(axlDBTransactionOops 
		    (tbx_shieldroute_data->transMark)
		)
	    ) 
	    ((axlFormGetField form_handle "delete_shield") 
		(axlDBTransactionOops 
		    (tbx_shieldroute_data->transMark)
		) 
		(tbx_shieldroute_data->shieldParam = TBX_SHIELDROUTE_Copy_Group_Param((tbx_shieldroute_data->tmpParam)))
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_SHIELDROUTE_RMB_Probe() 
    let((form_handle) 
	(form_handle = (tbx_shieldroute_data->Formid)) 
	when((axlFormGetField form_handle "select_cline") 
	    printf("Pick a shield group to extract parameters from\n") 
	    ((tbx_shieldroute_data->runTime)->paramProbe = t)
	)
    )
)
procedure(TBX_SHIELDROUTE_RMB_Temp_Group() 
    let((form_handle) 
	(form_handle = (tbx_shieldroute_data->Formid)) 
	when((axlFormGetField form_handle "select_cline") 
	    printf("Pick clines by subseqent picks, use RMB - Complete to finish\n") 
	    (tbx_shieldroute_data->runTime = ncons(nil)) 
	    ((tbx_shieldroute_data->runTime)->tempGroup = t)
	)
    )
)
procedure((TBX_SHIELDROUTE_RMB_Toggle \@optional arg) 
    let((form_handle) 
	(arg = arg) 
	(form_handle = (tbx_shieldroute_data->Formid)) 
	when((axlFormGetField form_handle "add_connect") 
	    (axlShell "toggle")
	)
    )
)
procedure(TBX_SHIELDROUTE_Read_Configuration() 
    let((att shield_param data group_name prm
	    group_config config_units design_units static_shape_void_all
	) 
	(shield_param = makeTable("shield_param_table" nil)) 
	(att = (axlGetAttachment "tbx_shieldroute" 
		'string
	    )) 
	when(att 
	    (data = car(linereadstring((att->data))))
	) 
	(design_units = car((axlDBGetDesignUnits)))
	when(data 
	    (config_units = car(data)) 
	    (data = cdr(data)) 
	    foreach(prm_set data 
		(static_shape_void_all = nil) 
		(group_config = list()) 
		(group_name = upperCase(car(prm_set)))
		foreach(entry 
		    cdr(prm_set) 
		    (prm = cons(nil 
			    copy(entry)
			)) 
		    when((prm->width) 
			(prm->width = (axlMKSConvert 
				(prm->width) config_units design_units
			    ))
		    ) 
		    cond((((prm->gap) && numberp((prm->gap)) && ((prm->gap) >= 0.0)) 
			    (prm->gap = (axlMKSConvert 
				    (prm->gap) config_units design_units
				))
			) 
			(((prm->type) != "global") 
			    (prm->gap = "NA")
			)
		    )
		    when((((prm->type) == "side") && (prm->voidByCns)) 
			remprop(prm 
			    'voidByCns
			) 
			(static_shape_void_all = t)
		    ) 
		    (group_config = cons(prm group_config))
		) 
		when(static_shape_void_all 
		    foreach(dpl group_config 
			when(((dpl->type) == "global") 
			    (dpl->staticShapeVoidAll = t)
			)
		    )
		) 
		(shield_param[group_name] = group_config)
	    )
	) 
	when((length(shield_param) > 0) 
	    (shield_param = TBX_SHIELDROUTE_Synchronize(shield_param))
	) shield_param
    )
)
procedure(TBX_SHIELDROUTE_Retrieve_Shieldgroup_Params(event_xy) 
    let((shield_group adv_params tmp_prm group_name result) 
	(axlClearSelSet) 
	(axlSetFindFilter ?enabled 
	    list("noall" "groups") ?onButtons 
	    list("groups")
	) 
	(axlSingleSelectPoint event_xy) 
	when((axlGetSelSet) 
	    (shield_group = car((axlGetSelSet))) 
	    (group_name = upperCase((shield_group->name)))
	)
	(result = list(nil nil)) 
	if((group_name && rexMatchp("^TBX_SHIELD_" group_name) && 
		(tbx_shieldroute_data->shieldParam)[group_name]) then 
	    foreach(prm 
		(tbx_shieldroute_data->shieldParam)[group_name] 
		cond(((((prm->type) == "tandem") && (prm->enable)) 
			(tmp_prm = copy(prm)) 
			(adv_params = cons(tmp_prm adv_params))
		    ) 
		    (((prm->type) == "side") 
			(tmp_prm = copy(prm)) 
			(adv_params = cons(tmp_prm adv_params))
		    ) 
		    (((prm->type) == "global") 
			(tmp_prm = copy(prm)) 
			(adv_params = cons(tmp_prm adv_params))
		    ) 
		    (((prm->type) == "via_ring") 
			(tmp_prm = copy(prm)) 
			(adv_params = cons(tmp_prm adv_params))
		    )
		)
	    ) 
	    when(adv_params 
		(adv_params = TBX_SHIELDROUTE_Adv_Synchronize(adv_params))
	    ) 
	    when(adv_params 
		(result = list(t adv_params))
	    )
	    else 
	    printf("Warning: No valid shield group selected\n") 
	    (result = list(nil nil))
	) result
    )
)
procedure(TBX_SHIELDROUTE_Route_Tmp_Path(rpath width oversize) 
    let((seg_list start_point clock_wise arc_center partial_path
	    end_point poly_data exp_poly result tmp_objects
	) 
	(seg_list = (axlPathGetPathSegs rpath)) 
	(start_point = (axlPathSegGetEndPoint 
		car(seg_list)
	    )) 
	(partial_path = (axlPathStart 
		list(start_point) width
	    )) 
	foreach(seg 
	    cdr(seg_list) 
	    (arc_center = (axlPathSegGetArcCenter seg)) 
	    (end_point = (axlPathSegGetEndPoint seg)) 
	    if(arc_center then 
		(clock_wise = (axlPathSegGetArcClockwise seg)) 
		(partial_path = (axlPathArcCenter partial_path width end_point clock_wise
			arc_center
		    )) else
		(partial_path = (axlPathLine partial_path width end_point))
	    )
	)
	when(partial_path 
	    (result = (axlDBCreatePath partial_path 
		    (tbx_shieldroute_data->tmpLineLayer)
		)) 
	    when(result 
		(tmp_objects = cons(caar(result) tmp_objects)) 
		(poly_data = TBX_SHIELDROUTE_Get_Path_Polygon(caar(result))) 
		(exp_poly = car((axlPolyExpand poly_data oversize 
			    'NONE
			)
		    )) 
		when(exp_poly 
		    (result = (axlDBCreateShape exp_poly t 
			    (tbx_shieldroute_data->tmpShapeLayer)
			)) 
		    when(result 
			(tmp_objects = cons(car(result) tmp_objects))
		    )
		)
	    )
	) 
	when((partial_path && poly_data) 
	    (result = list(partial_path poly_data tmp_objects))
	) result
    )
)
procedure(TBX_SHIELDROUTE_Save_Configuration() 
    let((data_str param_set data name_list design_units) 
	(axlDeleteAttachment "tbx_shieldroute") 
	(design_units = car((axlDBGetDesignUnits))) 
	foreach(key 
	    (tbx_shieldroute_data->shieldParam) 
	    (name_list = cons(key name_list))
	) 
	(name_list = sort(name_list nil))
	when(name_list 
	    foreach(grp name_list 
		(param_set = list()) 
		foreach(prm 
		    (tbx_shieldroute_data->shieldParam)[grp] 
		    when((((prm->type) == "global") || (prm->enable) || ((prm->type) == "via_ring")) 
			(prm = cdr(prm)) 
			(param_set = cons(prm param_set))
		    )
		) 
		(param_set = cons(grp param_set))
		(data = cons(param_set data))
	    ) 
	    (data = reverse(data)) 
	    (data = cons(design_units data)) 
	    (data_str = sprintf(nil "%L" data))
	    (axlCreateAttachment "tbx_shieldroute" nil 1 
		'string
		data_str
	    )
	)
    )
)
procedure(TBX_SHIELDROUTE_SelectMode_Process() 
    let((poly_data poly_base_structure_list pt_list pt_str_list first_seg
	    last_seg param_set group_name shield_items shield_group
	) 
	when(((tbx_shieldroute_data->runTime)->clineList) 
	    (shield_group = car(TBX_SHIELDROUTE_Select_Group("cline_data" 
			((tbx_shieldroute_data->runTime)->clineList)
		    )
		)) 
	    when(shield_group 
		TBX_SHIELDROUTE_Delete_Shield(shield_group 
		    (tbx_shieldroute_data->shieldParam) t
		)
	    ) 
	    ((tbx_shieldroute_data->runTime)->segPolyStack = nil) 
	    ((tbx_shieldroute_data->runTime)->padPolyStack = nil)
	    (tbx_shieldroute_data->activeGroup = TBX_SHIELDROUTE_Get_Next_Group()) 
	    foreach(path 
		((tbx_shieldroute_data->runTime)->clineList) 
		(first_seg = car((path->segments))) 
		(last_seg = (lastelem 
			(path->segments)
		    )) 
		foreach(xy 
		    list(car((first_seg->startEnd)) 
			cadr((last_seg->startEnd))
		    ) 
		    unless(exists(x pt_str_list 
			    (x == (axlGeo2Str xy))
			) 
			(pt_str_list = cons((axlGeo2Str xy) pt_str_list)) 
			(pt_list = cons(xy pt_list))
		    )
		)
		(poly_data = TBX_SHIELDROUTE_Get_Path_Polygon(path)) 
		((tbx_shieldroute_data->runTime)->segPolyStack = cons(poly_data 
			((tbx_shieldroute_data->runTime)->segPolyStack)
		    ))
	    ) 
	    (axlDehighlightObject 
		((tbx_shieldroute_data->runTime)->clineList)
	    ) 
	    ((tbx_shieldroute_data->runTime)->padPolyStack = TBX_SHIELDROUTE_Get_Padstack_Polygons(pt_list 
		    ((tbx_shieldroute_data->runTime)->activeLayer)
		)) 
	    (poly_base_structure_list = TBX_SHIELDROUTE_Get_Structure_Polygon(((tbx_shieldroute_data->runTime)->segPolyStack) 
		    ((tbx_shieldroute_data->runTime)->padPolyStack)
		))
	    (param_set = TBX_SHIELDROUTE_Derive_Params(((tbx_shieldroute_data->runTime)->activeLayer) 
		    (tbx_shieldroute_data->Formid)
		)) 
	    (group_name = upperCase(((tbx_shieldroute_data->activeGroup)->name))) 
	    ((tbx_shieldroute_data->shieldParam)[group_name] = param_set) 
	    (shield_items = TBX_SHIELDROUTE_Create_Shield_Structure(poly_base_structure_list param_set)) 
	    when(shield_items 
		(axlDBAddGroupObjects 
		    (tbx_shieldroute_data->activeGroup) shield_items
		)
	    )
	    foreach(path 
		((tbx_shieldroute_data->runTime)->clineList) 
		(axlDBAddGroupObjects 
		    (tbx_shieldroute_data->activeGroup) path
		)
	    ) 
	    (tbx_shieldroute_data->runTime = ncons(nil)) 
	    (axlClearDynamics)
	)
    )
)
procedure(TBX_SHIELDROUTE_Select_Group(mode arg) 
    let((xy shield_group_list cline cline_list) 
	cond(((mode == "pick_group") 
		(xy = arg) 
		(axlClearSelSet) 
		(axlSetFindFilter ?enabled 
		    list("noall" "groups") ?onButtons 
		    list("groups")
		) 
		(axlSingleSelectPoint xy)
		when((axlGetSelSet) 
		    (shield_group_list = list(car((axlGetSelSet))))
		)
	    ) 
	    (((mode == "pick_cline") || (mode == "cline_data")) 
		if((mode == "pick_cline") then 
		    (xy = arg) 
		    (axlClearSelSet) 
		    (axlSetFindFilter ?enabled 
			list("noall" "clines") ?onButtons 
			list("all")
		    )
		    (axlSingleSelectPoint xy) 
		    when((axlGetSelSet) 
			(cline = car((axlGetSelSet)))
		    ) else 
		    (cline_list = arg) 
		    (cline = car(cline_list))
		) 
		when(cline 
		    foreach(grp 
			(cline->parentGroups) 
			when(rexMatchp("^TBX_SHIELD_" 
				upperCase((grp->name))
			    ) 
			    (shield_group_list = list(grp))
			)
		    )
		)
	    ) 
	    ((mode == "all") 
		(shield_group_list = (axlSelectByName "GROUP" "TBX_SHIELD_*" t))
	    )
	) shield_group_list
    )
)
procedure(TBX_SHIELDROUTE_Set_Line_Lock(form_handle) 
    let((corner_size) 
	if(((axlFormGetField form_handle "lock_mode") == "line") then 
	    case((axlFormGetField form_handle "lock_angle") 
		("0" 
		    (axlSetLineLock ?arcEnable nil ?lockAngle 0)
		) 
		("45" 
		    (corner_size = (axlFormGetField form_handle "corner_size")) 
		    cond((((axlFormGetField form_handle "corner_mode") == "min") 
			    (axlSetLineLock ?arcEnable nil ?lockAngle 45
				?length45 corner_size ?fixed45 nil
			    )
			) 
			(((axlFormGetField form_handle "corner_mode") == "fixed") 
			    (axlSetLineLock ?arcEnable nil ?lockAngle 45
				?length45 corner_size ?fixed45 t
			    )
			)
		    )
		) 
		("90" 
		    (axlSetLineLock ?arcEnable nil ?lockAngle 90)
		)
	    ) else 
	    case((axlFormGetField form_handle "lock_angle") 
		("0" 
		    (axlSetLineLock ?arcEnable t ?lockAngle 0)
		) 
		("45" 
		    (corner_size = (axlFormGetField form_handle "corner_size")) 
		    cond((((axlFormGetField form_handle "corner_mode") == "min") 
			    (axlSetLineLock ?arcEnable t ?lockAngle 45
				?minRadius corner_size ?fixedRadius nil ?fixed45
				nil
			    )
			) 
			(((axlFormGetField form_handle "corner_mode") == "fixed") 
			    (axlSetLineLock ?arcEnable t ?lockAngle 45
				?lengthRadius corner_size ?fixedRadius t ?fixed45
				nil
			    )
			)
		    )
		) 
		("90" 
		    (corner_size = (axlFormGetField form_handle "corner_size")) 
		    cond((((axlFormGetField form_handle "corner_mode") == "min") 
			    (axlSetLineLock ?arcEnable t ?lockAngle 90
				?minRadius corner_size ?fixedRadius nil ?fixed45
				nil
			    )
			) 
			(((axlFormGetField form_handle "corner_mode") == "fixed") 
			    (axlSetLineLock ?arcEnable t ?lockAngle 90
				?lengthRadius corner_size ?fixedRadius t ?fixed45
				nil
			    )
			)
		    )
		)
	    )
	) t
    )
)
procedure(TBX_SHIELDROUTE_Show_Config() 
    let((att port info_file data) 
	(att = (axlGetAttachment "tbx_shieldroute" 
		'string
	    )) 
	when(att 
	    (data = car(linereadstring((att->data))))
	) 
	if(data then 
	    (info_file = strcat(getWorkingDir() "/shieldroute_config_att.txt")) 
	    (port = outfile(info_file "w")) 
	    fprintf(port "( %L\n" 
		car(data)
	    )
	    foreach(prmset 
		cdr(data) 
		fprintf(port "   ( %L\n" 
		    car(prmset)
		) 
		foreach(prm 
		    cdr(prmset) 
		    fprintf(port "     %L\n" prm)
		) 
		fprintf(port "   )\n")
	    ) 
	    fprintf(port ")\n") 
	    close(port) 
	    (axlUIViewFileCreate info_file "Shield Route: Configuration from database" nil) 
	    when(isFile(info_file) 
		deleteFile(info_file)
	    )
	    else 
	    (axlUIConfirm "No shield group information stored in database")
	)
    )
)
procedure(TBX_SHIELDROUTE_Snap_To_Object(xy xySnap) 
    let((result origin did_snap net_name ff_en
	    ff_on
	) 
	if((xy && xySnap) then 
	    (origin = (axlSnapToObject t xy)) 
	    if(origin then 
		(did_snap = t) 
		(ff_en = (axlGetFindFilter nil)) 
		(ff_on = (axlGetFindFilter t))
		(axlSetFindFilter ?enabled 
		    list("noall" "equivlogic" "nets" "clines") ?onButtons 
		    list("all")
		) 
		(axlClearSelSet) 
		(axlSingleSelectPoint origin) 
		when((axlGetSelSet) 
		    (net_name = (car((axlGetSelSet))->name)) 
		    if(!((tbx_shieldroute_data->runTime)->netName) then 
			((tbx_shieldroute_data->runTime)->netName = net_name) else 
			when((net_name != ((tbx_shieldroute_data->runTime)->netName)) 
			    printf("Warning: Net names do not match\n") 
			    (did_snap = nil) 
			    (origin = xy)
			)
		    )
		) 
		(axlClearSelSet)
		(axlSetFindFilter ?enabled 
		    cons("noall" ff_en) ?onButtons ff_on
		) else 
		(did_snap = nil) 
		(origin = xySnap)
	    ) 
	    (result = list(origin did_snap))
	    else 
	    (result = list(nil nil))
	) result
    )
)
procedure(TBX_SHIELDROUTE_Synchronize(paramSet) 
    let((group_list group_name_list key_list) 
	(group_list = (axlSelectByName "GROUP" "TBX_SHIELD_*" t)) 
	(group_name_list = mapcar(lambda((x) 
		    upperCase((x->name))
		) group_list
	    )) 
	(axlClearSelSet) 
	foreach(key paramSet 
	    (key_list = cons(key key_list))
	)
	foreach(key key_list 
	    unless(exists(x group_name_list 
		    (x == key)
		) 
		remove(key paramSet)
	    )
	) paramSet
    )
)
procedure(TBX_SHIELDROUTE_Update_All_Shields() 
    TBX_SHIELDROUTE_Update_Shield("all")
)
procedure(TBX_SHIELDROUTE_Update_Form(form_handle type) 
    let((cur_ring tmpCnt ok_duplicate) 
	case(type 
	    ("add_connect_opt" 
		if((axlFormGetField form_handle "add_connect") then 
		    (axlFormSetFieldEditable form_handle "subcolor" t) 
		    (axlFormSetFieldEditable form_handle "subclass" t) 
		    (axlFormSetFieldEditable form_handle "lock_mode" t)
		    (axlFormSetFieldEditable form_handle "lock_angle" t) 
		    (axlFormSetFieldEditable form_handle "corner_size" t) 
		    (axlFormSetFieldEditable form_handle "corner_mode" t) 
		    (axlFormSetFieldEditable form_handle "line_width" t) else
		    (axlFormSetFieldEditable form_handle "subcolor" nil) 
		    (axlFormSetFieldEditable form_handle "subclass" nil) 
		    (axlFormSetFieldEditable form_handle "lock_mode" nil) 
		    (axlFormSetFieldEditable form_handle "lock_angle" nil) 
		    (axlFormSetFieldEditable form_handle "corner_size" nil)
		    (axlFormSetFieldEditable form_handle "corner_mode" nil) 
		    (axlFormSetFieldEditable form_handle "line_width" nil)
		)
	    ) 
	    ("run_mode" 
		if(((axlFormGetField form_handle "update_shield") || 
			(axlFormGetField form_handle "delete_shield")) then 
		    (axlFormSetFieldEditable form_handle "use_default_params" nil) 
		    (axlFormSetFieldEditable form_handle "create_tandem_shield" nil) 
		    (axlFormSetFieldEditable form_handle "tandem_width" nil)
		    (axlFormSetFieldEditable form_handle "create_side_shield" nil) 
		    (axlFormSetFieldEditable form_handle "side_width" nil) 
		    (axlFormSetFieldEditable form_handle "side_gap" nil) 
		    (axlFormSetFieldEditable form_handle "use_advanced_params" nil) 
		    (axlFormSetFieldEditable form_handle "specify_advanced_params" nil)
		    (axlFormSetFieldEditable form_handle "shape_style" nil) 
		    (axlFormSetFieldEditable form_handle "shape_net" nil) 
		    (axlFormSetFieldEditable form_handle "browse_net" nil) else 
		    (axlFormSetFieldEditable form_handle "use_default_params" t)
		    (axlFormSetFieldEditable form_handle "create_tandem_shield" t) 
		    (axlFormSetFieldEditable form_handle "tandem_width" t) 
		    (axlFormSetFieldEditable form_handle "create_side_shield" t) 
		    (axlFormSetFieldEditable form_handle "side_width" t) 
		    (axlFormSetFieldEditable form_handle "side_gap" t)
		    (axlFormSetFieldEditable form_handle "use_advanced_params" t) 
		    (axlFormSetFieldEditable form_handle "specify_advanced_params" t) 
		    (axlFormSetFieldEditable form_handle "shape_style" t) 
		    if(((axlFormGetField form_handle "shape_style") == "Route Keepout") then 
			(axlFormSetFieldEditable form_handle "shape_net" nil) 
			(axlFormSetFieldEditable form_handle "browse_net" nil) else
			(axlFormSetFieldEditable form_handle "shape_net" t) 
			(axlFormSetFieldEditable form_handle "browse_net" t)
		    )
		)
	    ) 
	    ("shield_mode" 
		if((axlFormGetField form_handle "use_default_params") then 
		    (axlFormSetFieldEditable form_handle "create_tandem_shield" t) 
		    (axlFormSetFieldEditable form_handle "tandem_width" t) 
		    (axlFormSetFieldEditable form_handle "create_side_shield" t)
		    (axlFormSetFieldEditable form_handle "side_width" t) 
		    (axlFormSetFieldEditable form_handle "side_gap" t) 
		    (axlFormSetFieldEditable form_handle "shape_style" t) 
		    if(((axlFormGetField form_handle "shape_style") == "Route Keepout") then 
			(axlFormSetFieldEditable form_handle "shape_net" nil) 
			(axlFormSetFieldEditable form_handle "browse_net" nil) else
			(axlFormSetFieldEditable form_handle "shape_net" t) 
			(axlFormSetFieldEditable form_handle "browse_net" t)
		    ) else
		    (axlFormSetFieldEditable form_handle "create_tandem_shield" nil) 
		    (axlFormSetFieldEditable form_handle "tandem_width" nil) 
		    (axlFormSetFieldEditable form_handle "create_side_shield" nil) 
		    (axlFormSetFieldEditable form_handle "side_width" nil) 
		    (axlFormSetFieldEditable form_handle "side_gap" nil)
		    (axlFormSetFieldEditable form_handle "shape_style" nil) 
		    (axlFormSetFieldEditable form_handle "shape_net" nil) 
		    (axlFormSetFieldEditable form_handle "browse_net" nil)
		)
	    ) 
	    ("adv_side_shield" 
		if((axlFormGetField form_handle "adv_enable_side_shield") then 
		    (axlFormSetFieldEditable form_handle "adv_side_style" t) 
		    (axlFormSetFieldEditable form_handle "adv_side_width" t) 
		    (axlFormSetFieldEditable form_handle "adv_side_gap" t)
		    else 
		    (axlFormSetFieldEditable form_handle "adv_side_style" nil) 
		    (axlFormSetFieldEditable form_handle "adv_side_width" nil) 
		    (axlFormSetFieldEditable form_handle "adv_side_gap" nil)
		)
	    )
	    ("adv_via_param" 
		(axlFormSetFieldEditable form_handle "adv_add_via_to_list" nil) 
		(axlFormSetFieldEditable form_handle "adv_delete_via_from_list" nil) 
		(axlFormSetFieldEditable form_handle "adv_via_move_up" nil) 
		(axlFormSetFieldEditable form_handle "adv_via_move_down" nil)
		(axlFormSetFieldEditable form_handle "adv_ring_offset" nil) 
		(axlFormSetFieldEditable form_handle "adv_via_gap" nil) 
		(axlFormSetFieldEditable form_handle "adv_via_initial_offset" nil) 
		(axlFormSetFieldEditable form_handle "adv_via_stack_offset" nil) 
		(axlFormSetFieldEditable form_handle "adv_via_align" nil)
		(axlFormSetFieldEditable form_handle "adv_via_align_angle" nil) 
		(axlFormSetFieldEditable form_handle "adv_via_enable_drc" nil) 
		(axlFormSetFieldEditable form_handle "adv_via_drc_same_net" nil) 
		when((length((tbx_shieldroute_data->advTmpParams)) > 0) 
		    (axlFormSetFieldEditable form_handle "adv_add_via_to_list" t) 
		    (axlFormSetFieldEditable form_handle "adv_delete_via_from_list" t) 
		    (axlFormSetFieldEditable form_handle "adv_ring_offset" t) 
		    (axlFormSetFieldEditable form_handle "adv_via_gap" t)
		    (axlFormSetFieldEditable form_handle "adv_via_initial_offset" t) 
		    (axlFormSetFieldEditable form_handle "adv_via_enable_drc" t) 
		    when((axlFormGetField form_handle "adv_via_enable_drc") 
			(axlFormSetFieldEditable form_handle "adv_via_drc_same_net" t)
		    ) 
		    (cur_ring = (axlFormGetField form_handle "adv_ring_list")) 
		    when((cur_ring && (cur_ring != "") && (length(((tbx_shieldroute_data->advTmpParams)[cur_ring]->padstacks)) > 1)) 
			(tmpCnt = makeTable("tmp_cnt_data" 0)) 
			foreach(p 
			    ((tbx_shieldroute_data->advTmpParams)[cur_ring]->padstacks) 
			    (tmpCnt[p] = (tmpCnt[p] + 1))
			) 
			foreach(p tmpCnt 
			    when((tmpCnt[p] > 1) 
				(ok_duplicate = t)
			    )
			) 
			unless(ok_duplicate 
			    (axlFormSetFieldEditable form_handle "adv_via_move_up" t) 
			    (axlFormSetFieldEditable form_handle "adv_via_move_down" t)
			)
			(axlFormSetFieldEditable form_handle "adv_via_stack_offset" t) 
			(axlFormSetFieldEditable form_handle "adv_via_align" t) 
			when((((axlFormGetField form_handle "adv_via_align") == "inwards") || 
				((axlFormGetField form_handle "adv_via_align") == "outwards")) 
			    (axlFormSetFieldEditable form_handle "adv_via_align_angle" t)
			)
		    )
		)
	    )
	)
    )
)
procedure(TBX_SHIELDROUTE_Update_Shield(arg) 
    let((poly_data poly_base_structure_list pt_list pt_str_list first_seg
	    last_seg param_set group_name cline_list active_group
	    active_layer shield_items event_xy group_list
	) 
	if((arg == "all") then 
	    (group_list = TBX_SHIELDROUTE_Select_Group("all" nil)) else 
	    (event_xy = arg)
	    (group_list = TBX_SHIELDROUTE_Select_Group("pick_group" event_xy))
	) 
	foreach(grp group_list 
	    (active_group = grp) 
	    TBX_SHIELDROUTE_Delete_Shield(active_group 
		(tbx_shieldroute_data->shieldParam) nil
	    ) 
	    ((tbx_shieldroute_data->runTime)->segPolyStack = nil)
	    ((tbx_shieldroute_data->runTime)->padPolyStack = nil) 
	    (tbx_shieldroute_data->runTime = ncons(nil)) 
	    (pt_str_list = nil) 
	    (pt_list = nil) 
	    if(active_group then 
		(group_name = upperCase((active_group->name))) 
		(cline_list = mapcan(lambda((x) 
			    when(((x->objType) == "path") 
				list(x)
			    )
			) 
			(active_group->groupMembers)
		    )) 
		when(cline_list 
		    (active_layer = (car(cline_list)->layer)) 
		    if((tbx_shieldroute_data->shieldParam)[group_name] then 
			(param_set = (tbx_shieldroute_data->shieldParam)[group_name]) else 
			printf("Note: No shield configuration found for %L, derive parameters from ministatus\n" group_name)
			(param_set = TBX_SHIELDROUTE_Derive_Params(active_layer 
				(tbx_shieldroute_data->Formid)
			    )) 
			((tbx_shieldroute_data->shieldParam)[group_name] = param_set)
		    )
		)
		else 
		printf("Info: No shield group information found for selected clines\n")
	    )
	    when((cline_list && param_set) 
		(active_layer = (car(cline_list)->layer)) 
		foreach(path cline_list 
		    (first_seg = car((path->segments))) 
		    (last_seg = (lastelem 
			    (path->segments)
			)) 
		    foreach(xy 
			list(car((first_seg->startEnd)) 
			    cadr((last_seg->startEnd))
			) 
			unless(exists(x pt_str_list 
				(x == (axlGeo2Str xy))
			    ) 
			    (pt_str_list = cons((axlGeo2Str xy) pt_str_list)) 
			    (pt_list = cons(xy pt_list))
			)
		    )
		    (poly_data = TBX_SHIELDROUTE_Get_Path_Polygon(path)) 
		    ((tbx_shieldroute_data->runTime)->segPolyStack = cons(poly_data 
			    ((tbx_shieldroute_data->runTime)->segPolyStack)
			))
		) 
		(axlDehighlightObject cline_list) 
		((tbx_shieldroute_data->runTime)->padPolyStack = TBX_SHIELDROUTE_Get_Padstack_Polygons(pt_list active_layer))
		(poly_base_structure_list = TBX_SHIELDROUTE_Get_Structure_Polygon(((tbx_shieldroute_data->runTime)->segPolyStack) 
			((tbx_shieldroute_data->runTime)->padPolyStack)
		    )) 
		(shield_items = TBX_SHIELDROUTE_Create_Shield_Structure(poly_base_structure_list param_set)) 
		when(shield_items 
		    (axlDBAddGroupObjects active_group shield_items)
		) 
		foreach(path cline_list 
		    (axlDBAddGroupObjects active_group path)
		) 
		(tbx_shieldroute_data->runTime = ncons(nil))
		(axlClearDynamics)
	    )
	)
    )
)
procedure((TBX_SHIELDROUTE_Validate_Gap value \@optional formatString) 
    let((format_str ret_val float_value) 
	if(formatString then 
	    (format_str = strcat("%." 
		    sprintf(nil "%d" 
			cadr((axlDBGetDesignUnits))
		    ) "f"
		)) 
	    cond((numberp(value) 
		    if((value >= 0.0) then 
			(float_value = value) else 
			printf("Warning: Value must be positive or \"NA\"\n")
		    )
		) 
		((stringp(value) && atof(value)) 
		    if((atof(value) >= 0.0) then 
			(float_value = atof(value)) else 
			printf("Warning: Value must be positive or \"NA\"\n")
		    )
		)
	    ) 
	    if(float_value then 
		(ret_val = sprintf(nil format_str float_value)) else 
		(ret_val = "NA")
	    )
	    else 
	    if((stringp(value) && atof(value) && (atof(value) >= 0.0)) then 
		(ret_val = atof(value)) else 
		(ret_val = "NA")
	    )
	) ret_val
    )
)
procedure(TBX_SHIELDROUTE_Void_Pads(shield_poly layer_name) 
    let((offset shape_list etch_layer cur_pv_poly_list pad_poly_data
	    result
	) 
	(offset = (axlMKSConvert "25.0 UM" 
		car((axlDBGetDesignUnits))
	    )) 
	(etch_layer = strcat((axlMapClassName "ETCH") "/" 
		cadr(parseString(layer_name "/"))
	    )) 
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "pins" "vias") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet)
	(axlAddSelectBox 
	    (shield_poly->bBox)
	) 
	foreach(pv 
	    (axlGetSelSet) 
	    (cur_pv_poly_list = (axlPolyFromDB pv ?layer etch_layer)) 
	    when(cur_pv_poly_list 
		(cur_pv_poly_list = (axlPolyExpand cur_pv_poly_list offset 
			'NONE
		    )) 
		(pad_poly_data = nconc(pad_poly_data cur_pv_poly_list))
	    )
	) 
	(axlClearSelSet) 
	if(pad_poly_data then 
	    foreach(pl 
		(axlPolyOperation shield_poly pad_poly_data 
		    'ANDNOT
		) 
		(result = (axlDBCreateShape pl t layer_name)) 
		when(result 
		    (shape_list = cons(car(result) shape_list))
		)
	    ) else 
	    (result = (axlDBCreateShape shield_poly t layer_name))
	    when(result 
		(shape_list = list(car(result)))
	    )
	) shape_list
    )
)
procedure(TBX_SILKSCREEN_Calculate_Splits(seg start_inside isec_list) 
    let((order_list loop_index from_xy to_xy split_data
	    okay_circle debug_radius
	) 
	case((seg->objType) 
	    ("line" 
		(order_list = TBX_GEOM_Order_Points_on_Line(isec_list 
			car((seg->startEnd)) 
			cadr((seg->startEnd)) t
		    )) 
		when((boundp('tbxSilkscreenIsecOrderDebug) && order_list) 
		    (debug_radius = (axlMKSConvert "0.5 MM" 
			    car((axlDBGetDesignUnits))
			)) 
		    funcall((tbx_silkscreen_global->debugPoints) order_list debug_radius 1)
		) 
		(loop_index = 0) 
		when(start_inside 
		    (loop_index = 1)
		)
		(from_xy = nth(loop_index order_list)) 
		(to_xy = nth((loop_index + 1) order_list)) 
		while((from_xy && to_xy) 
		    (split_data = cons(list(nil 
				'objType "line" 
				'startEnd 
				list(from_xy to_xy)
				'width 
				(seg->width)
			    ) split_data
			)) 
		    (loop_index = (loop_index + 2)) 
		    (from_xy = nth(loop_index order_list)) 
		    (to_xy = nth((loop_index + 1) order_list))
		) 
		(split_data = reverse(split_data))
	    ) 
	    ("arc" 
		(order_list = TBX_GEOM_Order_Points_on_Arc(isec_list 
			car((seg->startEnd)) 
			cadr((seg->startEnd)) 
			(seg->xy) 
			(seg->isClockwise)
			t
		    )) 
		when((boundp('tbxSilkscreenIsecOrderDebug) && order_list) 
		    (debug_radius = (axlMKSConvert "0.5 MM" 
			    car((axlDBGetDesignUnits))
			)) 
		    funcall((tbx_silkscreen_global->debugPoints) order_list debug_radius 1)
		) 
		(loop_index = 0) 
		when(start_inside 
		    (loop_index = 1)
		)
		(from_xy = nth(loop_index order_list)) 
		(to_xy = nth((loop_index + 1) order_list)) 
		while((from_xy && to_xy) 
		    (okay_circle = nil) 
		    when(((axlGeo2Str from_xy) == 
			    (axlGeo2Str to_xy)) 
			(okay_circle = t)
		    ) 
		    (split_data = cons(list(nil 
				'objType "arc" 
				'startEnd 
				list(from_xy to_xy)
				'width 
				(seg->width) 
				'xy 
				(seg->xy) 
				'radius
				(axlDistance 
				    (seg->xy) from_xy
				) 
				'isClockwise 
				(seg->isClockwise) 
				'isCircle okay_circle
			    ) split_data
			)) 
		    (loop_index = (loop_index + 2))
		    (from_xy = nth(loop_index order_list)) 
		    (to_xy = nth((loop_index + 1) order_list))
		)
	    )
	) split_data
    )
)
procedure(TBX_SILKSCREEN_Callback(form_handle) 
    let((orgvis cfg_file cfg) 
	case((form_handle->curField) 
	    ("specifySourceData" 
		((tbx_silkscreen_global->source)->selected = TBX_FORM_Cross_Select(((tbx_silkscreen_global->source)->available) 
			((tbx_silkscreen_global->source)->selected) 
			(tbx_silkscreen_global->app)
		    ))
	    ) 
	    ("specifyObstacleData" 
		((tbx_silkscreen_global->obstacle)->selected = TBX_FORM_Cross_Select(((tbx_silkscreen_global->obstacle)->available) 
			((tbx_silkscreen_global->obstacle)->selected) 
			(tbx_silkscreen_global->app)
		    ))
	    ) 
	    ("ignoreBlocksHelp" 
		(axlUIConfirm 
		    ((tbx_silkscreen_global->app)->blocksHelpMsg)
		)
	    ) 
	    ("toggleHelp" 
		(axlUIConfirm 
		    ((tbx_silkscreen_global->app)->toggleHelpMsg)
		)
	    )
	    ("allOff" 
		TBX_SILKSCREEN_Toggle_Visibility("off")
	    ) 
	    ("limitView" 
		TBX_SILKSCREEN_Toggle_Visibility("limit")
	    ) 
	    ("sourceToggleTop" 
		TBX_SILKSCREEN_Toggle_Visibility("source_top")
	    ) 
	    ("sourceToggleBottom" 
		TBX_SILKSCREEN_Toggle_Visibility("source_bottom")
	    ) 
	    ("obstacleToggleTop" 
		TBX_SILKSCREEN_Toggle_Visibility("obstacle_top")
	    )
	    ("obstacleToggleBottom" 
		TBX_SILKSCREEN_Toggle_Visibility("obstacle_bottom")
	    ) 
	    ("resultToggleTop" 
		TBX_SILKSCREEN_Toggle_Visibility("result_top")
	    ) 
	    ("resultToggleBottom" 
		TBX_SILKSCREEN_Toggle_Visibility("result_bottom")
	    ) 
	    ("drcToggle" 
		TBX_SILKSCREEN_Toggle_Visibility("drc")
	    ) 
	    ("clearData" 
		when((axlOKToProceed) 
		    TBX_SILKSCREEN_Clear_Result()
		)
	    )
	    ("done" 
		TBX_SILKSCREEN_Save_Config(form_handle nil) 
		(axlFormClose form_handle) 
		(axlVisibleUpdate t) 
		unless(boundp('tbxSilkscreenNoCleanup) 
		    TBX_SILKSCREEN_Cleanup()
		)
	    ) 
	    ("run" 
		when((axlOKToProceed) 
		    (orgvis = (axlVisibleGet)) 
		    TBX_SILKSCREEN_Run(form_handle) 
		    (axlVisibleSet orgvis) 
		    (axlVisibleUpdate t)
		)
	    ) 
	    ("drc" 
		when((axlOKToProceed) 
		    TBX_SILKSCREEN_Clear_DRC() 
		    when(((form_handle->curValue) != "drcClear") 
			(orgvis = (axlVisibleGet)) 
			TBX_SILKSCREEN_Run(form_handle 
			    (form_handle->curValue)
			) 
			(axlVisibleSet orgvis) 
			(axlVisibleLayer "DRC ERROR CLASS/ALL" t)
			(axlVisibleUpdate t)
		    )
		)
	    ) 
	    ("config" 
		case((form_handle->curValue) 
		    ("saveTo" 
			(cfg_file = (axlDMFileBrowse "ALLEGRO_TEXT" t)) 
			when(cfg_file 
			    TBX_SILKSCREEN_Save_Config(form_handle cfg_file)
			)
		    ) 
		    ("loadFrom" 
			(cfg_file = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
			when((cfg_file && isFile(cfg_file)) 
			    (cfg = TBX_SILKSCREEN_Get_Config(cfg_file)) 
			    (axlFormSetField form_handle "silkText" 
				(cfg->silkText)
			    ) 
			    (axlFormSetField form_handle "silkLines" 
				(cfg->silkLines)
			    ) 
			    (axlFormSetField form_handle "silkShapes" 
				(cfg->silkShapes)
			    )
			    (axlFormSetField form_handle "processSide" 
				(cfg->processSide)
			    ) 
			    (axlFormSetField form_handle "minLineLength" 
				(cfg->minLineLength)
			    ) 
			    (axlFormSetField form_handle "minClearance" 
				(cfg->minClearance)
			    ) 
			    (axlFormSetField form_handle "undefLineWidth" 
				(cfg->undefLineWidth)
			    ) 
			    (axlFormSetField form_handle "ignoreBlocks" 
				(cfg->ignoreBlocks)
			    )
			    ((tbx_silkscreen_global->source)->selected = (cfg->sourceLayers)) 
			    ((tbx_silkscreen_global->obstacle)->selected = (cfg->obstacleLayers))
			)
		    )
		)
	    ) 
	    ("myHelp" 
		TBX_HELP_Launch("silkscreen")
	    )
	    (t t)
	)
    )
)
procedure(TBX_SILKSCREEN_Check(silk_data check_layers param) 
    let((offset selection_window obstacle_data class_name check_enable_filter
	    pin_layers via_layers other_layers path_list first_obj
	    result drc_info oversize xy second_obj
	) 
	(offset = (param->minClearance)) 
	(check_enable_filter = list("noall" "boundary_shapes" "shapes" "lines" "clines"
		"text"
	    )) 
	foreach(lyr check_layers 
	    (class_name = car(parseString(lyr "/"))) 
	    case(class_name 
		("PIN" 
		    (check_enable_filter = append1(check_enable_filter "pins")) 
		    (pin_layers = cons(lyr pin_layers))
		) 
		("VIA CLASS" 
		    (check_enable_filter = append1(check_enable_filter "vias")) 
		    (via_layers = cons(lyr via_layers))
		) 
		(t 
		    (other_layers = cons(lyr other_layers))
		)
	    )
	) 
	foreach(entry silk_data 
	    (selection_window = car(entry)) 
	    (path_list = cadr(entry)) 
	    (first_obj = caddr(entry))
	    (selection_window = (bBoxAdd selection_window 
		    list(((- offset):(- offset)) 
			(offset:offset)
		    )
		)) 
	    when(boundp('tbxSilkscreenSelectionWindowDebug) 
		(axlDBCreateRectangle selection_window nil "DRAWING FORMAT/OUTLINE")
	    ) 
	    (obstacle_data = TBX_SILKSCREEN_Get_Obstacles(selection_window check_enable_filter other_layers pin_layers via_layers)) 
	    (obstacle_data = setof(x obstacle_data 
		    (cadr(x) != first_obj)
		)) 
	    foreach(path path_list 
		(drc_info = nil) 
		if(((first_obj->objType) == "text") then 
		    (oversize = offset) 
		    (result = TBX_SILKSCREEN_Check_Overlap(path obstacle_data oversize)) 
		    when(result 
			(drc_info = nconc(drc_info result))
		    )
		    else 
		    foreach(seg 
			(path->segments) 
			(oversize = offset) 
			(result = TBX_SILKSCREEN_Check_Overlap(seg obstacle_data oversize)) 
			when(result 
			    (drc_info = nconc(drc_info result))
			)
		    )
		) 
		when(drc_info 
		    foreach(drc drc_info 
			(xy = car(drc)) 
			(second_obj = cadr(drc)) 
			TBX_SILKSCREEN_Create_DRC_Marker(xy 
			    (param->minClearance) first_obj second_obj
			)
		    )
		)
	    )
	)
	(axlVisibleUpdate t)
    )
)
procedure(TBX_SILKSCREEN_Check_Overlap(pseg obs_data oversize) 
    let((source_poly drc_list result drc_xy obs_dbid
	    obs_poly_set
	) 
	(source_poly = car((axlPolyFromDB pseg ?line2poly t ?endCapType
		    'ROUND
		)
	    )) 
	(source_poly = car((axlPolyExpand source_poly oversize 
		    'NONE
		)
	    )) 
	foreach(entry obs_data 
	    (obs_poly_set = car(entry)) 
	    (obs_dbid = cadr(entry)) 
	    foreach(pl obs_poly_set 
		(result = (axlPolyOperation source_poly pl 
			'AND
		    )) 
		when(car(result) 
		    foreach(apl result 
			(drc_xy = TBX_UTIL_Get_Box_Center((apl->bBox))) 
			(drc_list = cons(list(drc_xy obs_dbid) drc_list))
		    )
		)
	    )
	) drc_list
    )
)
procedure(TBX_SILKSCREEN_Cleanup() 
    (axlVisibleLayer 
	((tbx_silkscreen_global->tmpLayer)->silk) t
    ) 
    (axlVisibleLayer 
	((tbx_silkscreen_global->tmpLayer)->obstacle) t
    ) 
    (axlDeleteByLayer 
	((tbx_silkscreen_global->tmpLayer)->silk)
    ) 
    (axlDeleteByLayer 
	((tbx_silkscreen_global->tmpLayer)->obstacle)
    )
    (axlDeleteObject 
	(axlLayerGet 
	    ((tbx_silkscreen_global->tmpLayer)->obstacle)
	)
    ) 
    (axlDeleteObject 
	(axlLayerGet 
	    ((tbx_silkscreen_global->tmpLayer)->silk)
	)
    ) 
    (axlVisibleUpdate t)
)
procedure(TBX_SILKSCREEN_Clear_DRC() 
    let((drc_list) 
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "drcs") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	(drc_list = setof(x 
		(axlGetSelSet) 
		(((x->name) == "Externally Determined Violation") && ((x->source) == "SILKSCREEN"))
	    ))
	when(drc_list 
	    (axlDeleteObject drc_list)
	) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_SILKSCREEN_Clear_Result() 
    let((top_layer bottom_layer) 
	(top_layer = strcat((tbx_silkscreen_global->destination) "_TOP")) 
	(bottom_layer = strcat((tbx_silkscreen_global->destination) "_BOTTOM")) 
	foreach(lyr 
	    list(top_layer bottom_layer) 
	    when((axlIsLayer lyr) 
		(axlVisibleLayer lyr t)
	    )
	) 
	(axlVisibleUpdate nil)
	(axlDeleteByLayer 
	    list(top_layer bottom_layer)
	) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_SILKSCREEN_Create_DRC_Marker(drc_xy req_value first_obj second_obj) 
    let((obj_list) 
	(obj_list = list(first_obj)) 
	when(second_obj 
	    (obj_list = list(first_obj second_obj))
	) 
	(axlDBCreateExternalDRC 
	    list("SILKSCREEN" 
		sprintf(nil "%f" req_value)
	    ) drc_xy "DRC ERROR CLASS/ALL" obj_list
	)
    )
)
procedure(TBX_SILKSCREEN_Create_Obstacle_Shape(pl tmp_layer) 
    let((result shape) 
	(result = (axlDBCreateShape pl t tmp_layer)) 
	when(result 
	    (shape = car(result))
	) shape
    )
)
procedure(TBX_SILKSCREEN_Generate_Silk_Data(seg_list dest_layer) 
    let((rpath prev_seg appendPath cur_seg) 
	(appendPath = lambda((rp sg) 
		let((rpn) 
		    case((sg->objType) 
			("line" 
			    (rpn = (axlPathLine rp 
				    (sg->width) 
				    cadr((sg->startEnd))
				))
			) 
			("arc" 
			    (rpn = (axlPathArcCenter rp 
				    (sg->width) 
				    cadr((sg->startEnd)) 
				    (sg->isClockwise)
				    (sg->xy)
				))
			)
		    ) rpn
		)
	    )) 
	foreach(seg seg_list 
	    (cur_seg = seg) 
	    if(prev_seg then 
		when(((axlGeo2Str 
			    cadr((prev_seg->startEnd))
			) != (axlGeo2Str 
			    car((seg->startEnd))
			)) 
		    (axlDBCreatePath rpath dest_layer) 
		    (rpath = (axlPathStart 
			    list(car((seg->startEnd))) 0.0
			))
		) else 
		(rpath = (axlPathStart 
			list(car((seg->startEnd))) 0.0
		    ))
	    ) 
	    (rpath = funcall(appendPath rpath seg))
	    (prev_seg = seg)
	) 
	when((rpath && cur_seg) 
	    (rpath = funcall(appendPath rpath cur_seg)) 
	    (axlDBCreatePath rpath dest_layer)
	) t
    )
)
procedure(TBX_SILKSCREEN_Get_Config(file_name) 
    let((cfg_file cfg_dpl design_units min_line_length min_clearance
	    undef_line_width source_layers obstacle_layers att data
	) 
	(cfg_dpl = ncons(nil)) 
	(design_units = lowerCase(car((axlDBGetDesignUnits)))) 
	if(((design_units == "microns") || (design_units == "millimeters") || (design_units == "centimeters")) then 
	    (min_line_length = (axlMKSConvert "0.2 MM" design_units)) 
	    (min_clearance = (axlMKSConvert "0.2 MM" design_units)) 
	    (undef_line_width = (axlMKSConvert "0.1 MM" design_units))
	    else 
	    (min_line_length = (axlMKSConvert "8.0 MILS" design_units)) 
	    (min_clearance = (axlMKSConvert "8.0 MILS" design_units)) 
	    (undef_line_width = (axlMKSConvert "4.0 MILS" design_units))
	) 
	(source_layers = list("PACKAGE GEOMETRY/SILKSCREEN" "REF DES/SILKSCREEN" "BOARD GEOMETRY/SILKSCREEN"))
	(obstacle_layers = list("VIA CLASS/SOLDERMASK" "PIN/SOLDERMASK" "PACKAGE GEOMETRY/SOLDERMASK" "MANUFACTURING/LSM_KEEPOUT")) 
	(cfg_dpl->silkText = t) 
	(cfg_dpl->silkLines = t) 
	(cfg_dpl->silkShapes = nil) 
	(cfg_dpl->sourceLayers = source_layers)
	(cfg_dpl->obstacleLayers = obstacle_layers) 
	(cfg_dpl->processSide = "both") 
	(cfg_dpl->minLineLength = min_line_length) 
	(cfg_dpl->minClearance = min_clearance) 
	(cfg_dpl->undefLineWidth = undef_line_width)
	(cfg_dpl->ignoreBlocks = "") 
	if(file_name then 
	    (data = TBX_UTIL_File_Lineread(file_name)) else 
	    (att = (axlGetAttachment "tbx_silkscreen" 
		    'string
		))
	    if(att then 
		printf("Reading configuration from database.\n") 
		(data = car(linereadstring((att->data)))) else
		(cfg_file = car(TBX_UTIL_Search_Config("silkscreen.ini" nil nil ?includeWorkDir t))) 
		when(cfg_file 
		    printf("Reading defaults from %L\n" cfg_file) 
		    (data = TBX_UTIL_File_Lineread(cfg_file))
		)
	    )
	) 
	foreach(entry data 
	    cond((memq(car(entry) 
			list('minLineLength 
			    'minClearance 
			    'undefLineWidth
			)
		    ) 
		    putprop(cfg_dpl 
			(axlMKSConvert 
			    cadr(entry) design_units
			) 
			car(entry)
		    )
		) 
		(memq(car(entry) 
			list('sourceLayers 
			    'obstacleLayers
			)
		    ) 
		    putprop(cfg_dpl 
			cdr(entry) 
			car(entry)
		    )
		) 
		(t 
		    putprop(cfg_dpl 
			cadr(entry) 
			car(entry)
		    )
		)
	    )
	) cfg_dpl
    )
)
procedure(TBX_SILKSCREEN_Get_Layer_Pairs(mode) 
    let((class_list tmp_data base_name layer_info layer1
	    layer2 ident_str
	) 
	case(mode 
	    ("obstacle" 
		(class_list = list("ETCH" "BOUNDARY" "PIN" "VIA CLASS" "BOARD GEOMETRY"
			"PACKAGE GEOMETRY" "MANUFACTURING"
		    ))
	    ) 
	    ("source" 
		(class_list = list("BOARD GEOMETRY" "PACKAGE GEOMETRY" "REF DES" "COMPONENT VALUE" "DEVICE TYPE"
			"TOLERANCE" "USER PART NUMBER"
		    ))
	    )
	) 
	foreach(cls class_list 
	    (tmp_data = makeTable("tmp_data_table" nil)) 
	    foreach(scls 
		((axlGetParam 
			strcat("paramLayerGroup:" cls)
		    )->groupMembers) 
		when((rexMatchp("[_]*TOP$" scls) || 
			rexMatchp("[_]*BOTTOM$" scls)) 
		    (base_name = scls) 
		    rexCompile("[_]*TOP$") 
		    (base_name = rexReplace(base_name "" 0)) 
		    rexCompile("[_]*BOTTOM$")
		    (base_name = rexReplace(base_name "" 0)) 
		    (tmp_data[base_name] = cons(scls 
			    tmp_data[base_name]
			))
		)
	    ) 
	    foreach(bn tmp_data 
		when((length(tmp_data[bn]) == 2) 
		    (layer1 = strcat(cls "/" 
			    car(tmp_data[bn])
			)) 
		    (layer2 = strcat(cls "/" 
			    cadr(tmp_data[bn])
			)) 
		    if((strlen(bn) > 0) then 
			(ident_str = strcat(cls "/" bn)) else 
			(ident_str = cls)
		    ) 
		    (layer_info = cons(list(ident_str 
				reverse(sort(list(layer1 layer2) nil))
			    ) layer_info
			))
		)
	    )
	) 
	(layer_info = sortcar(layer_info nil)) layer_info
    )
)
procedure(TBX_SILKSCREEN_Get_Obstacles(selection_window enable_filter other_layers pin_layers via_layers) 
    let((path_list shape_list pin_list via_list poly_data
	    text_list tmp_path_list
	) 
	(axlVisibleDesign nil) 
	foreach(lyr other_layers 
	    (axlVisibleLayer lyr t)
	) 
	foreach(lyr pin_layers 
	    (axlVisibleLayer lyr t)
	) 
	foreach(lyr via_layers 
	    (axlVisibleLayer lyr t)
	)
	(axlVisibleUpdate nil) 
	(axlSetFindFilter ?enabled enable_filter ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlSingleSelectBox selection_window) 
	(text_list = setof(x 
		(axlGetSelSet) 
		(((x->objType) == "text") && member((x->layer) other_layers))
	    ))
	(path_list = setof(x 
		(axlGetSelSet) 
		(((x->objType) == "path") && member((x->layer) other_layers))
	    )) 
	(shape_list = setof(x 
		(axlGetSelSet) 
		((((x->objType) == "shape") || ((x->objType) == "polygon")) && member((x->layer) other_layers))
	    )) 
	(pin_list = setof(x 
		(axlGetSelSet) 
		((x->objType) == "pin")
	    )) 
	(via_list = setof(x 
		(axlGetSelSet) 
		((x->objType) == "via")
	    )) 
	(poly_data = tconc(nil nil))
	foreach(rp path_list 
	    tconc(poly_data 
		list((axlPolyFromDB rp ?line2poly t) rp)
	    )
	) 
	foreach(shp shape_list 
	    tconc(poly_data 
		list((axlPolyFromDB shp) shp)
	    )
	) 
	foreach(p pin_list 
	    foreach(lyr pin_layers 
		tconc(poly_data 
		    list((axlPolyFromDB p ?layer lyr ?padType
			    'REGULAR
			) p
		    )
		)
	    )
	) 
	foreach(v via_list 
	    foreach(lyr via_layers 
		tconc(poly_data 
		    list((axlPolyFromDB v ?layer lyr ?padType
			    'REGULAR
			) v
		    )
		)
	    )
	) 
	foreach(txt text_list 
	    (tmp_path_list = mapcan(lambda((x) x) 
		    (axlText2Lines txt)
		)) 
	    foreach(rp tmp_path_list 
		tconc(poly_data 
		    list((axlPolyFromDB rp ?endCapType 
			    'ROUND ?line2poly
			    t
			) txt
		    )
		)
	    )
	)
	(axlClearSelSet) 
	(poly_data = cdar(poly_data)) poly_data
    )
)
procedure(TBX_SILKSCREEN_Get_Segment_Intersections(seg shape) 
    let((result isec_list) 
	foreach(bseg 
	    (shape->segments) 
	    (result = TBX_GEOM_Get_Intersection(seg bseg t t)) 
	    when(result 
		(isec_list = nconc(isec_list result))
	    )
	) 
	foreach(vd 
	    (shape->voids) 
	    foreach(vseg 
		(vd->segments) 
		(result = TBX_GEOM_Get_Intersection(seg vseg t t)) 
		when(result 
		    (isec_list = nconc(isec_list result))
		)
	    )
	) isec_list
    )
)
procedure(TBX_SILKSCREEN_Get_Silk_Objects(source_layers param) 
    let((enable_filter line_data text_data shape_data text_param
	    silk_data tmp_list rpath_new selection_set result
	    rpath sel_box dbid_list
	) 
	(enable_filter = list("noall" "boundary_shapes" "shapes" "lines" "text")) 
	(axlVisibleDesign nil) 
	foreach(lyr source_layers 
	    (axlVisibleLayer lyr t)
	) 
	(axlVisibleUpdate nil)
	(axlSetFindFilter ?enabled enable_filter ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	(selection_set = (axlGetSelSet)) 
	(text_data = setof(x selection_set 
		(((x->objType) == "text") && member((x->layer) source_layers))
	    ))
	(line_data = setof(x selection_set 
		(((x->objType) == "path") && member((x->layer) source_layers))
	    )) 
	(shape_data = setof(x selection_set 
		((((x->objType) == "shape") || ((x->objType) == "polygon")) && member((x->layer) source_layers))
	    )) 
	(axlClearSelSet) 
	(axlVisibleUpdate nil) 
	(text_data = setof(x text_data 
		!member((x->textBlock) 
			(param->ignoreBlocks)
		    )
	    ))
	(silk_data = tconc(nil nil)) 
	foreach(pth line_data 
	    (rpath = (axlDB2Path pth)) 
	    when(setof(x 
		    (pth->segments) 
		    ((x->width) == 0.0)
		) 
		(rpath = car(TBX_DBCORE_Copy_Rpath(rpath 
			    (param->undefLineWidth) nil
			)
		    ))
	    ) 
	    (sel_box = TBX_UTIL_Get_Extents(list(rpath)))
	    (result = (axlDBCreatePath rpath 
		    (param->tmpLayerSilk)
		)) 
	    tconc(silk_data 
		list(sel_box 
		    car(result) pth
		)
	    )
	) 
	foreach(txt text_data 
	    (text_param = (axlGetParam 
		    strcat("paramTextBlock:" 
			(txt->textBlock)
		    )
		)) 
	    foreach(rpset 
		(axlText2Lines txt) 
		(tmp_list = nil) 
		(dbid_list = nil) 
		(sel_box = TBX_UTIL_Get_Extents(rpset))
		if(((text_param->photoWidth) == 0.0) then 
		    foreach(rp rpset 
			(rpath_new = car(TBX_DBCORE_Copy_Rpath(rp 
				    (param->undefLineWidth) nil
				)
			    )) 
			(tmp_list = cons(rpath_new tmp_list))
		    ) else 
		    (tmp_list = rpset)
		) 
		foreach(rp tmp_list 
		    (result = (axlDBCreatePath rp 
			    (param->tmpLayerSilk)
			)) 
		    when(result 
			(dbid_list = nconc(car(result) dbid_list))
		    )
		) 
		tconc(silk_data 
		    list(sel_box dbid_list txt)
		)
	    )
	) 
	foreach(shp shape_data 
	    (rpath = (axlDB2Path shp)) 
	    (rpath_new = car(TBX_DBCORE_Copy_Rpath(rpath 
			(param->undefLineWidth) nil
		    )
		)) 
	    (result = (axlDBCreatePath rpath_new 
		    (param->tmpLayerSilk)
		))
	    tconc(silk_data 
		list((shp->bBox) 
		    car(result) shp
		)
	    )
	) 
	(silk_data = cdar(silk_data))
	silk_data
    )
)
procedure(TBX_SILKSCREEN_Init() 
    let((layerPair name pair src_available obs_available
	    selector_msg blocks_help_msg toggle_help_msg app_dpl debugPoints
	    tmp_layer_dpl destination
	) 
	(destination = strcat((axlMapClassName "MANUFACTURING") "/AUTOSILK")) 
	(debugPoints = lambda((pt_list radius txt_id) 
		let((txt_orient) 
		    (txt_orient = (make_axlTextOrientation ?textBlock "1" ?rotation 0.0
			    ?mirrored nil ?justify "left"
			)) 
		    foreach(pt pt_list 
			when(txt_id 
			    (axlDBCreateText 
				sprintf(nil "%d" 
				    txt_id++
				) pt txt_orient "DRAWING FORMAT/OUTLINE"
				nil
			    )
			) 
			when(radius 
			    (axlDBCreateCircle 
				list(pt radius) 0.0 "DRAWING FORMAT/OUTLINE"
			    )
			)
		    )
		)
	    )) 
	if(axlGetVariable("FLW_DEBUG") then 
	    defvar(tbxSilkscreenSelectionWindowDebug t) 
	    defvar(tbxSilkscreenIsecDebug t) 
	    defvar(tbxSilkscreenIsecOrderDebug t)
	    defvar(tbxSilkscreenObstacleDataDebug t) 
	    defvar(tbxSilkscreenSourceDataDebug t) 
	    defvar(tbxSilkscreenNoCleanup t) 
	    defvar(tbxGeomIsecDebug t) else
	    (tbxSilkscreenSelectionWindowDebug = 'unbound) 
	    (tbxSilkscreenIsecDebug = 'unbound) 
	    (tbxSilkscreenIsecOrderDebug = 'unbound) 
	    (tbxSilkscreenObstacleDataDebug = 'unbound) 
	    (tbxSilkscreenSourceDataDebug = 'unbound)
	    (tbxSilkscreenNoCleanup = 'unbound) 
	    (tbxGeomIsecDebug = 'unbound)
	) 
	(layerPair = makeTable("layer_pair_table" nil))
	foreach(entry 
	    TBX_SILKSCREEN_Get_Layer_Pairs("source") 
	    (name = car(entry)) 
	    (pair = cadr(entry)) 
	    (src_available = cons(name src_available))
	    (layerPair[name] = pair)
	) 
	foreach(entry 
	    TBX_SILKSCREEN_Get_Layer_Pairs("obstacle") 
	    (name = car(entry)) 
	    (pair = cadr(entry)) 
	    (obs_available = cons(name obs_available))
	    (layerPair[name] = pair)
	) 
	(src_available = sort(src_available nil)) 
	(obs_available = sort(obs_available nil)) 
	unless(boundp('tbx_silkscreen_global) 
	    iliDefstruct('defstruct(tbx_silkscreen_global_struct app source obstacle layerPair
			debugPoints tmpLayer destination
		    )
	    ) 
	    defvar(tbx_silkscreen_global nil)
	)
	(tmp_layer_dpl = list(nil 
		'silk "MANUFACTURING/TBX_TMP_SLK" 
		'obstacle "MANUFACTURING/TBX_TMP_KPO"
	    )) 
	unless((axlIsLayer 
		(tmp_layer_dpl->silk)
	    ) 
	    (axlLayerCreateNonConductor 
		(tmp_layer_dpl->silk)
	    )
	) 
	unless((axlIsLayer 
		(tmp_layer_dpl->obstacle)
	    ) 
	    (axlLayerCreateNonConductor 
		(tmp_layer_dpl->obstacle)
	    )
	) 
	(selector_msg = "Note: Only TOP/BOTTOM layer pairs are listed. For example PACKAGE GEOMETRY/SOLDERMASK refers to PACKAGE GEOMETRY/SOLDERMASK_TOP and PACKAGE GEOMETRY/SOLDERMASK_BOTTOM,") 
	(selector_msg = sprintf(nil "%s PIN refers to PIN/TOP and PIN/BOTTOM." selector_msg))
	(blocks_help_msg = "") 
	(blocks_help_msg = strcat(blocks_help_msg "Use white space to separate individual blocks from each other.\n")) 
	(blocks_help_msg = strcat(blocks_help_msg "Use dash to specify a block range.\n")) 
	(blocks_help_msg = strcat(blocks_help_msg "Blocks can be specified in arbitrary order.\n")) 
	(blocks_help_msg = strcat(blocks_help_msg "\n"))
	(blocks_help_msg = strcat(blocks_help_msg "Example: \"1 2 3 4-10 15 30-35\"")) 
	(toggle_help_msg = "") 
	(toggle_help_msg = strcat(toggle_help_msg "Use T, B and Drc buttons to toggle visibility. T refers to TOP while B refers to BOTTOM side.")) 
	(app_dpl = list(nil 
		'selectorMsg selector_msg 
		'selectorDummyEvent nil
		'blocksHelpMsg blocks_help_msg 
		'toggleHelpMsg toggle_help_msg
	    )) 
	if(!tbx_silkscreen_global then 
	    (tbx_silkscreen_global = (make_tbx_silkscreen_global_struct ?destination destination ?tmpLayer tmp_layer_dpl
		    ?app app_dpl ?layerPair layerPair ?source
		    list(nil 
			'available src_available
		    ) ?obstacle 
		    list(nil 
			'available obs_available
		    ) ?debugPoints debugPoints
		)) else 
	    (tbx_silkscreen_global->destination = destination)
	    (tbx_silkscreen_global->tmpLayer = tmp_layer_dpl) 
	    (tbx_silkscreen_global->app = app_dpl) 
	    (tbx_silkscreen_global->layerPair = layerPair) 
	    (tbx_silkscreen_global->source = list(nil 
		    'available src_available
		)) 
	    (tbx_silkscreen_global->obstacle = list(nil 
		    'available obs_available
		))
	    (tbx_silkscreen_global->debugPoints = debugPoints)
	)
    )
)
procedure((TBX_SILKSCREEN_Main \@optional arg) 
    let((lic_check_result FORM_FILE fid VERSION_STR FC_FEATURE
	    FC_VERSION SUB_VERSION info_file port ok_start_app
	    cfg design_precision
	) 
	(FC_FEATURE = "SILKSCREEN") 
	(FC_VERSION = "17.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Silkscreen %s (C)2017" FC_VERSION))
	(ok_start_app = t) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./silkscreen_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Silkscreen information:\n") 
		fprintf(port "===============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "  reset    : Deletes internal configuration from database\n") 
		fprintf(port "\n") 
		close(port)
		(axlUIViewFileCreate info_file "Autosilk: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "reset")) 
		if((axlGetAttachment "tbx_silkscreen" 
			'string
		    ) then 
		    when((axlUIYesNo "Delete configuration from database?" nil 
			    'no
			) 
			(axlDeleteAttachment "tbx_silkscreen")
		    ) else 
		    printf("No configuration found in database.\n")
		) 
		(ok_start_app = nil)
	    ) 
	    (t 
		(ok_start_app = t)
	    )
	) 
	when(ok_start_app 
	    (lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
	    when(lic_check_result 
		TBX_SILKSCREEN_Init() 
		unless(boundp('tbxSilkscreenMain) 
		    defvar(tbxSilkscreenMain nil)
		) 
		(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "silkscreen_main")) 
		(fid = (axlFormCreate 
			'tbxSilkscreenMain FORM_FILE 
			'(e outer) 
			'TBX_SILKSCREEN_Callback
			t nil
		    ))
		((tbx_silkscreen_global->app)->formid = fid) 
		((tbx_silkscreen_global->app)->licCheck = lic_check_result) 
		((tbx_silkscreen_global->app)->version = VERSION_STR) 
		((tbx_silkscreen_global->app)->name = lowerCase(FC_FEATURE)) 
		TBX_FORM_Init_Header(fid "Licensed for: " lic_check_result VERSION_STR)
		(cfg = TBX_SILKSCREEN_Get_Config(nil)) 
		(axlFormSetField fid "silkText" 
		    (cfg->silkText)
		) 
		(axlFormSetField fid "silkLines" 
		    (cfg->silkLines)
		) 
		(axlFormSetField fid "silkShapes" 
		    (cfg->silkShapes)
		) 
		(axlFormSetField fid "processSide" 
		    (cfg->processSide)
		)
		(axlFormSetField fid "minLineLength" 
		    (cfg->minLineLength)
		) 
		(axlFormSetField fid "minClearance" 
		    (cfg->minClearance)
		) 
		(axlFormSetField fid "undefLineWidth" 
		    (cfg->undefLineWidth)
		) 
		(axlFormSetField fid "ignoreBlocks" 
		    (cfg->ignoreBlocks)
		) 
		(design_precision = cadr((axlDBGetDesignUnits)))
		(axlFormSetDecimal fid "minLineLength" design_precision) 
		(axlFormSetDecimal fid "undefLineWidth" design_precision) 
		(axlFormSetDecimal fid "ignoreBlocks" design_precision) 
		((tbx_silkscreen_global->source)->selected = (cfg->sourceLayers)) 
		((tbx_silkscreen_global->obstacle)->selected = (cfg->obstacleLayers))
		(axlFormDisplay fid) 
		(axlVisibleUpdate t) 
		TBX_FORM_Delete(lic_check_result FORM_FILE)
	    )
	)
    )
)
procedure(TBX_SILKSCREEN_Parse_Block_Range(range_str) 
    let((arr tmp_list start end int_block_list
	    str_block_list
	) 
	rexCompile(" *- *") 
	(range_str = rexReplace(range_str "-" 0)) 
	rexCompile("  *") 
	(range_str = rexReplace(range_str " " 0))
	(range_str = (axlStringRemoveSpaces range_str)) 
	foreach(spec 
	    parseString(range_str " ") 
	    cond((rexMatchp("-" spec) 
		    (arr = parseString(spec "-")) 
		    if(((length(arr) == 2) && atoi(car(arr)) && atoi(cadr(arr))) then 
			(tmp_list = list(atoi(car(arr)) 
				atoi(cadr(arr))
			    )) 
			(tmp_list = sort(tmp_list 
				'lessp
			    )) 
			(start = car(tmp_list))
			(end = cadr(tmp_list)) 
			for(i start end 
			    unless(memq(i int_block_list) 
				(int_block_list = cons(i int_block_list))
			    )
			) else 
			printf("Warning: Ignoring invalid block specifier %L\n" spec)
		    )
		) 
		(atoi(spec) 
		    unless(memq(atoi(spec) int_block_list) 
			(int_block_list = cons(atoi(spec) int_block_list))
		    )
		) 
		(t 
		    printf("Warning: Ignoring invalid block specifier %L\n" spec)
		)
	    )
	) 
	(int_block_list = sort(int_block_list 
		'lessp
	    )) 
	(str_block_list = mapcar(lambda((x) 
		    sprintf(nil "%d" x)
		) int_block_list
	    )) str_block_list
    )
)
procedure(TBX_SILKSCREEN_Post_Process(destination_layer min_length) 
    let((too_small) 
	(axlVisibleDesign nil) 
	(axlVisibleLayer destination_layer t) 
	(axlVisibleUpdate t) 
	(axlSetFindFilter ?enabled 
	    list("noall" "lines") ?onButtons 
	    list("all")
	)
	(axlClearSelSet) 
	(axlAddSelectAll) 
	(too_small = setof(x 
		(axlGetSelSet) 
		((axlDBGetLength x) < min_length)
	    )) 
	when(too_small 
	    (axlDeleteObject too_small)
	) 
	(axlClearSelSet)
	(axlDBRefreshId nil) t
    )
)
procedure(TBX_SILKSCREEN_Process(silk_data obstacle_layers destination_layer param) 
    let((offset selection_window obstacle_data obstacle_polys oversize
	    class_name obs_enable_filter pin_layers via_layers other_layers
	    seg_data result
	) 
	(axlVisibleLayer destination_layer t) 
	(axlVisibleUpdate nil) 
	(axlDeleteByLayer destination_layer) 
	(offset = (param->minClearance))
	(obs_enable_filter = list("noall" "boundary_shapes" "shapes" "lines" "clines")) 
	foreach(lyr obstacle_layers 
	    (class_name = car(parseString(lyr "/"))) 
	    case(class_name 
		("PIN" 
		    (obs_enable_filter = append1(obs_enable_filter "pins")) 
		    (pin_layers = cons(lyr pin_layers))
		) 
		("VIA CLASS" 
		    (obs_enable_filter = append1(obs_enable_filter "vias")) 
		    (via_layers = cons(lyr via_layers))
		) 
		(t 
		    (other_layers = cons(lyr other_layers))
		)
	    )
	) 
	foreach(entry silk_data 
	    (selection_window = car(entry)) 
	    (selection_window = (bBoxAdd selection_window 
		    list(((- offset):(- offset)) 
			(offset:offset)
		    )
		)) 
	    when(boundp('tbxSilkscreenSelectionWindowDebug) 
		(axlDBCreateRectangle selection_window nil "DRAWING FORMAT/OUTLINE")
	    )
	    (obstacle_data = TBX_SILKSCREEN_Get_Obstacles(selection_window obs_enable_filter other_layers pin_layers via_layers)) 
	    (obstacle_polys = mapcan(lambda((x) 
			car(x)
		    ) obstacle_data
		)) 
	    foreach(path 
		cadr(entry) 
		(seg_data = nil) 
		foreach(seg 
		    (path->segments) 
		    (oversize = (offset + ((seg->width) / 2.0))) 
		    (result = TBX_SILKSCREEN_Process_Segment(seg obstacle_polys oversize param)) 
		    (seg_data = nconc(seg_data result))
		) 
		TBX_SILKSCREEN_Generate_Silk_Data(seg_data destination_layer)
	    )
	) 
	(axlVisibleUpdate t)
    )
)
procedure(TBX_SILKSCREEN_Process_Segment(segment poly_list oversize param) 
    let((isec_list obstacle_obj result start_inside end_inside
	    seg_list seg_list_new debug_radius
	) 
	(poly_list = (axlPolyExpand poly_list oversize 
		'NONE
	    )) 
	(seg_list = list(segment)) 
	(seg_list_new = seg_list) 
	foreach(pl poly_list 
	    (obstacle_obj = TBX_SILKSCREEN_Create_Obstacle_Shape(pl 
		    (param->tmpLayerObstacle)
		)) 
	    (seg_list_new = nil) 
	    foreach(seg seg_list 
		(start_inside = nil) 
		(end_inside = nil) 
		when((axlGeoPointInShape 
			car((seg->startEnd)) obstacle_obj
		    ) 
		    (start_inside = t)
		)
		when((axlGeoPointInShape 
			cadr((seg->startEnd)) obstacle_obj
		    ) 
		    (end_inside = t)
		) 
		(isec_list = TBX_SILKSCREEN_Get_Segment_Intersections(seg obstacle_obj)) 
		when((boundp('tbxSilkscreenIsecDebug) && isec_list) 
		    (debug_radius = (axlMKSConvert "0.4 MM" 
			    car((axlDBGetDesignUnits))
			)) 
		    funcall((tbx_silkscreen_global->debugPoints) isec_list debug_radius nil)
		) 
		cond((isec_list 
			(result = TBX_SILKSCREEN_Calculate_Splits(seg start_inside isec_list)) 
			when(result 
			    (seg_list_new = nconc(seg_list_new result))
			)
		    ) 
		    ((start_inside && end_inside) t) 
		    (t 
			(seg_list_new = cons(seg seg_list_new))
		    )
		)
	    )
	    (seg_list = seg_list_new) 
	    unless(boundp('tbxSilkscreenObstacleDataDebug) 
		(axlDeleteObject obstacle_obj)
	    )
	)
	seg_list_new
    )
)
procedure((TBX_SILKSCREEN_Run form_handle \@optional drc_mode) 
    let((min_line_length min_clearance undef_line_width str_block_list source_data
	    obstacle_data source_layers obstacle_layers side silk_text
	    silk_shapes silk_lines param destination_layer side_cfg
	    check_data_obs check_data_src silk_data
	) 
	(silk_text = (axlFormGetField form_handle "silkText")) 
	(silk_lines = (axlFormGetField form_handle "silkLines")) 
	(silk_shapes = (axlFormGetField form_handle "silkShapes")) 
	(source_data = ((tbx_silkscreen_global->source)->selected))
	(obstacle_data = ((tbx_silkscreen_global->obstacle)->selected)) 
	(side = (axlFormGetField form_handle "processSide")) 
	(min_line_length = (axlFormGetField form_handle "minLineLength")) 
	(min_clearance = (axlFormGetField form_handle "minClearance")) 
	(undef_line_width = (axlFormGetField form_handle "undefLineWidth"))
	(str_block_list = TBX_SILKSCREEN_Parse_Block_Range((axlFormGetField form_handle "ignoreBlocks"))) 
	(param = ncons(nil)) 
	(param->includeText = silk_text) 
	(param->includeLines = silk_lines) 
	(param->includeShapes = silk_shapes)
	(param->minLineLength = min_line_length) 
	(param->minClearance = min_clearance) 
	(param->undefLineWidth = undef_line_width) 
	(param->ignoreBlocks = str_block_list) 
	(param->tmpLayerSilk = ((tbx_silkscreen_global->tmpLayer)->silk))
	(param->tmpLayerObstacle = ((tbx_silkscreen_global->tmpLayer)->obstacle)) 
	when(((side == "top") || (side == "both")) 
	    foreach(bn source_data 
		if((tbx_silkscreen_global->layerPair)[bn] then 
		    (source_layers = cons(car((tbx_silkscreen_global->layerPair)[bn]) source_layers)) else 
		    printf("Warning: Layer %s_TOP does not exist\n" bn)
		)
	    ) 
	    foreach(bn obstacle_data 
		if((tbx_silkscreen_global->layerPair)[bn] then 
		    (obstacle_layers = cons(car((tbx_silkscreen_global->layerPair)[bn]) obstacle_layers)) else 
		    printf("Warning: Layer %s_TOP does not exist\n" bn)
		)
	    ) 
	    (source_layers = sort(source_layers nil)) 
	    (obstacle_layers = sort(obstacle_layers nil))
	    (destination_layer = strcat((tbx_silkscreen_global->destination) "_TOP")) 
	    (side_cfg = cons(list(source_layers obstacle_layers destination_layer) side_cfg))
	) 
	(source_layers = nil) 
	(obstacle_layers = nil) 
	when(((side == "bottom") || (side == "both")) 
	    foreach(bn source_data 
		if((tbx_silkscreen_global->layerPair)[bn] then 
		    (source_layers = cons(cadr((tbx_silkscreen_global->layerPair)[bn]) source_layers)) else 
		    printf("Warning: Layer %s_BOTTOM does not exist\n" bn)
		)
	    ) 
	    foreach(bn obstacle_data 
		if((tbx_silkscreen_global->layerPair)[bn] then 
		    (obstacle_layers = cons(cadr((tbx_silkscreen_global->layerPair)[bn]) obstacle_layers)) else 
		    printf("Warning: Layer %s_BOTTOM does not exist\n" bn)
		)
	    ) 
	    (source_layers = sort(source_layers nil)) 
	    (obstacle_layers = sort(obstacle_layers nil))
	    (destination_layer = strcat((tbx_silkscreen_global->destination) "_BOTTOM")) 
	    (side_cfg = cons(list(source_layers obstacle_layers destination_layer) side_cfg))
	)
	(side_cfg = reverse(side_cfg)) 
	foreach(entry side_cfg 
	    (source_layers = car(entry)) 
	    (obstacle_layers = cadr(entry)) 
	    (destination_layer = caddr(entry))
	    (check_data_obs = nil) 
	    (check_data_src = nil) 
	    (silk_data = TBX_SILKSCREEN_Get_Silk_Objects(source_layers param)) 
	    if(drc_mode then 
		case(drc_mode 
		    ("drcAll" 
			(check_data_obs = silk_data) 
			(check_data_src = setof(x silk_data 
				((caddr(x)->objType) == "text")
			    ))
		    ) 
		    ("drcTextObstacle" 
			(check_data_obs = setof(x silk_data 
				((caddr(x)->objType) == "text")
			    ))
		    ) 
		    ("drcLineObstacle" 
			(check_data_obs = setof(x silk_data 
				(((caddr(x)->objType) == "path") || ((caddr(x)->objType) == "shape") || ((caddr(x)->objType) == "polygon"))
			    ))
		    ) 
		    ("drcTextSource" 
			(check_data_src = setof(x silk_data 
				((caddr(x)->objType) == "text")
			    ))
		    )
		) 
		when(check_data_obs 
		    TBX_SILKSCREEN_Check(check_data_obs obstacle_layers param)
		) 
		when(check_data_src 
		    TBX_SILKSCREEN_Check(check_data_src source_layers param)
		)
		else 
		(axlVisibleLayer destination_layer t) 
		(axlVisibleUpdate nil) 
		(axlDeleteByLayer destination_layer) 
		(axlVisibleUpdate t)
		unless((param->includeText) 
		    (silk_data = setof(x silk_data 
			    ((caddr(x)->objType) != "text")
			))
		) 
		unless((param->includeLines) 
		    (silk_data = setof(x silk_data 
			    ((caddr(x)->objType) != "path")
			))
		) 
		unless((param->includeShapes) 
		    (silk_data = setof(x silk_data 
			    (((caddr(x)->objType) != "shape") && ((caddr(x)->objType) != "polygon"))
			))
		) 
		when(silk_data 
		    TBX_SILKSCREEN_Process(silk_data obstacle_layers destination_layer param)
		) 
		TBX_SILKSCREEN_Post_Process(destination_layer 
		    (param->minLineLength)
		)
	    )
	) t
    )
)
procedure(TBX_SILKSCREEN_Save_Config(form_handle file_name) 
    let((short_units cfg_data port data_str) 
	(short_units = TBX_UTIL_Get_Short_Units()) 
	(cfg_data = list(list('silkText 
		    (axlFormGetField form_handle "silkText")
		) 
		list('silkLines 
		    (axlFormGetField form_handle "silkLines")
		) 
		list('silkShapes 
		    (axlFormGetField form_handle "silkShapes")
		) 
		cons('sourceLayers 
		    ((tbx_silkscreen_global->source)->selected)
		) 
		cons('obstacleLayers 
		    ((tbx_silkscreen_global->obstacle)->selected)
		)
		list('processSide 
		    (axlFormGetField form_handle "processSide")
		) 
		list('minLineLength 
		    sprintf(nil "%L %s" 
			(axlFormGetField form_handle "minLineLength") short_units
		    )
		) 
		list('minClearance 
		    sprintf(nil "%L %s" 
			(axlFormGetField form_handle "minClearance") short_units
		    )
		) 
		list('undefLineWidth 
		    sprintf(nil "%L %s" 
			(axlFormGetField form_handle "undefLineWidth") short_units
		    )
		) 
		list('ignoreBlocks 
		    (axlFormGetField form_handle "ignoreBlocks")
		)
	    )) 
	if(file_name then 
	    (port = outfile(file_name "w")) 
	    pprint(cfg_data port) 
	    close(port)
	    printf("Note: File %L has been written.\n" file_name) else 
	    (axlDeleteAttachment "tbx_silkscreen") 
	    (data_str = sprintf(nil "%L" cfg_data)) 
	    (axlCreateAttachment "tbx_silkscreen" nil 1 
		'string
		data_str
	    )
	) t
    )
)
procedure(TBX_SILKSCREEN_Toggle_Visibility(arg) 
    let((source_data obstacle_data source_layers_top obstacle_layers_top source_layers_bottom
	    obstacle_layers_bottom layer_list result_layers_top result_layers_bottom
	) 
	(source_data = ((tbx_silkscreen_global->source)->selected)) 
	(obstacle_data = ((tbx_silkscreen_global->obstacle)->selected)) 
	foreach(bn source_data 
	    when((tbx_silkscreen_global->layerPair)[bn] 
		(source_layers_top = cons(car((tbx_silkscreen_global->layerPair)[bn]) source_layers_top))
	    )
	) 
	foreach(bn obstacle_data 
	    when((tbx_silkscreen_global->layerPair)[bn] 
		(obstacle_layers_top = cons(car((tbx_silkscreen_global->layerPair)[bn]) obstacle_layers_top))
	    )
	)
	foreach(bn source_data 
	    when((tbx_silkscreen_global->layerPair)[bn] 
		(source_layers_bottom = cons(cadr((tbx_silkscreen_global->layerPair)[bn]) source_layers_bottom))
	    )
	) 
	foreach(bn obstacle_data 
	    when((tbx_silkscreen_global->layerPair)[bn] 
		(obstacle_layers_bottom = cons(cadr((tbx_silkscreen_global->layerPair)[bn]) obstacle_layers_bottom))
	    )
	) 
	(result_layers_top = list(strcat((tbx_silkscreen_global->destination) "_TOP"))) 
	(result_layers_bottom = list(strcat((tbx_silkscreen_global->destination) "_BOTTOM"))) 
	case(arg 
	    ("off" 
		(axlVisibleDesign nil)
	    ) 
	    ("limit" 
		(axlVisibleDesign nil) 
		(layer_list = nconc(source_layers_top source_layers_bottom obstacle_layers_top obstacle_layers_bottom result_layers_top
			result_layers_bottom
		    )) 
		(layer_list = cons(strcat((axlMapClassName "BOARD GEOMETRY") "/OUTLINE") layer_list)) 
		(layer_list = cons(strcat((axlMapClassName "BOARD GEOMETRY") "/DESIGN_OUTLINE") layer_list))
		(layer_list = cons(strcat((axlMapClassName "BOARD GEOMETRY") "/CUTOUT") layer_list))
	    ) 
	    ("source_top" 
		(layer_list = source_layers_top)
	    ) 
	    ("source_bottom" 
		(layer_list = source_layers_bottom)
	    )
	    ("obstacle_top" 
		(layer_list = obstacle_layers_top)
	    ) 
	    ("obstacle_bottom" 
		(layer_list = obstacle_layers_bottom)
	    ) 
	    ("result_top" 
		(axlDBControl 
		    'activeLayer 
		    car(result_layers_top)
		) 
		(layer_list = result_layers_top)
	    ) 
	    ("result_bottom" 
		(axlDBControl 
		    'activeLayer 
		    car(result_layers_bottom)
		) 
		(layer_list = result_layers_bottom)
	    ) 
	    ("drc" 
		(layer_list = list("DRC ERROR CLASS/ALL"))
	    )
	)
	foreach(lyr layer_list 
	    when((axlIsLayer lyr) 
		if((axlIsVisibleLayer lyr) then 
		    (axlVisibleLayer lyr nil) else 
		    (axlVisibleLayer lyr t)
		)
	    )
	) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_UTIL_Backup_Database(mode) 
    let((drawing_name_fp arr dir_name base_name ext
	    backup_init backup_init_fp backup_1 backup_2 backup_3
	) 
	when(axlGetVariable("FLW_ENABLE_DATABASE_BACKUP") 
	    (drawing_name_fp = (axlGetDrawingName)) 
	    (arr = (axlDMFileParts drawing_name_fp)) 
	    (dir_name = car(arr)) 
	    (base_name = cadr(arr))
	    (ext = nth(3 arr)) 
	    (backup_init = strcat("tbx_backup_init." ext)) 
	    (backup_init_fp = strcat(dir_name "/" backup_init)) 
	    case(mode 
		("init" 
		    when(isFile(backup_init_fp) 
			deleteFile(backup_init_fp)
		    ) 
		    (axlSaveDesign ?design backup_init_fp ?writeModel t)
		) 
		("commit" 
		    (backup_1 = strcat(dir_name "/" base_name "_tbx_backup_1." ext)) 
		    (backup_2 = strcat(dir_name "/" base_name "_tbx_backup_2." ext)) 
		    (backup_3 = strcat(dir_name "/" base_name "_tbx_backup_3." ext)) 
		    when(isFile(backup_2) 
			(axlOSFileMove backup_2 backup_3)
		    )
		    when(isFile(backup_1) 
			(axlOSFileMove backup_1 backup_2)
		    ) 
		    when(isFile(backup_init_fp) 
			(axlOSFileMove backup_init_fp backup_1)
		    )
		) 
		("cancel" 
		    deleteFile(backup_init_fp)
		) 
		(t t)
	    )
	)
    )
)
procedure(TBX_UTIL_Backup_File(file_name) 
    let((file1 file2 file3) 
	(file1 = strcat(file_name ",1")) 
	(file2 = strcat(file_name ",2")) 
	(file3 = strcat(file_name ",3")) 
	when(isFile(file2) 
	    (axlOSFileMove file2 file3)
	)
	when(isFile(file1) 
	    (axlOSFileMove file1 file2)
	) 
	when(isFile(file_name) 
	    (axlOSFileMove file_name file1)
	)
    )
)
procedure(TBX_UTIL_Change_Working_Dir() 
    let((database database_dir) 
	(database = (axlGetDrawingName)) 
	(database_dir = car((axlDMFileParts database))) 
	when((database_dir && (database_dir != getWorkingDir())) 
	    printf("Info: Changing working directory to %L\n" database_dir) 
	    changeWorkingDir(database_dir)
	) t
    )
)
procedure(TBX_UTIL_Check_Figures(fg_list) 
    let((rounded_rect chamfered_rect n_sided_poly donut) 
	(rounded_rect = setof(x fg_list 
		((x->figureName) == "ROUNDED_RECTANGLE")
	    )) 
	(chamfered_rect = setof(x fg_list 
		((x->figureName) == "CHAMFERED_RECTANGLE")
	    )) 
	(n_sided_poly = setof(x fg_list 
		((x->figureName) == "N-SIDED-POLY")
	    )) 
	(donut = setof(x fg_list 
		((x->figureName) == "DONUT")
	    ))
	when(rounded_rect 
	    printf("Note: Stand-alone figure ROUNDED_RECTANGLE not fully supported yet. Approximation by rectangle.\n")
	) 
	when(chamfered_rect 
	    printf("Note: Stand-alone figure CHAMFERED_RECTANGLE not fully supported yet. Approximation by rectangle.\n")
	) 
	when(n_sided_poly 
	    printf("Note:  Stand-alone figure N-SIDED-POLY not fully supported yet. Approximation by circle.\n")
	) 
	when(donut 
	    printf("Note:  Stand-alone figure N-SIDED-POLY not fully supported yet. Approximation by circle.\n")
	) t
    )
)
procedure(TBX_UTIL_Clean_Layer(layer_arg) 
    let((orgvis layer_list) 
	if((type(layer_arg) == 'string) then 
	    (layer_list = list(layer_arg)) else 
	    (layer_list = layer_arg)
	) 
	(orgvis = (axlVisibleGet)) 
	(axlVisibleDesign nil) 
	(axlVisibleUpdate t)
	(axlSetFindFilter ?enabled 
	    list("noall" "boundary_shapes" "shapes" "lines" "clines"
		"clinesegs" "text" "dynthemals"
	    ) ?onButtons 
	    list("all")
	) 
	foreach(lyr layer_list 
	    when((axlIsLayer lyr) 
		(axlVisibleLayer lyr t)
	    )
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	when((axlGetSelSet) 
	    (axlDeleteObject 
		(axlGetSelSet)
	    )
	)
	(axlVisibleSet orgvis) 
	(axlClearSelSet) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_UTIL_Clear_Directory(dir_name) 
    let((contents file_list dir_list sub_contents) 
	when((isDir(dir_name) && (dir_name != ".") && (dir_name != "..")) 
	    (contents = setof(x 
		    getDirFiles(dir_name) 
		    ((x != ".") && (x != ".."))
		)) 
	    (contents = mapcar(lambda((x) 
			strcat(dir_name "/" x)
		    ) contents
		)) 
	    (file_list = setof(x contents 
		    isFile(x)
		)) 
	    (dir_list = setof(x contents 
		    isDir(x)
		))
	    foreach(fn file_list 
		deleteFile(fn)
	    ) 
	    foreach(dn dir_list 
		(sub_contents = setof(x 
			getDirFiles(dir_name) 
			((x != ".") && (x != ".."))
		    )) 
		when(sub_contents 
		    TBX_UTIL_Clear_Directory(dn) 
		    deleteDir(dn)
		)
	    )
	)
    )
)
procedure((TBX_UTIL_Copy_To_Layer data destination_layer \@optional freeze_auto_voids) 
    let((copyPath copyText copyShape company_name freeze_voids) 
	(copyPath = lambda((seg_list dest_layer) 
		let((mypath) 
		    foreach(i seg_list 
			if(((i->objType) == "line") then 
			    if(!mypath then 
				(mypath = (axlPathStart 
					(i->startEnd) 
					(i->width)
				    )) else 
				(mypath = (axlPathLine mypath 
					(i->width) 
					cadr((i->startEnd))
				    ))
			    ) else 
			    if(!mypath then 
				(mypath = (axlPathStart 
					list(car((i->startEnd)))
				    )) 
				(mypath = (axlPathArcCenter mypath 
					(i->width) 
					cadr((i->startEnd)) 
					(i->isClockwise)
					(i->xy)
				    )) else
				(mypath = (axlPathArcCenter mypath 
					(i->width) 
					cadr((i->startEnd)) 
					(i->isClockwise)
					(i->xy)
				    ))
			    )
			)
		    ) 
		    when(mypath 
			(axlDBCreatePath mypath dest_layer)
		    )
		)
	    )) 
	(copyText = lambda((text_dbid dest_layer) 
		let((text_orient) 
		    (text_orient = (axlTextOrientationCopy text_dbid)) 
		    (axlDBCreateText 
			(text_dbid->text) 
			(text_dbid->xy) text_orient dest_layer
			nil
		    )
		)
	    )) 
	(copyShape = lambda((struct dest_layer auto_freeze) 
		let((poly_list shape_dbid shape_fill) 
		    cond((((struct->objType) == "polygon") 
			    (shape_dbid = struct)
			) 
			((((struct->objType) == "shape") && !(struct->shapeIsBoundary)) 
			    (shape_dbid = struct)
			) 
			((((struct->objType) == "shape") && (struct->shapeIsBoundary)) 
			    (shape_dbid = struct)
			) 
			(t 
			    printf("Unknown shape type\n") 
			    (shape_dbid = struct)
			)
		    ) 
		    (shape_fill = (shape_dbid->fill)) 
		    if((shape_dbid->shapeAuto) then 
			if(auto_freeze then 
			    foreach(autoshape 
				(shape_dbid->shapeAuto) 
				(poly_list = (axlPolyFromDB autoshape)) 
				(axlDBCreateShape 
				    car(poly_list) shape_fill dest_layer
				)
			    ) else 
			    (poly_list = (axlPolyFromDB shape_dbid))
			    (axlDBCreateShape 
				car(poly_list) shape_fill dest_layer
			    )
			) else 
			(poly_list = (axlPolyFromDB shape_dbid))
			(axlDBCreateShape 
			    car(poly_list) shape_fill dest_layer
			)
		    )
		)
	    )) 
	(company_name = t)
	if(company_name then 
	    when(freeze_auto_voids 
		(freeze_voids = freeze_auto_voids)
	    ) 
	    foreach(struct data 
		cond((((struct->objType) == "path") 
			funcall(copyPath 
			    (struct->segments) destination_layer
			)
		    ) 
		    ((((struct->objType) == "line") || ((struct->objType) == "arc")) 
			funcall(copyPath 
			    list(struct) destination_layer
			)
		    ) 
		    (((struct->objType) == "text") 
			funcall(copyText struct destination_layer)
		    ) 
		    ((((struct->objType) == "shape") || ((struct->objType) == "polygon")) 
			funcall(copyShape struct destination_layer freeze_voids)
		    ) 
		    (t t)
		)
	    ) else
	    t
	)
    )
)
procedure(TBX_UTIL_Define_Session_Variables(var_list file_mode) 
    let((var_info var_name new_value def_mode var_names) 
	(var_names = mapcar(lambda((x) 
		    cadr(x)
		) var_list
	    )) 
	(var_info = TBX_UTIL_Get_Enved_Info(var_names)) 
	foreach(entry var_list 
	    (def_mode = lowerCase(car(entry))) 
	    (var_name = lowerCase(cadr(entry))) 
	    (new_value = caddr(entry))
	    if(axlGetVariable(var_name) then 
		(var_info[var_name]->orgStatus = "set") 
		(var_info[var_name]->orgValue = axlGetVariable(var_name)) else
		(var_info[var_name]->orgStatus = "unset")
	    ) 
	    when(file_mode 
		TBX_UTIL_Update_Enved_Variable(def_mode var_name new_value)
	    ) 
	    cond(((def_mode == "set") 
		    (axlSetVariable var_name new_value)
		) 
		(((def_mode == "unset") || (def_mode == "clear")) 
		    (axlUnsetVariable var_name)
		)
	    )
	) var_info
    )
)
procedure(TBX_UTIL_Determine_INI_File() 
    let((path_list ini_file first_match search_dir) 
	if(axlGetVariable("parampath") then 
	    (path_list = parseString(axlGetVariable("parampath"))) 
	    foreach(p path_list 
		unless(first_match 
		    (search_dir = simplifyFilename(p)) 
		    (search_dir = (axlOSSlash search_dir)) 
		    when(isDir(search_dir) 
			foreach(f 
			    getDirFiles(search_dir) 
			    when((upperCase(f) == "FLOWARE.INI") 
				(ini_file = strcat(search_dir "/" f)) 
				(first_match = t)
			    )
			)
		    )
		)
	    ) else
	    (ini_file = nil)
	) ini_file
    )
)
procedure((TBX_UTIL_Export_XSection \@optional design_path) 
    let((inport outport format_str skip_line line
	    result tech_file_tmp tech_file_final arr design_name
	) 
	if(design_path then 
	    (arr = (axlDMFileParts design_path)) 
	    (design_name = lowerCase(cadr(arr))) 
	    (tech_file_tmp = strcat(getWorkingDir() "/" design_name "_tmp.tcf"))
	    (tech_file_final = strcat(getWorkingDir() "/" design_name ".tcf")) 
	    (format_str = sprintf(nil "techfile -$ -q -w -i x %L %L" design_path tech_file_tmp)) else 
	    (design_name = lowerCase((axlCurrentDesign))) 
	    (tech_file_tmp = strcat(getWorkingDir() "/" design_name "_tmp.tcf"))
	    (tech_file_final = strcat(getWorkingDir() "/" design_name ".tcf")) 
	    (format_str = sprintf(nil "techfile -$ -q -w -i x %%s %L" tech_file_tmp))
	) 
	(result = (axlRunBatchDBProgram "techfile" format_str ?silent t
		?reloadDB t
	    )) 
	if(result then 
	    (inport = infile(tech_file_tmp)) 
	    (outport = outfile(tech_file_final "w")) 
	    while((line = _gets(inport)) 
		cond((rexMatchp("<contents>" line) 
			(skip_line = t) 
			fprintf(outport "      <contents>\n") 
			fprintf(outport "         <value>units</value>\n") 
			fprintf(outport "         <value>crossSection</value>\n")
			fprintf(outport "         <value>no_properties</value>\n") 
			fprintf(outport "      </contents>\n")
		    ) 
		    (rexMatchp("</contents>" line) 
			(skip_line = nil)
		    ) 
		    (rexMatchp("<opFlags>" line) 
			(skip_line = t)
		    ) 
		    (rexMatchp("</opFlags>" line) 
			(skip_line = nil)
		    ) 
		    (rexMatchp("<drawing>" line) 
			(skip_line = t)
		    )
		    (rexMatchp("</drawing>" line) 
			(skip_line = nil)
		    ) 
		    (rexMatchp("<constraints>" line) 
			(skip_line = t)
		    ) 
		    (rexMatchp("</constraints>" line) 
			(skip_line = nil)
		    ) 
		    (!skip_line 
			fprintf(outport "%s" line)
		    )
		)
	    )
	    close(outport) 
	    close(inport) else 
	    printf("Error: Problems occured while writing tech file\n") 
	    (tech_file_final = nil)
	) tech_file_final
    )
)
procedure(TBX_UTIL_File_Lineread(file_name) 
    let((port data) 
	if(isFile(file_name) then 
	    (port = infile(file_name)) 
	    (data = car(lineread(port))) 
	    close(port)
	    else 
	    printf("Cannot access file %L\n" file_name)
	) data
    )
)
procedure(TBX_UTIL_Find_File(dir_name name) 
    let((match_name file_list file_name_exact) 
	(match_name = upperCase(name)) 
	(file_list = setof(x 
		getDirFiles(dir_name) 
		(upperCase(x) == match_name)
	    )) 
	when(file_list 
	    (file_name_exact = strcat(dir_name "/" 
		    car(file_list)
		))
	) file_name_exact
    )
)
procedure(TBX_UTIL_Form_Ini_Message(module_name) 
    let((msg) 
	(msg = "Note: File form.ini has been written to current working directory. ") 
	(msg = sprintf(nil "%sYou may control form defaults through path %s/form.ini " msg module_name)) 
	(msg = sprintf(nil "%sin FloWare/config or controlled by CDS_SITE or FLW_SITE.\n" msg)) 
	(msg = sprintf(nil "%sRefer to FloWare installation guide for more details." msg))
	(axlUIConfirm msg) t
    )
)
procedure(TBX_UTIL_Get_Box_Center(box) 
    let((x_ll y_ll x_ur y_ur x_center
	    y_center ret
	) 
	(x_ll = car((lowerLeft box))) 
	(y_ll = cadr((lowerLeft box))) 
	(x_ur = car((upperRight box))) 
	(y_ur = cadr((upperRight box)))
	(x_center = (x_ll + ((x_ur - x_ll) / 2.0))) 
	(y_center = (y_ll + ((y_ur - y_ll) / 2.0))) 
	(ret = (x_center:y_center)) ret
    )
)
procedure((TBX_UTIL_Get_Commands \@optional pattern) 
    let((tmp_file port shell_cmd cmd_list keyboard_cmd
	    line
	) 
	(tmp_file = (axlTempFile)) 
	(shell_cmd = sprintf(nil "helpcmd %s" tmp_file)) 
	(axlShell shell_cmd) 
	when(isFile(tmp_file) 
	    (port = infile(tmp_file)) 
	    while((line = _gets(port)) 
		(keyboard_cmd = buildString(parseString(line) " ")) 
		if(pattern then 
		    when(rexMatchp(pattern keyboard_cmd) 
			(cmd_list = cons(keyboard_cmd cmd_list))
		    ) else 
		    (cmd_list = cons(keyboard_cmd cmd_list))
		)
	    ) 
	    close(port)
	)
	(cmd_list = reverse(cmd_list)) cmd_list
    )
)
procedure((TBX_UTIL_Get_Config_Path module_name file_name \@optional regxp_test_pattern) 
    let((config_path cfg_root cfg_cds_site cfg_floware_site dir_data
	    dir_list ok_config
	) 
	when((axlGetVariable("FLOWARE_ROOT") && (type(axlGetVariable("FLOWARE_ROOT")) == 'string)) 
	    if(file_name then 
		(cfg_root = sprintf(nil "%s/config/%s/%s" 
			axlGetVariable("FLOWARE_ROOT") module_name file_name
		    )) else 
		(cfg_root = sprintf(nil "%s/config/%s" 
			axlGetVariable("FLOWARE_ROOT") module_name
		    ))
	    )
	) 
	when((axlGetVariable("CDS_SITE") && (type(axlGetVariable("CDS_SITE")) == 'string)) 
	    if(file_name then 
		(cfg_cds_site = sprintf(nil "%s/FloWare/config/%s/%s" 
			axlGetVariable("CDS_SITE") module_name file_name
		    )) else 
		(cfg_cds_site = sprintf(nil "%s/FloWare/config/%s" 
			axlGetVariable("CDS_SITE") module_name
		    ))
	    )
	) 
	when((axlGetVariable("FLW_SITE") && (type(axlGetVariable("FLW_SITE")) == 'string)) 
	    if(file_name then 
		(cfg_floware_site = sprintf(nil "%s/config/%s/%s" 
			axlGetVariable("FLW_SITE") module_name file_name
		    )) else 
		(cfg_floware_site = sprintf(nil "%s/config/%s" 
			axlGetVariable("FLW_SITE") module_name
		    ))
	    )
	) 
	if(file_name then 
	    cond(((cfg_floware_site && isFile(cfg_floware_site)) 
		    (config_path = cfg_floware_site)
		) 
		((cfg_cds_site && isFile(cfg_cds_site)) 
		    (config_path = cfg_cds_site)
		) 
		(t 
		    (config_path = cfg_root)
		)
	    ) else 
	    when((cfg_floware_site && isReadable(cfg_floware_site)) 
		(dir_list = cons(cfg_floware_site dir_list))
	    )
	    when((cfg_cds_site && isReadable(cfg_cds_site)) 
		(dir_list = cons(cfg_cds_site dir_list))
	    ) 
	    when(cfg_root 
		(dir_list = cons(cfg_root dir_list))
	    ) 
	    (dir_list = reverse(dir_list)) 
	    if(regxp_test_pattern then 
		foreach(dr dir_list 
		    unless(ok_config 
			(dir_data = mapcar(lambda((x) 
				    lowerCase(x)
				) 
				getDirFiles(dr)
			    )) 
			when(setof(x dir_data 
				rexMatchp(regxp_test_pattern x)
			    ) 
			    (config_path = dr) 
			    (ok_config = t)
			)
		    )
		) else 
		(config_path = car(dir_list))
	    )
	)
	cond((file_name 
		if((config_path && isReadable(config_path)) then config_path else 
		    printf("Cannot determine configuration path for module %L. Check your setup including variables CDS_SITE or FLW_SITE\n" module_name)
		    (config_path = nil)
		)
	    ) 
	    (regxp_test_pattern 
		if(ok_config then config_path else 
		    printf("No configuration directory found for module %L with files matching %L. Check your setup including variables CDS_SITE or FLW_SITE\n" module_name regxp_test_pattern)
		)
	    )
	) config_path
    )
)
procedure(TBX_UTIL_Get_Database_Filter_String() 
    let((filter_string brd_filter mcm_filter sip_filter) 
	(brd_filter = "Board files(*.brd)|*.brd|MCM files(*.mcm)|*.mcm|SIP files(*.sip)|*.sip|") 
	(mcm_filter = "MCM files(*.mcm)|*.mcm|SIP files(*.sip)|*.sip|Board files(*.brd)|*.brd|") 
	(sip_filter = "SIP files(*.sip)|*.sip|MCM files(*.mcm)|*.mcm|Board files(*.brd)|*.brd|") 
	case(upperCase((axlDesignType t)) 
	    ("BOARD" 
		(filter_string = brd_filter)
	    ) 
	    ("MCM" 
		(filter_string = mcm_filter)
	    ) 
	    ("SIP" 
		(filter_string = sip_filter)
	    ) 
	    (t 
		(filter_string = brd_filter)
	    )
	)
	filter_string
    )
)
procedure(TBX_UTIL_Get_Enved_Info(var_names) 
    let((arr env_file port line enved_section
	    status var_name var_info
	) 
	(var_names = mapcar(lambda((x) 
		    lowerCase(x)
		) var_names
	    )) 
	(env_file = strcat(axlGetVariable("LOCALENV") "/env")) 
	unless(isFile(env_file) 
	    (port = outfile(env_file "w")) 
	    fprintf(port "source $TELENV\n") 
	    fprintf(port "\n") 
	    fprintf(port "### User Preferences section\n")
	    fprintf(port "### This section is computer generated.\n") 
	    fprintf(port "### Please do not modify to the end of the file.\n") 
	    fprintf(port "### Place your hand edits above this section.\n") 
	    fprintf(port "###\n") 
	    close(port)
	) 
	(port = infile(env_file))
	(var_info = makeTable("var_info_table" nil)) 
	while((line = _gets(port)) 
	    cond((rexMatchp("^ *###" line) 
		    (enved_section = t)
		) 
		((enved_section && rexMatchp("^ *###" line)) t) 
		(enved_section 
		    rexCompile("=") 
		    (line = rexReplace(line " " 0)) 
		    if(isCallable('axlStringRemoveSpaces) then 
			(line = (axlStringRemoveSpaces line)) else 
			(line = TBX_UTIL_Trim_String(line))
		    ) 
		    (arr = parseString(line))
		    when((length(arr) >= 2) 
			(status = lowerCase(car(arr))) 
			(var_name = lowerCase(cadr(arr))) 
			when(((status == "set") || (status == "unset")) 
			    foreach(vn var_names 
				when((var_name == vn) 
				    if((status == "set") then 
					(var_info[vn] = list(nil 
						'envedStatus "set" 
						'envedValue 
						buildString(cddr(arr) " ")
					    )) else 
					(var_info[vn] = list(nil 
						'envedStatus "unset"
					    ))
				    )
				)
			    )
			)
		    )
		)
	    )
	) 
	close(port) 
	foreach(vn var_names 
	    unless(var_info[vn] 
		(var_info[vn] = list(nil 
			'envedStatus "clear"
		    ))
	    )
	) var_info
    )
)
procedure((TBX_UTIL_Get_Extents lo_arg \@key 
	(margin 0.0) axlPathCenter
    ) 
    let((arg_list box_data ll ur ll_x
	    ll_y ur_x ur_y extents tmp_data
	    design_ll design_width design_height center_offset rp_off
	    box_ll box_ur rpath_list poly_data
	) 
	if((type(lo_arg) == 'list) then 
	    (arg_list = lo_arg) else 
	    (arg_list = list(lo_arg))
	) 
	(box_data = mapcar(lambda((x) 
		    (x->bBox)
		) 
		setof(a arg_list 
		    (a->bBox)
		)
	    )) 
	(tmp_data = setof(x arg_list 
		(isBoxp x)
	    )) 
	(box_data = nconc(box_data tmp_data))
	(rpath_list = setof(x arg_list 
		(type(x) == '_axlPath)
	    )) 
	when(rpath_list 
	    (center_offset = (0:0)) 
	    when(axlPathCenter 
		(design_ll = car(((axlGetParam "paramDesign")->bBox))) 
		(design_width = ((axlGetParam "paramDesign")->width)) 
		(design_height = ((axlGetParam "paramDesign")->height)) 
		(center_offset = ((car(design_ll) + (design_width / 2.0)):(cadr(design_ll) + (design_height / 2.0))))
	    ) 
	    foreach(rp rpath_list 
		if(axlPathCenter then 
		    (rp_off = (axlPathOffset rp center_offset)) else 
		    (rp_off = rp)
		) 
		(poly_data = (axlPolyFromDB rp_off ?line2poly t)) 
		(tmp_data = mapcar(lambda((x) 
			    (x->bBox)
			) poly_data
		    ))
		foreach(b tmp_data 
		    (box_ll = car(b)) 
		    (box_ur = cadr(b)) 
		    unless(ll_x 
			(ll_x = car(box_ll))
		    )
		    unless(ll_y 
			(ll_y = cadr(box_ll))
		    ) 
		    unless(ur_x 
			(ur_x = car(box_ur))
		    ) 
		    unless(ur_y 
			(ur_y = cadr(box_ur))
		    ) 
		    when((car(box_ll) < ll_x) 
			(ll_x = car(box_ll))
		    ) 
		    when((cadr(box_ll) < ll_y) 
			(ll_y = cadr(box_ll))
		    )
		    when((car(box_ur) > ur_x) 
			(ur_x = car(box_ur))
		    ) 
		    when((cadr(box_ur) > ur_y) 
			(ur_y = cadr(box_ur))
		    )
		)
	    ) 
	    when(ll_x 
		(ll_x = (ll_x - car(center_offset)))
	    )
	    when(ll_y 
		(ll_y = (ll_y - cadr(center_offset)))
	    ) 
	    when(ur_x 
		(ur_x = (ur_x - car(center_offset)))
	    ) 
	    when(ur_y 
		(ur_y = (ur_y - cadr(center_offset)))
	    )
	) 
	foreach(b box_data 
	    (ll = car(b)) 
	    (ur = cadr(b)) 
	    unless(ll_x 
		(ll_x = car(ll))
	    )
	    unless(ll_y 
		(ll_y = cadr(ll))
	    ) 
	    unless(ur_x 
		(ur_x = car(ur))
	    ) 
	    unless(ur_y 
		(ur_y = cadr(ur))
	    ) 
	    when((car(ll) < ll_x) 
		(ll_x = car(ll))
	    ) 
	    when((cadr(ll) < ll_y) 
		(ll_y = cadr(ll))
	    )
	    when((car(ur) > ur_x) 
		(ur_x = car(ur))
	    ) 
	    when((cadr(ur) > ur_y) 
		(ur_y = cadr(ur))
	    )
	) 
	when(margin 
	    (ll_x = (ll_x - margin)) 
	    (ll_y = (ll_y - margin)) 
	    (ur_x = (ur_x + margin)) 
	    (ur_y = (ur_y + margin))
	) 
	(extents = list((ll_x:ll_y) 
		(ur_x:ur_y)
	    ))
	extents
    )
)
procedure(TBX_UTIL_Get_Flat_Path(path_name) 
    let((ok_match var_name var_value) 
	(path_name = (axlOSSlash path_name)) 
	cond((rexMatchp("[$][^/]*" path_name) 
		rexCompile("[$]\\([^/]*\\)") 
		rexExecute(path_name) 
		(ok_match = t)
	    ) 
	    (rexMatchp("%[^/]*%" path_name) 
		rexCompile("%\\([^/]*\\)%") 
		rexExecute(path_name) 
		(ok_match = t)
	    ) 
	    (t t)
	) 
	when(ok_match 
	    (var_name = rexSubstitute("\\1")) 
	    (var_value = axlGetVariable(var_name)) 
	    when(var_value 
		(var_value = (axlOSSlash var_value)) 
		(path_name = rexReplace(path_name var_value 0))
	    )
	) path_name
    )
)
procedure(TBX_UTIL_Get_Hash_Keys(hash_table sort) 
    let((key_list) 
	foreach(key hash_table 
	    (key_list = cons(key key_list))
	) 
	when(sort 
	    (key_list = sort(key_list nil))
	) key_list
    )
)
procedure(TBX_UTIL_Get_Layout_File_Extension() 
    let((ext) 
	case(upperCase((axlDesignType t)) 
	    ("BOARD" 
		(ext = "brd")
	    ) 
	    ("MCM" 
		(ext = "mcm")
	    ) 
	    ("SIP" 
		(ext = "sip")
	    ) 
	    (t 
		(ext = "brd")
	    )
	) ext
    )
)
procedure(TBX_UTIL_Get_Relative_Path(dest_dir ref_dir) 
    let((ref_dir_arr dest_dir_arr loop ok_relative rel_dir) 
	(dest_dir = simplifyFilename(dest_dir)) 
	(ref_dir = simplifyFilename(ref_dir)) 
	(dest_dir = (axlOSSlash dest_dir)) 
	(ref_dir = (axlOSSlash ref_dir))
	when((dest_dir && ref_dir) 
	    (dest_dir_arr = parseString(dest_dir "/")) 
	    (ref_dir_arr = parseString(ref_dir "/")) 
	    (loop = t) 
	    while((loop && car(dest_dir_arr) && car(ref_dir_arr)) 
		if((car(dest_dir_arr) == car(ref_dir_arr)) then 
		    (ok_relative = t) 
		    (dest_dir_arr = cdr(dest_dir_arr)) 
		    (ref_dir_arr = cdr(ref_dir_arr))
		    else 
		    (loop = nil)
		)
	    )
	) 
	if(ok_relative then 
	    cond(((!dest_dir_arr && !ref_dir_arr) 
		    (rel_dir = "./")
		) 
		((length(dest_dir_arr) > length(ref_dir_arr)) 
		    (rel_dir = buildString(dest_dir_arr "/")) 
		    (rel_dir = strcat("./" rel_dir))
		) 
		(t 
		    (rel_dir = buildString(dest_dir_arr "/")) 
		    foreach(entry ref_dir_arr 
			(entry = entry) 
			(rel_dir = strcat("../" rel_dir))
		    )
		)
	    ) 
	    rexCompile("/$") 
	    (rel_dir = rexReplace(rel_dir "" 0))
	    else 
	    printf("Info: Cannot retrieve relative directory\n") 
	    (rel_dir = dest_dir)
	) rel_dir
    )
)
procedure((TBX_UTIL_Get_Short_Units \@optional arg) 
    let((design_units short_units) 
	if(arg then 
	    (design_units = arg) else 
	    (design_units = lowerCase(car((axlDBGetDesignUnits))))
	) 
	case(design_units 
	    ("microns" 
		(short_units = "UM")
	    ) 
	    ("millimeters" 
		(short_units = "MM")
	    ) 
	    ("centimeters" 
		(short_units = "CM")
	    ) 
	    ("mils" 
		(short_units = "MILS")
	    )
	    ("inches" 
		(short_units = "IN")
	    ) 
	    (t 
		(short_units = design_units)
	    )
	) short_units
    )
)
procedure(TBX_UTIL_Get_Toolbox_Functions() 
    let((toc_file port line function_list function_name) 
	(toc_file = strcat(axlGetVariable("ALLEGRO_INSTALL_ROOT") "/share/pcb/etc/context/toolbox.toc")) 
	when(((axlVersion 
		    'version
		) >= 17.2) 
	    (toc_file = strcat(axlGetVariable("ALLEGRO_INSTALL_ROOT") "/share/pcb/etc/context/64bit/toolbox.toc"))
	) 
	when((isFile(toc_file) && isReadable(toc_file)) 
	    (port = infile(toc_file)) 
	    while((line = _gets(port)) 
		(function_name = buildString(parseString(line) " ")) 
		when(rexMatchp("^TBX" function_name) 
		    (function_list = cons(function_name function_list))
		)
	    ) 
	    close(port) 
	    (function_list = reverse(function_list))
	) function_list
    )
)
procedure(TBX_UTIL_Import_Techfile(tech_file) 
    let(status(command_str) 
	rexCompile("^\"") 
	(tech_file = rexReplace(tech_file "" 0)) 
	rexCompile("\"$") 
	(tech_file = rexReplace(tech_file "" 0))
	(command_str = sprintf(nil "techfile -$ -q -r  %L %%s" tech_file)) 
	(status = (axlRunBatchDBProgram "techfile" command_str ?silent t
		?reloadDB t
	    )) status
    )
)
procedure(TBX_UTIL_List_Move_Item(item_list item_name direction) 
    let((item_list_new cur_index last_index insert_index) 
	(last_index = (length(item_list) - 1)) 
	for(i 0 last_index 
	    when((nth(i item_list) == item_name) 
		(cur_index = i)
	    )
	) 
	cond((((direction == "up") || (direction == "left")) 
		if(zerop(cur_index) then 
		    (item_list_new = item_list) else 
		    (item_list_new = tconc(nil nil))
		    (insert_index = (cur_index - 1)) 
		    (item_list = setof(x item_list 
			    (x != item_name)
			)) 
		    for(i 0 
			(length(item_list) - 1) 
			when(eq(i insert_index) 
			    tconc(item_list_new item_name)
			) 
			tconc(item_list_new 
			    nth(i item_list)
			)
		    ) 
		    (item_list_new = cdar(item_list_new))
		)
	    ) 
	    (((direction == "down") || (direction == "right")) 
		if(eq(cur_index last_index) then 
		    (item_list_new = item_list) else 
		    (item_list_new = tconc(nil nil))
		    (insert_index = cur_index) 
		    (item_list = setof(x item_list 
			    (x != item_name)
			)) 
		    for(i 0 
			(length(item_list) - 1) 
			tconc(item_list_new 
			    nth(i item_list)
			) 
			when(eq(i insert_index) 
			    tconc(item_list_new item_name)
			)
		    ) 
		    (item_list_new = cdar(item_list_new))
		)
	    )
	) item_list_new
    )
)
procedure(TBX_UTIL_Map_Layer_Name(layer mode) 
    let((arr cls subcls cls_mapped layer_new
	    mcm_name pcb_name
	) 
	(mcm_name = makeTable("mcm_name_table" nil)) 
	(mcm_name["BOARD GEOMETRY"] = "SUBSTRATE GEOMETRY") 
	(mcm_name["ETCH"] = "CONDUCTOR") 
	(mcm_name["ANTI ETCH"] = "ANTI CONDUCTOR")
	(mcm_name["PACKAGE GEOMETRY"] = "COMPONENT GEOMETRY") 
	(mcm_name["PACKAGE KEEPIN"] = "COMPONENT KEEPIN") 
	(mcm_name["PACKAGE KEEPOUT"] = "COMPONENT KEEPOUT") 
	(pcb_name = makeTable("pcb_name_table" nil)) 
	(pcb_name["SUBSTRATE GEOMETRY"] = "BOARD GEOMETRY")
	(pcb_name["CONDUCTOR"] = "ETCH") 
	(pcb_name["ANTI CONDUCTOR"] = "ANTI ETCH") 
	(pcb_name["COMPONENT GEOMETRY"] = "PACKAGE GEOMETRY") 
	(pcb_name["COMPONENT KEEPIN"] = "PACKAGE KEEPIN") 
	(pcb_name["COMPONENT KEEPOUT"] = "PACKAGE KEEPOUT")
	(layer_new = layer) 
	(arr = parseString(upperCase(layer) "/")) 
	cond((onep(length(arr)) 
		(cls = layer)
	    ) 
	    ((length(arr) == 2) 
		(cls = car(arr)) 
		(subcls = cadr(arr))
	    )
	) 
	when(cls 
	    (cls_mapped = cls) 
	    cond((eq(mode t) 
		    (cls_mapped = (axlMapClassName cls t))
		) 
		(eq(mode nil) 
		    (cls_mapped = (axlMapClassName cls nil))
		) 
		(eq(mode 
			'forceMCM
		    ) 
		    when(mcm_name[cls] 
			(cls_mapped = mcm_name[cls])
		    )
		) 
		(eq(mode 
			'forcePCB
		    ) 
		    when(pcb_name[cls] 
			(cls_mapped = pcb_name[cls])
		    )
		)
	    ) 
	    if(subcls then 
		(layer_new = strcat(cls_mapped "/" subcls)) else 
		(layer_new = cls_mapped)
	    )
	) layer_new
    )
)
procedure(TBX_UTIL_Migrate(att_name_old att_name_new) 
    let((att data_str result new_name old_name
	    msg
	) 
	(att = (axlGetAttachment att_name_old 
		'string
	    )) 
	when((att && (att_name_old == "flw_postproc")) 
	    printf("Info: Deleting legacy attachment flw_posptroc...\n") 
	    (axlDeleteAttachment att_name_old) 
	    (att = nil)
	) 
	when(att 
	    (data_str = (att->data)) 
	    case(att_name_old 
		("flw_classolor" 
		    rexCompile("FLW_CLASSCOLOR") 
		    when((data_str && (type(data_str) == 'string)) 
			(data_str = rexReplace(data_str "TBX_CLASSCOLOR" 0))
		    ) 
		    foreach(grp 
			(axlSelectByName "GROUP" "FLW_CLASSCOLOR*" t) 
			(old_name = (grp->name)) 
			(new_name = rexReplace(old_name "TBX_CLASSCOLOR" 0)) 
			(axlDBGroupRename grp new_name)
		    )
		) 
		("flw_shieldroute" 
		    rexCompile("FLW_SHIELD_") 
		    when((data_str && (type(data_str) == 'string)) 
			(data_str = rexReplace(data_str "TBX_SHIELD_" 0))
		    ) 
		    foreach(grp 
			(axlSelectByName "GROUP" "FLW_SHIELD_*" t) 
			(old_name = (grp->name)) 
			(new_name = rexReplace(old_name "TBX_SHIELD_" 0)) 
			(axlDBGroupRename grp new_name)
		    )
		) 
		("flw_variassy" 
		    foreach(grp 
			(axlSelectByName "GROUP" "FLW_*" t) 
			unless(rexMatchp("FLW_SHIELD" 
				upperCase((grp->name))
			    ) 
			    rexCompile("^FLW_") 
			    (old_name = (grp->name)) 
			    (new_name = rexReplace(old_name "VAS_" 0)) 
			    (axlDBGroupRename grp new_name)
			)
		    )
		) 
		("flw_filerename" 
		    rexCompile("renameRules") 
		    (data_str = rexReplace(data_str "rules" 0)) 
		    rexCompile("varDef") 
		    (data_str = rexReplace(data_str "variables" 0))
		    rexCompile("cmdParam") 
		    (data_str = rexReplace(data_str "options" 0)) 
		    when((rexMatchp("<match>" data_str) || 
			    rexMatchp("<prematch>" data_str) || 
			    rexMatchp("<postmatch>" data_str)) 
			(msg = "Note: Legacy tags <match>, <prematch> and <postmatch> no longer supported. Refer to documentation.")
		    )
		)
	    ) 
	    when((data_str && (type(data_str) == 'string)) 
		printf("Info: Migrating database attachment to toolbox namespace\n") 
		(result = (axlCreateAttachment att_name_new nil 1 
			'string
			data_str
		    )) 
		when(msg 
		    (axlUIConfirm msg)
		)
	    ) 
	    (axlDeleteAttachment att_name_old)
	) 
	(axlClearSelSet)
	(axlDBRefreshId nil) result
    )
)
procedure(TBX_UTIL_No_Confirm(env_dpl mode) 
    let((var_list) 
	(var_list = var_list) 
	case(mode 
	    ("set" 
		unless(axlGetVariable("NOCONFIRM_SAVEDB") 
		    (axlSetVariable "NOCONFIRM_SAVEDB" t) 
		    putprop(env_dpl nil 
			'noConfirmSaveOrig
		    )
		) 
		unless(axlGetVariable("DB_TIER_NOMSG") 
		    (axlSetVariable "DB_TIER_NOMSG" t) 
		    putprop(env_dpl nil 
			'noTierMessageOrig
		    )
		) 
		unless(axlGetVariable("NOCONFIRM_UPREV") 
		    (axlSetVariable "NOCONFIRM_UPREV" t) 
		    putprop(env_dpl nil 
			'noConfirmUprevOrig
		    )
		)
	    ) 
	    ("reset" 
		unless(get(env_dpl 
			'noConfirmSaveOrig
		    ) 
		    (axlUnsetVariable "NOCONFIRM_SAVEDB")
		) 
		unless(get(env_dpl 
			'noTierMessageOrig
		    ) 
		    (axlUnsetVariable "DB_TIER_NOMSG")
		) 
		unless(get(env_dpl 
			'noConfirmUprevOrig
		    ) 
		    (axlUnsetVariable "NOCONFIRM_UPREV")
		)
	    ) 
	    (t t)
	) t
    )
)
procedure(TBX_UTIL_Normalize_Box(box) 
    let((pt1 pt2 x1 y1 x2
	    y2 x_ll y_ll x_ur y_ur
	    box_norm
	) 
	(pt1 = car(box)) 
	(pt2 = cadr(box)) 
	(x1 = car(pt1)) 
	(y1 = cadr(pt1))
	(x2 = car(pt2)) 
	(y2 = cadr(pt2)) 
	if((x1 <= x2) then 
	    (x_ll = x1) 
	    (x_ur = x2) else
	    (x_ll = x2) 
	    (x_ur = x1)
	) 
	if((y1 <= y2) then 
	    (y_ll = y1) 
	    (y_ur = y2) else
	    (y_ll = y2) 
	    (y_ur = y1)
	) 
	(box_norm = list((x_ll:y_ll) 
		(x_ur:y_ur)
	    ))
	box_norm
    )
)
procedure(TBX_UTIL_Read_INI_File(ini_file section) 
    let((arr inport line match start_tag
	    end_tag str item item_list ini_data_section
	    ini_data_other
	) 
	(inport = infile(ini_file)) 
	(start_tag = strcat("START_" 
		upperCase(section)
	    )) 
	(end_tag = strcat("END_" 
		upperCase(section)
	    )) 
	(ini_data_section = list())
	(ini_data_other = list()) 
	while((line = _gets(inport)) 
	    (str = line) 
	    cond((rexMatchp(start_tag 
			upperCase(str)
		    ) 
		    (match = t)
		) 
		(rexMatchp(end_tag 
			upperCase(str)
		    ) 
		    (match = nil)
		) 
		(!match 
		    (ini_data_other = cons(str ini_data_other))
		) 
		(match 
		    (arr = parseString(str "'")) 
		    when((length(arr) > 0) 
			(item_list = list()) 
			for(i 0 
			    (length(arr) - 1) 
			    if(zerop(mod(i 2)) then 
				(item_list = cons(nth(i arr) item_list)) else 
				(item = nth(i arr))
				rexCompile(" ") 
				(item = rexReplace(item "___WHITE_SPACE___" 0)) 
				(item_list = cons(item item_list))
			    )
			) 
			(item_list = reverse(item_list)) 
			(str = buildString(item_list "'"))
			rexCompile("'") 
			(str = rexReplace(str "" 0)) 
			(arr = parseString(str)) 
			(item_list = list()) 
			rexCompile("___WHITE_SPACE___")
			foreach(i arr 
			    (item = rexReplace(i " " 0)) 
			    (item_list = cons(item item_list))
			) 
			(item_list = reverse(item_list)) 
			(ini_data_section = cons(item_list ini_data_section))
		    )
		) 
		(t t)
	    )
	) 
	close(inport) 
	(ini_data_other = reverse(ini_data_other)) 
	list(ini_data_section ini_data_other)
    )
)
procedure((TBX_UTIL_Regex_From_Shell pattern \@optional ignore_case pattern_tag
	no_anchor
    ) 
    let((rex_pattern char_list lc_char uc_char) 
	rexCompile("^ *") 
	(pattern = rexReplace(pattern "" 0)) 
	rexCompile(" *$") 
	(pattern = rexReplace(pattern "" 0))
	(char_list = tconc(nil "")) 
	unless(no_anchor 
	    tconc(char_list "^")
	) 
	foreach(char 
	    parseString(pattern "") 
	    case(char 
		("*" 
		    if(pattern_tag then 
			tconc(char_list 
			    symbolToString('\\)
			) 
			tconc(char_list "(") 
			tconc(char_list ".")
			tconc(char_list "*") 
			tconc(char_list 
			    symbolToString('\\)
			) 
			tconc(char_list ")") else 
			tconc(char_list ".")
			tconc(char_list "*")
		    )
		) 
		("?" 
		    if(pattern_tag then 
			tconc(char_list 
			    symbolToString('\\)
			) 
			tconc(char_list "(") 
			tconc(char_list ".")
			tconc(char_list 
			    symbolToString('\\)
			) 
			tconc(char_list ")") else 
			tconc(char_list ".")
		    )
		) 
		("." 
		    tconc(char_list "[") 
		    tconc(char_list ".") 
		    tconc(char_list "]")
		) 
		(t 
		    (lc_char = lowerCase(char)) 
		    (uc_char = upperCase(char)) 
		    if((ignore_case && (lc_char != uc_char)) then 
			tconc(char_list "[") 
			tconc(char_list lc_char) 
			tconc(char_list uc_char)
			tconc(char_list "]") else 
			tconc(char_list char)
		    )
		)
	    )
	) 
	unless(no_anchor 
	    tconc(char_list "$")
	) 
	(rex_pattern = buildString(car(char_list) ""))
	rex_pattern
    )
)
procedure(TBX_UTIL_Resolve_Etch_Layers(lo_arg) 
    let((arg_list layer_list xsection_details tmp_list) 
	if((type(lo_arg) == 'string) then 
	    (arg_list = list(lo_arg)) else 
	    (arg_list = lo_arg)
	) 
	foreach(arg arg_list 
	    case(upperCase(arg) 
		("ALL" 
		    (tmp_list = (axlSubclassRoute))
		) 
		("OUTER" 
		    (tmp_list = list((axlConductorTopLayer) 
			    (axlConductorBottomLayer)
			))
		) 
		("INNER" 
		    (tmp_list = (axlSubclassRoute)) 
		    (tmp_list = cdr(tmp_list)) 
		    (tmp_list = reverse(tmp_list)) 
		    (tmp_list = cdr(tmp_list))
		    (tmp_list = reverse(tmp_list))
		) 
		("SIGNAL" 
		    (xsection_details = (axlGetXSection)) 
		    foreach(entry xsection_details 
			when((cadr(entry) == "CONDUCTOR") 
			    (tmp_list = cons(car(entry) tmp_list))
			)
		    ) 
		    (tmp_list = reverse(tmp_list))
		)
		("PLANE" 
		    foreach(entry xsection_details 
			when((cadr(entry) == "PLANE") 
			    (tmp_list = cons(car(entry) tmp_list))
			)
		    ) 
		    (tmp_list = reverse(tmp_list))
		) 
		(t 
		    (tmp_list = list(arg))
		)
	    ) 
	    foreach(lyr tmp_list 
		unless(exists(x layer_list 
			(x == lyr)
		    ) 
		    (layer_list = cons(lyr layer_list))
		)
	    )
	) layer_list
    )
)
procedure(TBX_UTIL_Restore_Session_Variables(var_info var_names file_mode) 
    let((def_mode var_value) 
	(var_names = mapcar(lambda((x) 
		    lowerCase(x)
		) var_names
	    )) 
	foreach(vn var_names 
	    when(var_info[vn] 
		when(file_mode 
		    (def_mode = (var_info[vn]->envedStatus)) 
		    (var_value = (var_info[vn]->envedValue)) 
		    TBX_UTIL_Update_Enved_Variable(def_mode vn var_value)
		) 
		(def_mode = (var_info[vn]->orgStatus)) 
		(var_value = (var_info[vn]->orgValue)) 
		if((def_mode == "set") then 
		    (axlSetVariable vn var_value) else 
		    (axlUnsetVariable vn)
		)
	    )
	)
    )
)
procedure((TBX_UTIL_Search_Config file_name sub_dir enable_wildcard \@key
	includeWorkDir includeRunDir
    ) 
    let((cfg_root cfg_site cfg_localenv cfg_curdir cfg_rundir
	    dir_list tmp_info path_info name_pattern file_list
	    file_path
	) 
	(tmp_info = makeTable("tmp_info_table" nil)) 
	(cfg_root = sprintf(nil "%s/share/pcb/toolbox/config" 
		axlGetVariable("ALLEGRO_INSTALL_ROOT")
	    )) 
	(cfg_site = sprintf(nil "%s/pcb/toolbox/config" 
		axlGetVariable("CDS_SITE")
	    )) 
	(cfg_localenv = sprintf(nil "%s/toolbox/config" 
		axlGetVariable("LOCALENV")
	    ))
	(cfg_curdir = getWorkingDir()) 
	(cfg_rundir = strcat(getWorkingDir() "/toolbox.run")) 
	when(sub_dir 
	    (cfg_root = sprintf(nil "%s/%s" cfg_root sub_dir)) 
	    (cfg_site = sprintf(nil "%s/%s" cfg_site sub_dir)) 
	    (cfg_localenv = sprintf(nil "%s/%s" cfg_localenv sub_dir))
	) 
	when(includeWorkDir 
	    (dir_list = cons(cfg_curdir dir_list))
	) 
	when((includeRunDir && isDir(cfg_rundir)) 
	    (dir_list = cons(cfg_rundir dir_list))
	)
	when(isDir(cfg_localenv) 
	    (dir_list = cons(cfg_localenv dir_list))
	) 
	when(isDir(cfg_site) 
	    (dir_list = cons(cfg_site dir_list))
	) 
	when(isDir(cfg_root) 
	    (dir_list = cons(cfg_root dir_list))
	) 
	if(enable_wildcard then 
	    (name_pattern = TBX_UTIL_Regex_From_Shell(file_name t)) 
	    foreach(dn dir_list 
		(file_list = rexMatchList(name_pattern 
			getDirFiles(dn)
		    )) 
		foreach(fn file_list 
		    (tmp_info[fn] = sprintf(nil "%s/%s" dn fn))
		)
	    ) else
	    foreach(dn dir_list 
		(file_path = sprintf(nil "%s/%s" dn file_name)) 
		when(isFile(file_path) 
		    (tmp_info[file_name] = file_path)
		)
	    )
	) 
	foreach(key tmp_info 
	    (path_info = cons(tmp_info[key] path_info))
	)
	path_info
    )
)
procedure((TBX_UTIL_Set_Layer_Priority layer_list \@optional script_mode) 
    let((script_file port class subclass arr
	    cmd prio_id
	) 
	if(script_mode then 
	    (axlLayerPriorityClearAll) 
	    (script_file = strcat(getWorkingDir() "/tbxlayerprio.scr")) 
	    (port = outfile(script_file "w"))
	    fprintf(port "scriptmode  +i +n\n") 
	    fprintf(port "version 16.6\n") 
	    fprintf(port "setwindow pcb\n") 
	    fprintf(port "generaledit\n") 
	    fprintf(port "layer priority\n")
	    fprintf(port "setwindow form.layerdlg\n") 
	    foreach(lyr layer_list 
		(arr = parseString(lyr "/")) 
		(class = car(arr)) 
		(subclass = cadr(arr))
		fprintf(port "FORM layerdlg treelist 'MULTISEL YES' %s '%s'\n" subclass class) 
		fprintf(port "FORM layerdlg treelist  %s '%s'\n" subclass class) 
		fprintf(port "FORM layerdlg add_tolist\n")
	    ) 
	    fprintf(port "FORM layerdlg apply\n") 
	    fprintf(port "FORM layerdlg done\n") 
	    fprintf(port "setwindow pcb\n")
	    close(port) 
	    (cmd = sprintf(nil "replay %L" script_file)) 
	    (axlShell cmd) 
	    when(isFile(script_file) 
		deleteFile(script_file)
	    ) else
	    (prio_id = 1) 
	    (axlLayerPriorityClearAll) 
	    foreach(lyr layer_list 
		(axlLayerPrioritySet lyr 
		    prio_id++
		)
	    )
	) 
	(axlVisibleUpdate t) t
    )
)
procedure(TBX_UTIL_Show_Att(pwd att_name) 
    let((att port info_file data) 
	when((pwd == "#flowcad") 
	    (att = (axlGetAttachment att_name 
		    'string
		)) 
	    when(att 
		(data = car(linereadstring((att->data))))
	    ) 
	    if(data then 
		(info_file = strcat(getWorkingDir() "/att_info.txt")) 
		(port = outfile(info_file "w")) 
		pprint(data port)
		close(port) 
		(axlUIViewFileCreate info_file "Attachment info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		) else 
		printf("Attachment %s  does not exist\n" att_name)
	    )
	) t
    )
)
procedure((TBX_UTIL_Smart_Convert m_str i_str \@optional arg) 
    let((design_units new_value) 
	if(arg then 
	    (design_units = lowerCase(arg)) else 
	    (design_units = lowerCase(car((axlDBGetDesignUnits))))
	) 
	if(((design_units == "microns") || (design_units == "millimeters") || (design_units == "centimeters") || (design_units == "um") || (design_units == "mm") || (design_units == "cm")) then 
	    (new_value = (axlMKSConvert m_str design_units)) else 
	    (new_value = (axlMKSConvert i_str design_units))
	) new_value
    )
)
procedure(TBX_UTIL_Trim_String(str) 
    let((str_clean) 
	rexCompile("^ *") 
	(str_clean = rexReplace(str "" 0)) 
	rexCompile(" *$") 
	(str_clean = rexReplace(str_clean "" 0))
	str_clean
    )
)
procedure((TBX_UTIL_Update_Enved_Variable def_mode var_name \@optional var_value) 
    let((arr env_file port line data
	    match_def enved_section
	) 
	(var_name = lowerCase(var_name)) 
	(def_mode = lowerCase(def_mode)) 
	(env_file = strcat(axlGetVariable("LOCALENV") "/env")) 
	(port = infile(env_file))
	while((line = _gets(port)) 
	    (data = cons(line data))
	) 
	(data = reverse(data)) 
	close(port) 
	(port = outfile(env_file "w")) 
	foreach(str data 
	    if(isCallable('axlStringRemoveSpaces) then 
		(str = (axlStringRemoveSpaces str)) else 
		(str = TBX_UTIL_Trim_String(str))
	    ) 
	    cond((rexMatchp("^ *###" str) 
		    (enved_section = t) 
		    fprintf(port "%s\n" str)
		) 
		((enved_section && rexMatchp("^ *###" str)) 
		    fprintf(port "%s\n" str)
		) 
		(enved_section 
		    (arr = parseString(lowerCase(str))) 
		    cond(((((car(arr) == "set") || (car(arr) == "unset")) && (cadr(arr) == var_name)) 
			    if((def_mode == "clear") then t else 
				if(var_value then 
				    fprintf(port "%s %s = %s\n" def_mode var_name var_value) else 
				    fprintf(port "%s %s\n" def_mode var_name)
				)
				(match_def = t)
			    )
			) 
			((str == "") t) 
			(t 
			    fprintf(port "%s\n" str)
			)
		    )
		) 
		(t 
		    fprintf(port "%s\n" str)
		)
	    )
	)
	when(((def_mode != "clear") && !match_def) 
	    if(var_value then 
		fprintf(port "%s %s = %s\n" def_mode var_name var_value) else 
		fprintf(port "%s %s\n" def_mode var_name)
	    )
	) 
	close(port) t
    )
)
procedure(TBX_UTIL_Zip_Data(launch_dir arg_list output_file verbose) 
    let((cdsroot zip_exe_win zip_exe_linux port batch_file
	    item_path item_str cid line log_file
	    file_pattern dir_contents sub_dir file_parts cmd
	    enable_wildcard app_dir
	) 
	(app_dir = strcat(getWorkingDir() "/toolbox.run")) 
	unless(isDir(app_dir) 
	    (app_dir = getWorkingDir())
	) 
	(log_file = strcat(app_dir "/cdnzip.log")) 
	when(isFile(output_file) 
	    printf("Info: Deleting file %L before zip...\n" output_file) 
	    deleteFile(output_file)
	)
	(cdsroot = (axlOSSlash 
		cdsGetInstPath()
	    )) 
	(zip_exe_win = strcat(cdsroot "/tools/bin/cdsZip.exe")) 
	(zip_exe_linux = strcat(cdsroot "/tools/bin/cdsZip")) 
	(zip_exe_win = sprintf(nil "%L" zip_exe_win)) 
	(zip_exe_linux = sprintf(nil "%L" zip_exe_linux))
	(output_file = (axlOSSlash 
		simplifyFilename(output_file)
	    )) 
	(output_file = sprintf(nil "%L" output_file)) 
	(item_str = "") 
	foreach(entry arg_list 
	    if((type(entry) == 'list) then 
		if(cadr(entry) then 
		    (enable_wildcard = t) else 
		    (enable_wildcard = nil)
		) 
		if(rexMatchp("/" 
			(axlOSSlash 
			    car(entry)
			)
		    ) then 
		    (file_parts = (axlDMFileParts 
			    (axlOSSlash 
				car(entry)
			    )
			)) 
		    (sub_dir = car(file_parts)) 
		    (file_pattern = caddr(file_parts))
		    when(enable_wildcard 
			(file_pattern = TBX_UTIL_Regex_From_Shell(file_pattern t))
		    ) 
		    (dir_contents = rexMatchList(file_pattern 
			    getDirFiles(strcat(launch_dir "/" sub_dir))
			)) 
		    (dir_contents = mapcar(lambda((x) 
				strcat(sub_dir "/" x)
			    ) dir_contents
			)) else 
		    (file_pattern = car(entry))
		    when(enable_wildcard 
			(file_pattern = TBX_UTIL_Regex_From_Shell(file_pattern t))
		    ) 
		    (dir_contents = rexMatchList(file_pattern 
			    getDirFiles(launch_dir)
			))
		) else
		(dir_contents = list(entry))
	    ) 
	    foreach(de dir_contents 
		(item_path = strcat(launch_dir "/" de)) 
		if((isFile(item_path) || isDir(item_path)) then 
		    (item_str = sprintf(nil "%s %L" item_str de)) else 
		    printf("Warning: Item %L does not exist\n" item_path)
		)
	    )
	) 
	if((item_str != "") then 
	    case(lowerCase(cdsPlat()) 
		("wint" 
		    (batch_file = strcat(app_dir "/cdnzip.bat")) 
		    (port = outfile(batch_file "w")) 
		    fprintf(port "cd /D %s\n" launch_dir) 
		    fprintf(port "%s  -r  %s  %s\n" zip_exe_win output_file item_str)
		    close(port)
		) 
		(t 
		    (batch_file = strcat(app_dir "/cdnzip.sh")) 
		    (port = outfile(batch_file "w")) 
		    fprintf(port "#!/bin/bash\n") 
		    fprintf(port "cd %s\n" launch_dir)
		    fprintf(port "%s  -r  %s  %s\n" zip_exe_linux output_file item_str) 
		    close(port) 
		    (cmd = sprintf(nil "chmod 770 %L" batch_file)) 
		    shell(cmd)
		)
	    ) 
	    when(batch_file 
		(cid = ipcBeginProcess(sprintf(nil "%L" batch_file))) 
		ipcWaitForProcess(cid) 
		(line = t) 
		(port = outfile(log_file "w"))
		while(line 
		    (line = ipcReadProcess(cid 1)) 
		    if(line then 
			when(verbose 
			    printf("%s" line)
			) 
			fprintf(port "%s" line) else
			printf("Zip command finished. Refer to log file %L\n" log_file)
		    )
		) 
		close(port) 
		printf("Note: File %s has been generated\n" output_file)
	    ) else
	    printf("Warning: Items to zip do not exist\n")
	)
	unless(axlGetVariable("FLW_DEBUG") 
	    when((batch_file && isFile(batch_file)) 
		deleteFile(batch_file)
	    )
	) t
    )
)
procedure(TBX_VARIASSY_Annotate_Component_Data() 
    let((label_source_1 label_source_2 dni_processing alt_graphics_style alt_label_prefix
	    alt_label_suffix modify_labels modify_graphics graphics_layer graphics_layer_top
	    graphics_layer_bottom graphics_source variant_attr variant_type text_attr
	    text_attr_1 text_attr_2 attach_to_symbol label_value_1 label_value_2
	    attach_dbid o_list extents result box_info
	    text_dbid cross_line_width cross_scale hatch_line_width hatch_spacing
	    rotation_origin angle group_info group_dbid cmp
	    fixed_line_width annotate_label_2 create_view_label_2 dni_remove_label_2 variant_layer
	    group_type label_data
	) 
	(label_source_1 = upperCase((axlFormGetField 
		    (tbx_variassy_global->formid) "get_labels_from"
		)
	    )) 
	(label_source_2 = upperCase((axlFormGetField 
		    (tbx_variassy_global->formid) "get_labels_from_2"
		)
	    )) 
	(annotate_label_2 = (axlFormGetField 
		(tbx_variassy_global->formid) "annotate_label_2"
	    )) 
	(create_view_label_2 = (axlFormGetField 
		(tbx_variassy_global->formid) "create_view_label_2"
	    ))
	(dni_remove_label_2 = (axlFormGetField 
		(tbx_variassy_global->formid) "dni_remove_label_2"
	    )) 
	(tbx_variassy_global->viewlog = cons(sprintf(nil "   Label content from %L %L" label_source_1 label_source_2) 
		(tbx_variassy_global->viewlog)
	    )) 
	(graphics_source = upperCase((axlFormGetField 
		    (tbx_variassy_global->formid) "get_graphics_from"
		)
	    )) 
	(tbx_variassy_global->viewlog = cons(sprintf(nil "   Graphic data from %L" graphics_source) 
		(tbx_variassy_global->viewlog)
	    )) 
	(attach_to_symbol = (axlFormGetField 
		(tbx_variassy_global->formid) "attach_to_symbol"
	    ))
	(tbx_variassy_global->viewlog = cons(sprintf(nil "   Attach to symbol:   %L" attach_to_symbol) 
		(tbx_variassy_global->viewlog)
	    )) 
	when((axlFormGetField 
		(tbx_variassy_global->formid) "use_fixed_outline_width"
	    ) 
	    (fixed_line_width = (axlFormGetField 
		    (tbx_variassy_global->formid) "fixed_outline_width"
		))
	) 
	(graphics_layer_top = strcat((axlMapClassName "PACKAGE GEOMETRY") "/" graphics_source "_TOP")) 
	(graphics_layer_bottom = strcat((axlMapClassName "PACKAGE GEOMETRY") "/" graphics_source "_BOTTOM")) 
	(tbx_variassy_global->viewlog = cons(sprintf(nil "   Graphics source layers are: %L" 
		    list(graphics_layer_top graphics_layer_bottom)
		) 
		(tbx_variassy_global->viewlog)
	    ))
	if((axlFormGetField 
		(tbx_variassy_global->formid) "modify_dni_style"
	    ) then 
	    (dni_processing = upperCase((axlFormGetField 
			(tbx_variassy_global->formid) "dni_style"
		    )
		)) else 
	    (dni_processing = "AS_IS")
	) 
	(tbx_variassy_global->viewlog = cons(sprintf(nil "   DNI parts: %L" dni_processing) 
		(tbx_variassy_global->viewlog)
	    )) 
	(cross_line_width = (axlFormGetField 
		(tbx_variassy_global->formid) "cross_line_width"
	    )) 
	(cross_scale = (axlFormGetField 
		(tbx_variassy_global->formid) "cross_scale"
	    )) 
	((tbx_variassy_global->drawParam)->crossLineWidth = cross_line_width)
	((tbx_variassy_global->drawParam)->crossScale = cross_scale) 
	(tbx_variassy_global->viewlog = cons(sprintf(nil "   DNI Cross params (line_width scale): %L %L" cross_line_width cross_scale) 
		(tbx_variassy_global->viewlog)
	    )) 
	(modify_labels = (axlFormGetField 
		(tbx_variassy_global->formid) "modify_alt_labels"
	    )) 
	(modify_graphics = (axlFormGetField 
		(tbx_variassy_global->formid) "modify_alt_graphics"
	    )) 
	(tbx_variassy_global->viewlog = cons(sprintf(nil "   Alt Parts: Modify labels %L, Modify graphics: %L" modify_labels modify_graphics) 
		(tbx_variassy_global->viewlog)
	    ))
	(alt_label_prefix = (axlFormGetField 
		(tbx_variassy_global->formid) "alt_label_prefix"
	    )) 
	(alt_label_suffix = (axlFormGetField 
		(tbx_variassy_global->formid) "alt_label_suffix"
	    )) 
	rexCompile("^ *") 
	(alt_label_prefix = rexReplace(alt_label_prefix "" 0)) 
	(alt_label_suffix = rexReplace(alt_label_suffix "" 0))
	rexCompile(" *$") 
	(alt_label_prefix = rexReplace(alt_label_prefix "" 0)) 
	(alt_label_suffix = rexReplace(alt_label_suffix "" 0)) 
	(tbx_variassy_global->viewlog = cons(sprintf(nil "   Alt label prefix: %L suffix: %L" alt_label_prefix alt_label_suffix) 
		(tbx_variassy_global->viewlog)
	    )) 
	(alt_graphics_style = upperCase((axlFormGetField 
		    (tbx_variassy_global->formid) "alt_graphics_style"
		)
	    ))
	(tbx_variassy_global->viewlog = cons(sprintf(nil "   Alt graphics style: %L" alt_graphics_style) 
		(tbx_variassy_global->viewlog)
	    )) 
	(hatch_line_width = (axlFormGetField 
		(tbx_variassy_global->formid) "hatch_line_width"
	    )) 
	(hatch_spacing = (axlFormGetField 
		(tbx_variassy_global->formid) "hatch_spacing"
	    )) 
	((tbx_variassy_global->drawParam)->hatchLineWidth = hatch_line_width) 
	((tbx_variassy_global->drawParam)->hatchSpacing = hatch_spacing)
	(tbx_variassy_global->viewlog = cons(sprintf(nil "   Alt hatch shape params (line_width spacing): %L %L" hatch_line_width hatch_spacing) 
		(tbx_variassy_global->viewlog)
	    )) 
	(variant_attr = (tbx_variassy_global->variantAttr)) 
	(text_attr_1 = (tbx_variassy_global->textAttr1)) 
	(text_attr_2 = (tbx_variassy_global->textAttr2)) 
	(group_info = (tbx_variassy_global->groupInfo))
	foreach(grp group_info 
	    (group_dbid = (axlDBCreateGroup grp "generic" nil)) 
	    (variant_layer = (group_info[grp]->groupLayer)) 
	    (group_type = (group_info[grp]->groupType))
	    foreach(refdes 
		(group_info[grp]->refdes) 
		(cmp = car((axlSelectByName "COMPREFDES" refdes))) 
		(variant_type = get(variant_attr[refdes] 
			'VARTYPE
		    )) 
		(label_value_1 = get(variant_attr[refdes] 
			stringToSymbol(label_source_1)
		    ))
		(label_value_2 = get(variant_attr[refdes] 
			stringToSymbol(label_source_2)
		    )) 
		unless(label_value_1 
		    (label_value_1 = "???")
		) 
		unless(label_value_2 
		    (label_value_2 = "???")
		) 
		if(((variant_attr[refdes]->MIRROR) == "YES") then 
		    (graphics_layer = graphics_layer_bottom) else 
		    (graphics_layer = graphics_layer_top)
		) 
		if(attach_to_symbol then 
		    (attach_dbid = (cmp->symbol)) else 
		    (attach_dbid = nil)
		)
		case(variant_type 
		    ("BASE" 
			if((group_type == "2") then 
			    (label_data = list(list(label_value_2 
					text_attr_2[refdes] variant_layer
				    )
				)) else 
			    (label_data = list(list(label_value_1 
					text_attr_1[refdes] variant_layer
				    )
				))
			    when((annotate_label_2 && !create_view_label_2) 
				(label_data = cons(list(label_value_2 
					    text_attr_2[refdes] variant_layer
					) label_data
				    ))
			    )
			) 
			(result = TBX_VARIASSY_Create_Label_Text(label_data attach_dbid group_dbid nil)) 
			TBX_VARIASSY_Copy_Graphics_Wrapper((cmp->symbol) graphics_layer variant_layer attach_dbid group_dbid
			    "unfill_shape" fixed_line_width
			)
		    ) 
		    ("CHANGE" 
			when(modify_labels 
			    (label_value_1 = strcat(alt_label_prefix label_value_1 alt_label_suffix)) 
			    (label_value_2 = strcat(alt_label_prefix label_value_2 alt_label_suffix))
			) 
			if((group_type == "2") then 
			    (label_data = list(list(label_value_2 
					text_attr_2[refdes] variant_layer
				    )
				)) else 
			    (label_data = list(list(label_value_1 
					text_attr_1[refdes] variant_layer
				    )
				))
			    when((annotate_label_2 && !create_view_label_2) 
				(label_data = cons(list(label_value_2 
					    text_attr_2[refdes] variant_layer
					) label_data
				    ))
			    )
			) 
			(result = TBX_VARIASSY_Create_Label_Text(label_data attach_dbid group_dbid nil)) 
			if(modify_graphics then 
			    case(alt_graphics_style 
				("HATCH_SHAPE" 
				    TBX_VARIASSY_Copy_Graphics_Wrapper((cmp->symbol) graphics_layer variant_layer attach_dbid group_dbid
					"hatch_shape" fixed_line_width
				    )
				) 
				(t t)
			    ) else 
			    TBX_VARIASSY_Copy_Graphics_Wrapper((cmp->symbol) graphics_layer variant_layer attach_dbid group_dbid
				"unfill_shape" fixed_line_width
			    )
			)
		    ) 
		    ("DNI" 
			case(dni_processing 
			    ("AS_IS" 
				if((group_type == "2") then 
				    (label_data = list(list(label_value_2 
						text_attr_2[refdes] variant_layer
					    )
					)) else 
				    (label_data = list(list(label_value_1 
						text_attr_1[refdes] variant_layer
					    )
					))
				    when((annotate_label_2 && !create_view_label_2 && !dni_remove_label_2) 
					(label_data = cons(list(label_value_2 
						    text_attr_2[refdes] variant_layer
						) label_data
					    ))
				    )
				) 
				(result = TBX_VARIASSY_Create_Label_Text(label_data attach_dbid group_dbid nil)) 
				TBX_VARIASSY_Copy_Graphics_Wrapper((cmp->symbol) graphics_layer variant_layer attach_dbid group_dbid
				    "unfill_shape" fixed_line_width
				)
			    ) 
			    ("REMOVE_ALL" t) 
			    ("REMOVE_LABEL_ONLY" 
				TBX_VARIASSY_Copy_Graphics_Wrapper((cmp->symbol) graphics_layer variant_layer attach_dbid group_dbid
				    "unfill_shape" fixed_line_width
				)
			    ) 
			    ("DRAW_CROSS_GRAPHICS" 
				if((group_type == "2") then 
				    (label_data = list(list(label_value_2 
						text_attr_2[refdes] variant_layer
					    )
					)) else 
				    (label_data = list(list(label_value_1 
						text_attr_1[refdes] variant_layer
					    )
					))
				    when((annotate_label_2 && !create_view_label_2 && !dni_remove_label_2) 
					(label_data = cons(list(label_value_2 
						    text_attr_2[refdes] variant_layer
						) label_data
					    ))
				    )
				) 
				(result = TBX_VARIASSY_Create_Label_Text(label_data attach_dbid group_dbid nil)) 
				TBX_VARIASSY_Copy_Graphics_Wrapper((cmp->symbol) graphics_layer variant_layer attach_dbid group_dbid
				    "unfill_shape" fixed_line_width
				) 
				(graphics_layer = graphics_layer_top)
				(o_list = list()) 
				foreach(ch 
				    (((cmp->symbol)->definition)->children) 
				    when(((((ch->objType) == "line") || ((ch->objType) == "path") || ((ch->objType) == "shape") || ((ch->objType) == "polygon")) && ((ch->layer) == graphics_layer)) 
					(o_list = cons(ch o_list))
				    )
				) 
				(extents = (axlDBGetExtents o_list nil)) 
				(box_info = TBX_VARIASSY_Utils_Form_Box(list(extents) 
					((cmp->symbol)->xy)
				    )) 
				when(box_info 
				    TBX_VARIASSY_Draw_Cross(box_info 
					((cmp->symbol)->xy) 
					((cmp->symbol)->rotation) 
					((cmp->symbol)->isMirrored) variant_layer
					attach_dbid group_dbid
				    )
				)
			    )
			    ("DRAW_CROSS_LABEL" 
				TBX_VARIASSY_Copy_Graphics_Wrapper((cmp->symbol) graphics_layer variant_layer attach_dbid group_dbid
				    "unfill_shape" fixed_line_width
				) 
				if((group_type == "2") then 
				    (label_data = list(list(label_value_2 
						text_attr_2[refdes] variant_layer
					    )
					)) else 
				    (label_data = list(list(label_value_1 
						text_attr_1[refdes] variant_layer
					    )
					))
				    when((annotate_label_2 && !create_view_label_2 && !dni_remove_label_2) 
					(label_data = cons(list(label_value_2 
						    text_attr_2[refdes] variant_layer
						) label_data
					    ))
				    )
				) 
				(result = TBX_VARIASSY_Create_Label_Text(label_data attach_dbid group_dbid nil)) 
				if(result then 
				    (result = TBX_VARIASSY_Create_Label_Text(label_data nil nil "tmp")) 
				    foreach(entry result 
					(text_dbid = car(entry)) 
					(text_attr = cadr(entry)) 
					(box_info = TBX_VARIASSY_Utils_Form_Box(list((text_dbid->bBox)) 
						list(0.0 0.0)
					    ))
					(rotation_origin = (text_attr->xy)) 
					(angle = (text_attr->rotation)) 
					when(box_info 
					    TBX_VARIASSY_Draw_Cross(box_info rotation_origin angle nil variant_layer
						attach_dbid group_dbid
					    ) 
					    (axlDeleteObject text_dbid)
					)
				    ) else
				    printf("Error: Cannot draw cross through label of %s\n" 
					(cmp->name)
				    )
				)
			    )
			)
		    ) 
		    (t t)
		)
	    )
	)
    )
)
procedure(TBX_VARIASSY_Annotate_Layer_Data(variant_cfg mode source_layers) 
    let((group_dbid result map_info source_data) 
	(map_info = makeTable("map_info_table" nil)) 
	case(mode 
	    ("generic" 
		(map_info[strcat("VAS_" 
			(variant_cfg->sysName) "_TOP_GENERIC"
		    )] = car((variant_cfg->layers))) 
		(map_info[strcat("VAS_" 
			(variant_cfg->sysName) "_BOT_GENERIC"
		    )] = cadr((variant_cfg->layers))) 
		when((length((variant_cfg->layers)) > 2) 
		    (map_info[strcat("VAS_" 
			    (variant_cfg->sysName) "_2_TOP_GENERIC"
			)] = caddr((variant_cfg->layers))) 
		    (map_info[strcat("VAS_" 
			    (variant_cfg->sysName) "_2_BOT_GENERIC"
			)] = nth(3 
			    (variant_cfg->layers)
			))
		)
	    ) 
	    ("top_only" 
		(map_info[strcat("VAS_" 
			(variant_cfg->sysName) "_TOP_0"
		    )] = car((variant_cfg->layers))) 
		when((length((variant_cfg->layers)) > 2) 
		    (map_info[strcat("VAS_" 
			    (variant_cfg->sysName) "_2_TOP_0"
			)] = caddr((variant_cfg->layers)))
		)
	    ) 
	    ("bottom_only" 
		(map_info[strcat("VAS_" 
			(variant_cfg->sysName) "_BOT_0"
		    )] = cadr((variant_cfg->layers))) 
		when((length((variant_cfg->layers)) > 2) 
		    (map_info[strcat("VAS_" 
			    (variant_cfg->sysName) "_2_BOT_0"
			)] = nth(3 
			    (variant_cfg->layers)
			))
		)
	    )
	) 
	(axlVisibleDesign nil) 
	foreach(lyr source_layers 
	    (axlVisibleLayer lyr t)
	)
	(axlVisibleUpdate nil) 
	(axlSetFindFilter ?enabled 
	    list("noall" "shapes" "lines" "text" "dynthemals") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	when((axlGetSelSet) 
	    (source_data = setof(x 
		    (axlGetSelSet) 
		    !((x->parent) && (upperCase(((x->parent)->type)) == "PACKAGE"))
		)) 
	    foreach(key map_info 
		(result = (axlSelectByName "GROUP" key)) 
		if(result then 
		    (group_dbid = car(result)) else 
		    (group_dbid = (axlDBCreateGroup key "generic" nil))
		) 
		TBX_VARIASSY_Copy_Layer_Data(source_data 
		    map_info[key] group_dbid
		)
	    )
	)
	(axlClearSelSet) t
    )
)
procedure(TBX_VARIASSY_Assign_Groups(attr_data variant_cfg) 
    let((group_info group_base_top group_base_bot group_base_top_2 group_base_bot_2
	    group_name_top group_name_bot group_name_top_2 group_name_bot_2 group_name_1
	    group_name_2 refdes_info side top_bottom arr
	    group_layer group_type refdes_list color_id_str
	) 
	(group_info = makeTable("group_info_table" nil)) 
	(refdes_info = makeTable("refdes_info_table" nil)) 
	(group_base_top = strcat("VAS_" 
		(variant_cfg->sysName) "_TOP"
	    )) 
	(group_base_bot = strcat("VAS_" 
		(variant_cfg->sysName) "_BOT"
	    ))
	(group_base_top_2 = strcat("VAS_" 
		(variant_cfg->sysName) "_2_TOP"
	    )) 
	(group_base_bot_2 = strcat("VAS_" 
		(variant_cfg->sysName) "_2_BOT"
	    )) 
	foreach(refdes attr_data 
	    if(((attr_data[refdes]->OBJECT_COLOR) && (type((attr_data[refdes]->OBJECT_COLOR)) == 'fixnum)) then 
		(color_id_str = sprintf(nil "%d" 
			(attr_data[refdes]->OBJECT_COLOR)
		    )) 
		(group_name_top = upperCase(strcat(group_base_top "_" color_id_str))) 
		(group_name_bot = upperCase(strcat(group_base_bot "_" color_id_str)))
		(group_name_top_2 = upperCase(strcat(group_base_top_2 "_" color_id_str))) 
		(group_name_bot_2 = upperCase(strcat(group_base_bot_2 "_" color_id_str))) else 
		(group_name_top = upperCase(strcat(group_base_top "_0"))) 
		(group_name_bot = upperCase(strcat(group_base_bot "_0")))
		(group_name_top_2 = upperCase(strcat(group_base_top_2 "_0"))) 
		(group_name_bot_2 = upperCase(strcat(group_base_bot_2 "_0")))
	    ) 
	    if(((attr_data[refdes]->MIRROR) == "YES") then 
		(group_name_1 = group_name_bot) 
		(group_name_2 = group_name_bot_2) else
		(group_name_1 = group_name_top) 
		(group_name_2 = group_name_top_2)
	    ) 
	    (refdes_info[group_name_1] = cons(refdes 
		    refdes_info[group_name_1]
		))
	    when((length((variant_cfg->layers)) > 2) 
		(refdes_info[group_name_2] = cons(refdes 
			refdes_info[group_name_2]
		    ))
	    )
	) 
	foreach(grp refdes_info 
	    (refdes_list = sort(refdes_info[grp] nil)) 
	    (arr = parseString(grp "_")) 
	    if((length(arr) > 4) then 
		(side = nth(3 arr)) 
		(top_bottom = list(caddr((variant_cfg->layers)) 
			cadddr((variant_cfg->layers))
		    )) 
		(group_type = "2")
		else 
		(side = caddr(arr)) 
		(top_bottom = list(car((variant_cfg->layers)) 
			cadr((variant_cfg->layers))
		    )) 
		(group_type = "1")
	    )
	    if((side == "TOP") then 
		(group_layer = car(top_bottom)) else 
		(group_layer = cadr(top_bottom))
	    ) 
	    (group_info[grp] = list(nil 
		    'refdes refdes_list 
		    'groupLayer group_layer
		    'groupType group_type
		))
	) group_info
    )
)
procedure(TBX_VARIASSY_Build_Popup_List(popup_name) 
    let((config base_list display_prefix dispatch_prefix pretty_name
	    popup_list class_name
	) 
	(popup_list = tconc(nil nil)) 
	case(popup_name 
	    ("label_master" 
		(config = list(list("REF DES" "Refdes" "refdes") 
			list("COMPONENT VALUE" "Value" "value") 
			list("USER PART NUMBER" "PartNr" "partnr") 
			list("DEVICE TYPE" "DevType" "devtype")
		    )) 
		foreach(entry config 
		    (class_name = car(entry)) 
		    (display_prefix = cadr(entry)) 
		    (dispatch_prefix = caddr(entry))
		    (base_list = TBX_VARIASSY_Get_Class_Top_Bottom_Base(class_name)) 
		    foreach(bn base_list 
			(pretty_name = strcat(upperCase(substring(bn 1 1)) 
				lowerCase(substring(bn 2))
			    )) 
			tconc(popup_list 
			    list(strcat(display_prefix " - " pretty_name) 
				strcat(dispatch_prefix "_" 
				    lowerCase(bn)
				)
			    )
			)
		    )
		) 
		(popup_list = cdar(popup_list))
	    ) 
	    ("graphics" 
		(class_name = "PACKAGE GEOMETRY") 
		(display_prefix = "PkgGeom") 
		(base_list = TBX_VARIASSY_Get_Class_Top_Bottom_Base(class_name)) 
		(base_list = remove("SOLDERMASK" base_list))
		(base_list = remove("PASTEMASK" base_list)) 
		foreach(bn base_list 
		    case(lowerCase(bn) 
			("assembly" 
			    (pretty_name = "Assembly")
			) 
			("place_bound" 
			    (pretty_name = "Place_Bound")
			) 
			("silkscreen" 
			    (pretty_name = "Silkscreen")
			) 
			("display" 
			    (pretty_name = "Display")
			)
			("dfa_bound" 
			    (pretty_name = "DFA_Bound")
			) 
			(t 
			    (pretty_name = strcat(upperCase(substring(bn 1 1)) 
				    lowerCase(substring(bn 2))
				))
			)
		    ) 
		    tconc(popup_list 
			list(pretty_name 
			    lowerCase(bn)
			)
		    )
		) 
		(popup_list = cdar(popup_list))
	    )
	) popup_list
    )
)
procedure(TBX_VARIASSY_Build_Variant_Popup(variant_names) 
    let((popup_list) 
	(popup_list = list()) 
	foreach(vn variant_names 
	    (popup_list = cons(list(vn vn) popup_list))
	) 
	(popup_list = sortcar(popup_list nil)) 
	when((length(popup_list) >= 2) 
	    (popup_list = cons(list("All Variants" "ALL_VARIANTS") popup_list))
	)
	(popup_list = cons(list("Core Design" "CORE_DESIGN") popup_list)) 
	(axlFormBuildPopup 
	    (tbx_variassy_global->formid) "variant" popup_list
	) popup_list
    )
)
procedure(TBX_VARIASSY_Callback(form_handle) 
    let((input_file output_file file_name variant_data attr_list
	    FORM_FILE1 fid1 label_master_1 label_master_2 attr_name
	    mirror_style direction distance orgvis winbox
	    cell alt_color_id variant_color_wins_over_group use_alt_color use_dni_color
	    use_group_color variant_file_display str_len vn_user_selection vn_names
	    full_clean variant_name annotate_label_2 create_view_label_2 mirror_to_top
	    overlay_layers variant_cfg color_list color_id row_num
	    dni_color_id context_list popup_data
	) 
	case((form_handle->curField) 
	    ("done" 
		TBX_VARIASSY_Save_Config(nil) 
		(axlFormClose form_handle) 
		(axlVisibleUpdate t)
	    ) 
	    ("cancel" 
		(axlFormClose form_handle) 
		(axlVisibleUpdate t)
	    ) 
	    ("modify_dni_style" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "dni_style" t) else 
		    (axlFormSetFieldEditable form_handle "dni_style" nil)
		)
	    ) 
	    ("dni_style" 
		if((((form_handle->curValue) == "remove_all") || ((form_handle->curValue) == "remove_label_only")) then 
		    (axlFormSetFieldEditable form_handle "dni_remove_label_2" nil) 
		    (axlFormSetField form_handle "dni_remove_label_2" t) else
		    if((axlFormGetField form_handle "annotate_label_2") then 
			(axlFormSetFieldEditable form_handle "dni_remove_label_2" t) else 
			(axlFormSetFieldEditable form_handle "dni_remove_label_2" nil)
		    )
		)
	    )
	    ("modify_dni_color" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "dni_color_id" t) else 
		    (axlFormSetFieldEditable form_handle "dni_color_id" nil)
		)
	    ) 
	    ("dni_color_id" 
		(color_list = (axlCVFColorChooserDlg 0)) 
		when(color_list 
		    (axlFormSetField form_handle "dni_color_id" 
			car(color_list)
		    ) 
		    (axlVisibleUpdate t) 
		    ((tbx_variassy_global->colorSwatch)->dni = car(color_list))
		)
	    ) 
	    ("get_graphics_from" 
		if(((upperCase((form_handle->curValue)) == "PLACE_BOUND") || (upperCase((form_handle->curValue)) == "DFA_BOUND")) then 
		    (axlFormSetFieldEditable form_handle "modify_alt_graphics" t) 
		    (axlFormSetFieldEditable form_handle "alt_graphics_style" t) else
		    (axlFormSetFieldEditable form_handle "modify_alt_graphics" nil) 
		    (axlFormSetField form_handle "modify_alt_graphics" nil) 
		    (axlFormSetFieldEditable form_handle "alt_graphics_style" nil)
		)
	    ) 
	    ("modify_alt_labels" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "alt_label_prefix" t) 
		    (axlFormSetFieldEditable form_handle "alt_label_suffix" t) else
		    (axlFormSetFieldEditable form_handle "alt_label_prefix" nil) 
		    (axlFormSetFieldEditable form_handle "alt_label_suffix" nil)
		)
	    ) 
	    ("modify_alt_color" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "alt_color_id" t) else 
		    (axlFormSetFieldEditable form_handle "alt_color_id" nil)
		)
	    )
	    ("alt_color_id" 
		(color_list = (axlCVFColorChooserDlg 0)) 
		when(color_list 
		    (axlFormSetField form_handle "alt_color_id" 
			car(color_list)
		    ) 
		    (axlVisibleUpdate t) 
		    ((tbx_variassy_global->colorSwatch)->alt = car(color_list))
		)
	    ) 
	    ("attach_to_symbol" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "retain_existing_label_attr" t) else 
		    (axlFormSetFieldEditable form_handle "retain_existing_label_attr" nil)
		)
	    ) 
	    ("annotate_label_2" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "get_labels_from_2" t) 
		    (axlFormSetFieldEditable form_handle "label_master_2" t) 
		    (axlFormSetFieldEditable form_handle "create_view_label_2" t)
		    when((((axlFormGetField form_handle "dni_style") == "draw_cross_graphics") || 
			    ((axlFormGetField form_handle "dni_style") == "draw_cross_label")) 
			(axlFormSetFieldEditable form_handle "dni_remove_label_2" t)
		    ) else 
		    (axlFormSetFieldEditable form_handle "get_labels_from_2" nil) 
		    (axlFormSetFieldEditable form_handle "label_master_2" nil) 
		    (axlFormSetFieldEditable form_handle "create_view_label_2" nil)
		    (axlFormSetFieldEditable form_handle "dni_remove_label_2" nil)
		)
	    ) 
	    ("create_view_label_2" 
		when((!(form_handle->curValue) && (axlFormGetField form_handle "retain_existing_label_attr")) 
		    (axlFormSetField form_handle "retain_existing_label_attr" nil)
		)
	    ) 
	    ("retain_existing_label_attr" 
		when(((form_handle->curValue) && (axlFormGetField form_handle "annotate_label_2") && 
			!(axlFormGetField form_handle "create_view_label_2")) 
		    (axlFormSetField form_handle "create_view_label_2" t)
		)
	    )
	    ("use_fixed_outline_width" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "fixed_outline_width" t) else 
		    (axlFormSetFieldEditable form_handle "fixed_outline_width" nil)
		)
	    ) 
	    ("bottom_view_handling" 
		case(lowerCase((form_handle->curValue)) 
		    ("no_action" 
			(axlFormSetFieldEditable form_handle "direction" nil) 
			(axlFormSetFieldEditable form_handle "distance_value" nil) 
			(axlFormSetFieldEditable form_handle "attach_to_symbol" t) 
			(axlFormSetFieldEditable form_handle "retain_existing_label_attr" t)
		    ) 
		    ("mirror_to_top" 
			(axlFormSetFieldEditable form_handle "direction" t) 
			(axlFormSetFieldEditable form_handle "distance_value" t) 
			(axlFormSetField form_handle "attach_to_symbol" nil) 
			(axlFormSetFieldEditable form_handle "attach_to_symbol" nil)
			(axlFormSetFieldEditable form_handle "retain_existing_label_attr" nil) 
			(axlFormSetField form_handle "retain_existing_label_attr" nil)
		    ) 
		    ("mirror_on_bottom" 
			(axlFormSetFieldEditable form_handle "direction" nil) 
			(axlFormSetFieldEditable form_handle "distance_value" nil) 
			(axlFormSetField form_handle "attach_to_symbol" nil) 
			(axlFormSetFieldEditable form_handle "attach_to_symbol" nil)
			(axlFormSetFieldEditable form_handle "retain_existing_label_attr" nil) 
			(axlFormSetField form_handle "retain_existing_label_attr" nil)
		    )
		)
	    ) 
	    ("top_layer_specify" 
		(FORM_FILE1 = TBX_FORM_Get_Name((tbx_variassy_global->licCheck) "variassy_include")) 
		(fid1 = (axlFormCreate 
			gensym() FORM_FILE1 
			'(e outer) 
			'TBX_VARIASSY_Include_Layers_Callback
			t nil
		    )) 
		TBX_FORM_Init_Header(fid1 "Licensed for " 
		    (tbx_variassy_global->licCheck) 
		    (tbx_variassy_global->version)
		) 
		(axlFormSetField fid1 "available_layers" 
		    TBX_VARIASSY_Get_Subclass_Info()
		)
		(axlFormSetField fid1 "selected_layers" 
		    ((tbx_variassy_global->includeLayers)->top)
		) 
		((tbx_variassy_global->includeLayers)->tmpSelection = ((tbx_variassy_global->includeLayers)->top)) 
		((tbx_variassy_global->includeLayers)->mode = "top") 
		(axlFormDisplay fid1) 
		TBX_FORM_Delete((tbx_variassy_global->licCheck) FORM_FILE1)
	    ) 
	    ("bottom_layer_specify" 
		(FORM_FILE1 = TBX_FORM_Get_Name((tbx_variassy_global->licCheck) "variassy_include")) 
		(fid1 = (axlFormCreate 
			gensym() FORM_FILE1 
			'(e outer) 
			'TBX_VARIASSY_Include_Layers_Callback
			t nil
		    )) 
		TBX_FORM_Init_Header(fid1 "Licensed for " 
		    (tbx_variassy_global->licCheck) 
		    (tbx_variassy_global->version)
		) 
		(axlFormSetField fid1 "available_layers" 
		    TBX_VARIASSY_Get_Subclass_Info()
		)
		(axlFormSetField fid1 "selected_layers" 
		    ((tbx_variassy_global->includeLayers)->bottom)
		) 
		((tbx_variassy_global->includeLayers)->tmpSelection = ((tbx_variassy_global->includeLayers)->bottom)) 
		((tbx_variassy_global->includeLayers)->mode = "bottom") 
		(axlFormDisplay fid1) 
		TBX_FORM_Delete((tbx_variassy_global->licCheck) FORM_FILE1)
	    ) 
	    ("generic_layer_specify" 
		(FORM_FILE1 = TBX_FORM_Get_Name((tbx_variassy_global->licCheck) "variassy_include")) 
		(fid1 = (axlFormCreate 
			gensym() FORM_FILE1 
			'(e outer) 
			'TBX_VARIASSY_Include_Layers_Callback
			t nil
		    )) 
		TBX_FORM_Init_Header(fid1 "Licensed for " 
		    (tbx_variassy_global->licCheck) 
		    (tbx_variassy_global->version)
		) 
		(axlFormSetField fid1 "available_layers" 
		    TBX_VARIASSY_Get_Subclass_Info()
		)
		(axlFormSetField fid1 "selected_layers" 
		    ((tbx_variassy_global->includeLayers)->generic)
		) 
		((tbx_variassy_global->includeLayers)->tmpSelection = ((tbx_variassy_global->includeLayers)->generic)) 
		((tbx_variassy_global->includeLayers)->mode = "generic") 
		(axlFormDisplay fid1) 
		TBX_FORM_Delete((tbx_variassy_global->licCheck) FORM_FILE1)
	    )
	    ("include_other_layers" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "top_layer_specify" t) 
		    (axlFormSetFieldEditable form_handle "bottom_layer_specify" t) 
		    (axlFormSetFieldEditable form_handle "generic_layer_specify" t)
		    else 
		    (axlFormSetFieldEditable form_handle "top_layer_specify" nil) 
		    (axlFormSetFieldEditable form_handle "bottom_layer_specify" nil) 
		    (axlFormSetFieldEditable form_handle "generic_layer_specify" nil)
		)
	    ) 
	    ("update_custom_variables" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "copy_custom_variables_to_variant_view" t) else 
		    (axlFormSetFieldEditable form_handle "copy_custom_variables_to_variant_view" nil)
		)
	    ) 
	    ("variant_file_load" 
		if((axlOKToProceed) then 
		    (file_name = (axlDMFileBrowse nil nil ?optFilters "Project Files (*.lst)|*.lst"
			    ?noSticky t
			)) 
		    (tbx_variassy_global->viewlog = cons(sprintf(nil "-->Reading external variant file %L" file_name) 
			    (tbx_variassy_global->viewlog)
			)) 
		    if(file_name then 
			(str_len = strlen(file_name)) 
			if((str_len > 55) then 
			    (variant_file_display = substring(file_name 
				    (str_len - 55)
				)) 
			    (variant_file_display = strcat("..." variant_file_display)) else
			    (variant_file_display = file_name)
			) 
			if(isFile(file_name) then 
			    (variant_data = TBX_VARIASSY_Load_File(file_name "list")) 
			    if(variant_data then 
				(axlFormSetField form_handle "variant_file" variant_file_display) 
				(tbx_variassy_global->variantData = variant_data) 
				(tbx_variassy_global->variantNames = TBX_VARIASSY_Get_Variant_Names((tbx_variassy_global->variantData)))
				(popup_data = TBX_VARIASSY_Build_Variant_Popup((tbx_variassy_global->variantNames))) 
				if((length(popup_data) > 1) then 
				    (axlFormSetField form_handle "variant" "ALL_VARIANTS") else 
				    (axlFormSetField form_handle "variant" "CORE_DESIGN")
				) else 
				(tbx_variassy_global->viewlog = cons(sprintf(nil "-->Error: Invalid format in file %L" file_name) 
					(tbx_variassy_global->viewlog)
				    ))
			    ) else
			    (tbx_variassy_global->viewlog = cons(sprintf(nil "-->Error: File %L does not exist" file_name) 
				    (tbx_variassy_global->viewlog)
				))
			)
			else 
			(axlFormSetField form_handle "variant_file" "*** No file selected ***")
		    )
		    else 
		    (axlUIWPrint form_handle "E - Finish current command first!")
		)
	    ) 
	    ("color_grid" 
		caseq((form_handle->event) 
		    (rightpopup 
			case((form_handle->curValue) 
			    ("add_row" 
				(tbx_variassy_global->colorGridRowCnt = ((tbx_variassy_global->colorGridRowCnt) + 1)) 
				(axlFormGridInsertRows form_handle "color_grid" 
				    (tbx_variassy_global->colorGridRowCnt) 1
				) 
				(row_num = (tbx_variassy_global->colorGridRowCnt)) 
				TBX_VARIASSY_Init_Empty_Grid_Row(form_handle row_num)
			    ) 
			    ("delete_row" 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 1) 
				(cell->row = (form_handle->row)) 
				if(((tbx_variassy_global->colorGridRowCnt) >= 2) then 
				    (axlFormGridDeleteRows form_handle "color_grid" 
					(form_handle->row) 1
				    ) 
				    (tbx_variassy_global->colorGridRowCnt = ((tbx_variassy_global->colorGridRowCnt) - 1)) else
				    (row_num = 1) 
				    TBX_VARIASSY_Init_Empty_Grid_Row(form_handle row_num)
				)
				(axlFormGridUpdate form_handle "color_grid")
			    )
			) 
			(axlFormGridUpdate form_handle "color_grid")
		    ) 
		    (cellselect 
			when(((form_handle->col) == 4) 
			    (color_id = car((axlCVFColorChooserDlg 0))) 
			    when(color_id 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 3) 
				(cell->row = (form_handle->row)) 
				(cell->value = color_id)
				(cell->noEdit = t) 
				(cell->backColor = color_id) 
				(cell->textColor = color_id) 
				(axlFormSetField form_handle "color_grid" cell)
			    ) 
			    (axlFormGridUpdate form_handle "color_grid")
			)
		    ) 
		    (change t)
		)
	    ) 
	    ("enable_group_color" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "variant_color_wins_over_group" t) else 
		    (axlFormSetFieldEditable form_handle "variant_color_wins_over_group" nil)
		    (axlFormSetField form_handle "variant_color_wins_over_group" nil)
		)
	    )
	    ("run" 
		(orgvis = (axlVisibleGet)) 
		(winbox = (axlWindowBoxGet)) 
		(tbx_variassy_global->viewlog = cons(sprintf(nil "-------------------------------------------------------------") 
			(tbx_variassy_global->viewlog)
		    )) 
		(tbx_variassy_global->viewlog = cons(sprintf(nil "Start Generate assembly variant views: %L" 
			    getCurrentTime()
			) 
			(tbx_variassy_global->viewlog)
		    ))
		(tbx_variassy_global->viewlog = cons(sprintf(nil "-------------------------------------------------------------") 
			(tbx_variassy_global->viewlog)
		    )) 
		(attr_list = (tbx_variassy_global->defaultAttrNames)) 
		(use_group_color = (axlFormGetField form_handle "enable_group_color")) 
		(use_alt_color = (axlFormGetField form_handle "modify_alt_color")) 
		(use_dni_color = (axlFormGetField form_handle "modify_dni_color"))
		when(use_group_color 
		    ((tbx_variassy_global->colorSpec)->base = TBX_VARIASSY_Extract_Color_Grid_Data(t)) 
		    ((tbx_variassy_global->colorSpec)->regxp = TBX_VARIASSY_Parse_Color_Spec(((tbx_variassy_global->colorSpec)->base))) 
		    foreach(entry 
			((tbx_variassy_global->colorSpec)->base) 
			(attr_name = upperCase(car(entry))) 
			unless(memq(stringToSymbol(attr_name) attr_list) 
			    (attr_list = cons(stringToSymbol(attr_name) attr_list))
			)
		    )
		) 
		(tbx_variassy_global->viewlog = cons(sprintf(nil "-->Reading attributes from master design using attributes %L" attr_list) 
			(tbx_variassy_global->viewlog)
		    )) 
		(tbx_variassy_global->designAttr = TBX_VARIASSY_Extract_Master_Design(attr_list)) 
		(tbx_variassy_global->viewlog = cons(sprintf(nil "-->Reading FIXED/LOCKED status, unprotecting components") 
			(tbx_variassy_global->viewlog)
		    )) 
		(tbx_variassy_global->protectInfo = TBX_VARIASSY_Unprotect_Components())
		case(lowerCase((axlFormGetField form_handle "bottom_view_handling")) 
		    ("mirror_to_top" 
			(mirror_style = "to_top") 
			(direction = lowerCase((axlFormGetField form_handle "direction"))) 
			(distance = (axlFormGetField form_handle "distance_value")) 
			(mirror_to_top = t)
		    ) 
		    ("mirror_on_bottom" 
			(mirror_style = "on_bottom_only")
		    ) 
		    ("no_action" t)
		) 
		(full_clean = (axlFormGetField form_handle "full_clean_before_update")) 
		(label_master_1 = upperCase((axlFormGetField form_handle "label_master"))) 
		(label_master_2 = (axlFormGetField form_handle "label_master_2")) 
		(annotate_label_2 = (axlFormGetField form_handle "annotate_label_2"))
		(create_view_label_2 = (axlFormGetField form_handle "create_view_label_2")) 
		when(use_alt_color 
		    (alt_color_id = ((tbx_variassy_global->colorSwatch)->alt))
		) 
		when(use_dni_color 
		    (dni_color_id = ((tbx_variassy_global->colorSwatch)->dni))
		) 
		when(use_group_color 
		    (variant_color_wins_over_group = (axlFormGetField form_handle "variant_color_wins_over_group"))
		) 
		(vn_user_selection = upperCase((axlFormGetField form_handle "variant")))
		case(vn_user_selection 
		    ("CORE_DESIGN" 
			(vn_names = list("CORE")) 
			(use_alt_color = nil) 
			(alt_color_id = nil) 
			(use_dni_color = nil)
			(dni_color_id = nil) 
			(variant_color_wins_over_group = nil)
		    ) 
		    ("ALL_VARIANTS" 
			(vn_names = (tbx_variassy_global->variantNames))
		    ) 
		    (t 
			(vn_names = list(vn_user_selection))
		    )
		) 
		foreach(vn vn_names 
		    (tbx_variassy_global->textAttr1 = makeTable("attr1_table" nil)) 
		    (tbx_variassy_global->textAttr2 = makeTable("attr2_table" nil)) 
		    (tbx_variassy_global->viewlog = cons(sprintf(nil "-->Processing variant %L" variant_name) 
			    (tbx_variassy_global->viewlog)
			))
		    (variant_name = vn) 
		    (tbx_variassy_global->viewlog = cons(sprintf(nil "-->Checking variant layers %L" vn_names) 
			    (tbx_variassy_global->viewlog)
			)) 
		    (variant_cfg = TBX_VARIASSY_Check_Variant_Layer(variant_name annotate_label_2 create_view_label_2)) 
		    (tbx_variassy_global->viewlog = cons(sprintf(nil "   Reading variant attributes for variant %L using attributes %L" variant_name attr_list) 
			    (tbx_variassy_global->viewlog)
			)) 
		    (tbx_variassy_global->variantAttr = TBX_VARIASSY_Extract_Variant_Design(attr_list variant_name))
		    if((axlFormGetField form_handle "retain_existing_label_attr") then 
			(tbx_variassy_global->viewlog = cons(sprintf(nil "   Reading text attributes: Label master: %L,  overwrite attributes for existing variant labels: %L" label_master_1 variant_name) 
				(tbx_variassy_global->viewlog)
			    )) 
			(overlay_layers = list(car((variant_cfg->layers)) 
				cadr((variant_cfg->layers))
			    )) 
			(tbx_variassy_global->textAttr1 = TBX_VARIASSY_Extract_Text_Attributes(label_master_1 overlay_layers))
			when((annotate_label_2 && create_view_label_2) 
			    (overlay_layers = list(caddr((variant_cfg->layers)) 
				    cadddr((variant_cfg->layers))
				)) 
			    (tbx_variassy_global->textAttr2 = TBX_VARIASSY_Extract_Text_Attributes(label_master_2 overlay_layers))
			) else 
			(tbx_variassy_global->viewlog = cons(sprintf(nil "   Reading text attributes: Label master: %L,  No variant labels." label_master_1) 
				(tbx_variassy_global->viewlog)
			    )) 
			(tbx_variassy_global->textAttr1 = TBX_VARIASSY_Extract_Text_Attributes(label_master_1 nil)) 
			when(annotate_label_2 
			    (tbx_variassy_global->textAttr2 = TBX_VARIASSY_Extract_Text_Attributes(label_master_2 nil))
			)
		    ) 
		    (tbx_variassy_global->viewlog = cons(sprintf(nil "   Determining component colors") 
			    (tbx_variassy_global->viewlog)
			)) 
		    (tbx_variassy_global->variantAttr = TBX_VARIASSY_Determine_Component_Color((tbx_variassy_global->variantAttr) use_group_color 
			    ((tbx_variassy_global->colorSpec)->regxp) use_alt_color alt_color_id
			    use_dni_color dni_color_id variant_color_wins_over_group
			)) 
		    (tbx_variassy_global->groupInfo = TBX_VARIASSY_Assign_Groups((tbx_variassy_global->variantAttr) variant_cfg)) 
		    (tbx_variassy_global->viewlog = cons(sprintf(nil "   Clearing layer data for variant %L" variant_name) 
			    (tbx_variassy_global->viewlog)
			))
		    TBX_VARIASSY_Clear_Layer_Data(variant_cfg full_clean) 
		    (tbx_variassy_global->viewlog = cons(sprintf(nil "   Annotating data for %L design" variant_name) 
			    (tbx_variassy_global->viewlog)
			)) 
		    TBX_VARIASSY_Annotate_Component_Data() 
		    when((axlFormGetField form_handle "include_other_layers") 
			(tbx_variassy_global->viewlog = cons(sprintf(nil "   Copying top only data for variant %L to ubclass: %L" variant_name 
				    ((tbx_variassy_global->includeLayers)->top)
				) 
				(tbx_variassy_global->viewlog)
			    )) 
			TBX_VARIASSY_Annotate_Layer_Data(variant_cfg "top_only" 
			    ((tbx_variassy_global->includeLayers)->top)
			) 
			(tbx_variassy_global->viewlog = cons(sprintf(nil "   Copying bottom only data for variant %L to ubclass: %L" variant_name 
				    ((tbx_variassy_global->includeLayers)->bottom)
				) 
				(tbx_variassy_global->viewlog)
			    )) 
			TBX_VARIASSY_Annotate_Layer_Data(variant_cfg "bottom_only" 
			    ((tbx_variassy_global->includeLayers)->bottom)
			)
		    ) 
		    when(mirror_style 
			(tbx_variassy_global->viewlog = cons(sprintf(nil "   Mirroring bottom view") 
				(tbx_variassy_global->viewlog)
			    )) 
			TBX_VARIASSY_Post_Process_Bottom_View(variant_cfg mirror_style direction distance)
		    )
		    TBX_VARIASSY_Colorize_Objects(variant_cfg) 
		    when((axlFormGetField form_handle "update_custom_variables") 
			(tbx_variassy_global->viewlog = cons(sprintf(nil "   Updating custom variables") 
				(tbx_variassy_global->viewlog)
			    )) 
			if((vn == "CORE") then 
			    (context_list = list("BASE")) else 
			    (context_list = list(vn))
			) 
			TBX_CUSTOMVAR_Update_Batch(context_list t t) 
			when((axlFormGetField form_handle "copy_custom_variables_to_variant_view") 
			    TBX_VARIASSY_Copy_Custom_Variables_To_Variant_View(variant_cfg mirror_to_top)
			)
		    ) 
		    when((axlFormGetField form_handle "include_other_layers") 
			(tbx_variassy_global->viewlog = cons(sprintf(nil "   Copying generic layers %L to %L subclass" 
				    ((tbx_variassy_global->includeLayers)->generic) variant_name
				) 
				(tbx_variassy_global->viewlog)
			    )) 
			TBX_VARIASSY_Annotate_Layer_Data(variant_cfg "generic" 
			    ((tbx_variassy_global->includeLayers)->generic)
			)
		    ) 
		    when((axlFormGetField form_handle "write_view_files") 
			(tbx_variassy_global->viewlog = cons(sprintf(nil "   Writing color files") 
				(tbx_variassy_global->viewlog)
			    )) 
			TBX_VARIASSY_Write_View_Files(variant_cfg mirror_to_top)
		    ) 
		    (tbx_variassy_global->viewlog = cons(sprintf(nil "-->Restoring FIXED/LOCKED status for components") 
			    (tbx_variassy_global->viewlog)
			))
		    TBX_VARIASSY_Protect_Components()
		) 
		(axlVisibleSet orgvis) 
		(axlWindowBoxSet winbox) 
		(axlVisibleUpdate t)
	    ) 
	    ("save_to_file" 
		(output_file = (axlDMFileBrowse "ALLEGRO_TEXT" t)) 
		when(output_file 
		    TBX_VARIASSY_Save_Config(output_file)
		)
	    ) 
	    ("load_from_file" 
		(input_file = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
		when((input_file && isFile(input_file)) 
		    (tbx_variassy_global->paramInfo = TBX_VARIASSY_Read_Config((tbx_variassy_global->paramInfo) input_file)) 
		    TBX_VARIASSY_Init_Form()
		)
	    ) 
	    ("myhelp" 
		(axlShell "tbx help variassy")
	    ) 
	    (t)
	)
    )
)
procedure(TBX_VARIASSY_Check_Variant_Layer(variant_name annotate_label_2 create_view_label_2) 
    let((layer_list cfg var_name_sys) 
	rexCompile("_") 
	(var_name_sys = upperCase(rexReplace(variant_name "-" 0))) 
	(layer_list = list()) 
	(layer_list = cons(strcat("MANUFACTURING/" var_name_sys "_TOP") layer_list))
	(layer_list = cons(strcat("MANUFACTURING/" var_name_sys "_BOTTOM") layer_list)) 
	when((annotate_label_2 && create_view_label_2) 
	    (layer_list = cons(strcat("MANUFACTURING/" var_name_sys "_2_TOP") layer_list)) 
	    (layer_list = cons(strcat("MANUFACTURING/" var_name_sys "_2_BOTTOM") layer_list))
	) 
	(layer_list = reverse(layer_list)) 
	foreach(lyr layer_list 
	    unless((axlLayerGet lyr) 
		(axlLayerCreateNonConductor lyr)
	    )
	) 
	(cfg = ncons(nil))
	(cfg->orgName = variant_name) 
	(cfg->sysName = var_name_sys) 
	(cfg->layers = layer_list) cfg
    )
)
procedure(TBX_VARIASSY_Clear_Layer_Data(variant_cfg full_clean) 
    let((group_name_pat) 
	(group_name_pat = strcat("VAS_" 
		(variant_cfg->sysName) "_*"
	    )) 
	(axlVisibleDesign nil) 
	foreach(lyr 
	    (variant_cfg->layers) 
	    (axlVisibleLayer lyr t)
	) 
	(axlVisibleUpdate nil)
	foreach(grp 
	    (axlSelectByName "GROUP" group_name_pat t) 
	    (axlDeleteObject 
		(grp->groupMembers)
	    ) 
	    (axlDBRefreshId grp) 
	    (axlDBDisbandGroup grp)
	) 
	(axlClearSelSet) 
	(axlVisibleUpdate nil) 
	when(full_clean 
	    (axlSetFindFilter ?enabled 
		list("noall" "shapes" "lines" "text" "dynthemals") ?onButtons 
		list("all")
	    ) 
	    (axlClearSelSet) 
	    (axlAddSelectAll) 
	    when((axlGetSelSet) 
		(axlDeleteObject 
		    (axlGetSelSet)
		)
	    )
	) t
    )
)
procedure(TBX_VARIASSY_Colorize_Objects(variant_cfg) 
    let((arr group_list color_id color_info group_name
	    port script_file cmd legacy_mode group_dbid
	) 
	(group_list = (axlSelectByName "GROUP" 
		strcat("VAS_" 
		    (variant_cfg->sysName) "_TOP_*"
		) t
	    )) 
	(group_list = nconc(group_list 
		(axlSelectByName "GROUP" 
		    strcat("VAS_" 
			(variant_cfg->sysName) "_BOT_*"
		    ) t
		)
	    )) 
	when((length((variant_cfg->layers)) > 2) 
	    (group_list = nconc(group_list 
		    (axlSelectByName "GROUP" 
			strcat("VAS_" 
			    (variant_cfg->sysName) "_2_TOP_*"
			) t
		    )
		)) 
	    (group_list = nconc(group_list 
		    (axlSelectByName "GROUP" 
			strcat("VAS_" 
			    (variant_cfg->sysName) "_2_BOT_*"
			) t
		    )
		))
	) 
	foreach(grp group_list 
	    (arr = parseString(upperCase((grp->name)) "_")) 
	    when((length(arr) >= 4) 
		if((length(arr) == 4) then 
		    (color_id = nth(3 arr)) else 
		    (color_id = nth(4 arr))
		) 
		when((color_id && atoi(color_id) && (atoi(color_id) > 0)) 
		    (color_info = cons(list(upperCase((grp->name)) 
				atoi(color_id)
			    ) color_info
			))
		)
	    )
	)
	(legacy_mode = nil) 
	if(legacy_mode then 
	    (script_file = strcat(getWorkingDir() "/color_script.scr")) 
	    (port = outfile(script_file "w")) 
	    fprintf(port "scriptmode +i +n\n")
	    foreach(entry color_info 
		(group_name = car(entry)) 
		(color_id = cadr(entry)) 
		fprintf(port "setwindow pcb\n")
		fprintf(port "trapsize 0\n") 
		fprintf(port "generaledit\n") 
		fprintf(port "assign color\n") 
		fprintf(port "setwindow form.mini\n") 
		fprintf(port "FORM mini hlt_candicane_state Solid \n")
		fprintf(port "FORM mini color_choose\n") 
		fprintf(port "cvf_chooser %d\n" color_id) 
		fprintf(port "setwindow form.find\n") 
		fprintf(port "FORM find all_off\n") 
		fprintf(port "FORM find groups YES\n")
		if(((axlVersion 
			    'version
			) >= 16.6) then 
		    fprintf(port "FORM find name_type Generic Group\n") else 
		    fprintf(port "FORM find name_type Group\n")
		) 
		fprintf(port "FORM find find_name %s\n" group_name) 
		fprintf(port "setwindow pcb\n") 
		fprintf(port "done\n")
	    ) 
	    close(port) 
	    (cmd = sprintf(nil "replay %L" script_file)) 
	    (axlShell cmd) else
	    foreach(entry color_info 
		(group_name = car(entry)) 
		(color_id = cadr(entry)) 
		(group_dbid = car((axlSelectByName "GROUP" group_name)))
		when(group_dbid 
		    (axlCustomColorObject group_dbid color_id)
		)
	    )
	) t
    )
)
procedure(TBX_VARIASSY_Copy_Custom_Variables_To_Variant_View(variant_cfg mirror_to_top) 
    let((var_name torient ph_list ph_param destination_layers
	    text_layer tbx_customvar_data gen_group group_dbid result
	) 
	(destination_layers = list(car((variant_cfg->layers)))) 
	unless(mirror_to_top 
	    (destination_layers = cons(cadr((variant_cfg->layers)) destination_layers))
	) 
	when((length((variant_cfg->layers)) > 2) 
	    (destination_layers = cons(caddr((variant_cfg->layers)) destination_layers)) 
	    unless(mirror_to_top 
		(destination_layers = cons(nth(3 
			    (variant_cfg->layers)
			) destination_layers
		    ))
	    )
	) 
	(destination_layers = reverse(destination_layers))
	(gen_group = makeTable("gen_group_data_table" nil)) 
	(gen_group[car(destination_layers)] = strcat("VAS_" 
		(variant_cfg->sysName) "_TOP_GENERIC"
	    )) 
	when(cadr(destination_layers) 
	    (gen_group[cadr(destination_layers)] = strcat("VAS_" 
		    (variant_cfg->sysName) "_BOT_GENERIC"
		))
	) 
	when(caddr(destination_layers) 
	    (gen_group[caddr(destination_layers)] = strcat("VAS_" 
		    (variant_cfg->sysName) "_2_TOP_GENERIC"
		))
	) 
	when(nth(3 destination_layers) 
	    (gen_group[nth(3 destination_layers)] = 
		strcat("VAS_" 
		    (variant_cfg->sysName) "_2_BOTTOM_GENERIC"
		))
	)
	foreach(lyr gen_group 
	    (result = (axlSelectByName "GROUP" 
		    gen_group[lyr]
		)) 
	    if(result then 
		(group_dbid = car(result)) else 
		(group_dbid = (axlDBCreateGroup 
			gen_group[lyr] "generic" nil
		    ))
	    ) 
	    (gen_group[lyr] = group_dbid)
	) 
	(ph_list = TBX_CUSTOMVAR_Get_All_Placeholders()) 
	(axlClearSelSet) 
	foreach(ph ph_list 
	    (ph_param = TBX_CUSTOMVAR_Get_Placeholder_Param(((ph->prop)->TBX_CUSTOMVAR_NAME) 
		    ((ph->prop)->TBX_CUSTOMVAR_ATTR)
		)) 
	    when(((ph_param->type) == "C") 
		if(((variant_cfg->sysName) == "CORE") then 
		    (text_layer = (ph_param->layer)) else 
		    (var_name = (variant_cfg->sysName))
		    (text_layer = strcat((axlMapClassName "DRAWING FORMAT") "/CXT_" var_name)) 
		    (tbx_customvar_data = eval('tbx_customvar_global)) 
		    foreach(entry 
			(tbx_customvar_data->layerMap)["CONTEXT"] 
			when((var_name == car(entry)) 
			    (text_layer = cadr(entry))
			)
		    )
		) 
		foreach(txt 
		    (axlDBGetAttachedText ph) 
		    when(((txt->layer) == text_layer) 
			foreach(dst_lyr destination_layers 
			    when((dst_lyr != text_layer) 
				(torient = (axlTextOrientationCopy txt)) 
				(result = (axlDBCreateText 
					(txt->text) 
					(txt->xy) torient dst_lyr
				    )) 
				when((result && gen_group[dst_lyr]) 
				    (axlDBAddGroupObjects 
					gen_group[dst_lyr] 
					car(result)
				    )
				)
			    )
			)
		    )
		)
	    )
	) t
    )
)
procedure(TBX_VARIASSY_Copy_Graphics_Wrapper(sym source_layer destination_layer attach_dbid group_dbid
	shape_style fixed_line_width
    ) 
    let((mypath data_found result text_orient) 
	foreach(ch 
	    (sym->children) 
	    cond(((((ch->objType) == "line") && ((ch->layer) == source_layer)) 
		    (data_found = t) 
		    (mypath = TBX_VARIASSY_Create_Path(list(ch) fixed_line_width)) 
		    (result = (axlDBCreatePath mypath destination_layer 
			    'line attach_dbid
			)) 
		    when((result && group_dbid) 
			(axlDBAddGroupObjects group_dbid 
			    car(result)
			)
		    )
		) 
		((((ch->objType) == "path") && ((ch->layer) == source_layer)) 
		    (data_found = t) 
		    (mypath = TBX_VARIASSY_Create_Path((ch->segments) fixed_line_width)) 
		    (result = (axlDBCreatePath mypath destination_layer 
			    'line attach_dbid
			)) 
		    when((result && group_dbid) 
			(axlDBAddGroupObjects group_dbid 
			    car(result)
			)
		    )
		) 
		(((((ch->objType) == "shape") || ((ch->objType) == "polygon")) && ((ch->layer) == source_layer)) 
		    (data_found = t) 
		    TBX_VARIASSY_Copy_Shape(ch destination_layer shape_style "include_voids" attach_dbid
			group_dbid fixed_line_width
		    )
		) 
		((((ch->objType) == "text") && ((ch->layer) == source_layer)) 
		    (data_found = t) 
		    (text_orient = (axlTextOrientationCopy ch)) 
		    (result = (axlDBCreateText 
			    (ch->text) 
			    (ch->xy) text_orient destination_layer
			    attach_dbid
			)) 
		    when((result && group_dbid) 
			(axlDBAddGroupObjects group_dbid 
			    car(result)
			)
		    )
		) 
		(t t)
	    )
	) 
	unless(data_found 
	    (tbx_variassy_global->viewlog = cons(sprintf(nil "   Error: Component %L, no data found on layer %L" 
			(sym->refdes) source_layer
		    ) 
		    (tbx_variassy_global->viewlog)
		))
	)
    )
)
procedure(TBX_VARIASSY_Copy_Layer_Data(o_list destination_layer group_dbid) 
    let((mypath text_orient result) 
	foreach(ch o_list 
	    cond((((ch->objType) == "line") 
		    (mypath = TBX_VARIASSY_Create_Path(list(ch) nil)) 
		    (result = (axlDBCreatePath mypath destination_layer 
			    'line nil
			)) 
		    when((result && group_dbid) 
			(axlDBAddGroupObjects group_dbid 
			    car(result)
			)
		    )
		) 
		(((ch->objType) == "path") 
		    (mypath = TBX_VARIASSY_Create_Path((ch->segments) nil)) 
		    (result = (axlDBCreatePath mypath destination_layer 
			    'line nil
			)) 
		    when((result && group_dbid) 
			(axlDBAddGroupObjects group_dbid 
			    car(result)
			)
		    )
		) 
		((((ch->objType) == "shape") || ((ch->objType) == "polygon")) 
		    TBX_VARIASSY_Copy_Shape(ch destination_layer "as_specified" "include_voids" nil
			group_dbid nil
		    )
		) 
		(((ch->objType) == "text") 
		    (text_orient = (axlTextOrientationCopy ch)) 
		    (result = (axlDBCreateText 
			    (ch->text) 
			    (ch->xy) text_orient destination_layer
			    nil
			)) 
		    when((result && group_dbid) 
			(axlDBAddGroupObjects group_dbid 
			    car(result)
			)
		    )
		) 
		(t t)
	    )
	)
    )
)
procedure(TBX_VARIASSY_Copy_Shape(struct dest_layer shape_mode void_mode attach_dbid
	group_dbid fixed_line_width
    ) 
    let((poly_list mypath oshape shape_dbid hatch_line_width
	    hatch_spacing hatch_angle shape_style hatch result
	) 
	(hatch_line_width = ((tbx_variassy_global->drawParam)->hatchLineWidth)) 
	(hatch_spacing = ((tbx_variassy_global->drawParam)->hatchSpacing)) 
	(hatch_angle = 45.0) 
	cond((((struct->objType) == "polygon") 
		(shape_dbid = struct)
	    ) 
	    ((((struct->objType) == "shape") && !(struct->shapeAuto) && !(struct->shapeBoundary)) 
		(shape_dbid = struct)
	    ) 
	    ((((struct->objType) == "shape") && (struct->shapeAuto) && !(struct->shapeBoundary)) 
		(shape_dbid = struct)
	    ) 
	    ((((struct->objType) == "shape") && !(struct->shapeAuto) && (struct->shapeBoundary)) 
		(shape_dbid = (struct->shapeBoundary))
	    )
	)
	cond((((struct->objType) == "polygon") 
		case(shape_mode 
		    ("fill_shape" 
			(shape_style = t)
		    ) 
		    ("hatch_shape" 
			(hatch = (make_axlFill)) 
			(hatch->spacing = hatch_spacing) 
			(hatch->width = hatch_line_width) 
			(hatch->angle = hatch_angle)
			(shape_style = list(hatch))
		    ) 
		    (t 
			(shape_style = nil)
		    )
		)
	    ) 
	    (((struct->objType) == "shape") 
		case(shape_mode 
		    ("unfill_shape" 
			(shape_style = nil)
		    ) 
		    ("hatch_shape" 
			(hatch = (make_axlFill)) 
			(hatch->spacing = hatch_spacing) 
			(hatch->width = hatch_line_width) 
			(hatch->angle = hatch_angle)
			(shape_style = list(hatch))
		    ) 
		    ("as_specified" 
			(shape_style = (shape_dbid->fill))
		    ) 
		    (t 
			(shape_style = t)
		    )
		)
	    )
	) 
	if(shape_style then 
	    if((void_mode == "include_voids") then 
		if((shape_dbid->shapeAuto) then 
		    foreach(autoshape 
			(shape_dbid->shapeAuto) 
			(poly_list = (axlPolyFromDB autoshape)) 
			(result = (axlDBCreateShape 
				car(poly_list) shape_style dest_layer nil
				attach_dbid
			    ))
		    ) else 
		    (poly_list = (axlPolyFromDB shape_dbid))
		    (result = (axlDBCreateShape 
			    car(poly_list) shape_style dest_layer nil
			    attach_dbid
			))
		) else 
		(mypath = TBX_VARIASSY_Create_Path((shape_dbid->segments) nil))
		(oshape = (axlDBCreateOpenShape mypath shape_style dest_layer nil
			attach_dbid
		    )) 
		(result = (axlDBCreateCloseShape oshape))
	    ) else 
	    if(!fixed_line_width then 
		(mypath = TBX_VARIASSY_Create_Path((shape_dbid->segments) nil)) 
		(oshape = (axlDBCreateOpenShape mypath shape_style dest_layer nil
			attach_dbid
		    )) 
		(result = (axlDBCreateCloseShape oshape))
		else 
		(mypath = TBX_VARIASSY_Create_Path((shape_dbid->segments) fixed_line_width)) 
		(result = (axlDBCreatePath mypath dest_layer 
			'line attach_dbid
		    ))
	    )
	) 
	when((result && group_dbid) 
	    (axlDBAddGroupObjects group_dbid 
		car(result)
	    )
	)
    )
)
procedure(TBX_VARIASSY_Create_Label_Text(label_data attach_dbid group_dbid mode) 
    let((text_rotation myorient result text_layer return_data
	    label_value label_attr label_layer
	) 
	foreach(entry label_data 
	    (label_value = car(entry)) 
	    (label_attr = cadr(entry)) 
	    (label_layer = caddr(entry))
	    if((mode == "tmp") then 
		(text_rotation = 0.0) 
		(text_layer = "DRAWING FORMAT/OUTLINE") else
		(text_rotation = (label_attr->rotation)) 
		(text_layer = label_layer)
	    ) 
	    cond(((label_attr == list(nil)) 
		    (tbx_variassy_global->viewlog = cons(sprintf(nil "   Error: No text attributes found for %L" 
				(attach_dbid->refdes)
			    ) 
			    (tbx_variassy_global->viewlog)
			)) 
		    (result = nil)
		) 
		(t 
		    (myorient = (make_axlTextOrientation ?textBlock 
			    (label_attr->textBlock) ?rotation text_rotation
			    ?mirrored 
			    (label_attr->isMirrored) ?justify 
			    (label_attr->justify)
			)) 
		    (result = (axlDBCreateText label_value 
			    (label_attr->xy) myorient text_layer
			    attach_dbid
			))
		)
	    ) 
	    when(result 
		foreach(txt 
		    car(result) 
		    (return_data = cons(list(txt label_attr) return_data))
		) 
		when(group_dbid 
		    (axlDBAddGroupObjects group_dbid 
			car(result)
		    )
		)
	    )
	) return_data
    )
)
procedure(TBX_VARIASSY_Create_Path(seg_list fixed_line_width) 
    let((mypath new_width) 
	foreach(i seg_list 
	    if(fixed_line_width then 
		(new_width = fixed_line_width) else 
		(new_width = (i->width))
	    ) 
	    if(((i->objType) == "line") then 
		if(!mypath then 
		    (mypath = (axlPathStart 
			    (i->startEnd) new_width
			)) else 
		    (mypath = (axlPathLine mypath new_width 
			    cadr((i->startEnd))
			))
		) else 
		if(!mypath then 
		    (mypath = (axlPathStart 
			    list(car((i->startEnd)))
			)) 
		    (mypath = (axlPathArcCenter mypath new_width 
			    cadr((i->startEnd)) 
			    (i->isClockwise)
			    (i->xy)
			)) else
		    (mypath = (axlPathArcCenter mypath new_width 
			    cadr((i->startEnd)) 
			    (i->isClockwise)
			    (i->xy)
			))
		)
	    )
	) mypath
    )
)
procedure(TBX_VARIASSY_Determine_Component_Color(attr_data use_group_color color_spec_regxp use_alt_color alt_color_id
	use_dni_color dni_color_id variant_color_wins_over_group
    ) 
    let((prop_name prop_value_list color_id vartype) 
	when((use_group_color || use_alt_color || use_dni_color) 
	    foreach(ref attr_data 
		(vartype = (attr_data[ref]->VARTYPE)) 
		when(use_group_color 
		    foreach(entry color_spec_regxp 
			(prop_name = upperCase(car(entry))) 
			(prop_value_list = cadr(entry)) 
			(color_id = caddr(entry))
			foreach(prp_val prop_value_list 
			    when((get(attr_data[ref] prop_name) && 
				    rexMatchp(prp_val 
					get(attr_data[ref] prop_name)
				    )) 
				(attr_data[ref]->OBJECT_COLOR = color_id)
			    )
			)
		    )
		) 
		when((use_alt_color && (vartype == "CHANGE")) 
		    cond((variant_color_wins_over_group 
			    (attr_data[ref]->OBJECT_COLOR = alt_color_id)
			) 
			(!(attr_data[ref]->OBJECT_COLOR) 
			    (attr_data[ref]->OBJECT_COLOR = alt_color_id)
			)
		    )
		)
		when((use_dni_color && (vartype == "DNI")) 
		    cond((variant_color_wins_over_group 
			    (attr_data[ref]->OBJECT_COLOR = dni_color_id)
			) 
			(!(attr_data[ref]->OBJECT_COLOR) 
			    (attr_data[ref]->OBJECT_COLOR = dni_color_id)
			)
		    )
		)
	    )
	) attr_data
    )
)
procedure(TBX_VARIASSY_Determine_Label_For_Write(label_value_1 text_attr_1 label_value_2 text_attr_2 annotate_label_2
	group_layer group_type
    ) 
    let((label_data) 
	if((group_type == "2") then 
	    (label_data = list(list(label_value_2 text_attr_2 group_layer))) else 
	    (label_data = list(list(label_value_1 text_attr_1 group_layer)))
	    when(annotate_label_2 
		(label_data = cons(list(label_value_2 text_attr_2 group_layer) label_data))
	    )
	) label_data
    )
)
procedure(TBX_VARIASSY_Determine_Mount_Type(cmp) 
    let((mount_type is_smd is_tht) 
	(mount_type = "UNDEF") 
	cond((((cmp->prop)->MOUNT_TYPE) 
		(mount_type = upperCase(((cmp->prop)->MOUNT_TYPE)))
	    ) 
	    ((((cmp->compdef)->prop)->MOUNT_TYPE) 
		(mount_type = upperCase((((cmp->compdef)->prop)->MOUNT_TYPE)))
	    ) 
	    ((((cmp->symbol)->prop)->MOUNT_TYPE) 
		(mount_type = upperCase((((cmp->symbol)->prop)->MOUNT_TYPE)))
	    ) 
	    (((((cmp->symbol)->definition)->prop)->MOUNT_TYPE) 
		(mount_type = upperCase(((((cmp->symbol)->definition)->prop)->MOUNT_TYPE)))
	    ) 
	    (t 
		foreach(p 
		    (cmp->pins) 
		    if((p->isThrough) then 
			(is_tht = t) else 
			(is_smd = t)
		    )
		) 
		when((is_tht && is_smd) 
		    (mount_type = "UNDEF")
		) 
		when((!is_tht && is_smd) 
		    (mount_type = "SMT")
		) 
		when((is_tht && !is_smd) 
		    (mount_type = "THT")
		)
	    )
	) mount_type
    )
)
procedure(TBX_VARIASSY_Draw_Cross(box_info rotation_origin angle mirror dest_layer
	attach_dbid group_dbid
    ) 
    let((x_ll y_ll x_ur y_ur xy1
	    xy2 xy3 xy4 line_width xy_list
	    pt_new mypath scale bbox box_center
	    dx1 dx2 dy1 dy2 x_scale
	    y_scale result
	) 
	(angle = (angle * 1.0)) 
	(line_width = ((tbx_variassy_global->drawParam)->crossLineWidth)) 
	(scale = ((tbx_variassy_global->drawParam)->crossScale)) 
	(bbox = car(box_info))
	(box_center = cadr(box_info)) 
	(x_ll = car((lowerLeft bbox))) 
	(y_ll = cadr((lowerLeft bbox))) 
	(x_ur = car((upperRight bbox))) 
	(y_ur = cadr((upperRight bbox)))
	(xy1 = (x_ll:y_ll)) 
	(xy2 = (x_ur:y_ll)) 
	(xy3 = (x_ur:y_ur)) 
	(xy4 = (x_ll:y_ur)) 
	foreach(pt 
	    list(xy1 xy2 xy3 xy4) 
	    if((scale != 1.0) then 
		(dx1 = (car(pt) - car(box_center))) 
		(dy1 = (cadr(pt) - cadr(box_center))) 
		(dx2 = (scale * dx1))
		(dy2 = (scale * dy1)) 
		(x_scale = (car(box_center) + dx2)) 
		(y_scale = (cadr(box_center) + dy2)) 
		(pt_new = (x_scale:y_scale)) else
		(pt_new = pt)
	    ) 
	    if(mirror then 
		(pt_new = (axlGeoRotatePt angle pt_new rotation_origin t)) else 
		(pt_new = (axlGeoRotatePt angle pt_new rotation_origin))
	    ) 
	    (xy_list = cons(pt_new xy_list))
	)
	(xy_list = reverse(xy_list)) 
	(mypath = (axlPathStart 
		list(car(xy_list) 
		    caddr(xy_list)
		) line_width
	    )) 
	(result = (axlDBCreatePath mypath dest_layer 
		'line attach_dbid
	    )) 
	when((result && group_dbid) 
	    (axlDBAddGroupObjects group_dbid 
		car(result)
	    )
	) 
	(mypath = (axlPathStart 
		list(cadr(xy_list) 
		    nth(3 xy_list)
		) line_width
	    ))
	(result = (axlDBCreatePath mypath dest_layer 
		'line attach_dbid
	    )) 
	when((result && group_dbid) 
	    (axlDBAddGroupObjects group_dbid 
		car(result)
	    )
	) t
    )
)
procedure(TBX_VARIASSY_Extract_Color_Grid_Data(valid_rows_only) 
    let((grid_info cell prop_name prop_value color_id) 
	(grid_info = list()) 
	for(i 1 
	    (tbx_variassy_global->colorGridRowCnt) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 1) 
	    (prop_name = ((axlFormGridGetCell 
			(tbx_variassy_global->formid) "color_grid" cell
		    )->value)) 
	    (prop_name = TBX_VARIASSY_Validate_Input(prop_name "string" "upperCaseNoSpace")) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 2) 
	    (prop_value = ((axlFormGridGetCell 
			(tbx_variassy_global->formid) "color_grid" cell
		    )->value)) 
	    (prop_value = TBX_VARIASSY_Validate_Input(prop_value "string" "upperCaseNoSpace")) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->row = i)
	    (cell->col = 3) 
	    (color_id = ((axlFormGridGetCell 
			(tbx_variassy_global->formid) "color_grid" cell
		    )->value)) 
	    (color_id = TBX_VARIASSY_Validate_Input(color_id "integer")) 
	    if(valid_rows_only then 
		when((prop_name && prop_value && color_id) 
		    (grid_info = cons(list(prop_name prop_value color_id) grid_info))
		) else 
		(grid_info = cons(list(prop_name prop_value color_id) grid_info))
	    )
	) 
	(grid_info = reverse(grid_info)) grid_info
    )
)
procedure(TBX_VARIASSY_Extract_Master_Design(attr_list) 
    let((comp_attr data refdes cdef_props c_props
	    attr_value_def attr_value_inst attr_value
	) 
	(comp_attr = makeTable("comp_attr_table" nil)) 
	foreach(comp 
	    ((axlDBGetDesign)->components) 
	    (data = ncons(nil)) 
	    (refdes = upperCase((comp->name))) 
	    when((comp->symbol) 
		foreach(attr_name attr_list 
		    caseq(attr_name 
			(REFDES 
			    (data->REFDES = refdes)
			) 
			(DEVICE_TYPE 
			    (data->DEVICE_TYPE = (comp->deviceType))
			) 
			(JEDEC_TYPE 
			    (data->JEDEC_TYPE = ((comp->symbol)->name))
			) 
			(MIRROR 
			    if(((comp->symbol)->isMirrored) then 
				(data->MIRROR = "YES") else 
				(data->MIRROR = "NO")
			    )
			)
			(MOUNT_TYPE 
			    (data->MOUNT_TYPE = TBX_VARIASSY_Determine_Mount_Type(comp))
			) 
			(VARTYPE 
			    (data->VARTYPE = "BASE")
			) 
			(t 
			    (cdef_props = (((comp->compdef)->prop)->??)) 
			    (cdef_props = cons(nil cdef_props)) 
			    (c_props = ((comp->prop)->??)) 
			    (c_props = cons(nil c_props))
			    (attr_value_def = get(cdef_props attr_name)) 
			    (attr_value_inst = get(c_props attr_name)) 
			    if(attr_value_inst then 
				(attr_value = attr_value_inst) else 
				(attr_value = attr_value_def)
			    ) 
			    putprop(data attr_value attr_name)
			)
		    )
		) 
		(comp_attr[refdes] = data)
	    )
	) comp_attr
    )
)
procedure(TBX_VARIASSY_Extract_Text_Attributes(label_master overlay_layers) 
    let((refdes text_attr layer_pairs top_layer bottom_layer
	    current_text_layer layer_str arr
	) 
	(text_attr = makeTable("text_attr_table" nil)) 
	(layer_str = "REF DES/ASSEMBLY") 
	(arr = parseString(lowerCase(label_master) "_")) 
	case(car(arr) 
	    ("refdes" 
		(layer_str = strcat((axlMapClassName "REF DES") "/" 
			upperCase(cadr(arr))
		    ))
	    ) 
	    ("value" 
		(layer_str = strcat((axlMapClassName "COMPONENT VALUE") "/" 
			upperCase(cadr(arr))
		    ))
	    ) 
	    ("partnr" 
		(layer_str = strcat((axlMapClassName "USER PART NUMBER") "/" 
			upperCase(cadr(arr))
		    ))
	    ) 
	    ("devtype" 
		(layer_str = strcat((axlMapClassName "DEVICE TYPE") "/" 
			upperCase(cadr(arr))
		    ))
	    )
	)
	foreach(cmp 
	    ((axlDBGetDesign)->components) 
	    (refdes = upperCase((cmp->name))) 
	    (text_attr[refdes] = ncons(nil))
	) 
	(layer_pairs = list(list(strcat(layer_str "_TOP") 
		    strcat(layer_str "_BOTTOM")
		)
	    )) 
	when(overlay_layers 
	    (layer_pairs = cons(list(car(overlay_layers) 
			cadr(overlay_layers)
		    ) layer_pairs
		))
	) 
	(layer_pairs = reverse(layer_pairs)) 
	(axlSetFindFilter ?enabled 
	    list("noall" "text") ?onButtons 
	    list("all")
	)
	foreach(pair layer_pairs 
	    (top_layer = car(pair)) 
	    (bottom_layer = cadr(pair)) 
	    (axlVisibleDesign nil)
	    (axlVisibleLayer top_layer t) 
	    (axlVisibleLayer bottom_layer t) 
	    (axlClearSelSet) 
	    (axlAddSelectAll) 
	    foreach(txt 
		(axlGetSelSet) 
		(refdes = ((txt->parent)->refdes)) 
		if(((txt->parent)->isMirrored) then 
		    (current_text_layer = bottom_layer) else 
		    (current_text_layer = top_layer)
		) 
		when((refdes && ((txt->layer) == current_text_layer)) 
		    putprop(text_attr[refdes] 
			(txt->bBox) 
			'bBox
		    ) 
		    putprop(text_attr[refdes] 
			(txt->text) 
			'text
		    ) 
		    putprop(text_attr[refdes] 
			(txt->xy) 
			'xy
		    ) 
		    putprop(text_attr[refdes] 
			(txt->rotation) 
			'rotation
		    )
		    putprop(text_attr[refdes] 
			(txt->textBlock) 
			'textBlock
		    ) 
		    putprop(text_attr[refdes] 
			(txt->justify) 
			'justify
		    ) 
		    putprop(text_attr[refdes] 
			(txt->isMirrored) 
			'isMirrored
		    ) 
		    putprop(text_attr[refdes] 
			(txt->layer) 
			'layer
		    )
		)
	    )
	) 
	(axlClearSelSet) 
	(axlVisibleUpdate nil) text_attr
    )
)
procedure(TBX_VARIASSY_Extract_Variant_Design(attr_list variant_name) 
    let((alt_flag comp_attr attrMaster tmp_list prop_list
	    attrVariant variant_lst_data variant_info var_param refdes
	) 
	(attrMaster = (tbx_variassy_global->designAttr)) 
	(variant_lst_data = (tbx_variassy_global->variantData)) 
	(attrVariant = makeTable("var_attr_table" nil)) 
	(variant_name = upperCase(variant_name))
	if((variant_name == "CORE") then 
	    foreach(ref attrMaster 
		(attrVariant[ref] = copy(attrMaster[ref]))
	    ) else 
	    foreach(ref attrMaster 
		(comp_attr = copy(attrMaster[ref])) 
		putprop(comp_attr "DNI" 
		    'VARTYPE
		) 
		(attrVariant[ref] = comp_attr)
	    )
	    (variant_info = list()) 
	    foreach(var_block variant_lst_data 
		when((variant_name == upperCase(car(var_block))) 
		    (tmp_list = list()) 
		    foreach(entry 
			cdr(var_block) 
			cond(((car(entry) == 'base) 
				foreach(ref 
				    cadr(entry) 
				    (tmp_list = cons(list(ref) tmp_list))
				)
			    ) 
			    (((car(entry) == 'alt_group) || (car(entry) == 'alternate)) 
				(tmp_list = cons(caddr(entry) tmp_list))
			    ) 
			    (((type(car(entry)) == 'string) || (type(car(entry)) == 'symbol)) 
				(tmp_list = cons(entry tmp_list))
			    ) 
			    (t 
				printf("Invalid format in variant file: %L\n" entry)
			    )
			)
		    )
		)
	    ) 
	    (variant_info = list()) 
	    foreach(entry tmp_list 
		(prop_list = list()) 
		(refdes = car(entry)) 
		if((type(refdes) == 'symbol) then 
		    (refdes = upperCase(symbolToString(refdes))) else 
		    (refdes = upperCase(refdes))
		)
		if((length(entry) > 1) then 
		    foreach(prp 
			cdr(entry) 
			(prop_list = cons(caddr(prp) prop_list)) 
			(prop_list = cons(cadr(prp) prop_list))
		    ) 
		    (prop_list = cons(refdes prop_list)) else
		    (prop_list = list(refdes))
		) 
		(variant_info = cons(prop_list variant_info))
	    ) 
	    foreach(entry variant_info 
		(refdes = car(entry)) 
		when(attrVariant[refdes] 
		    if(onep(length(entry)) then 
			putprop(attrVariant[refdes] "BASE" 
			    'VARTYPE
			) else 
			(var_param = cons(nil 
				cdr(entry)
			    ))
			(alt_flag = nil) 
			foreach(pname 
			    (var_param->?) 
			    when(exists(x attr_list 
				    (x == pname)
				) 
				(alt_flag = t)
			    )
			) 
			when(alt_flag 
			    foreach(pname 
				(var_param->?) 
				putprop(attrVariant[refdes] 
				    get(var_param pname) pname
				)
			    ) 
			    putprop(attrVariant[refdes] "CHANGE" 
				'VARTYPE
			    )
			)
		    )
		)
	    )
	) attrVariant
    )
)
procedure(TBX_VARIASSY_Get_Board_Size() 
    let((orgvis object_box result outline outline_layers) 
	(outline_layers = list(strcat((axlMapClassName "BOARD GEOMETRY") "/OUTLINE") 
		strcat((axlMapClassName "BOARD GEOMETRY") "/DESIGN_OUTLINE")
	    )) 
	(orgvis = (axlVisibleGet)) 
	(axlVisibleDesign nil) 
	foreach(lyr outline_layers 
	    (axlVisibleLayer lyr t)
	)
	(axlVisibleUpdate nil) 
	(axlSetFindFilter ?enabled 
	    list("noall" "shapes" "lines") ?onButtons 
	    list("all")
	) 
	(axlClearSelSet) 
	(axlAddSelectAll) 
	(object_box = (axlDBGetExtents 
		(axlGetSelSet) t
	    ))
	(result = TBX_VARIASSY_Utils_Form_Box(list(object_box) 
		(0:0)
	    )) 
	when(result 
	    (outline = ncons(nil)) 
	    (outline->bBox = car(result)) 
	    (outline->center = cadr(result)) 
	    (outline->width = caddr(result))
	    (outline->height = nth(3 result))
	) 
	(axlVisibleSet orgvis) 
	(axlVisibleUpdate t) outline
    )
)
procedure(TBX_VARIASSY_Get_Class_Top_Bottom_Base(class_name) 
    let((base_name base_list) 
	foreach(lyr 
	    ((axlGetParam 
		    strcat("paramLayerGroup:" 
			(axlMapClassName class_name)
		    )
		)->groupMembers) 
	    (base_name = upperCase(lyr)) 
	    when((rexMatchp("_TOP" base_name) || 
		    rexMatchp("_BOTTOM" base_name)) 
		rexCompile("_TOP") 
		(base_name = rexReplace(base_name "" 0)) 
		rexCompile("_BOTTOM") 
		(base_name = rexReplace(base_name "" 0))
		unless(member(base_name base_list) 
		    (base_list = cons(base_name base_list))
		)
	    )
	) 
	(base_list = sort(base_list nil)) base_list
    )
)
procedure(TBX_VARIASSY_Get_Subclass_Info() 
    let((layer_list layer class_list) 
	(layer_list = list()) 
	(class_list = list((axlMapClassName "BOARD GEOMETRY") 
		(axlMapClassName "DRAWING FORMAT") 
		(axlMapClassName "MANUFACTURING") 
		(axlMapClassName "PACKAGE GEOMETRY")
	    )) 
	foreach(cls class_list 
	    foreach(subcls 
		((axlGetParam 
			strcat("paramLayerGroup:" cls)
		    )->groupMembers) 
		(layer = strcat(cls "/" subcls)) 
		(layer_list = cons(layer layer_list))
	    )
	) 
	(layer_list = sort(layer_list nil))
	layer_list
    )
)
procedure(TBX_VARIASSY_Get_Variant_Names(vardata) 
    let((name name_list) 
	foreach(block vardata 
	    (name = car(block)) 
	    when((type(name) == 'string) 
		(name_list = cons(name name_list))
	    )
	) 
	(name_list = sort(name_list nil)) name_list
    )
)
procedure(TBX_VARIASSY_Include_Layers_Callback(form_handle) 
    case((form_handle->curField) 
	("add_selected" 
	    foreach(lyr 
		(axlFormListGetSelItems form_handle "available_layers") 
		unless(exists(x 
			((tbx_variassy_global->includeLayers)->tmpSelection) 
			(x == lyr)
		    ) 
		    ((tbx_variassy_global->includeLayers)->tmpSelection = cons(lyr 
			    ((tbx_variassy_global->includeLayers)->tmpSelection)
			))
		)
	    ) 
	    (axlFormListDeleteAll form_handle "selected_layers") 
	    (axlFormSetField form_handle "selected_layers" 
		((tbx_variassy_global->includeLayers)->tmpSelection)
	    )
	) 
	("remove_selected" 
	    foreach(lyr 
		(axlFormListGetSelItems form_handle "selected_layers") 
		((tbx_variassy_global->includeLayers)->tmpSelection = remove(lyr 
			((tbx_variassy_global->includeLayers)->tmpSelection)
		    ))
	    ) 
	    (axlFormListDeleteAll form_handle "selected_layers") 
	    (axlFormSetField form_handle "selected_layers" 
		((tbx_variassy_global->includeLayers)->tmpSelection)
	    )
	) 
	("cancel" 
	    (axlFormClose form_handle) 
	    (axlFinishEnterFun)
	) 
	("done" 
	    case(((tbx_variassy_global->includeLayers)->mode) 
		("top" 
		    ((tbx_variassy_global->includeLayers)->top = ((tbx_variassy_global->includeLayers)->tmpSelection))
		) 
		("bottom" 
		    ((tbx_variassy_global->includeLayers)->bottom = ((tbx_variassy_global->includeLayers)->tmpSelection))
		) 
		("generic" 
		    ((tbx_variassy_global->includeLayers)->generic = ((tbx_variassy_global->includeLayers)->tmpSelection))
		)
	    ) 
	    (axlFormClose form_handle) 
	    (axlFinishEnterFun)
	)
	("myhelp" 
	    (axlShell "tbx help variassy")
	)
    )
)
procedure(TBX_VARIASSY_Init() 
    let((attr_list default_popup param_order param_info grid_property_list
	    str outline_layers
	) 
	(outline_layers = list(strcat((axlMapClassName "BOARD GEOMETRY") "/OUTLINE") 
		strcat((axlMapClassName "BOARD GEOMETRY") "/DESIGN_OUTLINE")
	    )) 
	(attr_list = list('REFDES 
		'DEVICE_TYPE 
		'VALUE 
		'PART_NUMBER 
		'TOLERANCE
		'MIRROR 
		'VARTYPE
	    )) 
	foreach(attr attr_list 
	    when((attr != 'VARTYPE) 
		(str = symbolToString(attr)) 
		(grid_property_list = cons(list(upperCase(str) 
			    lowerCase(str)
			) grid_property_list
		    ))
	    )
	) 
	(grid_property_list = cons(list("MOUNT_TYPE" "mount_type") grid_property_list))
	(grid_property_list = cons(list("JEDEC_TYPE" "jedec_type") grid_property_list)) 
	(grid_property_list = sortcar(grid_property_list nil)) 
	(default_popup = makeTable("default_popup_table" nil)) 
	(default_popup["get_graphics_from"] = TBX_VARIASSY_Build_Popup_List("graphics")) 
	(default_popup["get_labels_from"] = list(list("Refdes" "refdes") 
		list("Value" "value") 
		list("Part_Number" "part_number") 
		list("Tolerance" "tolerance")
	    ))
	(default_popup["get_labels_from_2"] = default_popup["get_labels_from"]) 
	(default_popup["dni_style"] = list(list("Remove All" "remove_all") 
		list("Remove Label" "remove_label_only") 
		list("Cross Label" "draw_cross_label") 
		list("Cross Graphics" "draw_cross_graphics")
	    )) 
	(default_popup["label_master"] = TBX_VARIASSY_Build_Popup_List("label_master")) 
	(default_popup["label_master_2"] = default_popup["label_master"]) 
	(default_popup["alt_graphics_style"] = list(list("Hatch Shape" "hatch_shape")))
	(default_popup["direction"] = list(list("Top" "top") 
		list("Bottom" "bottom") 
		list("Left" "left") 
		list("Right" "right")
	    )) 
	(default_popup["bottom_view_handling"] = list(list("No Action" "no_action") 
		list("Mirror to top" "mirror_to_top") 
		list("Mirror on bottom only" "mirror_on_bottom")
	    )) 
	(default_popup["grid_property_select_popup"] = grid_property_list) 
	(param_order = list('modifyDniStyle 
		'dniStyle 
		'modifyDniColor 
		'dniColorId 
		'dniRemoveLabel2
		'getGraphicsFrom 
		'getLabelsFrom 
		'annotateLabel2 
		'getLabelsFrom2 
		'modifyAltLabels
		'altLabelPrefix 
		'altLabelSuffix 
		'modifyAltColor 
		'altColorId 
		'modifyAltGraphics
		'altGraphicsStyle 
		'labelMaster 
		'labelMaster2 
		'createViewLabel2 
		'attachToSymbol
		'retainExistingLabelAttr 
		'useFixedOutlineWidth 
		'fixedOutlineWidth 
		'crossLineWidth 
		'crossScale
		'hatchLineWidth 
		'hatchSpacing 
		'bottomViewHandling 
		'direction 
		'distanceValue
		'includeOtherLayers 
		'topLayerList 
		'bottomLayerList 
		'genericLayerList 
		'fullCleanBeforeUpdate
		'writeViewFiles 
		'updateCustomVariables 
		'copyCustomVariablesToVariantView 
		'groupColorSpec 
		'enableGroupColor
		'altColorWinsOverGroup
	    )) 
	(param_info = makeTable("param_info_table" nil))
	(param_info['modifyDniStyle] = list(nil 
		'field "modify_dni_style" 
		'type "check"
		'default t
	    )) 
	(param_info['dniStyle] = list(nil 
		'field "dni_style" 
		'type "popup"
		'default "remove_all"
	    )) 
	(param_info['modifyDniColor] = list(nil 
		'field "modify_dni_color" 
		'type "check"
		'default nil
	    )) 
	(param_info['dniColorId] = list(nil 
		'field "dni_color_id" 
		'type "color"
		'default 1
	    )) 
	(param_info['dniRemoveLabel2] = list(nil 
		'field "dni_remove_label_2" 
		'type "check"
		'default t
	    ))
	(param_info['getGraphicsFrom] = list(nil 
		'field "get_graphics_from" 
		'type "popup"
		'default "assembly"
	    )) 
	(param_info['getLabelsFrom] = list(nil 
		'field "get_labels_from" 
		'type "popup"
		'default "refdes"
	    )) 
	(param_info['annotateLabel2] = list(nil 
		'field "annotate_label_2" 
		'type "check"
		'default nil
	    )) 
	(param_info['getLabelsFrom2] = list(nil 
		'field "get_labels_from_2" 
		'type "popup"
		'default "value"
	    )) 
	(param_info['modifyAltLabels] = list(nil 
		'field "modify_alt_labels" 
		'type "check"
		'default nil
	    ))
	(param_info['altLabelPrefix] = list(nil 
		'field "alt_label_prefix" 
		'type "string"
		'default ""
	    )) 
	(param_info['altLabelSuffix] = list(nil 
		'field "alt_label_suffix" 
		'type "string"
		'default ""
	    )) 
	(param_info['modifyAltColor] = list(nil 
		'field "modify_alt_color" 
		'type "check"
		'default nil
	    )) 
	(param_info['altColorId] = list(nil 
		'field "alt_color_id" 
		'type "color"
		'default 17
	    )) 
	(param_info['modifyAltGraphics] = list(nil 
		'field "modify_alt_graphics" 
		'type "check"
		'default nil
	    ))
	(param_info['altGraphicsStyle] = list(nil 
		'field "alt_graphics_style" 
		'type "popup"
		'default "hatch_shape"
	    )) 
	(param_info['labelMaster] = list(nil 
		'field "label_master" 
		'type "popup"
		'default "refdes_assembly"
	    )) 
	(param_info['labelMaster2] = list(nil 
		'field "label_master_2" 
		'type "popup"
		'default "value_assembly"
	    )) 
	(param_info['createViewLabel2] = list(nil 
		'field "create_view_label_2" 
		'type "check"
		'default nil
	    )) 
	(param_info['attachToSymbol] = list(nil 
		'field "attach_to_symbol" 
		'type "check"
		'default nil
	    ))
	(param_info['retainExistingLabelAttr] = list(nil 
		'field "retain_existing_label_attr" 
		'type "check"
		'default nil
	    )) 
	(param_info['useFixedOutlineWidth] = list(nil 
		'field "use_fixed_outline_width" 
		'type "check"
		'default nil
	    )) 
	(param_info['fixedOutlineWidth] = list(nil 
		'field "fixed_outline_width" 
		'type "floatunit"
		'default 
		TBX_UTIL_Smart_Convert("0.2 MM" "8.0 MILS")
	    )) 
	(param_info['crossLineWidth] = list(nil 
		'field "cross_line_width" 
		'type "floatunit"
		'default 
		TBX_UTIL_Smart_Convert("0.2 MM" "8.0 MILS")
	    )) 
	(param_info['crossScale] = list(nil 
		'field "cross_scale" 
		'type "float"
		'default 1.0
	    ))
	(param_info['hatchLineWidth] = list(nil 
		'field "hatch_line_width" 
		'type "floatunit"
		'default 
		TBX_UTIL_Smart_Convert("0.1 MM" "4.0 MILS")
	    )) 
	(param_info['hatchSpacing] = list(nil 
		'field "hatch_spacing" 
		'type "floatunit"
		'default 
		TBX_UTIL_Smart_Convert("1.0 MM" "40.0 MILS")
	    )) 
	(param_info['bottomViewHandling] = list(nil 
		'field "bottom_view_handling" 
		'type "popup"
		'default "no_action"
	    )) 
	(param_info['direction] = list(nil 
		'field "direction" 
		'type "popup"
		'default "right"
	    )) 
	(param_info['distanceValue] = list(nil 
		'field "distance_value" 
		'type "floatunit"
		'default 
		TBX_UTIL_Smart_Convert("10.0 MM" "400.0 MILS")
	    ))
	(param_info['includeOtherLayers] = list(nil 
		'field "include_other_layers" 
		'type "check"
		'default nil
	    )) 
	(param_info['topLayerList] = list(nil 
		'field nil 
		'type "data"
		'default outline_layers
	    )) 
	(param_info['bottomLayerList] = list(nil 
		'field nil 
		'type "data"
		'default outline_layers
	    )) 
	(param_info['genericLayerList] = list(nil 
		'field nil 
		'type "data"
		'default 
		list("DRAWING FORMAT/OUTLINE")
	    )) 
	(param_info['fullCleanBeforeUpdate] = list(nil 
		'field "full_clean_before_update" 
		'type "check"
		'default nil
	    ))
	(param_info['writeViewFiles] = list(nil 
		'field "write_view_files" 
		'type "check"
		'default nil
	    )) 
	(param_info['updateCustomVariables] = list(nil 
		'field "update_custom_variables" 
		'type "check"
		'default nil
	    )) 
	(param_info['copyCustomVariablesToVariantView] = list(nil 
		'field "copy_custom_variables_to_variant_view" 
		'type "check"
		'default nil
	    )) 
	(param_info['groupColorSpec] = list(nil 
		'field "group_color_spec" 
		'type "grid"
		'default 
		list()
	    )) 
	(param_info['enableGroupColor] = list(nil 
		'field "enable_group_color" 
		'type "check"
		'default nil
	    ))
	(param_info['altColorWinsOverGroup] = list(nil 
		'field "variant_color_wins_over_group" 
		'type "check"
		'default nil
	    )) 
	unless(boundp('tbx_variassy_global) 
	    iliDefstruct('defstruct(tbx_variassy_global_struct formid defaultValue defaultPopup paramOrder
			paramInfo viewlog variantData variantNames designAttr
			variantAttr textAttr1 textAttr2 defaultAttrNames drawParam
			version colorSpec includeLayers colorSwatch colorGridRowCnt
			groupInfo boardOutline protectInfo layerInfo licCheck
		    )
	    ) 
	    defvar(tbx_variassy_global nil)
	) 
	if(!tbx_variassy_global then 
	    (tbx_variassy_global = (make_tbx_variassy_global_struct ?formid nil ?defaultPopup default_popup
		    ?paramOrder param_order ?paramInfo param_info ?colorSpec
		    ncons(nil) ?colorSwatch 
		    ncons(nil) ?colorGridRowCnt nil
		    ?groupInfo nil ?layerInfo nil ?protectInfo
		    nil ?boardOutline nil ?variantData nil
		    ?variantNames nil ?viewlog nil ?defaultAttrNames
		    attr_list ?designAttr nil ?variantAttr nil
		    ?textAttr1 nil ?textAttr2 nil ?drawParam
		    ncons(nil) ?includeLayers 
		    ncons(nil) ?version nil
		    ?licCheck nil
		)) else 
	    (tbx_variassy_global->formid = nil)
	    (tbx_variassy_global->defaultPopup = default_popup) 
	    (tbx_variassy_global->paramOrder = param_order) 
	    (tbx_variassy_global->paramInfo = param_info) 
	    (tbx_variassy_global->colorSpec = ncons(nil)) 
	    (tbx_variassy_global->colorSwatch = ncons(nil))
	    (tbx_variassy_global->colorGridRowCnt = nil) 
	    (tbx_variassy_global->groupInfo = nil) 
	    (tbx_variassy_global->layerInfo = nil) 
	    (tbx_variassy_global->protectInfo = nil) 
	    (tbx_variassy_global->boardOutline = nil)
	    (tbx_variassy_global->variantData = nil) 
	    (tbx_variassy_global->variantNames = nil) 
	    (tbx_variassy_global->viewlog = nil) 
	    (tbx_variassy_global->defaultAttrNames = attr_list) 
	    (tbx_variassy_global->designAttr = nil)
	    (tbx_variassy_global->variantAttr = nil) 
	    (tbx_variassy_global->textAttr1 = nil) 
	    (tbx_variassy_global->textAttr2 = nil) 
	    (tbx_variassy_global->drawParam = ncons(nil)) 
	    (tbx_variassy_global->includeLayers = ncons(nil))
	    (tbx_variassy_global->version = nil) 
	    (tbx_variassy_global->licCheck = nil)
	)
    )
)
procedure(TBX_VARIASSY_Init_Color_Grid_Cols() 
    let((p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 15) 
	(p->popup = "grid_property_select_popup")
	(p->headText = "Property") 
	(p->scriptLabel = "property_name") 
	(axlFormGridInsertCol 
	    (tbx_variassy_global->formid) "color_grid" p
	) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING)
	(p->colWidth = 15) 
	(p->fieldLength = 1024) 
	(p->headText = "Value") 
	(p->scriptLabel = "property_value") 
	(axlFormGridInsertCol 
	    (tbx_variassy_global->formid) "color_grid" p
	)
	(p = (make_formGridCol)) 
	(p->fieldType = 'LONG) 
	(p->colWidth = 3) 
	(p->fieldLength = 5) 
	(p->headText = "Color")
	(p->scriptLabel = "color_id") 
	(axlFormGridInsertCol 
	    (tbx_variassy_global->formid) "color_grid" p
	) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 2)
	(p->fieldLength = 10) 
	(p->headText = "") 
	(p->scriptLabel = "color_chooser") 
	(axlFormGridInsertCol 
	    (tbx_variassy_global->formid) "color_grid" p
	)
    )
)
procedure(TBX_VARIASSY_Init_Color_Grid_Rows() 
    if(zerop((tbx_variassy_global->colorGridRowCnt)) then 
	(axlFormGridInsertRows 
	    (tbx_variassy_global->formid) "color_grid" 0 1
	) 
	(tbx_variassy_global->colorGridRowCnt = 1) else
	(axlFormGridInsertRows 
	    (tbx_variassy_global->formid) "color_grid" 0 
	    (tbx_variassy_global->colorGridRowCnt)
	)
    ) 
    (axlFormGridSetBatch 
	(tbx_variassy_global->formid) "color_grid" 
	'TBX_VARIASSY_Init_Color_Grid_Rows_Callback nil
    )
)
procedure(TBX_VARIASSY_Init_Color_Grid_Rows_Callback(pvt_data) 
    let((cell row_num color_spec prop_name prop_value
	    color_id
	) 
	(pvt_data = pvt_data) 
	(row_num = 1) 
	if((length(((tbx_variassy_global->colorSpec)->base)) >= 1) then 
	    (color_spec = ((tbx_variassy_global->colorSpec)->base)) else 
	    (color_spec = list(list("" "" 1 "...")))
	) 
	foreach(entry color_spec 
	    (prop_name = upperCase(car(entry))) 
	    (prop_value = upperCase(cadr(entry))) 
	    (color_id = caddr(entry))
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 1) 
	    (cell->row = row_num) 
	    (cell->value = prop_name) 
	    (axlFormGridBatch cell)
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 2) 
	    (cell->row = row_num) 
	    (cell->value = prop_value) 
	    (axlFormGridBatch cell)
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 3) 
	    (cell->row = row_num) 
	    (cell->backColor = color_id) 
	    (cell->textColor = color_id)
	    (cell->value = color_id) 
	    (cell->noEdit = t) 
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 4)
	    (cell->row = row_num) 
	    (cell->value = "...") 
	    (cell->noEdit = t) 
	    (axlFormGridBatch cell) 
	    ++row_num
	)
	t
    )
)
procedure(TBX_VARIASSY_Init_Empty_Grid_Row(form_handle row_num) 
    let((default_color_id cell) 
	(default_color_id = 1) 
	(cell = (axlFormGridNewCell)) 
	(cell->col = 1) 
	(cell->row = row_num)
	(cell->value = "") 
	(axlFormSetField form_handle "color_grid" cell) 
	(cell = (axlFormGridNewCell)) 
	(cell->col = 2) 
	(cell->row = row_num)
	(cell->value = "") 
	(axlFormSetField form_handle "color_grid" cell) 
	(cell = (axlFormGridNewCell)) 
	(cell->col = 3) 
	(cell->row = row_num)
	(cell->value = default_color_id) 
	(cell->noEdit = t) 
	(cell->backColor = default_color_id) 
	(cell->textColor = default_color_id) 
	(axlFormSetField form_handle "color_grid" cell)
	(cell = (axlFormGridNewCell)) 
	(cell->col = 4) 
	(cell->row = row_num) 
	(cell->value = "...") 
	(cell->noEdit = t)
	(axlFormSetField form_handle "color_grid" cell)
    )
)
procedure(TBX_VARIASSY_Init_Form() 
    let((form_handle paramInfo variant_names popup_data field_name
	    field_type field_value
	) 
	(form_handle = (tbx_variassy_global->formid)) 
	(paramInfo = (tbx_variassy_global->paramInfo)) 
	(variant_names = (tbx_variassy_global->variantNames)) 
	(popup_data = TBX_VARIASSY_Build_Variant_Popup(variant_names))
	if((length(popup_data) > 1) then 
	    (axlFormSetField form_handle "variant" "ALL_VARIANTS") else 
	    (axlFormSetField form_handle "variant" "CORE_DESIGN")
	) 
	foreach(prm paramInfo 
	    when((paramInfo[prm]->field) 
		(field_name = (paramInfo[prm]->field)) 
		(field_type = (paramInfo[prm]->type)) 
		if((paramInfo[prm]->curValue) then 
		    (field_value = (paramInfo[prm]->curValue)) else 
		    (field_value = (paramInfo[prm]->default))
		) 
		case(field_type 
		    ("check" 
			cond((((type(field_value) == 'string) && (upperCase(field_value) == "ON")) 
				(axlFormSetField form_handle field_name t)
			    ) 
			    (((type(field_value) == 'string) && (upperCase(field_value) == "OFF")) 
				(axlFormSetField form_handle field_name nil)
			    ) 
			    (t t)
			)
		    ) 
		    ("formlist" 
			(axlFormListDeleteAll form_handle field_name) 
			(axlFormSetField form_handle field_name field_value)
		    ) 
		    ("popup" 
			(axlFormBuildPopup form_handle field_name 
			    (tbx_variassy_global->defaultPopup)[field_name]
			) 
			(axlFormSetField form_handle field_name field_value)
		    ) 
		    ("color" 
			(axlFormSetField form_handle field_name field_value) 
			caseq(prm 
			    (altColorId 
				((tbx_variassy_global->colorSwatch)->alt = field_value)
			    ) 
			    (dniColorId 
				((tbx_variassy_global->colorSwatch)->dni = field_value)
			    )
			)
		    )
		    ("grid" 
			((tbx_variassy_global->colorSpec)->base = field_value) 
			if(zerop(length(((tbx_variassy_global->colorSpec)->base))) then 
			    (tbx_variassy_global->colorGridRowCnt = 1) else 
			    (tbx_variassy_global->colorGridRowCnt = length(((tbx_variassy_global->colorSpec)->base)))
			) 
			(axlFormGridReset form_handle "color_grid") 
			TBX_VARIASSY_Init_Color_Grid_Cols()
			TBX_VARIASSY_Init_Color_Grid_Rows() 
			(axlFormGridUpdate form_handle "color_grid") 
			(axlFormGridEvents form_handle "color_grid" 
			    list('cellselect 
				'change 
				'rightpopup
			    )
			)
		    ) 
		    (t 
			(axlFormSetField form_handle field_name field_value)
		    )
		)
	    )
	) 
	(axlFormBuildPopup form_handle "grid_color_select_popup" 
	    (tbx_variassy_global->defaultPopup)["grid_color_select_popup"]
	) 
	(axlFormBuildPopup form_handle "grid_property_select_popup" 
	    (tbx_variassy_global->defaultPopup)["grid_property_select_popup"]
	) 
	if((paramInfo['genericLayerList]->curValue) then 
	    ((tbx_variassy_global->includeLayers)->generic = (paramInfo['genericLayerList]->curValue)) else 
	    ((tbx_variassy_global->includeLayers)->generic = (paramInfo['genericLayerList]->default))
	)
	if((paramInfo['topLayerList]->curValue) then 
	    ((tbx_variassy_global->includeLayers)->top = (paramInfo['topLayerList]->curValue)) else 
	    ((tbx_variassy_global->includeLayers)->top = (paramInfo['topLayerList]->default))
	) 
	if((paramInfo['bottomLayerList]->curValue) then 
	    ((tbx_variassy_global->includeLayers)->bottom = (paramInfo['bottomLayerList]->curValue)) else 
	    ((tbx_variassy_global->includeLayers)->bottom = (paramInfo['bottomLayerList]->default))
	) 
	if((axlFormGetField form_handle "modify_dni_style") then 
	    (axlFormSetFieldEditable form_handle "dni_style" t) else 
	    (axlFormSetFieldEditable form_handle "dni_style" nil)
	) 
	if((axlFormGetField form_handle "modify_dni_color") then 
	    (axlFormSetFieldEditable form_handle "dni_color_id" t) else 
	    (axlFormSetFieldEditable form_handle "dni_color_id" nil)
	) 
	if((((axlFormGetField form_handle "dni_style") == "remove_all") || 
		((axlFormGetField form_handle "dni_style") == "remove_label_only")) then 
	    (axlFormSetFieldEditable form_handle "dni_remove_label_2" nil) 
	    (axlFormSetField form_handle "dni_remove_label_2" t) else
	    (axlFormSetFieldEditable form_handle "dni_remove_label_2" t)
	)
	if((axlFormGetField form_handle "annotate_label_2") then 
	    (axlFormSetFieldEditable form_handle "get_labels_from_2" t) 
	    (axlFormSetFieldEditable form_handle "label_master_2" t) 
	    (axlFormSetFieldEditable form_handle "create_view_label_2" t)
	    when((((axlFormGetField form_handle "dni_style") == "draw_cross_graphics") || 
		    ((axlFormGetField form_handle "dni_style") == "draw_cross_label")) 
		(axlFormSetFieldEditable form_handle "dni_remove_label_2" t)
	    ) else 
	    (axlFormSetFieldEditable form_handle "get_labels_from_2" nil) 
	    (axlFormSetFieldEditable form_handle "label_master_2" nil) 
	    (axlFormSetFieldEditable form_handle "create_view_label_2" nil)
	    (axlFormSetFieldEditable form_handle "dni_remove_label_2" nil)
	) 
	if((axlFormGetField form_handle "attach_to_symbol") then 
	    (axlFormSetFieldEditable form_handle "retain_existing_label_attr" t) else 
	    (axlFormSetFieldEditable form_handle "retain_existing_label_attr" nil)
	    (axlFormSetField form_handle "retain_existing_label_attr" nil)
	) 
	if(((upperCase((axlFormGetField form_handle "get_graphics_from")) == "PLACE_BOUND") || 
		(upperCase((axlFormGetField form_handle "get_graphics_from")) == "DFA_BOUND")) then 
	    (axlFormSetFieldEditable form_handle "modify_alt_graphics" t) 
	    (axlFormSetFieldEditable form_handle "alt_graphics_style" t) else
	    (axlFormSetFieldEditable form_handle "modify_alt_graphics" nil) 
	    (axlFormSetField form_handle "modify_alt_graphics" nil) 
	    (axlFormSetFieldEditable form_handle "alt_graphics_style" nil)
	) 
	if((axlFormGetField form_handle "modify_alt_color") then 
	    (axlFormSetFieldEditable form_handle "alt_color_id" t) else 
	    (axlFormSetFieldEditable form_handle "alt_color_id" nil)
	) 
	if((axlFormGetField form_handle "modify_alt_labels") then 
	    (axlFormSetFieldEditable form_handle "alt_label_prefix" t) 
	    (axlFormSetFieldEditable form_handle "alt_label_suffix" t) else
	    (axlFormSetFieldEditable form_handle "alt_label_prefix" nil) 
	    (axlFormSetFieldEditable form_handle "alt_label_suffix" nil)
	)
	if((axlFormGetField form_handle "use_fixed_outline_width") then 
	    (axlFormSetFieldEditable form_handle "fixed_outline_width" t) else 
	    (axlFormSetFieldEditable form_handle "fixed_outline_width" nil)
	) 
	case(lowerCase((axlFormGetField form_handle "bottom_view_handling")) 
	    ("no_action" 
		(axlFormSetFieldEditable form_handle "direction" nil) 
		(axlFormSetFieldEditable form_handle "distance_value" nil) 
		(axlFormSetFieldEditable form_handle "attach_to_symbol" t) 
		(axlFormSetFieldEditable form_handle "retain_existing_label_attr" t)
	    ) 
	    ("mirror_to_top" 
		(axlFormSetFieldEditable form_handle "direction" t) 
		(axlFormSetFieldEditable form_handle "distance_value" t) 
		(axlFormSetField form_handle "attach_to_symbol" nil) 
		(axlFormSetFieldEditable form_handle "attach_to_symbol" nil)
		(axlFormSetFieldEditable form_handle "retain_existing_label_attr" nil) 
		(axlFormSetField form_handle "retain_existing_label_attr" nil)
	    ) 
	    ("mirror_on_bottom" 
		(axlFormSetFieldEditable form_handle "direction" nil) 
		(axlFormSetFieldEditable form_handle "distance_value" nil) 
		(axlFormSetField form_handle "attach_to_symbol" nil) 
		(axlFormSetFieldEditable form_handle "attach_to_symbol" nil)
		(axlFormSetFieldEditable form_handle "retain_existing_label_attr" nil) 
		(axlFormSetField form_handle "retain_existing_label_attr" nil)
	    )
	) 
	if((axlFormGetField form_handle "include_other_layers") then 
	    (axlFormSetFieldEditable form_handle "top_layer_specify" t) 
	    (axlFormSetFieldEditable form_handle "bottom_layer_specify" t) 
	    (axlFormSetFieldEditable form_handle "generic_layer_specify" t)
	    else 
	    (axlFormSetFieldEditable form_handle "top_layer_specify" nil) 
	    (axlFormSetFieldEditable form_handle "bottom_layer_specify" nil) 
	    (axlFormSetFieldEditable form_handle "generic_layer_specify" nil)
	) 
	if((axlFormGetField form_handle "update_custom_variables") then 
	    (axlFormSetFieldEditable form_handle "copy_custom_variables_to_variant_view" t) else 
	    (axlFormSetFieldEditable form_handle "copy_custom_variables_to_variant_view" nil)
	) 
	if((axlFormGetField form_handle "enable_group_color") then 
	    (axlFormSetFieldEditable form_handle "variant_color_wins_over_group" t) else 
	    (axlFormSetFieldEditable form_handle "variant_color_wins_over_group" nil)
	    (axlFormSetField form_handle "variant_color_wins_over_group" nil)
	)
	t
    )
)
procedure(TBX_VARIASSY_Load_File(file_name file_type) 
    let((inport data line port) 
	when((isFile(file_name) && isReadable(file_name)) 
	    cond(((file_type == "list") 
		    (inport = infile(file_name)) 
		    (data = car(lineread(inport))) 
		    close(inport)
		) 
		(t 
		    (port = infile(file_name)) 
		    while((line = _gets(port)) 
			(data = cons(line data))
		    ) 
		    close(port) 
		    (data = reverse(data))
		)
	    )
	) data
    )
)
procedure((TBX_VARIASSY_Main \@optional arg) 
    let((FORM_FILE fid lic_check_result VERSION_STR FC_FEATURE
	    FC_VERSION SUB_VERSION variant_file variant_data port
	    info_file board_outline variant_file_display str_len ok_start_app
	) 
	(FC_FEATURE = "VARIASSY") 
	(FC_VERSION = "16.4") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "Variant Assembly %s (C)2016" FC_VERSION))
	(board_outline = TBX_VARIASSY_Get_Board_Size()) 
	(ok_start_app = t) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./variant_assembly_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Variant Assembly information:\n") 
		fprintf(port "===============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "  viewlog  : Shows log file\n") 
		fprintf(port "  reset    : Deletes internal configuration from database\n") 
		fprintf(port "\n")
		close(port) 
		(axlUIViewFileCreate info_file "Variant Assembly: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "viewlog")) 
		TBX_VARIASSY_Viewlog() 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "reset")) 
		when((axlUIYesNo "Delete configuration from database?" nil 
			'no
		    ) 
		    (axlDeleteAttachment "tbx_variassy")
		) 
		(ok_start_app = nil)
	    ) 
	    (!board_outline 
		(axlUIConfirm "Error: Board outline not defined. Cannot proceed.\n") 
		(ok_start_app = nil)
	    )
	) 
	when(ok_start_app 
	    (lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
	    when(lic_check_result 
		(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "variassy_main")) 
		unless(boundp('tbxVariassyMainHandle) 
		    defvar(tbxVariassyMainHandle nil)
		) 
		(fid = (axlFormCreate 
			'tbxVariassyMainHandle FORM_FILE 
			'(e outer) 
			'TBX_VARIASSY_Callback
			t
		    )) 
		when(fid 
		    if(TBX_VARIASSY_Migration_Check() then 
			TBX_VARIASSY_Init() 
			TBX_UTIL_Migrate("flw_variassy" "tbx_variassy") 
			(tbx_variassy_global->licCheck = lic_check_result)
			(tbx_variassy_global->viewlog = cons(sprintf(nil "-->Initializing data structure...") 
				(tbx_variassy_global->viewlog)
			    )) 
			(tbx_variassy_global->boardOutline = board_outline) 
			(tbx_variassy_global->version = VERSION_STR) 
			TBX_FORM_Init_Header(fid "Licensed for " lic_check_result VERSION_STR) 
			(tbx_variassy_global->formid = fid)
			(variant_file = sprintf(nil "%s/variants.lst" 
				getWorkingDir()
			    )) 
			if(isFile(variant_file) then 
			    (variant_data = TBX_VARIASSY_Load_File(variant_file "list")) 
			    if(variant_data then 
				(str_len = strlen(variant_file)) 
				if((str_len > 55) then 
				    (variant_file_display = substring(variant_file 
					    (str_len - 55)
					)) 
				    (variant_file_display = strcat("..." variant_file_display)) else
				    (variant_file_display = variant_file)
				) 
				(axlFormSetField fid "variant_file" variant_file_display)
				(tbx_variassy_global->variantData = variant_data) 
				(tbx_variassy_global->viewlog = cons(sprintf(nil "-->Reading variant data from %L" variant_file) 
					(tbx_variassy_global->viewlog)
				    )) else 
				(axlUIWPrint fid "E - Cannot read data from variants.lst") 
				(tbx_variassy_global->viewlog = cons(sprintf(nil "-->Error: Cannot read variant file %L" variant_file) 
					(tbx_variassy_global->viewlog)
				    ))
			    ) else
			    (axlFormSetField fid "variant_file" "*** File variants.lst not found ***") 
			    (tbx_variassy_global->viewlog = cons(sprintf(nil "-->Info: File variants.lst not found") 
				    (tbx_variassy_global->viewlog)
				))
			) 
			(tbx_variassy_global->viewlog = cons(sprintf(nil "-->Extracting variant names") 
				(tbx_variassy_global->viewlog)
			    )) 
			(tbx_variassy_global->variantNames = TBX_VARIASSY_Get_Variant_Names((tbx_variassy_global->variantData))) 
			(tbx_variassy_global->viewlog = cons(sprintf(nil "   Variants found: %L" 
				    (tbx_variassy_global->variantNames)
				) 
				(tbx_variassy_global->viewlog)
			    ))
			(tbx_variassy_global->paramInfo = TBX_VARIASSY_Read_Config((tbx_variassy_global->paramInfo) nil)) 
			(tbx_variassy_global->viewlog = cons(sprintf(nil "-->Setting form default values") 
				(tbx_variassy_global->viewlog)
			    )) 
			TBX_VARIASSY_Init_Form() 
			(axlFormDisplay fid) 
			TBX_FORM_Delete(lic_check_result FORM_FILE)
		    )
		)
	    )
	)
    )
)
procedure(TBX_VARIASSY_Migration_Check() 
    let((att data color_id msg old_format
	    new_data token value prop_name prop_value
	    color_name new_color_spec data_str continue
	) 
	(color_id = makeTable("color_id_table" nil)) 
	(color_id["black"] = 167) 
	(color_id["gray"] = 168) 
	(color_id["silver"] = 169)
	(color_id["white"] = 170) 
	(color_id["maroon"] = 171) 
	(color_id["red"] = 172) 
	(color_id["purple"] = 173) 
	(color_id["fuchsia"] = 174)
	(color_id["orange"] = 175) 
	(color_id["green"] = 176) 
	(color_id["lime"] = 177) 
	(color_id["olive"] = 178) 
	(color_id["yellow"] = 179)
	(color_id["navy"] = 180) 
	(color_id["blue"] = 181) 
	(color_id["teal"] = 182) 
	(color_id["aqua"] = 183) 
	(att = (axlGetAttachment "flw_variassy" 
		'string
	    ))
	when(att 
	    (data = car(linereadstring((att->data))))
	) 
	foreach(entry data 
	    when((car(entry) == 'altColorName) 
		(old_format = t)
	    )
	) 
	(msg = "Info: Update legacy configuration.") 
	if(old_format then 
	    printf("%s\n" msg) 
	    (continue = t) 
	    foreach(entry data 
		(token = car(entry)) 
		(value = cadr(entry)) 
		caseq(token 
		    (altColorName 
			(new_data = cons(list('altColorId 
				    color_id[lowerCase(value)]
				) new_data
			    ))
		    ) 
		    (mirrorLayerList 
			(new_data = cons(list('topLayerList value) new_data)) 
			(new_data = cons(list('bottomLayerList value) new_data))
		    ) 
		    (groupColorSpec 
			foreach(spec value 
			    (prop_name = car(spec)) 
			    (prop_value = cadr(spec)) 
			    (color_name = lowerCase(caddr(spec)))
			    (new_color_spec = cons(list(prop_name prop_value 
					color_id[color_name]
				    ) new_color_spec
				))
			) 
			(new_color_spec = reverse(new_color_spec)) 
			(new_data = cons(list('groupColorSpec new_color_spec) new_data))
		    ) 
		    (t 
			(new_data = cons(list(token value) new_data))
		    )
		)
	    )
	    (new_data = cons(list('modifyDniStyle "off") new_data)) 
	    (new_data = cons(list('modifyDniColor "off") new_data)) 
	    (new_data = cons(list('dniColorId 1) new_data)) 
	    (new_data = reverse(new_data)) 
	    (axlDeleteAttachment "flw_variassy")
	    (data_str = sprintf(nil "%L" new_data)) 
	    (axlCreateAttachment "flw_variassy" nil 1 
		'string
		data_str
	    ) else 
	    (continue = t)
	) continue
    )
)
procedure(TBX_VARIASSY_Mirror_View_Fit_Extents(group_list offset) 
    let((all_members extents box_ll box_ur box_ll_off
	    box_ur_off design_box ok_fit
	) 
	foreach(grp group_list 
	    foreach(mb 
		(grp->groupMembers) 
		(all_members = cons(mb all_members))
	    )
	) 
	(extents = (axlDBGetExtents all_members nil)) 
	(box_ll = car(extents)) 
	(box_ur = cadr(extents))
	(box_ll_off = ((car(box_ll) + car(offset)):(cadr(box_ll) + cadr(offset)))) 
	(box_ur_off = ((car(box_ur) + car(offset)):(cadr(box_ur) + cadr(offset)))) 
	(design_box = ((axlGetParam "paramDesign")->bBox)) 
	if(((axlIsPointInsideBox box_ll_off design_box) && 
		(axlIsPointInsideBox box_ur_off design_box)) then 
	    (ok_fit = t) else 
	    (ok_fit = nil)
	) ok_fit
    )
)
procedure(TBX_VARIASSY_Parse_Color_Spec(color_spec) 
    let((color_spec_regxp prop_name prop_value prop_value_list color_id) 
	rexMagic(nil) 
	(color_spec_regxp = list()) 
	foreach(entry color_spec 
	    (prop_name = car(entry)) 
	    (prop_value = cadr(entry)) 
	    (color_id = caddr(entry))
	    (prop_value_list = list()) 
	    foreach(pat 
		parseString(prop_value ";") 
		rexCompile(".") 
		(pat = rexReplace(pat "[.]" 0)) 
		rexCompile("*")
		(pat = rexReplace(pat ".*" 0)) 
		(pat = strcat("^" pat "$")) 
		(prop_value_list = cons(pat prop_value_list))
	    ) 
	    (prop_value_list = reverse(prop_value_list)) 
	    (color_spec_regxp = cons(list(prop_name prop_value_list color_id) color_spec_regxp))
	) 
	rexMagic(t)
	(color_spec_regxp = reverse(color_spec_regxp)) color_spec_regxp
    )
)
procedure(TBX_VARIASSY_Post_Process_Bottom_View(variant_cfg mirror_style direction distance) 
    let((width height center group_members_tmptop group_list
	    dx dy patt_info bottom_layer bottom_group_pattern
	) 
	(patt_info = makeTable("patt_info_table" nil)) 
	(patt_info[cadr((variant_cfg->layers))] = strcat("VAS_" 
		(variant_cfg->sysName) "_BOT_*"
	    )) 
	when((length((variant_cfg->layers)) > 2) 
	    (patt_info[nth(3 
		    (variant_cfg->layers)
		)] = strcat("VAS_" 
		    (variant_cfg->sysName) "_2_BOT_*"
		))
	) 
	(width = ((tbx_variassy_global->boardOutline)->width))
	(height = ((tbx_variassy_global->boardOutline)->height)) 
	(center = ((tbx_variassy_global->boardOutline)->center)) 
	foreach(key patt_info 
	    (bottom_layer = key) 
	    (bottom_group_pattern = patt_info[bottom_layer]) 
	    case(mirror_style 
		("to_top" 
		    case(direction 
			("right" 
			    (dx = (width + distance)) 
			    (dy = 0.0)
			) 
			("left" 
			    (dx = ((- width) - distance)) 
			    (dy = 0.0)
			) 
			("top" 
			    (dx = 0.0) 
			    (dy = (height + distance))
			) 
			("bottom" 
			    (dx = 0.0) 
			    (dy = ((- height) - distance))
			)
		    ) 
		    (group_list = (axlSelectByName "GROUP" bottom_group_pattern t)) 
		    when(group_list 
			if(TBX_VARIASSY_Mirror_View_Fit_Extents(group_list 
				(dx:dy)
			    ) then 
			    (axlTransformObject group_list ?mirror t ?origin
				center ?move 
				(dx:dy)
			    ) 
			    (axlDBRefreshId nil) else
			    printf("Warning: Mirror view does not fit into extents. Adjust drawing size and/or spacing distance.\n")
			)
		    )
		) 
		("on_bottom_only" 
		    (group_list = (axlSelectByName "GROUP" bottom_group_pattern t)) 
		    when(group_list 
			(axlTransformObject group_list ?mirror t ?origin
			    center
			) 
			(axlDBRefreshId nil) 
			foreach(grp group_list 
			    (group_members_tmptop = (grp->groupMembers)) 
			    TBX_VARIASSY_Copy_Layer_Data(group_members_tmptop bottom_layer grp) 
			    (axlDeleteObject group_members_tmptop)
			)
		    )
		) 
		(t t)
	    )
	) 
	(axlVisibleUpdate nil)
    )
)
procedure(TBX_VARIASSY_Protect_Components() 
    let((protect_attr refdes) 
	(protect_attr = (tbx_variassy_global->protectInfo)) 
	foreach(cmp 
	    ((axlDBGetDesign)->components) 
	    when((cmp->symbol) 
		(refdes = upperCase((cmp->name))) 
		when(protect_attr[refdes] 
		    when(car(protect_attr[refdes]) 
			(axlDBAddProp 
			    (cmp->symbol) 
			    list("FIXED" t)
			)
		    ) 
		    when(cadr(protect_attr[refdes]) 
			(axlDBAddProp 
			    (cmp->symbol) 
			    list("LOCKED" t)
			)
		    )
		)
	    )
	) t
    )
)
procedure(TBX_VARIASSY_Read_Config(paramInfo input_file) 
    let((att port data user_units new_value
	    value param
	) 
	if(input_file then 
	    (port = infile(input_file)) 
	    (data = car(lineread(port))) 
	    close(port)
	    else 
	    (att = (axlGetAttachment "tbx_variassy" 
		    'string
		)) 
	    when(att 
		(data = car(linereadstring((att->data))))
	    )
	) 
	(user_units = car((axlDBGetDesignUnits))) 
	when(data 
	    foreach(entry data 
		when((car(entry) == 'units) 
		    (user_units = cadr(entry))
		)
	    ) 
	    foreach(entry data 
		(param = car(entry)) 
		(value = cadr(entry)) 
		cond(((param == 'units) t) 
		    ((paramInfo[param] && ((paramInfo[param]->type) == "check")) 
			(paramInfo[param]->curValue = value)
		    ) 
		    ((paramInfo[param] && ((paramInfo[param]->type) == "floatunit")) 
			(new_value = (axlMKSConvert value user_units)) 
			(paramInfo[param]->curValue = new_value)
		    ) 
		    (!paramInfo[param] 
			printf("Warning: Unknown param %L, skipping...\n" param)
		    ) 
		    (t 
			(paramInfo[param]->curValue = value)
		    )
		)
	    )
	) paramInfo
    )
)
procedure(TBX_VARIASSY_Save_Config(output_file) 
    let((form_handle group_color_spec port value data_str
	    config_data paramInfo paramOrder
	) 
	(form_handle = (tbx_variassy_global->formid)) 
	(group_color_spec = TBX_VARIASSY_Extract_Color_Grid_Data(t)) 
	(paramInfo = (tbx_variassy_global->paramInfo)) 
	(paramOrder = (tbx_variassy_global->paramOrder))
	(config_data = list()) 
	(config_data = cons(list('units 
		    car((axlDBGetDesignUnits))
		) config_data
	    )) 
	foreach(prm paramOrder 
	    case((paramInfo[prm]->type) 
		("data" 
		    caseq(prm 
			(topLayerList 
			    (value = ((tbx_variassy_global->includeLayers)->top))
			) 
			(bottomLayerList 
			    (value = ((tbx_variassy_global->includeLayers)->bottom))
			) 
			(genericLayerList 
			    (value = ((tbx_variassy_global->includeLayers)->generic))
			)
		    )
		) 
		("check" 
		    if((axlFormGetField form_handle 
			    (paramInfo[prm]->field)
			) then 
			(value = "on") else 
			(value = "off")
		    )
		) 
		("string" 
		    (value = (axlFormGetField form_handle 
			    (paramInfo[prm]->field)
			)) 
		    unless(value 
			(value = "")
		    )
		) 
		("color" 
		    caseq(prm 
			(altColorId 
			    (value = ((tbx_variassy_global->colorSwatch)->alt))
			) 
			(dniColorId 
			    (value = ((tbx_variassy_global->colorSwatch)->dni))
			)
		    )
		)
		("grid" 
		    when((prm == 'groupColorSpec) 
			(value = group_color_spec)
		    )
		) 
		(t 
		    (value = (axlFormGetField form_handle 
			    (paramInfo[prm]->field)
			))
		)
	    ) 
	    (config_data = cons(list(prm value) config_data))
	) 
	(config_data = reverse(config_data)) 
	if(output_file then 
	    (port = outfile(output_file)) 
	    fprintf(port "(\n") 
	    foreach(entry config_data 
		fprintf(port "   %L\n" entry)
	    )
	    fprintf(port ")\n") 
	    close(port) else 
	    (axlDeleteAttachment "tbx_variassy") 
	    (data_str = sprintf(nil "%L" config_data))
	    (axlCreateAttachment "tbx_variassy" nil 1 
		'string
		data_str
	    )
	)
	t
    )
)
procedure(TBX_VARIASSY_Unprotect_Components() 
    let((protect_attr was_fixed was_locked) 
	(protect_attr = makeTable("protect_attr_table" nil)) 
	foreach(cmp 
	    ((axlDBGetDesign)->components) 
	    when((cmp->symbol) 
		(was_fixed = nil) 
		(was_locked = nil) 
		when((((cmp->symbol)->prop)->FIXED) 
		    (axlDBDeleteProp 
			(cmp->symbol) "FIXED"
		    ) 
		    (was_fixed = t)
		) 
		when((((cmp->symbol)->prop)->LOCKED) 
		    (axlDBDeleteProp 
			(cmp->symbol) "LOCKED"
		    ) 
		    (was_locked = t)
		)
		(protect_attr[upperCase((cmp->name))] = list(was_fixed was_locked))
	    )
	) protect_attr
    )
)
procedure(TBX_VARIASSY_Utils_Form_Box(bb_list offset) 
    let((x_ll y_ll x_ur y_ur x1
	    y1 x2 y2 ret_list x_center
	    y_center x_offset y_offset width height
	) 
	(x_offset = car(offset)) 
	(y_offset = cadr(offset)) 
	foreach(bb bb_list 
	    when(bb 
		(x1 = caar(bb)) 
		(y1 = cadar(bb)) 
		(x2 = caadr(bb)) 
		(y2 = cadadr(bb))
		unless(x_ll 
		    (x_ll = x1) 
		    (y_ll = y1) 
		    (x_ur = x2) 
		    (y_ur = y2)
		) 
		when((x1 < x_ll) 
		    (x_ll = x1)
		) 
		when((y1 < y_ll) 
		    (y_ll = y1)
		) 
		when((x1 > x_ur) 
		    (x_ur = x1)
		) 
		when((y1 > y_ur) 
		    (y_ur = y1)
		)
		when((x2 < x_ll) 
		    (x_ll = x2)
		) 
		when((y2 < y_ll) 
		    (y_ll = y2)
		) 
		when((x2 > x_ur) 
		    (x_ur = x2)
		) 
		when((y2 > y_ur) 
		    (y_ur = y2)
		)
	    )
	) 
	if((x_ll && y_ll && x_ur && y_ur) then 
	    (x_ll = (x_ll + x_offset)) 
	    (y_ll = (y_ll + y_offset)) 
	    (x_ur = (x_ur + x_offset))
	    (y_ur = (y_ur + y_offset)) 
	    (x_center = (x_ll + ((x_ur - x_ll) / 2))) 
	    (y_center = (y_ll + ((y_ur - y_ll) / 2))) 
	    (width = (x_ur - x_ll)) 
	    (height = (y_ur - y_ll))
	    (ret_list = list(list((x_ll:y_ll) 
			(x_ur:y_ur)
		    ) 
		    (x_center:y_center) width height
		)) else 
	    (ret_list = nil)
	)
	ret_list
    )
)
procedure((TBX_VARIASSY_Validate_Input value type_required \@optional mode) 
    let((new_value) 
	case(type_required 
	    ("string" 
		when((value && (type(value) == 'string)) 
		    (new_value = value) 
		    rexCompile("^ *") 
		    (new_value = rexReplace(new_value "" 0)) 
		    rexCompile(" *$")
		    (new_value = rexReplace(new_value "" 0)) 
		    when(mode 
			case(mode 
			    ("lowerCaseNoSpace" 
				rexCompile(" ") 
				(new_value = rexReplace(new_value "" 0)) 
				(new_value = lowerCase(new_value))
			    ) 
			    ("upperCaseNoSpace" 
				rexCompile(" ") 
				(new_value = rexReplace(new_value "" 0)) 
				(new_value = upperCase(new_value))
			    ) 
			    ("asIs" t)
			)
		    )
		)
	    ) 
	    ("float" 
		cond(((value && (type(value) == 'string)) 
			when(atof(value) 
			    (new_value = atof(value))
			)
		    ) 
		    ((value && (type(value) == 'flonum)) 
			(new_value = value)
		    ) 
		    ((value && (type(value) == 'fixnum)) 
			(new_value = (value * 1.0))
		    )
		)
	    ) 
	    ("integer" 
		cond(((value && (type(value) == 'string)) 
			when(atoi(value) 
			    (new_value = atoi(value))
			)
		    ) 
		    ((value && (type(value) == 'flonum)) 
			(new_value = round(value))
		    ) 
		    ((value && (type(value) == 'fixnum)) 
			(new_value = value)
		    )
		)
	    )
	) new_value
    )
)
procedure(TBX_VARIASSY_Viewlog() 
    let((out_f log_file) 
	(log_file = strcat(getWorkingDir() "/variassy.log")) 
	(out_f = outfile(log_file "w")) 
	foreach(item 
	    reverse((tbx_variassy_global->viewlog)) 
	    fprintf(out_f "%s\n" item)
	) 
	close(out_f)
	if(!isFile(log_file) then 
	    (axlUIConfirm "Unable to Open  Variant Assembly log file, Check Permissions!") else 
	    (axlUIViewFileCreate log_file " Variant Assembly - Log" nil)
	) t
    )
)
procedure(TBX_VARIASSY_Write_View_Files(variant_cfg mirror_to_top) 
    let((color_file port color_config work_dir var_name_lc) 
	(var_name_lc = lowerCase((variant_cfg->sysName))) 
	(work_dir = getWorkingDir()) 
	(color_config = list(list(strcat(work_dir "/var_" var_name_lc "_top.color") 
		    list(car((variant_cfg->layers)))
		)
	    )) 
	unless(mirror_to_top 
	    (color_config = cons(list(strcat(work_dir "/var_" var_name_lc "_bottom.color") 
			list(cadr((variant_cfg->layers)))
		    ) color_config
		))
	)
	when((length((variant_cfg->layers)) > 2) 
	    (color_config = cons(list(strcat(work_dir "/var_" var_name_lc "_2_top.color") 
			list(caddr((variant_cfg->layers)))
		    ) color_config
		)) 
	    unless(mirror_to_top 
		(color_config = cons(list(strcat(work_dir "/var_" var_name_lc "_2_bottom.color") 
			    list(nth(3 
				    (variant_cfg->layers)
				)
			    )
			) color_config
		    ))
	    )
	) 
	foreach(entry color_config 
	    (color_file = car(entry)) 
	    (port = outfile(color_file "w")) 
	    fprintf(port "color -globvis off\n")
	    foreach(lyr 
		cadr(entry) 
		fprintf(port "color -vis \"%s\"\n" lyr)
	    ) 
	    close(port) 
	    printf("Note: View files (*.color) have been written for variant %s\n" 
		(variant_cfg->sysName)
	    )
	) t
    )
)
procedure(TBX_VARIBOM_Build_Sort_Popup(mode) 
    let((popup_list sort1 sort2 sort3 tmp_list
	    prp_list
	) 
	(popup_list = list()) 
	if((tbx_varibom_data->param) then 
	    foreach(prm 
		(tbx_varibom_data->param) 
		(popup_list = cons(list(upperCase(cadr(prm)) 
			    lowerCase(cadr(prm))
			) popup_list
		    )) 
		(prp_list = cons(cadr(prm) prp_list))
	    ) 
	    unless(member("VARTYPE" prp_list) 
		(popup_list = cons(list("VARTYPE" "vartype") popup_list))
	    ) 
	    (popup_list = sortcar(popup_list nil))
	    (popup_list = cons(list("<No Sort>" "<no_sort>") popup_list))
	) 
	when(popup_list 
	    cond(((mode == "init") 
		    (sort1 = (tbx_varibom_data->custom)["sort_level1"]) 
		    (sort2 = (tbx_varibom_data->custom)["sort_level2"]) 
		    (sort3 = (tbx_varibom_data->custom)["sort_level3"])
		) 
		((mode == "update") 
		    (sort1 = (axlFormGetField 
			    (tbx_varibom_data->formid) "sort_level1"
			)) 
		    (sort2 = (axlFormGetField 
			    (tbx_varibom_data->formid) "sort_level2"
			)) 
		    (sort3 = (axlFormGetField 
			    (tbx_varibom_data->formid) "sort_level3"
			))
		) 
		(t t)
	    ) 
	    (axlFormBuildPopup 
		(tbx_varibom_data->formid) "sort_level1" popup_list
	    ) 
	    (axlFormBuildPopup 
		(tbx_varibom_data->formid) "sort_level2" popup_list
	    ) 
	    (axlFormBuildPopup 
		(tbx_varibom_data->formid) "sort_level3" popup_list
	    )
	    (tmp_list = list()) 
	    foreach(sitem 
		list(sort1 sort2 sort3) 
		if((sitem && (sitem != "<no_sort>") && member(sitem prp_list)) then 
		    (tmp_list = cons(sitem tmp_list)) else 
		    (tmp_list = cons("INVALID" tmp_list))
		)
	    ) 
	    (tmp_list = reverse(tmp_list)) 
	    (tmp_list = remove("INVALID" tmp_list)) 
	    if(car(tmp_list) then 
		(axlFormSetField 
		    (tbx_varibom_data->formid) "sort_level1" 
		    car(tmp_list)
		) 
		if(cadr(tmp_list) then 
		    (axlFormSetField 
			(tbx_varibom_data->formid) "sort_level2" 
			cadr(tmp_list)
		    ) else 
		    (axlFormSetField 
			(tbx_varibom_data->formid) "sort_level2" "<no_sort>"
		    )
		) 
		if(caddr(tmp_list) then 
		    (axlFormSetField 
			(tbx_varibom_data->formid) "sort_level3" 
			caddr(tmp_list)
		    ) else 
		    (axlFormSetField 
			(tbx_varibom_data->formid) "sort_level3" "<no_sort>"
		    )
		)
		else 
		(axlFormSetField 
		    (tbx_varibom_data->formid) "sort_level1" "refdes"
		)
	    )
	) t
    )
)
procedure(TBX_VARIBOM_Build_Variant_Popup(variant_data) 
    let((popup_item popup_list) 
	(popup_list = list()) 
	if(variant_data then 
	    foreach(varblock variant_data 
		(popup_item = car(varblock)) 
		when((type(popup_item) == 'string) 
		    (popup_list = cons(list(upperCase(popup_item) 
				lowerCase(popup_item)
			    ) popup_list
			))
		)
	    ) 
	    (popup_list = sortcar(popup_list nil)) 
	    when(popup_list 
		(popup_list = cons(list("All Variants" "all") popup_list)) 
		(popup_list = cons(list("Common" "common") popup_list)) 
		(popup_list = cons(list("Core Design" "core") popup_list)) 
		(axlFormBuildPopup 
		    (tbx_varibom_data->formid) "variant_name" popup_list
		)
	    )
	    else 
	    (popup_list = cons(list("Core Design" "core") popup_list)) 
	    (axlFormBuildPopup 
		(tbx_varibom_data->formid) "variant_name" popup_list
	    )
	) popup_list
    )
)
procedure(TBX_VARIBOM_Calculate_Column_Width(attrTable) 
    let((column_width cmp_cnt param_cnt pname pvalue
	    pwidth col_id width pre post
	    min_width
	) 
	(param_cnt = length((tbx_varibom_data->param))) 
	(column_width = makeVector(param_cnt 1)) 
	(cmp_cnt = strlen(sprintf(nil "%d" 
		    length(attrTable)
		)
	    )) 
	foreach(prm 
	    (tbx_varibom_data->param) 
	    (col_id = car(prm)) 
	    (pwidth = nth(4 prm)) 
	    if((pwidth > 0) then 
		(column_width[(col_id - 1)] = list(pwidth "" "")) else 
		(min_width = 1)
		when((axlFormGetField 
			(tbx_varibom_data->formid) "insert_column_names"
		    ) 
		    (min_width = strlen(nth(5 prm)))
		) 
		if(onep(col_id) then 
		    (column_width[(col_id - 1)] = list(min_width "" " ")) else 
		    (column_width[(col_id - 1)] = list(min_width " " " "))
		)
	    )
	)
	foreach(prm 
	    (tbx_varibom_data->param) 
	    (pname = cadr(prm)) 
	    (pwidth = nth(4 prm)) 
	    (col_id = car(prm))
	    if((pwidth > 0) then t else 
		(width = car(column_width[(col_id - 1)]))
		(pre = cadr(column_width[(col_id - 1)])) 
		(post = caddr(column_width[(col_id - 1)])) 
		if((upperCase(pname) == "ROWNUM") then 
		    (cmp_cnt = sprintf(nil "%d" 
			    length(attrTable)
			)) 
		    when((strlen(cmp_cnt) > width) 
			(width = strlen(cmp_cnt))
		    ) else
		    foreach(ref attrTable 
			(pvalue = get(attrTable[ref] pname)) 
			when((strlen(pvalue) > width) 
			    (width = strlen(pvalue))
			)
		    )
		) 
		(column_width[(col_id - 1)] = list(width pre post))
	    )
	) column_width
    )
)
procedure(TBX_VARIBOM_Check_OutDir(dir_name) 
    if((dir_name && (type(dir_name) == 'string)) then 
	(dir_name = simplifyFilename(dir_name)) 
	(dir_name = (axlOSSlash dir_name)) 
	if(dir_name then 
	    unless(isDir(dir_name) 
		if(createDir(dir_name) then 
		    (tbx_varibom_data->viewlog = cons(sprintf(nil "Info: Creating directory %s\n" dir_name) 
			    (tbx_varibom_data->viewlog)
			)) else 
		    (tbx_varibom_data->viewlog = cons(sprintf(nil "Error: Could not create directory %s. Redirecting output to current working directory\n" dir_name) 
			    (tbx_varibom_data->viewlog)
			))
		    (dir_name = ".")
		)
	    ) else 
	    (dir_name = ".")
	)
	else 
	(dir_name = ".")
    ) dir_name
)
procedure(TBX_VARIBOM_Check_Parameter_Files() 
    let((par_file) 
	foreach(dir_name 
	    parseString(axlGetVariable("textpath")) 
	    foreach(file 
		getDirFiles(dir_name) 
		when((upperCase(file) == "BOM_PARAMS.PAR") 
		    (par_file = sprintf(nil "%s/%s" dir_name file))
		)
	    )
	) par_file
    )
)
procedure(TBX_VARIBOM_Determine_Mount_Type(cmp) 
    let((mount_type is_smd is_tht) 
	(mount_type = "UNDEF") 
	cond((((cmp->prop)->MOUNT_TYPE) 
		(mount_type = upperCase(((cmp->prop)->MOUNT_TYPE)))
	    ) 
	    ((((cmp->compdef)->prop)->MOUNT_TYPE) 
		(mount_type = upperCase((((cmp->compdef)->prop)->MOUNT_TYPE)))
	    ) 
	    ((((cmp->symbol)->prop)->MOUNT_TYPE) 
		(mount_type = upperCase((((cmp->symbol)->prop)->MOUNT_TYPE)))
	    ) 
	    (((((cmp->symbol)->definition)->prop)->MOUNT_TYPE) 
		(mount_type = upperCase(((((cmp->symbol)->definition)->prop)->MOUNT_TYPE)))
	    ) 
	    (t 
		foreach(p 
		    (cmp->pins) 
		    if((p->isThrough) then 
			(is_tht = t) else 
			(is_smd = t)
		    )
		) 
		when((is_tht && is_smd) 
		    (mount_type = "UNDEF")
		) 
		when((!is_tht && is_smd) 
		    (mount_type = "SMT")
		) 
		when((is_tht && !is_smd) 
		    (mount_type = "THT")
		)
	    )
	) mount_type
    )
)
procedure(TBX_VARIBOM_Extract_Master_Design(attr_list alt_origin bom_ignore_list jedecRotationOffset) 
    let((comp_attr data refdes pt_x pt_y
	    cdef_props c_props attr_value_def attr_value_inst attr_value
	    mount_type jedec_type
	) 
	(comp_attr = makeTable("comp_attr_table" nil)) 
	foreach(comp 
	    ((axlDBGetDesign)->components) 
	    (refdes = upperCase((comp->name))) 
	    unless(exists(x bom_ignore_list 
		    (x == refdes)
		) 
		(data = ncons(nil)) 
		foreach(attr_name attr_list 
		    caseq(attr_name 
			(REFDES 
			    putprop(data refdes 
				'REFDES
			    )
			) 
			(CLASS 
			    putprop(data 
				(comp->class) 
				'CLASS
			    )
			) 
			(DEVICE_TYPE 
			    putprop(data 
				(comp->deviceType) 
				'DEVICE_TYPE
			    )
			) 
			(JEDEC_TYPE 
			    putprop(data 
				((comp->symbol)->name) 
				'JEDEC_TYPE
			    )
			)
			(ROTATION 
			    if((comp->symbol) then 
				(jedec_type = upperCase(((comp->symbol)->name))) 
				putprop(data 
				    TBX_MATH_Normalize_Angle((((comp->symbol)->rotation) + jedecRotationOffset[jedec_type])) 
				    'ROTATION
				) else
				putprop(data 
				    ((comp->symbol)->rotation) 
				    'ROTATION
				)
			    )
			) 
			(MIRROR 
			    putprop(data 
				((comp->symbol)->isMirrored) 
				'MIRROR
			    )
			) 
			(X 
			    (pt_x = car((axlDBAltOrigin alt_origin 
					(comp->symbol)
				    )
				)) 
			    putprop(data pt_x 
				'X
			    )
			) 
			(Y 
			    (pt_y = cadr((axlDBAltOrigin alt_origin 
					(comp->symbol)
				    )
				)) 
			    putprop(data pt_y 
				'Y
			    )
			) 
			(MOUNT_TYPE 
			    (mount_type = TBX_VARIBOM_Determine_Mount_Type(comp)) 
			    putprop(data mount_type 
				'MOUNT_TYPE
			    )
			)
			(VARTYPE 
			    putprop(data "BASE" 
				'VARTYPE
			    )
			) 
			(ROWNUM t) 
			(t 
			    (cdef_props = (((comp->compdef)->prop)->??)) 
			    (cdef_props = cons(nil cdef_props)) 
			    (c_props = ((comp->prop)->??)) 
			    (c_props = cons(nil c_props))
			    (attr_value_def = get(cdef_props attr_name)) 
			    (attr_value_inst = get(c_props attr_name)) 
			    if(attr_value_inst then 
				(attr_value = attr_value_inst) else 
				(attr_value = attr_value_def)
			    ) 
			    putprop(data attr_value attr_name)
			)
		    )
		) 
		(comp_attr[refdes] = data)
	    )
	) comp_attr
    )
)
procedure(TBX_VARIBOM_Extract_Parameter_List() 
    let((cell tmp_list val_list cell_value prop_name
	    param_list id
	) 
	(tmp_list = list()) 
	for(r 1 
	    (tbx_varibom_data->gridRows) 
	    (val_list = list()) 
	    for(c 1 6 
		(cell = (axlFormGridNewCell)) 
		(cell->row = r)
		(cell->col = c) 
		(cell_value = ((axlFormGridGetCell 
			    (tbx_varibom_data->formid) "part_spec_grid" cell
			)->value)) 
		when(((c == 2) && cell_value && (cell_value != "")) 
		    (prop_name = cell_value)
		) 
		when(((c == 6) && prop_name && (!cell_value || (cell_value == ""))) 
		    (cell_value = prop_name)
		) 
		(val_list = cons(cell_value val_list))
	    )
	    (val_list = reverse(val_list)) 
	    (tmp_list = cons(val_list tmp_list))
	) 
	(tmp_list = sortcar(tmp_list 
		'lessp
	    )) 
	(id = 0)
	foreach(entry tmp_list 
	    (param_list = cons(cons(++id 
			cdr(entry)
		    ) param_list
		))
	) 
	(param_list = reverse(param_list)) 
	when(zerop(length(param_list)) 
	    (param_list = list(list(1 "REFDES" "String" 0 -1
			"REF"
		    )
		))
	) param_list
    )
)
procedure(TBX_VARIBOM_Extract_Variant_Design(report_param variant_name report_base report_alternate report_dni) 
    let((alt_flag comp_attr attrMaster tmp_list prop_list
	    attrVariant variant_lst_data variant_info var_param refdes
	) 
	(attrMaster = (tbx_varibom_data->designAttr)) 
	(variant_lst_data = (tbx_varibom_data->variant)) 
	(attrVariant = makeTable("var_attr_table" nil)) 
	foreach(ref attrMaster 
	    (comp_attr = copy(attrMaster[ref])) 
	    putprop(comp_attr "DNI" 
		'VARTYPE
	    ) 
	    (attrVariant[ref] = comp_attr)
	)
	(variant_name = upperCase(variant_name)) 
	(variant_info = list()) 
	foreach(var_block variant_lst_data 
	    when((variant_name == upperCase(car(var_block))) 
		(tmp_list = list()) 
		foreach(entry 
		    cdr(var_block) 
		    cond(((car(entry) == 'base) 
			    foreach(ref 
				cadr(entry) 
				(tmp_list = cons(list(ref) tmp_list))
			    )
			) 
			(((car(entry) == 'alt_group) || (car(entry) == 'alternate)) 
			    (tmp_list = cons(caddr(entry) tmp_list))
			) 
			(((type(car(entry)) == 'string) || (type(car(entry)) == 'symbol)) 
			    (tmp_list = cons(entry tmp_list))
			) 
			(t 
			    printf("Invalid format in variant file: %L\n" entry)
			)
		    )
		)
	    )
	) 
	(variant_info = list()) 
	foreach(entry tmp_list 
	    (prop_list = list()) 
	    (refdes = car(entry)) 
	    if((type(refdes) == 'symbol) then 
		(refdes = upperCase(symbolToString(refdes))) else 
		(refdes = upperCase(refdes))
	    )
	    if((length(entry) > 1) then 
		foreach(prp 
		    cdr(entry) 
		    (prop_list = cons(caddr(prp) prop_list)) 
		    (prop_list = cons(cadr(prp) prop_list))
		) 
		(prop_list = cons(refdes prop_list)) else
		(prop_list = list(refdes))
	    ) 
	    (variant_info = cons(prop_list variant_info))
	)
	foreach(entry variant_info 
	    (refdes = car(entry)) 
	    when(attrVariant[refdes] 
		if(onep(length(entry)) then 
		    putprop(attrVariant[refdes] "BASE" 
			'VARTYPE
		    ) 
		    unless(report_base 
			remove(refdes attrVariant)
		    ) else
		    (var_param = cons(nil 
			    cdr(entry)
			)) 
		    (alt_flag = nil) 
		    foreach(pname 
			(var_param->?) 
			when(exists(x report_param 
				(x == pname)
			    ) 
			    (alt_flag = t)
			)
		    ) 
		    when(alt_flag 
			foreach(pname 
			    (var_param->?) 
			    putprop(attrVariant[refdes] 
				get(var_param pname) pname
			    )
			) 
			putprop(attrVariant[refdes] "CHANGE" 
			    'VARTYPE
			) 
			unless(report_alternate 
			    remove(refdes attrVariant)
			)
		    )
		)
	    )
	) 
	unless(report_dni 
	    foreach(ref attrVariant 
		when((get(attrVariant[ref] 
			    'VARTYPE
			) == "DNI") 
		    remove(ref attrVariant)
		)
	    )
	) attrVariant
    )
)
procedure(TBX_VARIBOM_Format_Data(attrTable) 
    let((pname ptype pacc pvalue_str pvalue
	    undef_value out_units mirror_false_str mirror_true_str design_units
	    format_str decimal_point is_mirrored x y
	    rot rule
	) 
	(design_units = car((axlDBGetDesignUnits))) 
	(undef_value = (axlFormGetField 
		(tbx_varibom_data->formid) "undefined_value"
	    )) 
	(out_units = (axlFormGetField 
		(tbx_varibom_data->formid) "output_units"
	    )) 
	case((axlFormGetField 
		(tbx_varibom_data->formid) "decimal_point"
	    ) 
	    ("comma" 
		(decimal_point = ",")
	    ) 
	    ("dot" 
		(decimal_point = ".")
	    ) 
	    (t 
		(decimal_point = ".")
	    )
	)
	case(lowerCase((axlFormGetField 
		    (tbx_varibom_data->formid) "mirror_status"
		)
	    ) 
	    ("yes/no" 
		(mirror_false_str = "NO") 
		(mirror_true_str = "YES")
	    ) 
	    ("top/bot" 
		(mirror_false_str = "TOP") 
		(mirror_true_str = "BOT")
	    ) 
	    ("0/1" 
		(mirror_false_str = "0") 
		(mirror_true_str = "1")
	    ) 
	    ("a/b" 
		(mirror_false_str = "A") 
		(mirror_true_str = "B")
	    )
	    (t 
		(mirror_false_str = "NO") 
		(mirror_true_str = "YES")
	    )
	) 
	foreach(ref attrTable 
	    (is_mirrored = get(attrTable[ref] 
		    'MIRROR
		)) 
	    foreach(prm 
		(tbx_varibom_data->param) 
		(pname = stringToSymbol(cadr(prm))) 
		(ptype = caddr(prm)) 
		(pacc = nth(3 prm))
		(pvalue = get(attrTable[ref] pname)) 
		cond(((pname == 'MIRROR) 
			if(pvalue then 
			    putprop(attrTable[ref] mirror_true_str 
				'MIRROR
			    ) else 
			    putprop(attrTable[ref] mirror_false_str 
				'MIRROR
			    )
			)
		    ) 
		    ((upperCase(ptype) == "FLOAT") 
			(format_str = strcat("%." 
				sprintf(nil "%d" pacc) "f"
			    )) 
			if(pvalue then 
			    if(((type(pvalue) == 'flonum) || (type(pvalue) == 'fixnum)) then 
				(pvalue = (pvalue * 1.0)) 
				caseq(pname 
				    (X 
					when((axlFormGetField 
						(tbx_varibom_data->formid) "transform_xy_angle"
					    ) 
					    (x = pvalue) 
					    (x = x) 
					    if(is_mirrored then 
						(rule = (tbx_varibom_data->formula)["bottom_x"]) else 
						(rule = (tbx_varibom_data->formula)["top_x"])
					    ) 
					    (pvalue = evalstring(rule))
					) 
					if(pvalue then 
					    (pvalue = (axlMKSConvert pvalue design_units out_units)) 
					    (pvalue_str = sprintf(nil format_str pvalue)) else
					    (tbx_varibom_data->viewlog = cons(sprintf(nil "   Warning: Cannot validate expression for rule %L" rule) 
						    (tbx_varibom_data->viewlog)
						)) 
					    (pvalue_str = undef_value)
					)
				    ) 
				    (Y 
					when((axlFormGetField 
						(tbx_varibom_data->formid) "transform_xy_angle"
					    ) 
					    (y = pvalue) 
					    (y = y) 
					    if(is_mirrored then 
						(rule = (tbx_varibom_data->formula)["bottom_y"]) else 
						(rule = (tbx_varibom_data->formula)["top_y"])
					    ) 
					    (pvalue = evalstring(rule))
					) 
					if(pvalue then 
					    (pvalue = (axlMKSConvert pvalue design_units out_units)) 
					    (pvalue_str = sprintf(nil format_str pvalue)) else
					    (tbx_varibom_data->viewlog = cons(sprintf(nil "   Warning: Cannot validate expression for rule %L" rule) 
						    (tbx_varibom_data->viewlog)
						)) 
					    (pvalue_str = undef_value)
					)
				    ) 
				    (ROTATION 
					when((axlFormGetField 
						(tbx_varibom_data->formid) "transform_xy_angle"
					    ) 
					    (rot = pvalue) 
					    (rot = rot) 
					    if(is_mirrored then 
						(rule = (tbx_varibom_data->formula)["bottom_rotation"]) else 
						(rule = (tbx_varibom_data->formula)["top_rotation"])
					    ) 
					    (pvalue = evalstring(rule))
					) 
					if(pvalue then 
					    when((abs(pvalue) == 360.0) 
						(pvalue = 0.0)
					    ) 
					    (pvalue_str = sprintf(nil format_str pvalue)) else
					    (tbx_varibom_data->viewlog = cons(sprintf(nil "   Warning: Cannot validate expression for rule %L" rule) 
						    (tbx_varibom_data->viewlog)
						)) 
					    (pvalue_str = undef_value)
					)
				    ) 
				    (t 
					(pvalue_str = sprintf(nil format_str pvalue))
				    )
				) else
				(pvalue_str = sprintf(nil "%L" pvalue))
			    ) 
			    when((decimal_point != ".") 
				rexCompile("[.]") 
				(pvalue_str = rexReplace(pvalue_str decimal_point 0))
			    ) else
			    (pvalue_str = undef_value)
			) 
			putprop(attrTable[ref] pvalue_str pname)
		    ) 
		    ((upperCase(ptype) == "INTEGER") 
			if(pvalue then 
			    if((type(pvalue) == 'fixnum) then 
				(pvalue_str = sprintf(nil "%d" pvalue)) else 
				(pvalue_str = sprintf(nil "%L" pvalue))
			    ) else 
			    (pvalue_str = undef_value)
			) 
			putprop(attrTable[ref] pvalue_str pname)
		    ) 
		    ((upperCase(ptype) == "STRING") 
			if(pvalue then 
			    if((type(pvalue) == 'string) then 
				(pvalue_str = sprintf(nil "%s" pvalue)) else 
				(pvalue_str = sprintf(nil "%L" pvalue))
			    ) else 
			    (pvalue_str = undef_value)
			) 
			putprop(attrTable[ref] pvalue_str pname)
		    ) 
		    (t 
			unless(pvalue 
			    putprop(attrTable[ref] undef_value pname)
			)
		    )
		)
	    )
	)
    )
)
procedure(TBX_VARIBOM_Get_Jedec_Rotation_Offset() 
    let((cfg_file port uc_str arr jedec_type
	    offset_value line jedecRotationOffset
	) 
	(cfg_file = car(TBX_UTIL_Search_Config("jedec_type_rotation_offset.txt" "varibom" nil ?includeWorkDir t))) 
	(jedecRotationOffset = makeTable("jedec_rotation_offset_data" 0.0)) 
	when((isFile(cfg_file) && isReadable(cfg_file)) 
	    printf("Reading rotation offset configuration form %L\n" cfg_file) 
	    (port = infile(cfg_file)) 
	    while((line = _gets(port)) 
		(uc_str = upperCase(line)) 
		if(rexMatchp("^[ \t]*#" uc_str) then t else 
		    (arr = parseString(uc_str))
		    when((length(arr) == 2) 
			(jedec_type = car(arr)) 
			if(atof(cadr(arr)) then 
			    (offset_value = atof(cadr(arr))) 
			    (jedecRotationOffset[jedec_type] = offset_value) else
			    printf("Invalid rotation offset specifed for %L\n" jedec_type)
			)
		    )
		)
	    ) 
	    close(port)
	) jedecRotationOffset
    )
)
procedure(TBX_VARIBOM_Ignore_Parts(prop_name prop_value_pattern) 
    let((pattern_arr prop_value match comp_list) 
	(prop_value_pattern = upperCase(prop_value_pattern)) 
	rexMagic(nil) 
	rexCompile(".") 
	(prop_value_pattern = rexReplace(prop_value_pattern "[.]" 0))
	rexCompile("*") 
	(prop_value_pattern = rexReplace(prop_value_pattern ".*" 0)) 
	rexMagic(t) 
	(pattern_arr = parseString(prop_value_pattern "|")) 
	foreach(cmp 
	    ((axlDBGetDesign)->components) 
	    (match = nil) 
	    (prop_value = nil) 
	    case(lowerCase(prop_name) 
		("refdes" 
		    (prop_value = (cmp->name))
		) 
		("bom_ignore" 
		    when((((cmp->compdef)->prop)->BOM_IGNORE) 
			if((type((((cmp->compdef)->prop)->BOM_IGNORE)) == 'string) then 
			    (prop_value = (((cmp->compdef)->prop)->BOM_IGNORE)) else 
			    (prop_value = "TRUE")
			)
		    ) 
		    when(((cmp->prop)->BOM_IGNORE) 
			if((type(((cmp->prop)->BOM_IGNORE)) == 'string) then 
			    (prop_value = ((cmp->prop)->BOM_IGNORE)) else 
			    (prop_value = "TRUE")
			)
		    )
		) 
		("device_type" 
		    (prop_value = (cmp->deviceType))
		)
	    )
	    when(prop_value 
		(prop_value = upperCase(prop_value)) 
		foreach(pat pattern_arr 
		    when(rexMatchp(strcat("^" pat "$") prop_value) 
			(match = t)
		    )
		) 
		when(match 
		    (comp_list = cons(upperCase((cmp->name)) comp_list))
		)
	    )
	)
	(comp_list = sort(comp_list nil)) comp_list
    )
)
procedure(TBX_VARIBOM_Init(version) 
    let((custom default max_open_windows max_split_cnt data_type
	    default_part_spec tmplog default_grid_props form_config main_cfg
	    transf_cfg
	) 
	(tmplog = list()) 
	(tmplog = cons(sprintf(nil "-->Initializing data structure") tmplog)) 
	(tmplog = cons(sprintf(nil "   Checking environment variables") tmplog)) 
	if(axlGetVariable("TBX_VARIBOM_MAX_OPEN_WINDOWS") then 
	    (max_open_windows = atoi(axlGetVariable("TBX_VARIBOM_MAX_OPEN_WINDOWS"))) 
	    unless(max_open_windows 
		printf("Warning: Invalid value specified in environment variable  TBX_VARIBOM_MAX_OPEN_WINDOWS. Using default value 5") 
		(max_open_windows = 5)
	    ) else
	    (max_open_windows = 5)
	)
	if(axlGetVariable("TBX_VARIBOM_MAX_SPLIT_CNT") then 
	    (max_split_cnt = atoi(axlGetVariable("TBX_VARIBOM_MAX_SPLIT_CNT"))) 
	    unless(max_split_cnt 
		printf("Warning: Invalid value specified in environment variable  TBX_VARIBOM_MAX_SPLIT_CNT. Using default value 10") 
		(max_split_cnt = 10)
	    ) else
	    (max_split_cnt = 10)
	) 
	(data_type = makeTable("data_type_table" nil)) 
	(data_type["ROWNUM"] = "integer") 
	(data_type["X"] = "float") 
	(data_type["Y"] = "float")
	(data_type["ROTATION"] = "float") 
	(data_type["MIRROR"] = "string") 
	(data_type["VARTYPE"] = "string") 
	(data_type["MOUNT_TYPE"] = "string") 
	(data_type["REFDES"] = "string")
	(data_type["CLASS"] = "string") 
	(data_type["DEVICE_TYPE"] = "string") 
	(data_type["JEDEC_TYPE"] = "string") 
	(data_type["PART_NUMBER"] = "string") 
	(data_type["VALUE"] = "string")
	(default_grid_props = list("ROWNUM" "X" "Y" "ROTATION" "MIRROR"
		"VARTYPE" "MOUNT_TYPE" "REFDES" "CLASS" "DEVICE_TYPE"
		"JEDEC_TYPE" "PART_NUMBER" "VALUE"
	    )) 
	(default_grid_props = sort(default_grid_props nil)) 
	(default_part_spec = list(list(1 "ROWNUM" "integer" 0 -1
		    "POS"
		) 
		list(2 "REFDES" "string" 0 -1
		    "REF"
		) 
		list(3 "DEVICE_TYPE" "string" 0 -1
		    "DEVICE"
		) 
		list(4 "X" "float" 2 -1
		    "SYM_X"
		) 
		list(5 "Y" "float" 2 -1
		    "SYM_Y"
		)
		list(6 "ROTATION" "float" 2 -1
		    "ROTATION"
		) 
		list(7 "MIRROR" "string" 0 -1
		    "MIRROR"
		) 
		list(8 "MOUNT_TYPE" "string" 0 -1
		    "MOUNTING"
		) 
		list(9 "VARTYPE" "string" 0 -1
		    "VTYPE"
		)
	    )) 
	(main_cfg = list(list('outputDir "output_dir" "string" ".") 
		list('insertExtHeader "insert_external_header_file" "check" "off") 
		list('extHeaderFile "external_header_file" "string" "") 
		list('insertColName "insert_column_names" "check" "on") 
		list('writeText "write_text" "check" "on")
		list('viewText "view_text" "check" "on") 
		list('writeCSV "write_csv" "check" "off") 
		list('viewCSV "view_csv" "check" "off") 
		list('writeHTML "write_html" "check" "off") 
		list('viewHTML "view_html" "check" "off")
		list('reportUnchanged "report_unchanged_parts" "check" "on") 
		list('reportAlternate "report_alternate_parts" "check" "on") 
		list('reportDNI "report_dni_parts" "check" "off") 
		list('partSpec "part_spec_grid" "grid" default_part_spec) 
		list('excludeFromBOM "exclude_from_bom" "check" "off")
		list('excludePropName "exclude_prop_name" "popup" "bom_ignore") 
		list('excludePropValue "exclude_prop_value" "string" "*") 
		list('undefValue "undefined_value" "string" "NA") 
		list('mirrorStatus "mirror_status" "popup" "yes/no") 
		list('decimalPoint "decimal_point" "popup" "dot")
		list('outputUnits "output_units" "popup" "mm") 
		list('fileExt "file_extension" "string" "bom") 
		list('addColSep "add_column_separator" "check" "on") 
		list('csvSeparator "csv_separator" "string" ";") 
		list('xyOrigin "xy_at_symbol_origin" "radio" "on")
		list('xyCenter "xy_at_symbol_center" "radio" "off") 
		list('transform "transform_xy_angle" "check" "off") 
		list('jedecRotationOffset "use_jedec_rotation_offset" "check" "off") 
		list('sortLevel1 "sort_level1" "popup" "refdes") 
		list('sortLevel2 "sort_level2" "popup" "<no_sort>")
		list('sortLevel3 "sort_level3" "popup" "<no_sort>") 
		list('newlineLevel1 "newline_level1" "check" "off") 
		list('splitLevel1 "split_level1" "check" "off") 
		list('newlineLevel2 "newline_level2" "check" "off") 
		list('splitLevel2 "split_level2" "check" "off")
	    )) 
	(transf_cfg = list(list('topX "top_x" "string" "x") 
		list('topY "top_y" "string" "y") 
		list('topRot "top_rotation" "string" "rot") 
		list('bottomX "bottom_x" "string" "x") 
		list('bottomY "bottom_y" "string" "y")
		list('bottomRot "bottom_rotation" "string" "rot")
	    ))
	(form_config = ncons(nil)) 
	(form_config->main = main_cfg) 
	(form_config->transf = transf_cfg) 
	(default = makeTable("default_table" nil)) 
	foreach(entry main_cfg 
	    (default[cadr(entry)] = nth(3 entry))
	)
	foreach(entry transf_cfg 
	    (default[cadr(entry)] = nth(3 entry))
	) 
	unless(boundp('tbx_varibom_data) 
	    iliDefstruct('defstruct(tbx_varibom_data_struct formid formConfig variant param
			viewlog designAttr variantAttr colWidth refOrder
			extHeader gridRows default custom curSplitCnt
			maxWindowsCnt openWindows maxSplitCnt version dataType
			defaultGridProps formula reports licCheck curVariantName
			curReportName
		    )
	    ) 
	    defvar(tbx_varibom_data nil)
	) 
	if(!tbx_varibom_data then 
	    (tbx_varibom_data = (make_tbx_varibom_data_struct ?formid nil ?formConfig form_config
		    ?variant nil ?param nil ?viewlog
		    tmplog ?designAttr nil ?variantAttr nil
		    ?colWidth nil ?refOrder nil ?extHeader
		    nil ?gridRows nil ?curSplitCnt 0
		    ?default default ?custom custom ?maxWindowsCnt
		    max_open_windows ?maxSplitCnt max_split_cnt ?openWindows nil
		    ?version version ?dataType data_type ?defaultGridProps
		    default_grid_props ?formula nil ?reports 
		    ncons(nil)
		    ?licCheck nil ?curVariantName nil ?curReportName
		    nil
		)) else 
	    (tbx_varibom_data->formid = nil)
	    (tbx_varibom_data->formConfig = form_config) 
	    (tbx_varibom_data->variant = nil) 
	    (tbx_varibom_data->designAttr = nil) 
	    (tbx_varibom_data->variantAttr = nil) 
	    (tbx_varibom_data->param = nil)
	    (tbx_varibom_data->viewlog = tmplog) 
	    (tbx_varibom_data->colWidth = nil) 
	    (tbx_varibom_data->refOrder = nil) 
	    (tbx_varibom_data->extHeader = nil) 
	    (tbx_varibom_data->gridRows = nil)
	    (tbx_varibom_data->curSplitCnt = 0) 
	    (tbx_varibom_data->default = default) 
	    (tbx_varibom_data->custom = custom) 
	    (tbx_varibom_data->maxWindowsCnt = max_open_windows) 
	    (tbx_varibom_data->maxSplitCnt = max_split_cnt)
	    (tbx_varibom_data->openWindows = nil) 
	    (tbx_varibom_data->version = version) 
	    (tbx_varibom_data->dataType = data_type) 
	    (tbx_varibom_data->defaultGridProps = default_grid_props) 
	    (tbx_varibom_data->formula = nil)
	    (tbx_varibom_data->reports = ncons(nil)) 
	    (tbx_varibom_data->licCheck = nil) 
	    (tbx_varibom_data->curVariantName = nil) 
	    (tbx_varibom_data->curReportName = nil)
	)
    )
)
procedure(TBX_VARIBOM_Init_Form(form_handle form_tag) 
    let((field_name field_type field_value msg token
	    field_info param_data variant_name variant_popup_data
	) 
	caseq(form_tag 
	    (Main 
		(field_info = ((tbx_varibom_data->formConfig)->main)) 
		(param_data = (tbx_varibom_data->custom)["part_spec_grid"]) 
		(tbx_varibom_data->param = TBX_VARIBOM_Param_Integrity(param_data)) 
		(tbx_varibom_data->gridRows = length((tbx_varibom_data->param)))
		(variant_popup_data = TBX_VARIBOM_Build_Variant_Popup((tbx_varibom_data->variant))) 
		TBX_VARIBOM_Build_Sort_Popup("init") 
		(axlFormBuildPopup form_handle "grid_property_select_popup" 
		    (tbx_varibom_data->defaultGridProps)
		)
	    ) 
	    (Transform 
		(field_info = ((tbx_varibom_data->formConfig)->transf)) 
		(msg = "Note: Variant BOM always subtracts multiple of 360 for angles equal or greater than 360 degrees\n") 
		(msg = strcat(msg "Note: You may also use unit specifiers in your formulas, possible values are um, mm, mil, inch and cm.")) 
		(axlFormSetField form_handle "info_note" msg)
	    ) 
	    (t t)
	) 
	foreach(entry field_info 
	    (token = car(entry)) 
	    (field_name = cadr(entry)) 
	    (field_type = caddr(entry))
	    (field_value = (tbx_varibom_data->custom)[field_name]) 
	    cond(((field_type == "popup") 
		    (axlFormSetField form_handle field_name field_value)
		) 
		((field_type == "grid") 
		    when((token == 'partSpec) 
			TBX_VARIBOM_Init_Grid_Tables()
		    )
		) 
		(((field_type == "check") || (field_type == "radio")) 
		    if((lowerCase(field_value) == "on") then 
			(axlFormSetField form_handle field_name t) else 
			(axlFormSetField form_handle field_name nil)
		    )
		) 
		(t 
		    (axlFormSetField form_handle field_name field_value)
		)
	    )
	) 
	when((form_tag == 'Main) 
	    (axlFormSetFieldEditable form_handle "report_name" t) 
	    cond((member("all" 
			mapcar(lambda((x) 
				cadr(x)
			    ) variant_popup_data
			)
		    ) 
		    (axlFormSetField form_handle "variant_name" "all") 
		    (axlFormSetField form_handle "report_name" "<variant_name>")
		) 
		(t 
		    (axlFormSetField form_handle "variant_name" "core") 
		    (axlFormSetField form_handle "report_name" "core")
		)
	    ) 
	    when(((axlFormGetField form_handle "variant_name") == "all") 
		(axlFormSetFieldEditable form_handle "report_name" nil)
	    ) 
	    if((axlFormGetField form_handle "write_text") then 
		(axlFormSetFieldEditable form_handle "view_text" t) else 
		(axlFormSetFieldEditable form_handle "view_text" nil)
	    )
	    if((axlFormGetField form_handle "write_csv") then 
		(axlFormSetFieldEditable form_handle "view_csv" t) else 
		(axlFormSetFieldEditable form_handle "view_csv" nil)
	    ) 
	    if((axlFormGetField form_handle "write_html") then 
		(axlFormSetFieldEditable form_handle "view_html" t) else 
		(axlFormSetFieldEditable form_handle "view_html" nil)
	    ) 
	    (variant_name = lowerCase((axlFormGetField form_handle "variant_name"))) 
	    if((variant_name == "core") then 
		(axlFormSetFieldEditable form_handle "report_unchanged_parts" nil) 
		(axlFormSetFieldEditable form_handle "report_alternate_parts" nil) 
		(axlFormSetFieldEditable form_handle "report_dni_parts" nil)
		else 
		(axlFormSetFieldEditable form_handle "report_unchanged_parts" t) 
		(axlFormSetFieldEditable form_handle "report_alternate_parts" t) 
		(axlFormSetFieldEditable form_handle "report_dni_parts" t)
	    ) 
	    if(((!(axlFormGetField form_handle "newline_level1") && 
			!(axlFormGetField form_handle "split_level1")) || 
		    ((axlFormGetField form_handle "sort_level2") == "<no_sort>")) then 
		(axlFormSetField form_handle "newline_level2" nil) 
		(axlFormSetField form_handle "split_level2" nil) 
		(axlFormSetFieldEditable form_handle "newline_level2" nil)
		(axlFormSetFieldEditable form_handle "split_level2" nil) else 
		(axlFormSetFieldEditable form_handle "newline_level2" t) 
		(axlFormSetFieldEditable form_handle "split_level2" t)
	    )
	    when((axlFormGetField form_handle "newline_level1") 
		(axlFormSetField form_handle "split_level1" nil) 
		when((axlFormGetField form_handle "split_level2") 
		    (axlFormSetField form_handle "split_level2" nil)
		)
	    ) 
	    when((axlFormGetField form_handle "split_level1") 
		(axlFormSetField form_handle "newline_level1" nil)
	    ) 
	    when((axlFormGetField form_handle "newline_level2") 
		(axlFormSetField form_handle "split_level2" nil)
	    ) 
	    when((axlFormGetField form_handle "split_level2") 
		(axlFormSetField form_handle "newline_level2" nil) 
		(axlFormSetField form_handle "split_level1" t) 
		(axlFormSetField form_handle "newline_level1" nil)
	    ) 
	    if((axlFormGetField form_handle "exclude_from_bom") then 
		(axlFormSetFieldEditable form_handle "exclude_prop_name" t) 
		(axlFormSetFieldEditable form_handle "exclude_prop_value" t) else
		(axlFormSetFieldEditable form_handle "exclude_prop_name" nil) 
		(axlFormSetFieldEditable form_handle "exclude_prop_value" nil)
	    )
	) t
    )
)
procedure(TBX_VARIBOM_Init_Grid_Cols() 
    let((lf p) 
	(lf = (tbx_varibom_data->formid)) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'LONG) 
	(p->colWidth = 2)
	(p->align = 'right) 
	(p->fieldLength = 4) 
	(p->min = 1) 
	(p->max = 50) 
	(p->headText = "Nr")
	(p->scriptLabel = "nr") 
	(axlFormGridInsertCol lf "part_spec_grid" p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 10)
	(p->popup = "grid_property_select_popup") 
	(p->headText = "Parameter") 
	(p->scriptLabel = "param") 
	(axlFormGridInsertCol lf "part_spec_grid" p) 
	(p = (make_formGridCol))
	(p->fieldType = 'ENUMSET) 
	(p->colWidth = 5) 
	(p->align = 'left) 
	(p->popup = "data_type_popup") 
	(p->headText = "Type")
	(p->scriptLabel = "type") 
	(axlFormGridInsertCol lf "part_spec_grid" p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'LONG) 
	(p->colWidth = 3)
	(p->fieldLength = 50) 
	(p->min = 0) 
	(p->max = 5) 
	(p->decimals = 0) 
	(p->headText = "Acc.")
	(p->scriptLabel = "acc") 
	(axlFormGridInsertCol lf "part_spec_grid" p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'LONG) 
	(p->colWidth = 3)
	(p->fieldLength = 50) 
	(p->min = -1) 
	(p->max = 255) 
	(p->headText = "Width") 
	(p->scriptLabel = "width")
	(axlFormGridInsertCol lf "part_spec_grid" p) 
	(p = (make_formGridCol)) 
	(p->fieldType = 'STRING) 
	(p->colWidth = 10) 
	(p->fieldLength = 50)
	(p->headText = "Name") 
	(p->scriptLabel = "title") 
	(axlFormGridInsertCol lf "part_spec_grid" p)
    )
)
procedure(TBX_VARIBOM_Init_Grid_Tables() 
    (axlFormGridReset 
	(tbx_varibom_data->formid) "part_spec_grid"
    ) 
    TBX_VARIBOM_Init_Grid_Cols() 
    (axlFormGridInsertRows 
	(tbx_varibom_data->formid) "part_spec_grid" 0 
	(tbx_varibom_data->gridRows)
    ) 
    (axlFormGridSetBatch 
	(tbx_varibom_data->formid) "part_spec_grid" 
	'TBX_VARIBOM_Update_Grid_Rows_CB nil
    )
    (axlFormGridEvents 
	(tbx_varibom_data->formid) "part_spec_grid" 
	list('cellselect 
	    'change 
	    'rightpopup
	)
    ) 
    (axlFormGridUpdate 
	(tbx_varibom_data->formid) "part_spec_grid"
    )
)
procedure(TBX_VARIBOM_Load_File(file_name file_type) 
    let((inport data line port) 
	when((isFile(file_name) && isReadable(file_name)) 
	    cond(((file_type == "list") 
		    (inport = infile(file_name)) 
		    (data = car(lineread(inport))) 
		    close(inport)
		) 
		(t 
		    (port = infile(file_name)) 
		    while((line = _gets(port)) 
			(line = car(parseString(line "\n"))) 
			if(line then 
			    (data = cons(line data)) else 
			    (data = cons("" data))
			)
		    ) 
		    close(port) 
		    (data = reverse(data))
		)
	    )
	) data
    )
)
procedure((TBX_VARIBOM_Main \@optional arg) ;²»Í¬bomÐÅÏ¢
    let((lic_check_result VERSION_STR FC_FEATURE FC_VERSION SUB_VERSION
	    fid FORM_FILE variant_file variant_data port
	    info_file ok_start_app
	) 
	(FC_FEATURE = "VARIBOM") 
	(FC_VERSION = "17.1") 
	(SUB_VERSION = "03") 
	(VERSION_STR = sprintf(nil "Variant BOM %s (C)2017" FC_VERSION))
	(ok_start_app = t) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./varibom_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Variant BOM information:\n") 
		fprintf(port "========================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "  viewlog  : Shows log file\n") 
		fprintf(port "  reset   : Deletes internal configuration from database\n") 
		fprintf(port "\n")
		fprintf(port "Environment variables:\n") 
		fprintf(port "  TBX_VARIBOM_MAX_OPEN_WINDOWS\n") 
		fprintf(port "     Specifies the maximum number of report windows to be opened.\n") 
		fprintf(port "     e.g. set TBX_VARIBOM_MAX_OPEN_WINDOWS = 10\n") 
		fprintf(port "     The default limit is not to open more than 5 files simultaneously.\n")
		fprintf(port "  TBX_VARIBOM_MAX_SPLIT_CNT\n") 
		fprintf(port "     When option Split output files is enabled the final report is split into several files\n") 
		fprintf(port "     depending on the values of the Level 1 sort parameter. If, for example, Level 1 is\n") 
		fprintf(port "     set to Refdes, many files would be generated which is obviously not intended.\n") 
		fprintf(port "     e.g. set TBX_VARIBOM_MAX_SPLIT_CNT = 20\n")
		fprintf(port "     The default limit is not to generate more than 10 files.\n") 
		close(port) 
		(axlUIViewFileCreate info_file "Variant BOM: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "viewlog")) 
		TBX_VARIBOM_Viewlog() 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "reset")) 
		when((axlUIYesNo "Delete configuration from database?" nil 
			'no
		    ) 
		    (axlDeleteAttachment "tbx_varibom")
		) 
		(ok_start_app = nil)
	    )
	) 
	when(ok_start_app 
	    (lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
	    when(lic_check_result 
		(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "varibom_main")) 
		unless(boundp('tbxVaribomMainHandle) 
		    defvar(tbxVaribomMainHandle nil)
		) 
		(fid = (axlFormCreate 
			'tbxVaribomMainHandle FORM_FILE 
			'(e outer) 
			'TBX_VARIBOM_Main_Callback
			t nil
		    )) 
		when(fid 
		    TBX_VARIBOM_Init(VERSION_STR) 
		    TBX_UTIL_Migrate("flw_varibom" "tbx_varibom") 
		    (tbx_varibom_data->formid = fid) 
		    (tbx_varibom_data->licCheck = lic_check_result)
		    (variant_file = sprintf(nil "%s/variants.lst" 
			    getWorkingDir()
			)) 
		    if(isFile(variant_file) then 
			(variant_data = TBX_VARIBOM_Load_File(variant_file "list")) 
			if(variant_data then 
			    (axlFormSetField 
				(tbx_varibom_data->formid) "variants_file" variant_file
			    ) 
			    (tbx_varibom_data->variant = variant_data) 
			    (tbx_varibom_data->viewlog = cons(sprintf(nil "-->Reading variant data from %s" variant_file) 
				    (tbx_varibom_data->viewlog)
				))
			    else 
			    (axlUIWPrint fid "E - Cannot read data from variants.lst") 
			    (tbx_varibom_data->viewlog = cons(sprintf(nil "-->Error: Cannot read variant file %s" variant_file) 
				    (tbx_varibom_data->viewlog)
				))
			) else
			(tbx_varibom_data->viewlog = cons(sprintf(nil "-->Info: File variants.lst not found") 
				(tbx_varibom_data->viewlog)
			    ))
		    ) 
		    (tbx_varibom_data->custom = TBX_VARIBOM_Read_Config(nil)) 
		    (tbx_varibom_data->viewlog = cons(sprintf(nil "-->Setting form default values") 
			    (tbx_varibom_data->viewlog)
			)) 
		    (tbx_varibom_data->viewlog = cons(sprintf(nil "-->Initialize form settings") 
			    (tbx_varibom_data->viewlog)
			))
		    TBX_VARIBOM_Init_Form(fid 
			'Main
		    ) 
		    (tbx_varibom_data->curVariantName = (axlFormGetField fid "variant_name")) 
		    (tbx_varibom_data->curReportName = (axlFormGetField fid "report_name")) 
		    TBX_FORM_Init_Header(fid "Licensed for " lic_check_result VERSION_STR) 
		    (axlFormDisplay 
			(tbx_varibom_data->formid)
		    )
		    TBX_FORM_Delete(lic_check_result FORM_FILE)
		)
	    )
	)
    )
)
procedure(TBX_VARIBOM_Main_Callback(form_handle) 
    let((file_name variant_data output_file input_file FORM_FILE2
	    fid2 cell tmp_list cur_row val
	    msg popup_data cur_variant cur_report
	) 
	case((form_handle->curField) 
	    ("part_spec_grid" 
		caseq((form_handle->event) 
		    (rightpopup 
			case((form_handle->curValue) 
			    ("del_row" 
				(cur_row = (form_handle->row)) 
				(cell = (axlFormGridNewCell)) 
				(cell->row = cur_row) 
				(cell->col = 2)
				(val = upperCase(((axlFormGridGetCell form_handle "part_spec_grid" cell)->value))) 
				if(((val == "REFDES") || (val == "VARTYPE")) then 
				    (axlUIConfirm "Cannot delete this row") else 
				    (axlFormGridDeleteRows form_handle "part_spec_grid" cur_row 1)
				    (tbx_varibom_data->gridRows = ((tbx_varibom_data->gridRows) - 1))
				)
			    ) 
			    ("add_row" 
				(tbx_varibom_data->gridRows = ((tbx_varibom_data->gridRows) + 1)) 
				(axlFormGridInsertRows form_handle "part_spec_grid" 
				    (tbx_varibom_data->gridRows) 1
				) 
				(tmp_list = list((tbx_varibom_data->gridRows) "PROP_NAME" "String" 0 "?????")) 
				for(c 1 5 
				    (cell = (axlFormGridNewCell)) 
				    (cell->col = c)
				    (cell->row = (tbx_varibom_data->gridRows)) 
				    (cell->value = nth((c - 1) tmp_list)) 
				    (axlFormSetField form_handle "part_spec_grid" cell)
				)
			    ) 
			    ("move_down" 
				(cur_row = (form_handle->row)) 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 1) 
				(cell->row = cur_row)
				(cell->value = (cur_row + 1)) 
				(axlFormSetField form_handle "part_spec_grid" cell) 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 1) 
				(cell->row = (cur_row + 1))
				(cell->value = cur_row) 
				(axlFormSetField form_handle "part_spec_grid" cell)
			    ) 
			    ("move_up" 
				(cur_row = (form_handle->row)) 
				when((cur_row > 1) 
				    (cell = (axlFormGridNewCell)) 
				    (cell->col = 1) 
				    (cell->row = cur_row) 
				    (cell->value = (cur_row - 1))
				    (axlFormSetField form_handle "part_spec_grid" cell) 
				    (cell = (axlFormGridNewCell)) 
				    (cell->col = 1) 
				    (cell->row = (cur_row - 1)) 
				    (cell->value = cur_row)
				    (axlFormSetField form_handle "part_spec_grid" cell)
				)
			    )
			    (t)
			) 
			(tbx_varibom_data->param = TBX_VARIBOM_Extract_Parameter_List()) 
			(tbx_varibom_data->gridRows = length((tbx_varibom_data->param))) 
			TBX_VARIBOM_Build_Sort_Popup("init")
			TBX_VARIBOM_Init_Grid_Tables()
		    ) 
		    (change 
			caseq((form_handle->col) 
			    (1 
				(cur_row = (form_handle->row)) 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 1) 
				(cell->row = cur_row)
				(cell->value = (form_handle->curValue)) 
				(axlFormSetField form_handle "part_spec_grid" cell) 
				(cell = (axlFormGridNewCell)) 
				(cell->col = 1) 
				(cell->row = (form_handle->curValue))
				(cell->value = (form_handle->row)) 
				(axlFormSetField form_handle "part_spec_grid" cell)
			    ) 
			    (3 t) 
			    (5 
				(cell = (axlFormGridNewCell)) 
				(cell->col = (form_handle->col)) 
				(cell->row = (form_handle->row)) 
				if(zerop((form_handle->curValue)) then 
				    (cell->value = -1) 
				    (axlUIWPrint form_handle "E - Zero width not supported.") else
				    (cell->value = (form_handle->curValue))
				)
				(axlFormSetField form_handle "part_spec_grid" cell)
			    ) 
			    (t t)
			) 
			(tbx_varibom_data->param = TBX_VARIBOM_Extract_Parameter_List()) 
			(tbx_varibom_data->gridRows = length((tbx_varibom_data->param))) 
			TBX_VARIBOM_Build_Sort_Popup("init")
			TBX_VARIBOM_Init_Grid_Tables()
		    )
		)
	    ) 
	    ("exclude_from_bom" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "exclude_prop_name" t) 
		    (axlFormSetFieldEditable form_handle "exclude_prop_value" t) else
		    (axlFormSetFieldEditable form_handle "exclude_prop_name" nil) 
		    (axlFormSetFieldEditable form_handle "exclude_prop_value" nil)
		)
	    ) 
	    ("load_variant_file" 
		if((axlOKToProceed) then 
		    (tbx_varibom_data->viewlog = cons(sprintf(nil "-->Reading external variant file") 
			    (tbx_varibom_data->viewlog)
			)) 
		    (file_name = (axlDMFileBrowse nil nil ?optFilters "Project Files (*.lst)|*.lst"
			    ?noSticky t
			)) 
		    when(file_name 
			(axlFormSetField form_handle "variants_file" file_name) 
			if(isFile(file_name) then 
			    (variant_data = TBX_VARIBOM_Load_File(file_name "list")) 
			    if(variant_data then 
				(axlFormSetField form_handle "variants_file" file_name) 
				(tbx_varibom_data->variant = variant_data) 
				(popup_data = TBX_VARIBOM_Build_Variant_Popup((tbx_varibom_data->variant)))
				(axlFormSetFieldEditable form_handle "report_name" t) 
				(cur_variant = (tbx_varibom_data->curVariantName)) 
				(cur_report = (tbx_varibom_data->curReportName)) 
				cond(((cur_variant && member(cur_variant 
						mapcar(lambda((x) 
							cadr(x)
						    ) popup_data
						)
					    )) 
					(axlFormSetField form_handle "variant_name" cur_variant) 
					(axlFormSetField form_handle "report_name" cur_report)
				    ) 
				    (member("all" 
					    mapcar(lambda((x) 
						    cadr(x)
						) popup_data
					    )
					) 
					(axlFormSetField form_handle "variant_name" "all") 
					(axlFormSetField form_handle "report_name" "<variant_name>")
				    ) 
				    (t 
					(axlFormSetField form_handle "variant_name" "core") 
					(axlFormSetField form_handle "report_name" "core")
				    )
				) 
				when(((axlFormGetField form_handle "variant_name") == "all") 
				    (axlFormSetFieldEditable form_handle "report_name" nil)
				)
				(tbx_varibom_data->curVariantName = (axlFormGetField form_handle "variant_name")) 
				(tbx_varibom_data->curReportName = (axlFormGetField form_handle "report_name")) else 
				(tbx_varibom_data->viewlog = cons(sprintf(nil "Error: Invalid format in file %s" file_name) 
					(tbx_varibom_data->viewlog)
				    ))
			    ) else
			    (tbx_varibom_data->viewlog = cons(sprintf(nil "Error: File %s does not exist" file_name) 
				    (tbx_varibom_data->viewlog)
				))
			)
		    )
		    else 
		    (axlUIWPrint form_handle "E - Finish current command first!")
		)
	    ) 
	    ("run" 
		if((axlOKToProceed) then 
		    foreach(win 
			(tbx_varibom_data->openWindows) 
			(axlUIWClose win)
		    ) 
		    (tbx_varibom_data->openWindows = nil) 
		    (tbx_varibom_data->viewlog = cons(sprintf(nil "\n-->Date: %s" 
				getCurrentTime()
			    ) 
			    (tbx_varibom_data->viewlog)
			))
		    (tbx_varibom_data->viewlog = cons(sprintf(nil "-->Create Variant BOM Reports") 
			    (tbx_varibom_data->viewlog)
			)) 
		    ((tbx_varibom_data->reports)->TEXT = nil) 
		    ((tbx_varibom_data->reports)->CSV = nil) 
		    ((tbx_varibom_data->reports)->HTML = nil) 
		    TBX_VARIBOM_Start_Create_Reports()
		    ((tbx_varibom_data->reports)->TEXT = sort(((tbx_varibom_data->reports)->TEXT) nil)) 
		    ((tbx_varibom_data->reports)->CSV = sort(((tbx_varibom_data->reports)->CSV) nil)) 
		    ((tbx_varibom_data->reports)->HTML = sort(((tbx_varibom_data->reports)->HTML) nil)) 
		    when((axlFormGetField form_handle "view_text") 
			TBX_VARIBOM_View_Generated_Reports(((tbx_varibom_data->reports)->TEXT) "text")
		    ) 
		    when((axlFormGetField form_handle "view_csv") 
			TBX_VARIBOM_View_Generated_Reports(((tbx_varibom_data->reports)->CSV) "csv")
		    )
		    when((axlFormGetField form_handle "view_html") 
			TBX_VARIBOM_View_Generated_Reports(((tbx_varibom_data->reports)->HTML) "html")
		    ) else 
		    (axlUIWPrint form_handle "E - Finish current command first!")
		)
	    )
	    ("variant_name" 
		case((form_handle->curValue) 
		    ("all" 
			(axlFormSetFieldEditable form_handle "report_name" nil) 
			(file_name = "<variant_name>") 
			(axlFormSetFieldEditable form_handle "report_unchanged_parts" t) 
			(axlFormSetFieldEditable form_handle "report_alternate_parts" t)
			(axlFormSetFieldEditable form_handle "report_dni_parts" t)
		    ) 
		    ("core" 
			(axlFormSetFieldEditable form_handle "report_name" t) 
			(file_name = "core") 
			(axlFormSetFieldEditable form_handle "report_unchanged_parts" nil) 
			(axlFormSetFieldEditable form_handle "report_alternate_parts" nil)
			(axlFormSetFieldEditable form_handle "report_dni_parts" nil)
		    ) 
		    ("common" 
			(axlFormSetFieldEditable form_handle "report_name" t) 
			(file_name = "common") 
			(axlFormSetFieldEditable form_handle "report_unchanged_parts" nil) 
			(axlFormSetFieldEditable form_handle "report_alternate_parts" nil)
			(axlFormSetFieldEditable form_handle "report_dni_parts" nil)
		    ) 
		    (t 
			(axlFormSetFieldEditable form_handle "report_name" t) 
			(file_name = (axlFormGetField form_handle "variant_name")) 
			(axlFormSetFieldEditable form_handle "report_unchanged_parts" t) 
			(axlFormSetFieldEditable form_handle "report_alternate_parts" t)
			(axlFormSetFieldEditable form_handle "report_dni_parts" t)
		    )
		) 
		(axlFormSetField form_handle "report_name" file_name) 
		(tbx_varibom_data->curVariantName = (form_handle->curValue)) 
		(tbx_varibom_data->curReportName = (axlFormGetField form_handle "report_name"))
	    ) 
	    ("report_name" 
		(tbx_varibom_data->curReportName = (form_handle->curValue))
	    ) 
	    ("newline_level1" 
		if(((!(form_handle->curValue) && !(axlFormGetField form_handle "split_level1")) || 
			((axlFormGetField form_handle "sort_level2") == "<no_sort>")) then 
		    (axlFormSetField form_handle "newline_level2" nil) 
		    (axlFormSetField form_handle "split_level2" nil) 
		    (axlFormSetFieldEditable form_handle "newline_level2" nil)
		    (axlFormSetFieldEditable form_handle "split_level2" nil) else 
		    (axlFormSetFieldEditable form_handle "newline_level2" t) 
		    (axlFormSetFieldEditable form_handle "split_level2" t)
		) 
		when((form_handle->curValue) 
		    (axlFormSetField form_handle "split_level1" nil) 
		    when((axlFormGetField form_handle "split_level2") 
			(axlFormSetField form_handle "split_level2" nil)
		    )
		)
	    ) 
	    ("split_level1" 
		if(((!(form_handle->curValue) && !(axlFormGetField form_handle "newline_level1")) || 
			((axlFormGetField form_handle "sort_level2") == "<no_sort>")) then 
		    (axlFormSetField form_handle "newline_level2" nil) 
		    (axlFormSetField form_handle "split_level2" nil) 
		    (axlFormSetFieldEditable form_handle "newline_level2" nil)
		    (axlFormSetFieldEditable form_handle "split_level2" nil) else 
		    (axlFormSetFieldEditable form_handle "newline_level2" t) 
		    (axlFormSetFieldEditable form_handle "split_level2" t)
		) 
		when((form_handle->curValue) 
		    (axlFormSetField form_handle "newline_level1" nil)
		)
	    ) 
	    ("sort_level2" 
		if(((!(axlFormGetField form_handle "split_level1") && 
			    !(axlFormGetField form_handle "newline_level1")) || 
			((form_handle->curValue) == "<no_sort>")) then 
		    (axlFormSetField form_handle "newline_level2" nil) 
		    (axlFormSetField form_handle "split_level2" nil) 
		    (axlFormSetFieldEditable form_handle "newline_level2" nil)
		    (axlFormSetFieldEditable form_handle "split_level2" nil) else 
		    (axlFormSetFieldEditable form_handle "newline_level2" t) 
		    (axlFormSetFieldEditable form_handle "split_level2" t)
		)
	    )
	    ("newline_level2" 
		when((form_handle->curValue) 
		    (axlFormSetField form_handle "split_level2" nil)
		)
	    ) 
	    ("split_level2" 
		when((form_handle->curValue) 
		    (axlFormSetField form_handle "newline_level2" nil) 
		    (axlFormSetField form_handle "split_level1" t) 
		    (axlFormSetField form_handle "newline_level1" nil)
		)
	    ) 
	    ("variant_file" 
		(file_name = (axlFormGetField form_handle "variant_file")) 
		(file_name = car(parseString(file_name "."))) 
		(file_name = strcat(file_name "." 
			lowerCase((axlFormGetField form_handle "file_extension"))
		    )) 
		(axlFormSetField form_handle "variant_file" file_name)
	    ) 
	    ("common_file" 
		(file_name = (axlFormGetField form_handle "common_file")) 
		(file_name = car(parseString(file_name "."))) 
		(file_name = strcat(file_name "." 
			lowerCase((axlFormGetField form_handle "file_extension"))
		    )) 
		(axlFormSetField form_handle "common_file" file_name)
	    ) 
	    ("output_dir" 
		(axlFormSetField form_handle "output_dir" 
		    (form_handle->curValue)
		)
	    )
	    ("write_html" 
		if((axlFormGetField form_handle "write_html") then 
		    (axlFormSetFieldEditable form_handle "view_html" t) else 
		    (axlFormSetFieldEditable form_handle "view_html" nil)
		)
	    ) 
	    ("write_csv" 
		if((axlFormGetField form_handle "write_csv") then 
		    (axlFormSetFieldEditable form_handle "view_csv" t) else 
		    (axlFormSetFieldEditable form_handle "view_csv" nil)
		)
	    ) 
	    ("write_text" 
		if((axlFormGetField form_handle "write_text") then 
		    (axlFormSetFieldEditable form_handle "view_text" t) else 
		    (axlFormSetFieldEditable form_handle "view_text" nil)
		)
	    ) 
	    ("specify_transformation" 
		(tbx_varibom_data->viewlog = cons(sprintf(nil "-->Specifying transformation rules") 
			(tbx_varibom_data->viewlog)
		    )) 
		(FORM_FILE2 = TBX_FORM_Get_Name((tbx_varibom_data->licCheck) "varibom_transform")) 
		(fid2 = (axlFormCreate 
			gensym("tbxvaribomtransform") FORM_FILE2 
			'(e outer) 
			'TBX_VARIBOM_Transformation_Callback
			t
		    )) 
		(tbx_varibom_data->viewlog = cons(sprintf(nil "   Launching transform callback") 
			(tbx_varibom_data->viewlog)
		    ))
		TBX_FORM_Init_Header(fid2 "Licensed for " 
		    (tbx_varibom_data->licCheck) 
		    (tbx_varibom_data->version)
		) 
		TBX_VARIBOM_Init_Form(fid2 
		    'Transform
		) 
		(axlFormDisplay fid2) 
		TBX_FORM_Delete((tbx_varibom_data->licCheck) FORM_FILE2)
	    ) 
	    ("use_jedec_rotation_offset" t)
	    ("jedec_mini_help" 
		(msg = "If enabled an offset will be added to symbol rotation value as specified in configuration file \"jedec_type_rotation_offset.txt\" ") 
		(msg = sprintf(nil "%s located in directory <install_root>/share/pcb/toolbox/config/varibom. " msg)) 
		(msg = sprintf(nil "%s A local file in current working directory overrides defaults." msg)) 
		(axlUIConfirm msg)
	    ) 
	    ("load_header_file" 
		if((axlOKToProceed) then 
		    (file_name = (axlDMFileBrowse nil nil ?optFilters "Header Files (*.txt)|*.txt"
			    ?noSticky t
			)) 
		    when(file_name 
			(axlFormSetField form_handle "external_header_file" file_name)
		    ) else
		    (axlUIWPrint form_handle "E - Finish current command first!")
		)
	    ) 
	    ("save_to_file" 
		(output_file = (axlDMFileBrowse "ALLEGRO_TEXT" t)) 
		when(output_file 
		    TBX_VARIBOM_Save_Config(output_file)
		)
	    ) 
	    ("load_from_file" 
		(input_file = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
		when((input_file && isFile(input_file)) 
		    (tbx_varibom_data->custom = TBX_VARIBOM_Read_Config(input_file)) 
		    TBX_VARIBOM_Init_Form(form_handle 
			'Main
		    )
		)
	    ) 
	    ("done" 
		TBX_VARIBOM_Save_Config(nil) 
		(axlFormClose form_handle) 
		(axlVisibleUpdate t)
	    )
	    ("cancel" 
		(axlFormClose form_handle) 
		(axlVisibleUpdate t)
	    ) 
	    ("my_help" 
		(axlShell "tbx help varibom")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_VARIBOM_Param_Integrity(pdata) 
    let((tmp_list pind pname ptype pacc
	    pwidth pdisp good_data param_list id
	) 
	(tmp_list = list()) 
	foreach(entry pdata 
	    (good_data = t) 
	    (pind = car(entry)) 
	    (pname = cadr(entry))
	    (ptype = caddr(entry)) 
	    (pacc = nth(3 entry)) 
	    (pwidth = nth(4 entry)) 
	    (pdisp = nth(5 entry)) 
	    cond(((type(pname) == 'string) 
		    (pname = upperCase(pname)) 
		    cond(((pname == "") 
			    (good_data = nil) 
			    (tbx_varibom_data->viewlog = cons(sprintf(nil "   Warning: Invalid parameter in row %L. Skipping..." pind) 
				    (tbx_varibom_data->viewlog)
				))
			) 
			(rexMatchp("^[0-9]" pname) 
			    (good_data = nil) 
			    (tbx_varibom_data->viewlog = cons(sprintf(nil "   Warning: Parameter %L must begin with a character. Skipping..." pname) 
				    (tbx_varibom_data->viewlog)
				))
			) 
			(!stringToSymbol(pname) 
			    (tbx_varibom_data->viewlog = cons(sprintf(nil "   Warning: Parameter %L, Cannot convert to symbol. Skipping..." pname) 
				    (tbx_varibom_data->viewlog)
				)) 
			    (good_data = nil)
			)
		    )
		) 
		((type(pname) == 'symbol) 
		    (pname = upperCase(symbolToString(pname)))
		) 
		(t 
		    (tbx_varibom_data->viewlog = cons(sprintf(nil "   Warning: Invalid data type for %L  for param %L. Skipping..." 
				type(pname) pname
			    ) 
			    (tbx_varibom_data->viewlog)
			)) 
		    (good_data = nil)
		)
	    )
	    when(good_data 
		cond((((pname == "X") || (pname == "Y") || (pname == "ROTATION")) 
			(ptype = "float") 
			when((type(pacc) != 'fixnum) 
			    (tbx_varibom_data->viewlog = cons(sprintf(nil "   Warning:Invalid accuracy specifier %L for param %L. Setting value to 2" pacc pname) 
				    (tbx_varibom_data->viewlog)
				)) 
			    (pacc = 2)
			)
		    ) 
		    ((pname == "MIRROR") 
			(ptype = "string") 
			(pacc = 0)
		    ) 
		    (t t)
		) 
		if((type(pwidth) == 'fixnum) then 
		    when(zerop(pwidth) 
			(pwidth = 1)
		    ) else 
		    (pwidth = -1)
		) 
		(tmp_list = cons(list(pind pname ptype pacc pwidth
			    pdisp
			) tmp_list
		    ))
	    )
	) 
	if((length(tmp_list) > 0) then 
	    (tmp_list = sortcar(tmp_list 
		    'lessp
		)) 
	    (id = 0) 
	    foreach(entry tmp_list 
		(param_list = cons(cons(++id 
			    cdr(entry)
			) param_list
		    ))
	    )
	    (param_list = reverse(param_list)) else 
	    printf("Warning: Invalid part specification.\n") 
	    (param_list = (param_list = list(list(1 "REFDES" "String" 0 -1
			    "REF"
			)
		    )))
	) param_list
    )
)
procedure(TBX_VARIBOM_Print_CSV_File(attrData report_name) 
    let((data_str pname port pvalue ref_list
	    tmp_list csv_file file_counter header_str out_str
	    csv_separator
	) 
	(csv_separator = (axlFormGetField 
		(tbx_varibom_data->formid) "csv_separator"
	    )) 
	(header_str = "") 
	when((axlFormGetField 
		(tbx_varibom_data->formid) "insert_external_header_file"
	    ) 
	    foreach(line 
		TBX_VARIBOM_Process_External_Header(report_name) 
		(header_str = sprintf(nil "%s\n%s" header_str line))
	    )
	) 
	(tmp_list = list())
	when((axlFormGetField 
		(tbx_varibom_data->formid) "insert_column_names"
	    ) 
	    foreach(prm 
		(tbx_varibom_data->param) 
		(tmp_list = cons(nth(5 prm) tmp_list))
	    ) 
	    (tmp_list = reverse(tmp_list)) 
	    (data_str = buildString(tmp_list csv_separator)) 
	    if((header_str != "") then 
		(header_str = sprintf(nil "%s\n%s" header_str data_str)) else 
		(header_str = sprintf(nil "%s" data_str))
	    )
	) 
	if((tbx_varibom_data->refOrder) then 
	    (ref_list = (tbx_varibom_data->refOrder)) else 
	    foreach(key attrData 
		(ref_list = cons(key ref_list))
	    )
	    (ref_list = sort(ref_list 
		    'axlStrcmpAlpNum
		))
	) 
	if(((tbx_varibom_data->curSplitCnt) >= 1) then 
	    (file_counter = 1) 
	    (csv_file = sprintf(nil "%s_%d.csv" report_name file_counter)) else
	    (csv_file = sprintf(nil "%s.csv" report_name))
	) 
	(port = outfile(csv_file "w")) 
	fprintf(port "%s\n" header_str)
	foreach(val ref_list 
	    cond(((type(val) == 'string) 
		    (tmp_list = list()) 
		    foreach(prm 
			(tbx_varibom_data->param) 
			(pname = cadr(prm)) 
			(pvalue = get(attrData[val] pname)) 
			(tmp_list = cons(pvalue tmp_list))
		    ) 
		    (tmp_list = reverse(tmp_list)) 
		    (out_str = buildString(tmp_list csv_separator))
		    fprintf(port "%s\n" out_str)
		) 
		((val == 'split) 
		    close(port) 
		    ((tbx_varibom_data->reports)->CSV = cons(csv_file 
			    ((tbx_varibom_data->reports)->CSV)
			)) 
		    (file_counter = (file_counter + 1)) 
		    (csv_file = sprintf(nil "%s_%d.csv" report_name file_counter))
		    (port = outfile(csv_file "w")) 
		    fprintf(port "%s\n" header_str)
		) 
		((val == 'newline) 
		    fprintf(port "\n")
		)
	    )
	) 
	close(port) 
	((tbx_varibom_data->reports)->CSV = cons(csv_file 
		((tbx_varibom_data->reports)->CSV)
	    )) 
	printf("Note: File %s has been written\n" csv_file) t
    )
)
procedure(TBX_VARIBOM_Print_Formatted_File(attrData report_name) 
    let((port tmp_list tmp_value col_width format_str
	    out_str data_str line_sep_str col_sep_str pindex
	    ref_list pname pvalue header_str ascii_file
	    file_counter pwidth pre post
	) 
	if((axlFormGetField 
		(tbx_varibom_data->formid) "add_column_separator"
	    ) then 
	    (col_sep_str = "|") else 
	    (col_sep_str = "")
	) 
	(col_width = (tbx_varibom_data->colWidth)) 
	(header_str = "") 
	when((axlFormGetField 
		(tbx_varibom_data->formid) "insert_external_header_file"
	    ) 
	    (header_str = buildString(TBX_VARIBOM_Process_External_Header(report_name) "\n"))
	)
	(tmp_list = list()) 
	when((axlFormGetField 
		(tbx_varibom_data->formid) "insert_column_names"
	    ) 
	    foreach(prm 
		(tbx_varibom_data->param) 
		(pindex = (car(prm) - 1)) 
		(pwidth = car(col_width[pindex])) 
		(pre = cadr(col_width[pindex]))
		(post = caddr(col_width[pindex])) 
		(pvalue = strcat(pre 
			nth(5 prm) post
		    )) 
		(pwidth = (pwidth + strlen(pre) + strlen(post))) 
		if((strlen(pvalue) <= pwidth) then 
		    (format_str = strcat("%-" 
			    sprintf(nil "%d" pwidth) "s"
			)) 
		    (tmp_value = sprintf(nil format_str pvalue)) else
		    (tmp_value = substring(pvalue 1 pwidth))
		) 
		(tmp_list = cons(tmp_value tmp_list))
	    ) 
	    (tmp_list = reverse(tmp_list)) 
	    (data_str = buildString(tmp_list col_sep_str)) 
	    (line_sep_str = "")
	    for(i 0 
		strlen(data_str) 
		(line_sep_str = strcat(line_sep_str "+"))
	    ) 
	    if((header_str != "") then 
		(header_str = sprintf(nil "%s\n%s" header_str line_sep_str)) else 
		(header_str = sprintf(nil "%s" line_sep_str))
	    ) 
	    (header_str = sprintf(nil "%s\n%s" header_str data_str)) 
	    (header_str = sprintf(nil "%s\n%s" header_str line_sep_str))
	) 
	if((tbx_varibom_data->refOrder) then 
	    (ref_list = (tbx_varibom_data->refOrder)) else 
	    foreach(key attrData 
		(ref_list = cons(key ref_list))
	    )
	    (ref_list = sort(ref_list 
		    'axlStrcmpAlpNum
		))
	) 
	if(((tbx_varibom_data->curSplitCnt) >= 1) then 
	    (file_counter = 1) 
	    (ascii_file = sprintf(nil "%s_%d.%s" report_name file_counter 
		    (axlFormGetField 
			(tbx_varibom_data->formid) "file_extension"
		    )
		)) else
	    (ascii_file = sprintf(nil "%s.%s" report_name 
		    (axlFormGetField 
			(tbx_varibom_data->formid) "file_extension"
		    )
		))
	) 
	(port = outfile(ascii_file "w"))
	when((strlen(header_str) > 0) 
	    fprintf(port "%s\n" header_str)
	) 
	foreach(val ref_list 
	    cond(((type(val) == 'string) 
		    (tmp_list = list()) 
		    foreach(prm 
			(tbx_varibom_data->param) 
			(pindex = (car(prm) - 1)) 
			(pwidth = car(col_width[pindex])) 
			(pre = cadr(col_width[pindex]))
			(post = caddr(col_width[pindex])) 
			(pname = cadr(prm)) 
			(pvalue = strcat(pre 
				get(attrData[val] pname) post
			    )) 
			(pwidth = (pwidth + strlen(pre) + strlen(post))) 
			if((strlen(pvalue) <= pwidth) then 
			    (format_str = strcat("%-" 
				    sprintf(nil "%d" pwidth) "s"
				)) 
			    (tmp_value = sprintf(nil format_str pvalue)) else
			    (tmp_value = substring(pvalue 1 pwidth))
			)
			(tmp_list = cons(tmp_value tmp_list))
		    ) 
		    (tmp_list = reverse(tmp_list)) 
		    (out_str = buildString(tmp_list col_sep_str))
		    fprintf(port "%s\n" out_str)
		) 
		((val == 'split) 
		    close(port) 
		    ((tbx_varibom_data->reports)->TEXT = cons(ascii_file 
			    ((tbx_varibom_data->reports)->TEXT)
			)) 
		    (file_counter = (file_counter + 1)) 
		    (ascii_file = sprintf(nil "%s_%d.%s" report_name file_counter 
			    (axlFormGetField 
				(tbx_varibom_data->formid) "file_extension"
			    )
			))
		    (port = outfile(ascii_file "w")) 
		    fprintf(port "%s\n" header_str)
		) 
		((val == 'newline) 
		    fprintf(port "\n")
		)
	    )
	) 
	close(port) 
	((tbx_varibom_data->reports)->TEXT = cons(ascii_file 
		((tbx_varibom_data->reports)->TEXT)
	    )) 
	printf("Note: File %s has been written\n" ascii_file)
	t
    )
)
procedure(TBX_VARIBOM_Print_HTML_File(attrData report_name) 
    let((bgcolor dbid xy pname port
	    pvalue ref_list row_nr colspan tmp_list
	    header_str html_file file_counter
	) 
	(header_str = "") 
	(header_str = sprintf(nil "%s<HTML>\n" header_str)) 
	(header_str = sprintf(nil "%s  <HEAD>\n\n" header_str)) 
	(header_str = sprintf(nil "%s  <TITLE>FlowCAD Variant BOM</TITLE>\n" header_str))
	(header_str = sprintf(nil "%s  <style type=\"text/css\">\n" header_str)) 
	(header_str = sprintf(nil "%s    body{font:13px arial,helvetica,clean,sans-serif;*font-size:small;*font:x-small;} table{font-size:inherit;}\n" header_str)) 
	(header_str = sprintf(nil "%s    body {text-align:center;color:#333;direction:ltr;} body,h1,h2,h3,h4,h5,h6,ul,ol,li,dl,dt,dd,p,form,fieldset,legend,input,img {margin:0;padding:0;} img,fieldset { border:0;}em {font-style:normal;}a:link,a:visited {text-decoration:none;}a:hover {text-decoration:underline;}\n" header_str)) 
	(header_str = sprintf(nil "%s  </style>\n\n" header_str)) 
	(header_str = sprintf(nil "%s<BODY align=\"left\">\n" header_str))
	(tmp_list = list()) 
	when((axlFormGetField 
		(tbx_varibom_data->formid) "insert_column_names"
	    ) 
	    foreach(prm 
		(tbx_varibom_data->param) 
		(tmp_list = cons(nth(5 prm) tmp_list))
	    ) 
	    (tmp_list = reverse(tmp_list)) 
	    (colspan = length(tmp_list))
	) 
	when((axlFormGetField 
		(tbx_varibom_data->formid) "insert_external_header_file"
	    ) 
	    (header_str = sprintf(nil "%s<div style=\"text-align:center\">\n" header_str)) 
	    (header_str = sprintf(nil "%s<table border=\"0\" width=\"80%%\" cellpadding=\"3\" cellspacing=\"0\">\n" header_str)) 
	    foreach(line 
		TBX_VARIBOM_Process_External_Header(report_name) 
		(header_str = sprintf(nil "%s<tr>\n" header_str)) 
		(header_str = sprintf(nil "%s<td  style=\"font-size:18px;text-align:left;color:#000000\"  width=\"100%%\" colspan=\"2\"><b>%s</b></td>\n" header_str line)) 
		(header_str = sprintf(nil "%s</tr>\n" header_str))
	    ) 
	    (header_str = sprintf(nil "%s</table>\n" header_str))
	    (header_str = sprintf(nil "%s</div>\n" header_str))
	) 
	(header_str = sprintf(nil "%s<br>\n" header_str)) 
	(header_str = sprintf(nil "%s<div style=\"text-align:center\">\n" header_str))
	(header_str = sprintf(nil "%s<table border=\"1\" width=\"80%%\" cellpadding=\"3\" cellspacing=\"0\">\n" header_str)) 
	when(tmp_list 
	    (header_str = sprintf(nil "%s<tr>\n" header_str)) 
	    foreach(entry tmp_list 
		(header_str = sprintf(nil "%s<td style=\"text-align:left\"  bgcolor=\"#cccccc\"  valign=\"top\"><b>%s</b></td>\n" header_str entry))
	    ) 
	    (header_str = sprintf(nil "%s</tr>\n" header_str))
	) 
	if((tbx_varibom_data->refOrder) then 
	    (ref_list = (tbx_varibom_data->refOrder)) else 
	    foreach(key attrData 
		(ref_list = cons(key ref_list))
	    )
	    (ref_list = sort(ref_list 
		    'axlStrcmpAlpNum
		))
	) 
	if(((tbx_varibom_data->curSplitCnt) >= 1) then 
	    (file_counter = 1) 
	    (html_file = sprintf(nil "%s_%d.html" report_name file_counter)) else
	    (html_file = sprintf(nil "%s.html" report_name))
	) 
	(port = outfile(html_file "w"))
	fprintf(port "%s\n" header_str) 
	(row_nr = 1) 
	foreach(val ref_list 
	    cond(((type(val) == 'string) 
		    if(evenp(row_nr) then 
			(bgcolor = "bgcolor=\"#ffffcc\"") else 
			(bgcolor = "")
		    ) 
		    fprintf(port "    <tr align=\"left\" %s>\n" bgcolor) 
		    foreach(prm 
			(tbx_varibom_data->param) 
			(pname = cadr(prm)) 
			(pvalue = get(attrData[val] pname)) 
			if((pname == "REFDES") then 
			    (dbid = car((axlSelectByName "COMPONENT" pvalue))) 
			    (xy = ((dbid->symbol)->xy)) 
			    if(xy then 
				fprintf(port "      <td valign=\"top\"><a href=\"xprobe:xy:%f,%f\">%s</a></td>\n" 
				    car(xy) 
				    cadr(xy) pvalue
				) else 
				fprintf(port "      <td valign=\"top\">%s</td>\n" pvalue)
			    )
			    else 
			    fprintf(port "      <td valign=\"top\">%s</td>\n" pvalue)
			)
		    ) 
		    fprintf(port "    </tr>\n")
		) 
		((val == 'split) 
		    fprintf(port "    </table>\n") 
		    fprintf(port "</div>\n") 
		    fprintf(port "  </BODY>\n\n") 
		    fprintf(port "  </HEAD>\n\n")
		    fprintf(port "</HTML>\n") 
		    close(port) 
		    ((tbx_varibom_data->reports)->HTML = cons(html_file 
			    ((tbx_varibom_data->reports)->HTML)
			)) 
		    (file_counter = (file_counter + 1)) 
		    (html_file = sprintf(nil "%s_%d.html" report_name file_counter))
		    (port = outfile(html_file "w")) 
		    fprintf(port "%s\n" header_str) 
		    (row_nr = 1)
		) 
		((val == 'newline) 
		    fprintf(port "      <td valign=\"top\" colspan=\"%d\">&nbsp;</td>\n" colspan)
		)
	    ) 
	    ++row_nr
	) 
	fprintf(port "    </table>\n") 
	fprintf(port "</div>\n")
	fprintf(port "  </BODY>\n\n") 
	fprintf(port "  </HEAD>\n\n") 
	fprintf(port "</HTML>\n") 
	close(port) 
	((tbx_varibom_data->reports)->HTML = cons(html_file 
		((tbx_varibom_data->reports)->HTML)
	    ))
	printf("Note: File %s has been written\n" html_file) t
    )
)
procedure(TBX_VARIBOM_Process_External_Header(report_name) 
    let((header_new time design_name new_str date
	    text_data
	) 
	(design_name = (axlCurrentDesign)) 
	(date = parseString(getCurrentTime() " ")) 
	(time = caddr(date)) 
	(date = sprintf(nil "%s.%s.%s" 
		cadr(date) 
		car(date) 
		car(last(date))
	    ))
	(header_new = list()) 
	(text_data = (tbx_varibom_data->extHeader)) 
	if(text_data then 
	    foreach(txt text_data 
		rexCompile("\\$DESIGN\\$") 
		(new_str = rexReplace(txt design_name 0)) 
		rexCompile("\\$DATE\\$")
		(new_str = rexReplace(new_str date 0)) 
		rexCompile("\\$TIME\\$") 
		(new_str = rexReplace(new_str time 0)) 
		rexCompile("\\$FILE\\$") 
		(new_str = rexReplace(new_str report_name 0))
		rexCompile("\\$UNITS\\$") 
		(new_str = rexReplace(new_str 
			(axlFormGetField 
			    (tbx_varibom_data->formid) "output_units"
			) 0
		    )) 
		(header_new = cons(new_str header_new))
	    ) else 
	    printf("Warning: No external header text found. Check path to external header file.\n")
	) 
	(header_new = reverse(header_new)) header_new
    )
)
procedure(TBX_VARIBOM_Read_Config(input_file) 
    let((att port data default new_value
	    value field_type token field_name form_data
	    tmp_table custom
	) 
	if(input_file then 
	    (port = infile(input_file)) 
	    (data = car(lineread(port))) 
	    close(port)
	    else 
	    (att = (axlGetAttachment "tbx_varibom" 
		    'string
		)) 
	    when(att 
		(data = car(linereadstring((att->data))))
	    )
	) 
	(tmp_table = makeTable("tmp_table_h" nil)) 
	foreach(entry 
	    ((tbx_varibom_data->formConfig)->main) 
	    (tmp_table[car(entry)] = entry)
	) 
	foreach(entry 
	    ((tbx_varibom_data->formConfig)->transf) 
	    (tmp_table[car(entry)] = entry)
	)
	(default = (tbx_varibom_data->default)) 
	(custom = makeTable("custom_table" nil)) 
	foreach(fld default 
	    (custom[fld] = default[fld])
	) 
	when(data 
	    foreach(item data 
		(form_data = cdr(item)) 
		foreach(entry form_data 
		    (token = car(entry)) 
		    if((length(entry) > 2) then 
			(value = cdr(entry)) else 
			(value = cadr(entry))
		    ) 
		    (field_name = cadr(tmp_table[token]))
		    (field_type = caddr(tmp_table[token])) 
		    (new_value = value) 
		    if(field_name then 
			when(((field_type == "check") || (field_type == "radio")) 
			    if((upperCase(value) == "ON") then 
				(new_value = "on") else 
				(new_value = "off")
			    )
			) 
			(custom[field_name] = new_value) else
			when(((token != 'variantName) && (token != 'reportName)) 
			    printf("Warning: Unknown token %L, skipping...\n" token)
			)
		    )
		)
	    )
	) custom
    )
)
procedure(TBX_VARIBOM_Save_Config(output_file) 
    let((form_handle port value data_str config_data
	    result field_name field_type token
	) 
	(form_handle = (tbx_varibom_data->formid)) 
	foreach(entry 
	    ((tbx_varibom_data->formConfig)->main) 
	    (field_name = cadr(entry)) 
	    (field_type = caddr(entry)) 
	    cond(((field_type == "check") 
		    if((axlFormGetField form_handle field_name) then 
			(value = "on") else 
			(value = "off")
		    ) 
		    ((tbx_varibom_data->custom)[field_name] = value)
		) 
		((field_type == "radio") 
		    when((axlFormGetField form_handle field_name) 
			(value = "on") 
			((tbx_varibom_data->custom)[field_name] = value)
		    )
		) 
		((field_type == "string") 
		    (value = (axlFormGetField form_handle field_name)) 
		    unless(value 
			(value = "")
		    ) 
		    ((tbx_varibom_data->custom)[field_name] = value)
		) 
		((field_type == "grid") 
		    when((field_name == "part_spec_grid") 
			(value = TBX_VARIBOM_Extract_Parameter_List()) 
			((tbx_varibom_data->custom)[field_name] = value)
		    )
		) 
		(t 
		    (value = (axlFormGetField form_handle field_name)) 
		    ((tbx_varibom_data->custom)[field_name] = value)
		)
	    )
	) 
	(result = list()) 
	(config_data = list())
	foreach(entry 
	    ((tbx_varibom_data->formConfig)->main) 
	    (token = car(entry)) 
	    (field_name = cadr(entry)) 
	    (field_type = caddr(entry))
	    (value = (tbx_varibom_data->custom)[field_name]) 
	    if((type(value) == 'list) then 
		(config_data = cons(cons(token value) config_data)) else 
		(config_data = cons(list(token value) config_data))
	    )
	) 
	(config_data = reverse(config_data)) 
	(config_data = cons('Main config_data)) 
	(result = cons(config_data result)) 
	(config_data = list())
	foreach(entry 
	    ((tbx_varibom_data->formConfig)->transf) 
	    (token = car(entry)) 
	    (field_name = cadr(entry)) 
	    (value = (tbx_varibom_data->custom)[field_name])
	    (config_data = cons(list(token value) config_data))
	) 
	(config_data = reverse(config_data)) 
	(config_data = cons('Transform config_data)) 
	(result = cons(config_data result)) 
	(result = reverse(result))
	if(output_file then 
	    (port = outfile(output_file)) 
	    fprintf(port "(\n") 
	    foreach(frm result 
		fprintf(port "   (%L\n" 
		    car(frm)
		) 
		foreach(entry 
		    cdr(frm) 
		    if((length(entry) > 2) then 
			fprintf(port "      (%L\n" 
			    car(entry)
			) 
			foreach(val 
			    cdr(entry) 
			    fprintf(port "          %L\n" val)
			) 
			fprintf(port "      )\n")
			else 
			fprintf(port "      %L\n" entry)
		    )
		) 
		fprintf(port "   )\n")
	    )
	    fprintf(port ")\n") 
	    close(port) else 
	    (axlDeleteAttachment "tbx_varibom") 
	    (data_str = sprintf(nil "%L" result))
	    (axlCreateAttachment "tbx_varibom" nil 1 
		'string
		data_str
	    )
	) t
    )
)
procedure(TBX_VARIBOM_Sort_Data(attrData) 
    let((sort_param_1 sort_param_2 sort_param_3 pval_1 pval_2
	    pval_3 pval_1_previous pval_2_previous atable btable
	    key_str arr data master_list ref_order
	    level_1_sorted level_2_sorted level_3_sorted split_cnt newline_level1
	    split_level1 sort_list split_level2 newline_level2 apply_row_num
	    row_num sep1 sep2 cmp_order
	) 
	(newline_level1 = (axlFormGetField 
		(tbx_varibom_data->formid) "newline_level1"
	    )) 
	(split_level1 = (axlFormGetField 
		(tbx_varibom_data->formid) "split_level1"
	    )) 
	(newline_level2 = (axlFormGetField 
		(tbx_varibom_data->formid) "newline_level2"
	    )) 
	(split_level2 = (axlFormGetField 
		(tbx_varibom_data->formid) "split_level2"
	    ))
	when(newline_level1 
	    (sep1 = 'newline)
	) 
	when(split_level1 
	    (sep1 = 'split)
	) 
	when(newline_level2 
	    (sep2 = 'newline)
	) 
	when(split_level2 
	    (sep2 = 'split)
	) 
	(atable = makeTable("atable_table" nil))
	(btable = makeTable("btable_table" nil)) 
	(split_cnt = 0) 
	(sort_param_1 = upperCase((axlFormGetField 
		    (tbx_varibom_data->formid) "sort_level1"
		)
	    )) 
	(sort_param_2 = upperCase((axlFormGetField 
		    (tbx_varibom_data->formid) "sort_level2"
		)
	    )) 
	(sort_param_3 = upperCase((axlFormGetField 
		    (tbx_varibom_data->formid) "sort_level3"
		)
	    ))
	when(((sort_param_1 == nil) || (sort_param_1 == "")) 
	    (sort_param_1 = "<NO_SORT>")
	) 
	when(((sort_param_2 == nil) || (sort_param_2 == "")) 
	    (sort_param_2 = "<NO_SORT>")
	) 
	when(((sort_param_3 == nil) || (sort_param_3 == "")) 
	    (sort_param_3 = "<NO_SORT>")
	) 
	(sort_list = list(sort_param_1 sort_param_2 sort_param_3)) 
	(sort_list = remove("<NO_SORT>" sort_list))
	(sort_param_1 = car(sort_list)) 
	(sort_param_2 = cadr(sort_list)) 
	(sort_param_3 = caddr(sort_list)) 
	(master_list = list()) 
	if(sort_param_1 then 
	    foreach(refdes attrData 
		(pval_1 = get(attrData[refdes] 
			stringToSymbol(sort_param_1)
		    )) 
		when(sort_param_2 
		    (pval_2 = get(attrData[refdes] 
			    stringToSymbol(sort_param_2)
			))
		) 
		when(sort_param_3 
		    (pval_3 = get(attrData[refdes] 
			    stringToSymbol(sort_param_3)
			))
		)
		cond((sort_param_3 
			(key_str = strcat(pval_1 "!" pval_2)) 
			(atable[key_str] = cons(list(pval_3 refdes) 
				atable[key_str]
			    ))
		    ) 
		    ((!sort_param_3 && sort_param_2) 
			(atable[pval_1] = cons(list(pval_2 refdes) 
				atable[pval_1]
			    ))
		    ) 
		    ((!sort_param_3 && !sort_param_2 && sort_param_1) 
			(master_list = cons(list(pval_1 refdes) master_list))
		    )
		)
	    ) 
	    cond((sort_param_3 
		    foreach(key atable 
			(arr = parseString(key "!")) 
			(pval_1 = car(arr)) 
			(pval_2 = cadr(arr))
			(data = atable[key]) 
			(data = cons(pval_2 data)) 
			(btable[pval_1] = cons(data 
				btable[pval_1]
			    ))
		    ) 
		    foreach(key btable 
			(data = btable[key]) 
			(data = cons(key data)) 
			(master_list = cons(data master_list))
		    )
		) 
		((!sort_param_3 && sort_param_2) 
		    foreach(key atable 
			(data = atable[key]) 
			(data = cons(key data)) 
			(master_list = cons(data master_list))
		    )
		) 
		((!sort_param_3 && !sort_param_2 && sort_param_1) t)
	    ) 
	    (ref_order = tconc(nil nil))
	    cond((sort_param_3 
		    (level_1_sorted = sortcar(master_list 
			    'axlStrcmpAlpNum
			)) 
		    foreach(entry1 level_1_sorted 
			(level_2_sorted = sortcar(cdr(entry1) 
				'axlStrcmpAlpNum
			    )) 
			foreach(entry2 level_2_sorted 
			    (level_3_sorted = sortcar(cdr(entry2) 
				    'axlStrcmpAlpNum
				)) 
			    foreach(pair level_3_sorted 
				tconc(ref_order 
				    cadr(pair)
				)
			    ) 
			    when(sep2 
				tconc(ref_order sep2)
			    )
			) 
			when(sep1 
			    tconc(ref_order sep1)
			)
		    )
		) 
		((!sort_param_3 && sort_param_2) 
		    (level_1_sorted = sortcar(master_list 
			    'axlStrcmpAlpNum
			)) 
		    foreach(entry1 level_1_sorted 
			(level_2_sorted = sortcar(cdr(entry1) 
				'axlStrcmpAlpNum
			    )) 
			(pval_2_previous = nil) 
			foreach(pair level_2_sorted 
			    (pval_2 = car(pair)) 
			    cond((!pval_2_previous 
				    (pval_2_previous = pval_2)
				) 
				((pval_2 != pval_2_previous) 
				    when((sep2 && (pval_2 != pval_2_previous)) 
					tconc(ref_order sep2) 
					(pval_2_previous = pval_2)
				    )
				) 
				(t 
				    (pval_2_previous = pval_2)
				)
			    ) 
			    tconc(ref_order 
				cadr(pair)
			    )
			)
			when(sep1 
			    tconc(ref_order sep1)
			)
		    )
		) 
		((!sort_param_3 && !sort_param_2 && sort_param_1) 
		    (pval_1_previous = nil) 
		    (level_1_sorted = sortcar(master_list 
			    'axlStrcmpAlpNum
			)) 
		    foreach(pair level_1_sorted 
			(pval_1 = car(pair)) 
			cond((!pval_1_previous 
				(pval_1_previous = pval_1)
			    ) 
			    ((pval_1 != pval_1_previous) 
				when((sep1 && (pval_1 != pval_1_previous)) 
				    tconc(ref_order sep1) 
				    (pval_1_previous = pval_1)
				)
			    ) 
			    (t 
				(pval_1_previous = pval_1)
			    )
			) 
			tconc(ref_order 
			    cadr(pair)
			)
		    )
		) 
		(t t)
	    ) 
	    (ref_order = cdar(ref_order)) 
	    (cmp_order = listToVector(ref_order)) 
	    (ref_order = tconc(nil nil)) 
	    for(i 0 
		(length(cmp_order) - 1) 
		cond((((i <= (length(cmp_order) - 2)) && (type(cmp_order[i]) == 'symbol) && (type(cmp_order[(i + 1)]) == 'symbol)) t) 
		    (((i == (length(cmp_order) - 1)) && (type(cmp_order[i]) == 'symbol)) t) 
		    (t 
			tconc(ref_order 
			    cmp_order[i]
			) 
			when((cmp_order[i] == 'split) 
			    ++split_cnt
			)
		    )
		)
	    )
	    (ref_order = cdar(ref_order)) 
	    foreach(prm 
		(tbx_varibom_data->param) 
		when((cadr(prm) == "ROWNUM") 
		    (apply_row_num = t)
		)
	    ) 
	    when(apply_row_num 
		(row_num = 0) 
		foreach(ref ref_order 
		    when((type(ref) == 'string) 
			++row_num 
			(attrData[ref]->ROWNUM = sprintf(nil "%d" row_num))
		    )
		)
	    ) else 
	    printf("Warning: No sort parameter specified. May lead to random output\n")
	)
	(tbx_varibom_data->curSplitCnt = split_cnt) 
	(tbx_varibom_data->refOrder = ref_order) t
    )
)
procedure(TBX_VARIBOM_Start_Create_Reports() 
    let((alt_origin design_attr common_attr report_param variant_attr
	    variant_name pvalue ref_list report_name base_list
	    common_list report_base report_alternate report_dni bom_ignore_list
	    exclude_from_bom exclude_prop_name exclude_prop_value
	) 
	(tbx_varibom_data->viewlog = cons(sprintf(nil "-->Validating spec with respect to unit specifiers") 
		(tbx_varibom_data->viewlog)
	    )) 
	(tbx_varibom_data->formula = TBX_VARIBOM_Validate_Spec()) 
	(exclude_from_bom = (axlFormGetField 
		(tbx_varibom_data->formid) "exclude_from_bom"
	    )) 
	(exclude_prop_name = (axlFormGetField 
		(tbx_varibom_data->formid) "exclude_prop_name"
	    ))
	(exclude_prop_value = (axlFormGetField 
		(tbx_varibom_data->formid) "exclude_prop_value"
	    )) 
	if((axlFormGetField 
		(tbx_varibom_data->formid) "xy_at_symbol_center"
	    ) then 
	    (alt_origin = 'center) else 
	    (alt_origin = 'origin)
	) 
	if((axlFormGetField 
		(tbx_varibom_data->formid) "use_jedec_rotation_offset"
	    ) then 
	    (tbx_varibom_data->jedecRotationOffset = TBX_VARIBOM_Get_Jedec_Rotation_Offset()) else 
	    (tbx_varibom_data->jedecRotationOffset = makeTable("jedec_rotation_offset_data" 0.0))
	) 
	(tbx_varibom_data->viewlog = cons(sprintf(nil "-->Checking part specification") 
		(tbx_varibom_data->viewlog)
	    )) 
	(tbx_varibom_data->param = TBX_VARIBOM_Param_Integrity((tbx_varibom_data->param)))
	(tbx_varibom_data->gridRows = length((tbx_varibom_data->param))) 
	(report_param = list()) 
	foreach(entry 
	    (tbx_varibom_data->param) 
	    (report_param = cons(stringToSymbol(cadr(entry)) report_param))
	) 
	(report_param = reverse(report_param)) 
	when(exclude_from_bom 
	    (tbx_varibom_data->viewlog = cons(sprintf(nil "-->Reading components to exclude from BOM  %L with Value %L" exclude_prop_name exclude_prop_value) 
		    (tbx_varibom_data->viewlog)
		)) 
	    (bom_ignore_list = TBX_VARIBOM_Ignore_Parts(exclude_prop_name exclude_prop_value)) 
	    when((length(bom_ignore_list) > 0) 
		printf("Info: Skipping %d components due to Exclude Part setting: %s=%s\n" 
		    length(bom_ignore_list) 
		    upperCase(exclude_prop_name) exclude_prop_value
		)
	    )
	)
	(tbx_varibom_data->viewlog = cons(sprintf(nil "-->Reading attributes from core design") 
		(tbx_varibom_data->viewlog)
	    )) 
	(design_attr = TBX_VARIBOM_Extract_Master_Design(report_param alt_origin bom_ignore_list 
		(tbx_varibom_data->jedecRotationOffset)
	    )) 
	(tbx_varibom_data->designAttr = design_attr) 
	cond((((axlFormGetField 
			(tbx_varibom_data->formid) "variant_name"
		    ) == "core") 
		(tbx_varibom_data->viewlog = cons(sprintf(nil "-->Writing report for Core design") 
			(tbx_varibom_data->viewlog)
		    )) 
		(report_name = (axlFormGetField 
			(tbx_varibom_data->formid) "report_name"
		    )) 
		TBX_VARIBOM_Write_Wrapper((tbx_varibom_data->designAttr) report_name)
	    ) 
	    (((axlFormGetField 
			(tbx_varibom_data->formid) "variant_name"
		    ) == "common") 
		(report_base = t) 
		(report_alternate = nil) 
		(report_dni = nil) 
		(base_list = list())
		foreach(vari 
		    (tbx_varibom_data->variant) 
		    (tbx_varibom_data->viewlog = cons(sprintf(nil "-->Reading attributes for variant %L" 
				car(vari)
			    ) 
			    (tbx_varibom_data->viewlog)
			)) 
		    (variant_attr = TBX_VARIBOM_Extract_Variant_Design(report_param 
			    upperCase(car(vari)) report_base report_alternate report_dni
			)) 
		    (tbx_varibom_data->variantAttr = variant_attr)
		    (ref_list = list()) 
		    foreach(ref variant_attr 
			(pvalue = get(variant_attr[ref] 
				'VARTYPE
			    )) 
			when((pvalue == "BASE") 
			    (ref_list = cons(ref ref_list))
			)
		    ) 
		    (base_list = cons(ref_list base_list))
		) 
		(common_list = car(base_list)) 
		for(i 1 
		    (length(base_list) - 1) 
		    (common_list = setof(element common_list 
			    member(element 
				nth(i base_list)
			    )
			))
		) 
		(design_attr = (tbx_varibom_data->designAttr)) 
		(common_attr = makeTable("common_attr_table" nil))
		foreach(ref common_list 
		    (common_attr[ref] = copy(design_attr[ref]))
		) 
		(tbx_varibom_data->commonAttr = common_attr) 
		(report_name = (axlFormGetField 
			(tbx_varibom_data->formid) "report_name"
		    )) 
		(tbx_varibom_data->viewlog = cons(sprintf(nil "-->Writing report for common parts of all variants") 
			(tbx_varibom_data->viewlog)
		    )) 
		TBX_VARIBOM_Write_Wrapper((tbx_varibom_data->commonAttr) report_name)
	    ) 
	    (t 
		(report_base = (axlFormGetField 
			(tbx_varibom_data->formid) "report_unchanged_parts"
		    )) 
		(report_alternate = (axlFormGetField 
			(tbx_varibom_data->formid) "report_alternate_parts"
		    )) 
		(report_dni = (axlFormGetField 
			(tbx_varibom_data->formid) "report_dni_parts"
		    )) 
		if(((axlFormGetField 
			    (tbx_varibom_data->formid) "variant_name"
			) == "all") then 
		    foreach(vari 
			(tbx_varibom_data->variant) 
			(tbx_varibom_data->viewlog = cons(sprintf(nil "-->Extracting attributes for variant %L" 
				    car(vari)
				) 
				(tbx_varibom_data->viewlog)
			    )) 
			(variant_attr = TBX_VARIBOM_Extract_Variant_Design(report_param 
				car(vari) report_base report_alternate report_dni
			    )) 
			(tbx_varibom_data->variantAttr = variant_attr)
			(report_name = car(vari)) 
			(tbx_varibom_data->viewlog = cons(sprintf(nil "-->Writing report for variant %L" 
				    car(vari)
				) 
				(tbx_varibom_data->viewlog)
			    )) 
			TBX_VARIBOM_Write_Wrapper((tbx_varibom_data->variantAttr) report_name)
		    ) else 
		    (report_name = (axlFormGetField 
			    (tbx_varibom_data->formid) "report_name"
			))
		    (variant_name = (axlFormGetField 
			    (tbx_varibom_data->formid) "variant_name"
			)) 
		    (tbx_varibom_data->viewlog = cons(sprintf(nil "-->Extracting attributes for variant %L" variant_name) 
			    (tbx_varibom_data->viewlog)
			)) 
		    (variant_attr = TBX_VARIBOM_Extract_Variant_Design(report_param variant_name report_base report_alternate report_dni)) 
		    (tbx_varibom_data->variantAttr = variant_attr) 
		    (tbx_varibom_data->viewlog = cons(sprintf(nil "-->Writing report for variant %L" variant_name) 
			    (tbx_varibom_data->viewlog)
			))
		    TBX_VARIBOM_Write_Wrapper((tbx_varibom_data->variantAttr) report_name)
		)
	    )
	)
    )
)
procedure(TBX_VARIBOM_Transformation_Callback(form_handle) 
    let((field_name field_value) 
	case((form_handle->curField) 
	    ("done" 
		foreach(entry 
		    ((tbx_varibom_data->formConfig)->transf) 
		    (field_name = cadr(entry)) 
		    (field_value = lowerCase((axlFormGetField form_handle field_name))) 
		    if((field_value != "") then 
			rexCompile("^ *") 
			(field_value = rexReplace(field_value "" 0)) 
			rexCompile(" *$")
			(field_value = rexReplace(field_value "" 0)) 
			rexCompile(" +") 
			(field_value = rexReplace(field_value " " 0)) 
			((tbx_varibom_data->custom)[field_name] = field_value) else
			((tbx_varibom_data->custom)[field_name] = (tbx_varibom_data->default)[field_name])
		    )
		) 
		(axlFormClose form_handle) 
		(axlFinishEnterFun) 
		(tbx_varibom_data->viewlog = cons(sprintf(nil "   Current spec %L" 
			    (tbx_varibom_data->transformSpec)
			) 
			(tbx_varibom_data->viewlog)
		    ))
	    ) 
	    ("cancel" 
		(axlFormClose form_handle) 
		(axlCancelEnterFun)
	    ) 
	    ("my_help" 
		(axlShell "tbx help varibom")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_VARIBOM_Update_Grid_Rows_CB(textCol) 
    let((cell index no_edit param_name param_type) 
	(index = 1) 
	(textCol = textCol) 
	foreach(prm 
	    (tbx_varibom_data->param) 
	    (no_edit = nil) 
	    (param_name = upperCase(cadr(prm))) 
	    (param_type = caddr(prm))
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 1) 
	    (cell->row = index) 
	    (cell->value = index) 
	    (axlFormGridBatch cell)
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 2) 
	    (cell->row = index) 
	    (cell->value = param_name) 
	    (cell->noEdit = nil)
	    (axlFormGridBatch cell) 
	    when((tbx_varibom_data->dataType)[param_name] 
		(no_edit = t) 
		(param_type = (tbx_varibom_data->dataType)[param_name])
	    ) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 3) 
	    (cell->row = index)
	    (cell->value = param_type) 
	    (cell->noEdit = no_edit) 
	    (axlFormGridBatch cell) 
	    if((lowerCase(param_type) == "float") then 
		(cell = (axlFormGridNewCell)) 
		(cell->col = 4) 
		(cell->row = index)
		(cell->value = nth(3 prm)) 
		(cell->noEdit = nil) else 
		(cell = (axlFormGridNewCell)) 
		(cell->col = 4)
		(cell->row = index) 
		(cell->value = 0) 
		(cell->noEdit = t)
	    ) 
	    (axlFormGridBatch cell)
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 5) 
	    (cell->row = index) 
	    (cell->value = nth(4 prm)) 
	    (cell->noEdit = nil)
	    (axlFormGridBatch cell) 
	    (cell = (axlFormGridNewCell)) 
	    (cell->col = 6) 
	    (cell->row = index) 
	    (cell->value = nth(5 prm))
	    (cell->noEdit = nil) 
	    (axlFormGridBatch cell) 
	    ++index
	)
    )
)
procedure(TBX_VARIBOM_Validate_Spec() 
    let((formula_str field_name value_str formula) 
	(formula = makeTable("formula_table" nil)) 
	foreach(entry 
	    ((tbx_varibom_data->formConfig)->transf) 
	    (field_name = cadr(entry)) 
	    (formula_str = (tbx_varibom_data->custom)[field_name]) 
	    rexCompile("[*][*]")
	    (formula_str = rexReplace(formula_str "___POWER___" 0)) 
	    rexCompile("[*]") 
	    (formula_str = rexReplace(formula_str " * " 0)) 
	    rexCompile("[+]") 
	    (formula_str = rexReplace(formula_str " + " 0))
	    rexCompile("-") 
	    (formula_str = rexReplace(formula_str " - " 0)) 
	    rexCompile("/") 
	    (formula_str = rexReplace(formula_str " / " 0)) 
	    rexCompile("um")
	    (value_str = sprintf(nil " * %f" 
		    (axlMKSConvert "1 UM" 
			car((axlDBGetDesignUnits))
		    )
		)) 
	    (formula_str = rexReplace(formula_str value_str 0)) 
	    rexCompile("mm") 
	    (value_str = sprintf(nil " * %f" 
		    (axlMKSConvert "1 MM" 
			car((axlDBGetDesignUnits))
		    )
		)) 
	    (formula_str = rexReplace(formula_str value_str 0))
	    rexCompile("mil") 
	    (value_str = sprintf(nil " * %f" 
		    (axlMKSConvert "1 MIL" 
			car((axlDBGetDesignUnits))
		    )
		)) 
	    (formula_str = rexReplace(formula_str value_str 0)) 
	    rexCompile("inch") 
	    (value_str = sprintf(nil " * %f" 
		    (axlMKSConvert "1 INCH" 
			car((axlDBGetDesignUnits))
		    )
		))
	    (formula_str = rexReplace(formula_str value_str 0)) 
	    rexCompile("cm") 
	    (value_str = sprintf(nil " * %f" 
		    (axlMKSConvert "1 CM" 
			car((axlDBGetDesignUnits))
		    )
		)) 
	    (formula_str = rexReplace(formula_str value_str 0)) 
	    rexCompile("[*] *[*]")
	    (formula_str = rexReplace(formula_str " * " 0)) 
	    rexCompile(" +") 
	    (formula_str = rexReplace(formula_str " " 0)) 
	    rexCompile("___POWER___") 
	    (formula_str = rexReplace(formula_str "**" 0))
	    (formula[field_name] = formula_str)
	) formula
    )
)
procedure(TBX_VARIBOM_View_Generated_Reports(report_list type) 
    let((html_flag win_id) 
	foreach(rpt report_list 
	    if(isFile(rpt) then 
		if((length((tbx_varibom_data->openWindows)) <= (tbx_varibom_data->maxWindowsCnt)) then 
		    cond(((type == "html") 
			    (html_flag = axlGetVariable("allegro_html")) 
			    (axlSetVariable "allegro_html" t) 
			    (win_id = (axlUIViewFileCreate rpt 
				    strcat("File: " rpt) nil
				)) 
			    (tbx_varibom_data->openWindows = cons(win_id 
				    (tbx_varibom_data->openWindows)
				))
			    unless(html_flag 
				(axlUnsetVariable "allegro_html")
			    )
			) 
			(t 
			    (win_id = (axlUIViewFileCreate rpt 
				    strcat("File: " rpt) nil
				)) 
			    (tbx_varibom_data->openWindows = cons(win_id 
				    (tbx_varibom_data->openWindows)
				))
			)
		    ) else 
		    printf("Maximum number of open files reached. Use file manager to view the contents of your reports\n")
		) else 
		printf("Warning: Unable to open file %s" rpt)
	    )
	)
    )
)
procedure(TBX_VARIBOM_Viewlog() 
    let((out_f log_file) 
	(log_file = strcat(getWorkingDir() "/varibom.log")) 
	(out_f = outfile(log_file "w")) 
	foreach(item 
	    reverse((tbx_varibom_data->viewlog)) 
	    fprintf(out_f "%s\n" item)
	) 
	close(out_f)
	if(!isFile(log_file) then 
	    (axlUIConfirm "Unable to Open  Variant BOM Log File, Check Permissions!") else 
	    (axlUIViewFileCreate log_file " Variant BOM - Log" nil)
	)
    )
)
procedure(TBX_VARIBOM_Write_Wrapper(attrData report_name) 
    let((continue file_base_name col_width header_file header_data) 
	(tbx_varibom_data->viewlog = cons(sprintf(nil "   Formatting data") 
		(tbx_varibom_data->viewlog)
	    )) 
	TBX_VARIBOM_Format_Data(attrData) 
	TBX_VARIBOM_Sort_Data(attrData) 
	(file_base_name = strcat(TBX_VARIBOM_Check_OutDir((axlFormGetField 
			(tbx_varibom_data->formid) "output_dir"
		    )
		) "/" report_name
	    ))
	(continue = t) 
	when((((axlFormGetField 
			(tbx_varibom_data->formid) "split_level1"
		    ) || (axlFormGetField 
			(tbx_varibom_data->formid) "split_level2"
		    )) && ((tbx_varibom_data->curSplitCnt) > (tbx_varibom_data->maxSplitCnt))) 
	    (continue = (axlUIYesNo 
		    sprintf(nil "More than %d files will be generated per item due to your sort settings\nDo you want to continue?" 
			(tbx_varibom_data->maxSplitCnt)
		    ) nil 
		    'no
		))
	) 
	(header_file = (axlFormGetField 
		(tbx_varibom_data->formid) "external_header_file"
	    )) 
	when((axlFormGetField 
		(tbx_varibom_data->formid) "insert_external_header_file"
	    ) 
	    (tbx_varibom_data->viewlog = cons(sprintf(nil "-->Reading external header file") 
		    (tbx_varibom_data->viewlog)
		)) 
	    if((header_file && isFile(header_file)) then 
		(header_data = TBX_VARIBOM_Load_File(header_file "text")) 
		if(header_data then 
		    (tbx_varibom_data->extHeader = header_data) 
		    (tbx_varibom_data->viewlog = cons(sprintf(nil "Reading data from file %s" header_file) 
			    (tbx_varibom_data->viewlog)
			)) else
		    (tbx_varibom_data->viewlog = cons(sprintf(nil "Error: Invalid data when reading %s" header_file) 
			    (tbx_varibom_data->viewlog)
			))
		) else
		(tbx_varibom_data->viewlog = cons(sprintf(nil "Error: Cannot access header file %L" header_file) 
			(tbx_varibom_data->viewlog)
		    ))
	    )
	) 
	when(continue 
	    when((axlFormGetField 
		    (tbx_varibom_data->formid) "write_text"
		) 
		(tbx_varibom_data->viewlog = cons(sprintf(nil "   Calculating column widths") 
			(tbx_varibom_data->viewlog)
		    )) 
		(col_width = TBX_VARIBOM_Calculate_Column_Width(attrData)) 
		(tbx_varibom_data->colWidth = col_width) 
		(tbx_varibom_data->viewlog = cons(sprintf(nil "   Writing ASCII file") 
			(tbx_varibom_data->viewlog)
		    ))
		TBX_VARIBOM_Print_Formatted_File(attrData file_base_name)
	    ) 
	    when((axlFormGetField 
		    (tbx_varibom_data->formid) "write_csv"
		) 
		(tbx_varibom_data->viewlog = cons(sprintf(nil "   Writing CSV file") 
			(tbx_varibom_data->viewlog)
		    )) 
		TBX_VARIBOM_Print_CSV_File(attrData file_base_name)
	    ) 
	    when((axlFormGetField 
		    (tbx_varibom_data->formid) "write_html"
		) 
		(tbx_varibom_data->viewlog = cons(sprintf(nil "   Writing HTML file") 
			(tbx_varibom_data->viewlog)
		    )) 
		TBX_VARIBOM_Print_HTML_File(attrData file_base_name)
	    )
	)
    )
)
procedure(TBX_XSECGEN_Add_Labels(sym_location sym_inst) 
    let((xsection_base_width xsection_width formid include_name_label include_material_label
	    include_thickness_label include_via_label txt_block txt_orient sym_location_x
	    sym_location_y label_name_x label_material_x label_via_y label_thickness_x
	    column_spacing label_info start_y end_y step_size_x
	    label_name_width label_via_width label_thickness_width char_height txt_x
	    txt_y geom_ul_x geom_ul_y via_cnt layer_name
	    layer_thickness layer_material via_name last_layer total_thickness
	    x1 y1 x2 y2 mypath
	) 
	(label_info = (tbx_xsecgen_global->labelInfo)) 
	(formid = (tbx_xsecgen_global->formid)) 
	(xsection_base_width = (axlFormGetField formid "xsection_base_width")) 
	(include_name_label = (axlFormGetField formid "include_layer_name"))
	(include_material_label = (axlFormGetField formid "include_material_name")) 
	(include_thickness_label = (axlFormGetField formid "include_thickness")) 
	(include_via_label = (axlFormGetField formid "include_via_label")) 
	(column_spacing = (axlFormGetField formid "extra_column_spacing")) 
	(txt_block = (axlFormGetField formid "label_text_block"))
	(txt_block = sprintf(nil "%d" txt_block)) 
	(sym_location_x = car(sym_location)) 
	(sym_location_y = cadr(sym_location)) 
	if(include_name_label then 
	    (label_name_width = (cadr(label_info["name"]) + column_spacing)) else 
	    (label_name_width = 0)
	) 
	if(include_via_label then 
	    (label_via_width = (cadr(label_info["via"]) + (tbx_xsecgen_global->labelOffsetY))) else 
	    (label_via_width = 0)
	)
	if(include_thickness_label then 
	    (label_thickness_width = (cadr(label_info["thickness"]) + column_spacing)) else 
	    (label_thickness_width = 0)
	) 
	(xsection_width = (xsection_base_width + column_spacing)) 
	(label_name_x = sym_location_x) 
	(geom_ul_x = (sym_location_x + label_name_width)) 
	(geom_ul_y = (sym_location_y - label_via_width))
	(label_thickness_x = (sym_location_x + label_name_width + xsection_width)) 
	(label_material_x = (sym_location_x + label_name_width + xsection_width + label_thickness_width)) 
	(label_via_y = ((sym_location_y - label_via_width) + (tbx_xsecgen_global->labelOffsetY))) 
	(txt_orient = (make_axlTextOrientation ?textBlock txt_block ?rotation 0.0
		?mirrored nil ?justify "left"
	    )) 
	(char_height = ((axlGetParam 
		    strcat("paramTextBlock:" txt_block)
		)->height))
	foreach(entry 
	    (tbx_xsecgen_global->layerInfo) 
	    (layer_name = nth(3 entry)) 
	    (layer_material = nth(4 entry)) 
	    (layer_thickness = nth(5 entry))
	    (start_y = nth(6 entry)) 
	    (end_y = nth(7 entry)) 
	    (txt_y = (geom_ul_y - (start_y + ((end_y - start_y) / 2.0)) - (char_height / 2.0))) 
	    when(include_name_label 
		(txt_x = label_name_x) 
		when((layer_name != "-") 
		    (axlDBCreateText layer_name 
			(txt_x:txt_y) txt_orient 
			(tbx_xsecgen_global->labelLayer)
			sym_inst
		    )
		)
	    ) 
	    when(include_thickness_label 
		(txt_x = label_thickness_x) 
		(axlDBCreateText layer_thickness 
		    (txt_x:txt_y) txt_orient 
		    (tbx_xsecgen_global->labelLayer)
		    sym_inst
		)
	    )
	    when(include_material_label 
		(txt_x = label_material_x) 
		(axlDBCreateText layer_material 
		    (txt_x:txt_y) txt_orient 
		    (tbx_xsecgen_global->labelLayer)
		    sym_inst
		)
	    )
	) 
	(via_cnt = length((tbx_xsecgen_global->viaInfo))) 
	when((include_via_label && (via_cnt > 0)) 
	    (txt_orient = (make_axlTextOrientation ?textBlock txt_block ?rotation 90.0
		    ?mirrored nil ?justify "left"
		)) 
	    (step_size_x = (xsection_base_width / (via_cnt + 1.0))) 
	    (txt_x = geom_ul_x) 
	    (txt_y = label_via_y)
	    foreach(entry 
		(tbx_xsecgen_global->viaInfo) 
		(via_name = car(entry)) 
		(txt_x = (txt_x + step_size_x)) 
		(axlDBCreateText via_name 
		    ((txt_x + (char_height / 2.0)):txt_y) txt_orient 
		    (tbx_xsecgen_global->labelLayer)
		    sym_inst
		)
	    )
	) 
	(last_layer = car(reverse((tbx_xsecgen_global->layerInfo)))) 
	(end_y = nth(7 last_layer))
	(total_thickness = nth(8 last_layer)) 
	when(include_thickness_label 
	    (txt_orient = (make_axlTextOrientation ?textBlock txt_block ?rotation 0.0
		    ?mirrored nil ?justify "right"
		)) 
	    (txt_x = (label_thickness_x - column_spacing)) 
	    (txt_y = (geom_ul_y - end_y - (2 * (tbx_xsecgen_global->labelOffsetY)) - char_height)) 
	    (axlDBCreateText "Total thickness (nominal):" 
		(txt_x:txt_y) txt_orient 
		(tbx_xsecgen_global->labelLayer)
		sym_inst
	    )
	    (txt_orient = (make_axlTextOrientation ?textBlock txt_block ?rotation 0.0
		    ?mirrored nil ?justify "left"
		)) 
	    (txt_x = label_thickness_x) 
	    (axlDBCreateText total_thickness 
		(txt_x:txt_y) txt_orient 
		(tbx_xsecgen_global->labelLayer)
		sym_inst
	    ) 
	    (x1 = label_thickness_x) 
	    (y1 = (geom_ul_y - end_y - (tbx_xsecgen_global->labelOffsetY)))
	    (x2 = ((x1 + label_thickness_width) - column_spacing)) 
	    (y2 = y1) 
	    (mypath = (axlPathStart 
		    list((x1:y1) 
			(x2:y2)
		    ) 
		    (axlMKSConvert "0.2 MM" 
			car((axlDBGetDesignUnits))
		    )
		)) 
	    (axlDBCreatePath mypath 
		(tbx_xsecgen_global->labelLayer) nil sym_inst
	    )
	)
    )
)
procedure(TBX_XSECGEN_Build_Dynamics(box_width box_height) 
    let((design_box design_ll design_ur design_ll_x design_ll_y
	    design_ur_x design_ur_y box_ll_x box_ll_y box_ur_x
	    box_ur_y offset origin_x origin_y mypath
	) 
	(offset = (axlMKSConvert "1 MM" 
		car((axlDBGetDesignUnits))
	    )) 
	(design_box = ((axlGetParam "paramDesign")->bBox)) 
	(design_ll = car(design_box)) 
	(design_ll_x = car(design_ll))
	(design_ll_y = cadr(design_ll)) 
	(design_ur = cadr(design_box)) 
	(design_ur_x = car(design_ur)) 
	(design_ur_y = cadr(design_ur)) 
	(origin_x = (design_ll_x + offset))
	(origin_y = (design_ll_y + box_height + offset)) 
	(box_ll_x = (design_ll_x + offset)) 
	(box_ll_y = (design_ll_y + offset)) 
	(box_ur_x = (design_ll_x + box_width + offset)) 
	(box_ur_y = (design_ll_y + box_height + offset))
	if(((box_ll_x > design_ll_x) && (box_ll_y > design_ll_y) && (box_ur_x < design_ur_x) && (box_ur_y < design_ur_y)) then 
	    (axlClearDynamics) 
	    (mypath = (axlPathStart 
		    list((box_ll_x:box_ll_y) 
			(box_ur_x:box_ll_y) 
			(box_ur_x:box_ur_y) 
			(box_ll_x:box_ur_y) 
			(box_ll_x:box_ll_y)
		    ) 0.1
		)) 
	    (axlAddSimpleMoveDynamics 
		(origin_x:origin_y) mypath "path"
	    )
	    mypath else 
	    printf("Error: Destination window will not fit at all into drawing extents\n") nil
	)
    )
)
procedure(TBX_XSECGEN_Callback(form_handle) 
    let((cmd result via_info scale_layers scale_type
	    row_spacing cond_height diel_height text_block text_height
	    min_height input_file output_file form_settings popup
	    continue msg_str
	) 
	case((form_handle->curField) 
	    ("done" 
		TBX_XSECGEN_Save_Config(nil) 
		TBX_FORM_Done(form_handle nil)
	    ) 
	    ("preview" 
		(popup = (axlUIPopupDefine nil 
			list(list("Clear Preview" 
				'TBX_XSECGEN_Popup_Clear_Preview
			    ) 
			    list("Done" 
				'TBX_XSECGEN_Popup_Done
			    )
			)
		    )) 
		(axlUIPopupSet popup) 
		(scale_layers = (axlFormGetField form_handle "scale_layers")) 
		(scale_type = (axlFormGetField form_handle "layer_scale_type"))
		(min_height = (axlFormGetField form_handle "min_layer_height")) 
		(row_spacing = (axlFormGetField form_handle "extra_row_spacing")) 
		(cond_height = (axlFormGetField form_handle "conductor_height")) 
		(diel_height = (axlFormGetField form_handle "dielectric_height")) 
		(text_block = (axlFormGetField form_handle "label_text_block"))
		(text_block = sprintf(nil "%d" text_block)) 
		(tbx_xsecgen_global->layerInfo = TBX_XSECGEN_Get_Layer_Info(cond_height diel_height row_spacing scale_layers scale_type
			min_height
		    )) 
		(via_info = TBX_XSECGEN_Get_Via_Info()) 
		(tbx_xsecgen_global->viaInfo = TBX_XSECGEN_Sort_Via_Stacks(via_info)) 
		(tbx_xsecgen_global->labelInfo = TBX_XSECGEN_Get_Label_Info((tbx_xsecgen_global->layerInfo) 
			(tbx_xsecgen_global->viaInfo) text_block
		    ))
		(result = TBX_XSECGEN_Get_Total_Extents()) 
		TBX_XSECGEN_Build_Dynamics(car(result) 
		    cadr(result)
		)
	    ) 
	    ("conductor_style" 
		if(((form_handle->curValue) == "hatch_both") then 
		    (axlFormSetFieldEditable form_handle "conductor_hatch_width" t) 
		    (axlFormSetFieldEditable form_handle "conductor_hatch_spacing" t) else
		    (axlFormSetFieldEditable form_handle "conductor_hatch_width" nil) 
		    (axlFormSetFieldEditable form_handle "conductor_hatch_spacing" nil)
		)
	    ) 
	    ("dielectric_style" 
		if(((form_handle->curValue) == "hatch_diag") then 
		    (axlFormSetFieldEditable form_handle "dielectric_hatch_width" t) 
		    (axlFormSetFieldEditable form_handle "dielectric_hatch_spacing" t) else
		    (axlFormSetFieldEditable form_handle "dielectric_hatch_width" nil) 
		    (axlFormSetFieldEditable form_handle "dielectric_hatch_spacing" nil)
		)
	    )
	    ("scale_layers" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "conductor_height" nil) 
		    (axlFormSetFieldEditable form_handle "dielectric_height" nil) 
		    (axlFormSetFieldEditable form_handle "layer_scale_type" t)
		    (axlFormSetFieldEditable form_handle "min_layer_height" t) else 
		    (axlFormSetFieldEditable form_handle "conductor_height" t) 
		    (axlFormSetFieldEditable form_handle "dielectric_height" t) 
		    (axlFormSetFieldEditable form_handle "layer_scale_type" nil)
		    (axlFormSetFieldEditable form_handle "min_layer_height" nil)
		)
	    ) 
	    ("include_via_stack" 
		if((form_handle->curValue) then 
		    (axlFormSetFieldEditable form_handle "show_inner_pads" t) 
		    (axlFormSetFieldEditable form_handle "include_via_label" t) else
		    (axlFormSetFieldEditable form_handle "show_inner_pads" nil) 
		    (axlFormSetFieldEditable form_handle "include_via_label" nil)
		)
	    ) 
	    ("save_to_file" 
		if((axlOKToProceed) then 
		    (axlCancelEnterFun) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics)
		    (output_file = (axlDMFileBrowse "ALLEGRO_TEXT" t)) 
		    when(output_file 
			TBX_XSECGEN_Save_Config(output_file)
		    ) else 
		    (axlUIWPrint form_handle "W - Finish current command first  ")
		)
	    ) 
	    ("load_from_file" 
		if((axlOKToProceed) then 
		    (axlCancelEnterFun) 
		    (axlUIPopupSet nil) 
		    (axlClearDynamics)
		    (input_file = (axlDMFileBrowse "ALLEGRO_TEXT" nil)) 
		    when((input_file && isFile(input_file)) 
			(form_settings = TBX_XSECGEN_Read_Config(input_file)) 
			TBX_XSECGEN_Update_Form(form_settings)
		    ) else 
		    (axlUIWPrint form_handle "W - Finish current command first  ")
		)
	    ) 
	    ("run" 
		(scale_layers = (axlFormGetField form_handle "scale_layers")) 
		(scale_type = (axlFormGetField form_handle "layer_scale_type")) 
		(min_height = (axlFormGetField form_handle "min_layer_height")) 
		(row_spacing = (axlFormGetField form_handle "extra_row_spacing"))
		(cond_height = (axlFormGetField form_handle "conductor_height")) 
		(diel_height = (axlFormGetField form_handle "dielectric_height")) 
		(text_block = (axlFormGetField form_handle "label_text_block")) 
		(text_block = sprintf(nil "%d" text_block)) 
		(text_height = ((axlGetParam 
			    strcat("paramTextBlock:" text_block)
			)->height))
		(continue = t) 
		cond(((scale_layers && (text_height > (min_height + row_spacing))) 
			(msg_str = sprintf(nil "Text block %s has a height of %.3f which is greater than\nminimum height plus row spacing. Adjust your settings" text_block text_height)) 
			(axlUIConfirm msg_str) 
			(continue = nil)
		    ) 
		    (((text_height > (cond_height + row_spacing)) || (text_height > (diel_height + row_spacing))) 
			(msg_str = sprintf(nil "Text block %s has a height of %.3f which is greater than\nminimum conductor (or dielectric) height plus row spacing. Adjust your settings" text_block text_height)) 
			(axlUIConfirm msg_str) 
			(continue = nil)
		    ) 
		    (t 
			(continue = t)
		    )
		) 
		when(continue 
		    (tbx_xsecgen_global->layerInfo = TBX_XSECGEN_Get_Layer_Info(cond_height diel_height row_spacing scale_layers scale_type
			    min_height
			)) 
		    (via_info = TBX_XSECGEN_Get_Via_Info()) 
		    (tbx_xsecgen_global->viaInfo = TBX_XSECGEN_Sort_Via_Stacks(via_info)) 
		    (tbx_xsecgen_global->labelInfo = TBX_XSECGEN_Get_Label_Info((tbx_xsecgen_global->layerInfo) 
			    (tbx_xsecgen_global->viaInfo) text_block
			))
		    (cmd = "tbx xsecgen run") 
		    (axlShell cmd)
		)
	    )
	    ("myhelp" 
		(axlShell "tbx help xsecgen")
	    ) 
	    (t t)
	)
    )
)
procedure(TBX_XSECGEN_Draw_Debug_Rectangle(box_ul width height sym_inst) 
    let((box_ll_x box_ll_y box_ur_x box_ur_y) 
	when(box_ul 
	    (box_ll_x = car(box_ul)) 
	    (box_ll_y = (cadr(box_ul) - height)) 
	    (box_ur_x = (car(box_ul) + width)) 
	    (box_ur_y = cadr(box_ul))
	    (axlDBCreateRectangle 
		list((box_ll_x:box_ll_y) 
		    (box_ur_x:box_ur_y)
		) nil 
		(tbx_xsecgen_global->condLayer) nil
		sym_inst
	    )
	) t
    )
)
procedure(TBX_XSECGEN_Draw_Geometry(sym_location sym_inst) 
    let((formid geom_ul_x geom_ul_y height cond_hatch_width
	    cond_hatch_spacing cond_hatch_45 cond_hatch_135 diel_hatch_width diel_hatch_spacing
	    diel_hatch_45 diel_hatch_135 diel_hatch_list box_ll box_ll_x
	    box_ll_y box_ur_x box_ur_y xsection_width start_y
	    end_y include_via_stack include_name_label include_via_label column_spacing
	    radius radius_inner_hole radius_outer_hole radius_pad step_size_x
	    via_cnt via_start_lyr via_end_lyr lyr_id lyr_type
	    lyr_nr open_shape via_center_x fill_style abs_lay_id
	    via_part_left via_part_right first_elem mypath show_inner_pads
	) 
	(formid = (tbx_xsecgen_global->formid)) 
	(include_name_label = (axlFormGetField formid "include_layer_name")) 
	(include_via_label = (axlFormGetField formid "include_via_label")) 
	(column_spacing = (axlFormGetField formid "extra_column_spacing"))
	(cond_hatch_width = (axlFormGetField formid "conductor_hatch_width")) 
	(cond_hatch_spacing = (axlFormGetField formid "conductor_hatch_spacing")) 
	(diel_hatch_width = (axlFormGetField formid "dielectric_hatch_width")) 
	(diel_hatch_spacing = (axlFormGetField formid "dielectric_hatch_spacing")) 
	(include_via_stack = (axlFormGetField formid "include_via_stack"))
	(xsection_width = (axlFormGetField formid "xsection_base_width")) 
	(geom_ul_x = car(sym_location)) 
	(geom_ul_y = cadr(sym_location)) 
	when(include_name_label 
	    (geom_ul_x = (geom_ul_x + cadr((tbx_xsecgen_global->labelInfo)["name"]) + column_spacing))
	) 
	when(include_via_label 
	    (geom_ul_y = (geom_ul_y - cadr((tbx_xsecgen_global->labelInfo)["via"]) - (tbx_xsecgen_global->labelOffsetY)))
	)
	(cond_hatch_45 = (make_axlFill)) 
	(cond_hatch_45->spacing = cond_hatch_spacing) 
	(cond_hatch_45->width = cond_hatch_width) 
	(cond_hatch_45->angle = 45.0) 
	(cond_hatch_135 = (make_axlFill))
	(cond_hatch_135->spacing = cond_hatch_spacing) 
	(cond_hatch_135->width = cond_hatch_width) 
	(cond_hatch_135->angle = 135.0) 
	(diel_hatch_45 = (make_axlFill)) 
	(diel_hatch_45->spacing = diel_hatch_spacing)
	(diel_hatch_45->width = diel_hatch_width) 
	(diel_hatch_45->angle = 45.0) 
	(diel_hatch_135 = (make_axlFill)) 
	(diel_hatch_135->spacing = diel_hatch_spacing) 
	(diel_hatch_135->width = diel_hatch_width)
	(diel_hatch_135->angle = 135.0) 
	(diel_hatch_list = list(diel_hatch_45 diel_hatch_135)) 
	(open_shape = makeTable("open_shape_table" nil)) 
	(fill_style = makeTable("fill_style_table" nil)) 
	(abs_lay_id = makeTable("abs_lay_id_table" nil))
	foreach(lyr 
	    (tbx_xsecgen_global->layerInfo) 
	    (lyr_id = car(lyr)) 
	    (lyr_type = cadr(lyr)) 
	    (lyr_nr = caddr(lyr))
	    (start_y = nth(6 lyr)) 
	    (end_y = nth(7 lyr)) 
	    when((lyr_nr > 0) 
		(abs_lay_id[lyr_nr] = lyr_id)
	    ) 
	    cond((((lyr_type == "C") || (lyr_type == "P")) 
		    case((axlFormGetField formid "conductor_style") 
			("hatch_both" 
			    (fill_style[lyr_id] = list((tbx_xsecgen_global->condLayer) 
				    list(cond_hatch_45 cond_hatch_135)
				))
			) 
			("fill" 
			    (fill_style[lyr_id] = list((tbx_xsecgen_global->condLayer) t))
			) 
			("unfill" 
			    (fill_style[lyr_id] = list((tbx_xsecgen_global->condLayer) nil))
			) 
			(t 
			    (fill_style[lyr_id] = list((tbx_xsecgen_global->condLayer) nil))
			)
		    )
		) 
		(((lyr_type == "D") || (lyr_type == "M")) 
		    case((axlFormGetField formid "dielectric_style") 
			("hatch_diag" 
			    (fill_style[lyr_id] = list((tbx_xsecgen_global->dielLayer) 
				    list(car(diel_hatch_list))
				)) 
			    (diel_hatch_list = reverse(diel_hatch_list))
			) 
			("fill" 
			    (fill_style[lyr_id] = list((tbx_xsecgen_global->dielLayer) t))
			) 
			("unfill" 
			    (fill_style[lyr_id] = list((tbx_xsecgen_global->dielLayer) nil))
			) 
			(t 
			    (fill_style[lyr_id] = list((tbx_xsecgen_global->dielLayer) nil))
			)
		    )
		) 
		(t 
		    (fill_style[lyr_id] = list((tbx_xsecgen_global->dielLayer) nil))
		)
	    ) 
	    when(include_via_stack 
		(open_shape[lyr_id] = list((geom_ul_x:(geom_ul_y - end_y)) 
			(end_y - start_y)
		    ))
	    )
	) 
	if((include_via_stack && (length((tbx_xsecgen_global->viaInfo)) > 0)) then 
	    (via_cnt = length((tbx_xsecgen_global->viaInfo))) 
	    (step_size_x = (xsection_width / (via_cnt + 1.0))) 
	    (radius_pad = (0.25 * step_size_x))
	    (radius_outer_hole = (0.12 * step_size_x)) 
	    (radius_inner_hole = (0.05 * step_size_x)) 
	    (via_center_x = geom_ul_x) 
	    (show_inner_pads = (axlFormGetField formid "show_inner_pads")) 
	    foreach(via 
		(tbx_xsecgen_global->viaInfo) 
		(via_part_left = list()) 
		(via_part_right = list()) 
		(via_start_lyr = abs_lay_id[cadr(via)])
		(via_end_lyr = abs_lay_id[caddr(via)]) 
		(via_center_x = (via_center_x + step_size_x)) 
		foreach(lyr 
		    (tbx_xsecgen_global->layerInfo) 
		    (lyr_id = car(lyr)) 
		    (lyr_type = cadr(lyr)) 
		    (start_y = nth(6 lyr))
		    (end_y = nth(7 lyr)) 
		    if(((lyr_id < via_start_lyr) || (lyr_id > via_end_lyr)) then t else 
			cond(((lyr_id == via_start_lyr) 
				(radius = radius_pad) 
				(via_part_left = cons(((via_center_x - radius_inner_hole):(geom_ul_y - start_y)) via_part_left)) 
				(via_part_left = cons(((via_center_x - radius_pad):(geom_ul_y - start_y)) via_part_left)) 
				(via_part_left = cons(((via_center_x - radius_pad):(geom_ul_y - end_y)) via_part_left))
				(via_part_left = cons(((via_center_x - radius_outer_hole):(geom_ul_y - end_y)) via_part_left)) 
				(via_part_right = cons(((via_center_x + radius_inner_hole):(geom_ul_y - start_y)) via_part_right)) 
				(via_part_right = cons(((via_center_x + radius_pad):(geom_ul_y - start_y)) via_part_right)) 
				(via_part_right = cons(((via_center_x + radius_pad):(geom_ul_y - end_y)) via_part_right)) 
				(via_part_right = cons(((via_center_x + radius_outer_hole):(geom_ul_y - end_y)) via_part_right))
			    ) 
			    ((lyr_id == via_end_lyr) 
				(radius = radius_pad) 
				(via_part_left = cons(((via_center_x - radius_outer_hole):(geom_ul_y - start_y)) via_part_left)) 
				(via_part_left = cons(((via_center_x - radius_pad):(geom_ul_y - start_y)) via_part_left)) 
				(via_part_left = cons(((via_center_x - radius_pad):(geom_ul_y - end_y)) via_part_left))
				(via_part_left = cons(((via_center_x - radius_inner_hole):(geom_ul_y - end_y)) via_part_left)) 
				(via_part_right = cons(((via_center_x + radius_outer_hole):(geom_ul_y - start_y)) via_part_right)) 
				(via_part_right = cons(((via_center_x + radius_pad):(geom_ul_y - start_y)) via_part_right)) 
				(via_part_right = cons(((via_center_x + radius_pad):(geom_ul_y - end_y)) via_part_right)) 
				(via_part_right = cons(((via_center_x + radius_inner_hole):(geom_ul_y - end_y)) via_part_right))
			    ) 
			    (t 
				(radius = radius_outer_hole) 
				if(((lyr_type == "C") || (lyr_type == "P")) then 
				    when(show_inner_pads 
					(radius = radius_pad) 
					(via_part_left = cons(((via_center_x - radius_outer_hole):(geom_ul_y - start_y)) via_part_left)) 
					(via_part_left = cons(((via_center_x - radius_pad):(geom_ul_y - start_y)) via_part_left)) 
					(via_part_left = cons(((via_center_x - radius_pad):(geom_ul_y - end_y)) via_part_left))
					(via_part_left = cons(((via_center_x - radius_outer_hole):(geom_ul_y - end_y)) via_part_left)) 
					(via_part_right = cons(((via_center_x + radius_outer_hole):(geom_ul_y - start_y)) via_part_right)) 
					(via_part_right = cons(((via_center_x + radius_pad):(geom_ul_y - start_y)) via_part_right)) 
					(via_part_right = cons(((via_center_x + radius_pad):(geom_ul_y - end_y)) via_part_right)) 
					(via_part_right = cons(((via_center_x + radius_outer_hole):(geom_ul_y - end_y)) via_part_right))
				    )
				)
			    )
			)
			(box_ll = car(open_shape[lyr_id])) 
			(height = cadr(open_shape[lyr_id])) 
			(box_ll_x = car(box_ll)) 
			(box_ll_y = cadr(box_ll)) 
			(box_ur_x = (via_center_x - radius))
			(box_ur_y = (box_ll_y + height)) 
			(axlDBCreateRectangle 
			    list((box_ll_x:box_ll_y) 
				(box_ur_x:box_ur_y)
			    ) 
			    cadr(fill_style[lyr_id]) 
			    car(fill_style[lyr_id]) nil
			    sym_inst
			) 
			(box_ll_x = (via_center_x + radius)) 
			(box_ll_y = box_ll_y) 
			(open_shape[lyr_id] = list((box_ll_x:box_ll_y) height))
		    )
		) 
		(via_part_left = reverse(via_part_left)) 
		(first_elem = car(via_part_left))
		(via_part_left = append1(via_part_left first_elem)) 
		(mypath = (axlPathStart via_part_left 0.0)) 
		(axlDBCreateShape mypath t 
		    (tbx_xsecgen_global->viaLayer) nil
		    sym_inst
		) 
		(via_part_right = reverse(via_part_right)) 
		(first_elem = car(via_part_right))
		(via_part_right = append1(via_part_right first_elem)) 
		(mypath = (axlPathStart via_part_right 0.0)) 
		(axlDBCreateShape mypath t 
		    (tbx_xsecgen_global->viaLayer) nil
		    sym_inst
		)
	    )
	    foreach(id open_shape 
		(box_ll = car(open_shape[id])) 
		(height = cadr(open_shape[id])) 
		(box_ll_x = car(box_ll))
		(box_ll_y = cadr(box_ll)) 
		(box_ur_x = (geom_ul_x + xsection_width)) 
		(box_ur_y = (box_ll_y + height)) 
		(axlDBCreateRectangle 
		    list((box_ll_x:box_ll_y) 
			(box_ur_x:box_ur_y)
		    ) 
		    cadr(fill_style[id]) 
		    car(fill_style[id]) nil
		    sym_inst
		)
	    ) else 
	    foreach(entry 
		(tbx_xsecgen_global->layerInfo) 
		(lyr_id = car(entry)) 
		(start_y = nth(6 entry)) 
		(end_y = nth(7 entry))
		(box_ll_x = geom_ul_x) 
		(box_ll_y = (geom_ul_y - end_y)) 
		(box_ur_x = (box_ll_x + xsection_width)) 
		(box_ur_y = (geom_ul_y - start_y)) 
		(axlDBCreateRectangle 
		    list((box_ll_x:box_ll_y) 
			(box_ur_x:box_ur_y)
		    ) 
		    cadr(fill_style[lyr_id]) 
		    car(fill_style[lyr_id]) nil
		    sym_inst
		)
	    )
	) t
    )
)
procedure(TBX_XSECGEN_Fit_to_Canvas(location_ul width height) 
    let((design_box design_ll design_ll_x design_ll_y design_ur
	    design_ur_x design_ur_y sym_ll_x sym_ll_y sym_ur_x
	    sym_ur_y return_value
	) 
	(design_box = ((axlGetParam "paramDesign")->bBox)) 
	(design_ll = car(design_box)) 
	(design_ll_x = car(design_ll)) 
	(design_ll_y = cadr(design_ll))
	(design_ur = cadr(design_box)) 
	(design_ur_x = car(design_ur)) 
	(design_ur_y = cadr(design_ur)) 
	(sym_ll_x = car(location_ul)) 
	(sym_ll_y = (cadr(location_ul) - height))
	(sym_ur_x = (car(location_ul) + width)) 
	(sym_ur_y = cadr(location_ul)) 
	if(((sym_ll_x > design_ll_x) && (sym_ll_y > design_ll_y) && (sym_ur_x < design_ur_x) && (sym_ur_y < design_ur_y)) then 
	    (return_value = t) else 
	    (return_value = nil)
	) return_value
    )
)
procedure(TBX_XSECGEN_Get_Label_Info(layer_info via_info text_block) 
    let((block_info char_height char_width char_space layer_name_width
	    layer_material_width layer_thickness_width via_name_width label_info width
	    char_cnt char_cnt_name char_cnt_material char_cnt_thickness char_cnt_via
	    last_layer
	) 
	(label_info = makeTable("label_info_table" nil)) 
	(block_info = (axlGetParam 
		strcat("paramTextBlock:" text_block)
	    )) 
	(char_height = (block_info->height)) 
	(char_width = (block_info->width))
	(char_space = (block_info->charSpace)) 
	(layer_name_width = 0) 
	(layer_material_width = 0) 
	(layer_thickness_width = 0) 
	(via_name_width = 0)
	foreach(entry layer_info 
	    (char_cnt = strlen(nth(3 entry))) 
	    (width = ((char_cnt * char_width) + ((char_cnt - 1) * char_space))) 
	    when((width > layer_name_width) 
		(layer_name_width = width) 
		(char_cnt_name = char_cnt)
	    )
	    (char_cnt = strlen(nth(4 entry))) 
	    (width = ((char_cnt * char_width) + ((char_cnt - 1) * char_space))) 
	    when((width > layer_material_width) 
		(layer_material_width = width) 
		(char_cnt_material = char_cnt)
	    ) 
	    (char_cnt = strlen(nth(5 entry))) 
	    (width = ((char_cnt * char_width) + ((char_cnt - 1) * char_space)))
	    when((width > layer_thickness_width) 
		(layer_thickness_width = width) 
		(char_cnt_thickness = char_cnt)
	    )
	) 
	foreach(entry via_info 
	    (char_cnt = strlen(car(entry))) 
	    (width = ((char_cnt * char_width) + ((char_cnt - 1) * char_space))) 
	    when((width > via_name_width) 
		(via_name_width = width) 
		(char_cnt_via = char_cnt)
	    )
	) 
	(last_layer = car(reverse(layer_info))) 
	(char_cnt = strlen(nth(8 last_layer))) 
	(width = ((char_cnt * char_width) + ((char_cnt - 1) * char_space)))
	when((width > layer_thickness_width) 
	    (layer_thickness_width = width) 
	    (char_cnt_thickness = char_cnt)
	) 
	(label_info["name"] = list(char_height layer_name_width char_cnt_name)) 
	(label_info["material"] = list(char_height layer_material_width char_cnt_material)) 
	(label_info["thickness"] = list(char_height layer_thickness_width char_cnt_thickness)) 
	(label_info["via"] = list(char_height via_name_width char_cnt_via))
	label_info
    )
)
procedure(TBX_XSECGEN_Get_Layer_Info(cond_canvas_height_default diel_canvas_height_default row_spacing scale_layers scale_type
	canvas_height_min
    ) 
    let((layer_data lyr_type lyr_name lyr_material lyr_thickness
	    lyr_number design_units units_str thickness_list layer_info
	    start_y end_y canvas_height thickness_min factor
	    divisor_log lyr_id total_thickness_from_top
	) 
	(design_units = car((axlDBGetDesignUnits))) 
	case(lowerCase(design_units) 
	    ("millimeters" 
		(units_str = "MM")
	    ) 
	    ("microns" 
		(units_str = "UM")
	    ) 
	    ("inches" 
		(units_str = "IN")
	    ) 
	    ("centimeters" 
		(units_str = "CM")
	    )
	    ("mils" 
		(units_str = "MIL")
	    ) 
	    (t 
		(units_str = design_units)
	    )
	) 
	(layer_data = list()) 
	(thickness_list = list())
	(lyr_id = 0) 
	(total_thickness_from_top = 0.0) 
	foreach(lyr 
	    (axlGetXSection) 
	    unless((upperCase(caddr(lyr)) == "AIR") 
		++lyr_id 
		case(upperCase(cadr(lyr)) 
		    ("DIELECTRIC" 
			(lyr_type = "D") 
			(lyr_number = -1) 
			(lyr_name = car(lyr)) 
			when((lyr_name == "") 
			    (lyr_name = "-")
			)
			(lyr_material = caddr(lyr)) 
			(lyr_thickness = (axlMKSConvert 
				nth(3 lyr) design_units
			    )) 
			(total_thickness_from_top = (total_thickness_from_top + lyr_thickness)) 
			(thickness_list = cons(lyr_thickness thickness_list))
		    ) 
		    ("PLANE" 
			(lyr_type = "P") 
			(lyr_number = (((axlLayerGet 
					strcat((axlMapClassName "ETCH") "/" 
					    car(lyr)
					)
				    )->number) + 1)) 
			(lyr_name = car(lyr)) 
			(lyr_material = caddr(lyr))
			(lyr_thickness = (axlMKSConvert 
				nth(3 lyr) design_units
			    )) 
			(total_thickness_from_top = (total_thickness_from_top + lyr_thickness)) 
			(thickness_list = cons(lyr_thickness thickness_list))
		    ) 
		    ("CONDUCTOR" 
			(lyr_type = "C") 
			(lyr_number = (((axlLayerGet 
					strcat((axlMapClassName "ETCH") "/" 
					    car(lyr)
					)
				    )->number) + 1)) 
			(lyr_name = car(lyr)) 
			(lyr_material = caddr(lyr))
			(lyr_thickness = (axlMKSConvert 
				nth(3 lyr) design_units
			    )) 
			(total_thickness_from_top = (total_thickness_from_top + lyr_thickness)) 
			(thickness_list = cons(lyr_thickness thickness_list))
		    ) 
		    (t 
			(lyr_type = "M") 
			(lyr_number = -1) 
			(lyr_name = "mask") 
			(lyr_material = caddr(lyr))
			(lyr_thickness = (axlMKSConvert 
				nth(3 lyr) design_units
			    )) 
			(total_thickness_from_top = (total_thickness_from_top + lyr_thickness)) 
			(thickness_list = cons(lyr_thickness thickness_list))
		    )
		) 
		(layer_data = cons(list(lyr_id lyr_type lyr_number lyr_name lyr_material
			    lyr_thickness total_thickness_from_top
			) layer_data
		    ))
	    )
	) 
	(layer_data = reverse(layer_data)) 
	(thickness_min = car(sort(thickness_list 
		    'lessp
		)
	    ))
	case(scale_type 
	    ("log2" 
		(divisor_log = log(2))
	    ) 
	    ("log5" 
		(divisor_log = log(5))
	    ) 
	    ("log10" 
		(divisor_log = log(10))
	    ) 
	    (t t)
	) 
	(start_y = 0.0) 
	(layer_info = list()) 
	foreach(entry layer_data 
	    (lyr_id = car(entry)) 
	    (lyr_type = cadr(entry)) 
	    (lyr_number = caddr(entry))
	    (lyr_name = nth(3 entry)) 
	    (lyr_material = nth(4 entry)) 
	    (lyr_thickness = nth(5 entry)) 
	    (total_thickness_from_top = nth(6 entry)) 
	    cond((((lyr_type == "C") || (lyr_type == "P")) 
		    if(scale_layers then 
			(factor = (lyr_thickness / thickness_min)) 
			if((scale_type == "linear") then 
			    (factor = factor) else 
			    (factor = (1 + (log(factor) / divisor_log)))
			) 
			(canvas_height = (factor * canvas_height_min))
			else 
			(canvas_height = cond_canvas_height_default)
		    )
		) 
		((lyr_type == "D") 
		    if(scale_layers then 
			(factor = (lyr_thickness / thickness_min)) 
			if((scale_type == "linear") then 
			    (factor = factor) else 
			    (factor = (1 + (log(factor) / divisor_log)))
			) 
			(canvas_height = (factor * canvas_height_min))
			else 
			(canvas_height = diel_canvas_height_default)
		    )
		) 
		(t 
		    if(scale_layers then 
			(factor = (lyr_thickness / thickness_min)) 
			if((scale_type == "linear") then 
			    (factor = factor) else 
			    (factor = (1 + (log(factor) / divisor_log)))
			) 
			(canvas_height = (factor * canvas_height_min))
			else 
			(canvas_height = diel_canvas_height_default)
		    )
		)
	    )
	    (start_y = start_y) 
	    (end_y = (start_y + canvas_height)) 
	    (lyr_id = car(entry)) 
	    (lyr_type = cadr(entry)) 
	    (lyr_number = caddr(entry))
	    (lyr_name = nth(3 entry)) 
	    (lyr_material = nth(4 entry)) 
	    (lyr_thickness = nth(5 entry)) 
	    (lyr_thickness = sprintf(nil "%.3f%s" lyr_thickness 
		    lowerCase(units_str)
		)) 
	    (total_thickness_from_top = sprintf(nil "%.3f%s" total_thickness_from_top 
		    lowerCase(units_str)
		))
	    (layer_info = cons(list(lyr_id lyr_type lyr_number lyr_name lyr_material
			lyr_thickness start_y end_y total_thickness_from_top
		    ) layer_info
		)) 
	    (start_y = (start_y + canvas_height + row_spacing))
	) 
	(layer_info = reverse(layer_info))
	layer_info
    )
)
procedure(TBX_XSECGEN_Get_Total_Extents() 
    let((xsection_width xsection_height include_layer_name include_thickness include_material_name
	    include_via_label column_spacing form_handle result last_layer
	    label_info
	) 
	(form_handle = (tbx_xsecgen_global->formid)) 
	(label_info = (tbx_xsecgen_global->labelInfo)) 
	(xsection_width = (axlFormGetField form_handle "xsection_base_width")) 
	(xsection_height = 0.0)
	(column_spacing = (axlFormGetField form_handle "extra_column_spacing")) 
	(include_layer_name = (axlFormGetField form_handle "include_layer_name")) 
	(include_material_name = (axlFormGetField form_handle "include_material_name")) 
	(include_thickness = (axlFormGetField form_handle "include_thickness")) 
	(include_via_label = (axlFormGetField form_handle "include_via_label"))
	when(include_layer_name 
	    (xsection_width = (xsection_width + cadr(label_info["name"]) + column_spacing))
	) 
	when(include_material_name 
	    (xsection_width = (xsection_width + cadr(label_info["material"]) + column_spacing))
	) 
	when(include_thickness 
	    (xsection_width = (xsection_width + cadr(label_info["thickness"]) + column_spacing)) 
	    (xsection_height = (xsection_height + (2 * (tbx_xsecgen_global->labelOffsetY)) + car(label_info["thickness"])))
	) 
	when(include_via_label 
	    (xsection_height = (xsection_height + cadr(label_info["via"]) + (tbx_xsecgen_global->labelOffsetY)))
	) 
	(last_layer = car(reverse((tbx_xsecgen_global->layerInfo))))
	(xsection_height = (xsection_height + nth(7 last_layer))) 
	(result = list(xsection_width xsection_height)) result
    )
)
procedure(TBX_XSECGEN_Get_Via_Info() 
    let((orgvis layer_name layer_id cnt start_lyr
	    end_lyr via_stack_info via_list
	) 
	(layer_id = makeTable("layer_id_table" nil)) 
	(cnt = 0) 
	foreach(lyr 
	    ((axlGetParam 
		    strcat("paramLayerGroup:" 
			(axlMapClassName "ETCH")
		    )
		)->groupMembers) 
	    (layer_name = strcat((axlMapClassName "ETCH") "/" lyr)) 
	    ++cnt 
	    (layer_id[upperCase(layer_name)] = cnt)
	) 
	(via_stack_info = makeTable("via_stack_info_table" nil))
	(axlSetFindFilter ?enabled 
	    '("NOALL" "VIAS") ?onButtons 
	    '("VIAS")
	) 
	(orgvis = (axlVisibleGet)) 
	(axlVisibleDesign t) 
	foreach(via 
	    (axlGetSelSet 
		(axlAddSelectAll)
	    ) 
	    (start_lyr = upperCase(car((via->startEnd)))) 
	    (end_lyr = upperCase(cadr((via->startEnd)))) 
	    when((start_lyr != end_lyr) 
		(via_stack_info[upperCase((via->name))] = list(layer_id[start_lyr] 
			layer_id[end_lyr]
		    ))
	    )
	) 
	(axlClearSelSet)
	(axlVisibleSet orgvis) 
	(via_list = list()) 
	foreach(key via_stack_info 
	    (via_list = cons(cons(key 
			via_stack_info[key]
		    ) via_list
		))
	) via_list
    )
)
procedure(TBX_XSECGEN_Init() 
    let((cond_layer defaults design_units diel_layer via_layer
	    label_layer label_offset_y prm layer color
	) 
	unless(boundp('tbx_xsecgen_global) 
	    iliDefstruct('defstruct(tbx_xsecgen_global_struct formid viaInfo layerInfo labelInfo
			viewlog condLayer dielLayer labelLayer viaLayer
			labelOffsetY defaults licCheck
		    )
	    ) 
	    defvar(tbx_xsecgen_global nil)
	) 
	(cond_layer = "MANUFACTURING/XSECTION_COND") 
	(diel_layer = "MANUFACTURING/XSECTION_DIEL") 
	(via_layer = "MANUFACTURING/XSECTION_VIA")
	(label_layer = "MANUFACTURING/XSECTION_LABEL") 
	(label_offset_y = (axlMKSConvert "2.0 MM" 
		car((axlDBGetDesignUnits))
	    )) 
	(axlColorSet 189 
	    list(255 0 0)
	) 
	(axlColorSet 190 
	    list(0 255 0)
	) 
	(axlColorSet 191 
	    list(0 0 255)
	)
	(axlColorSet 192 
	    list(255 255 0)
	) 
	foreach(entry 
	    list(list(cond_layer 189) 
		list(diel_layer 190) 
		list(via_layer 191) 
		list(label_layer 192)
	    ) 
	    (layer = car(entry)) 
	    (color = cadr(entry)) 
	    unless((axlIsLayer layer) 
		(axlLayerCreateNonConductor layer) 
		(prm = (axlLayerGet layer)) 
		(prm->color = color) 
		(axlLayerSet prm)
	    )
	    (axlVisibleLayer layer t)
	) 
	(axlVisibleUpdate t) 
	(design_units = car((axlDBGetDesignUnits))) 
	(defaults = ncons(nil))
	putprop(defaults design_units 
	    'units
	) 
	putprop(defaults t 
	    'includeLayerName
	) 
	putprop(defaults t 
	    'includeMaterialName
	) 
	putprop(defaults t 
	    'includeThickness
	) 
	putprop(defaults t 
	    'includeViaStack
	)
	putprop(defaults t 
	    'includeViaLabel
	) 
	putprop(defaults t 
	    'showInnerPads
	) 
	putprop(defaults 
	    (axlMKSConvert "100.0 MM" design_units) 
	    'xsectionBaseWidth
	) 
	putprop(defaults 0.0 
	    'extraRowSpacing
	) 
	putprop(defaults 
	    (axlMKSConvert "2.0 MM" design_units) 
	    'extraColumnSpacing
	)
	putprop(defaults 4 
	    'labelTextBlock
	) 
	putprop(defaults nil 
	    'scaleLayers
	) 
	putprop(defaults "log10" 
	    'layerScaleType
	) 
	putprop(defaults 
	    (axlMKSConvert "2.0 MM" design_units) 
	    'minLayerHeight
	) 
	putprop(defaults 
	    (axlMKSConvert "2.0 MM" design_units) 
	    'conductorHeight
	)
	putprop(defaults "fill" 
	    'conductorStyle
	) 
	putprop(defaults 
	    (axlMKSConvert "0.1 MM" design_units) 
	    'conductorHatchWidth
	) 
	putprop(defaults 
	    (axlMKSConvert "0.5 MM" design_units) 
	    'conductorHatchSpacing
	) 
	putprop(defaults 
	    (axlMKSConvert "2.0 MM" design_units) 
	    'dielectricHeight
	) 
	putprop(defaults "fill" 
	    'dielectricStyle
	)
	putprop(defaults 
	    (axlMKSConvert "0.1 MM" design_units) 
	    'dielectricHatchWidth
	) 
	putprop(defaults 
	    (axlMKSConvert "0.5 MM" design_units) 
	    'dielectricHatchSpacing
	) 
	if(!tbx_xsecgen_global then 
	    (tbx_xsecgen_global = (make_tbx_xsecgen_global_struct ?formid nil ?defaults defaults
		    ?labelInfo nil ?layerInfo nil ?condLayer
		    cond_layer ?dielLayer diel_layer ?viaLayer via_layer
		    ?labelLayer label_layer ?viaInfo nil ?labelOffsetY
		    label_offset_y ?viewlog nil ?licCheck nil
		)) else 
	    (tbx_xsecgen_global->formid = nil)
	    (tbx_xsecgen_global->defaults = defaults) 
	    (tbx_xsecgen_global->labelInfo = nil) 
	    (tbx_xsecgen_global->layerInfo = nil) 
	    (tbx_xsecgen_global->condLayer = cond_layer) 
	    (tbx_xsecgen_global->dielLayer = diel_layer)
	    (tbx_xsecgen_global->viaLayer = via_layer) 
	    (tbx_xsecgen_global->labelLayer = label_layer) 
	    (tbx_xsecgen_global->viaInfo = nil) 
	    (tbx_xsecgen_global->labelOffsetY = label_offset_y) 
	    (tbx_xsecgen_global->viewlog = nil)
	    (tbx_xsecgen_global->licCheck = nil)
	)
    )
)
procedure((TBX_XSECGEN_Main \@optional arg) 
    let((lic_check_result FORM_FILE fid FC_FEATURE FC_VERSION
	    SUB_VERSION VERSION_STR port info_file form_settings
	) 
	(FC_FEATURE = "XSECGEN") 
	(FC_VERSION = "17.1") 
	(SUB_VERSION = "02") 
	(VERSION_STR = sprintf(nil "Cross Section Generator %s (C)2017" FC_VERSION))
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./xsecgen_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "Cross Section Generator information:\n") 
		fprintf(port "====================================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  reset   : Removes configuration settings from database\n") 
		fprintf(port "  version : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port)
		(axlUIViewFileCreate info_file "Cross Section Generator: Quick Info" nil) 
		when(isFile(info_file) 
		    deleteFile(info_file)
		)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION)
	    ) 
	    ((arg && (lowerCase(arg) == "reset")) 
		when((axlUIYesNo "Delete configuration from database?" nil 
			'no
		    ) 
		    (axlDeleteAttachment "tbx_xsecgen")
		)
	    ) 
	    (t 
		(lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
		when(lic_check_result 
		    TBX_XSECGEN_Init() 
		    TBX_UTIL_Migrate("flw_xsecgen" "tbx_xsecgen") 
		    (axlCmdRegister "tbx xsecgen run" 
			'TBX_XSECGEN_Run ?cmdType "interactive"
		    ) 
		    (FORM_FILE = TBX_FORM_Get_Name(lic_check_result "xsecgen_main"))
		    (fid = (axlFormCreate 
			    gensym("tbxxsecgenmain") FORM_FILE 
			    '(e outer) 
			    'TBX_XSECGEN_Callback
			    t
			)) 
		    (tbx_xsecgen_global->formid = fid) 
		    (tbx_xsecgen_global->licCheck = lic_check_result) 
		    TBX_FORM_Init_Header(fid "Licensed for " lic_check_result VERSION_STR) 
		    (form_settings = TBX_XSECGEN_Read_Config(nil))
		    TBX_XSECGEN_Update_Form(form_settings) 
		    (axlFormDisplay fid) 
		    (axlShell "noappmode") 
		    TBX_FORM_Delete(lic_check_result FORM_FILE)
		)
	    )
	)
    )
)
procedure(TBX_XSECGEN_Popup_Clear_Preview() 
    (axlFinishEnterFun) 
    (axlUIPopupSet nil) 
    (axlClearDynamics)
)
procedure(TBX_XSECGEN_Popup_Done() 
    (axlFinishEnterFun) 
    (axlUIPopupSet nil) 
    (axlClearDynamics)
)
procedure(TBX_XSECGEN_Read_Config(input_file) 
    let((att data port user_settings token
	    value check_fields mks_fields user_units ini_file
	) 
	(check_fields = list('includeLayerName 
		'includeMaterialName 
		'includeThickness 
		'includeViaStack 
		'includeViaLabel
		'showInnerPads 
		'scaleLayers
	    )) 
	(mks_fields = list('xsectionBaseWidth 
		'extraRowSpacing 
		'extraColumnSpacing 
		'minLayerHeight 
		'conductorHeight
		'conductorHatchWidth 
		'conductorHatchSpacing 
		'dielectricHeight 
		'dielectricHatchWidth 
		'dielectricHatchSpacing
	    )) 
	if(input_file then 
	    (port = infile(input_file)) 
	    (data = car(lineread(port))) 
	    close(port)
	    else 
	    (att = (axlGetAttachment "tbx_xsecgen" 
		    'string
		)) 
	    if(att then 
		(data = car(linereadstring((att->data)))) else 
		(ini_file = car(TBX_UTIL_Search_Config("xsecgen.ini" nil nil ?includeWorkDir t)))
		when(ini_file 
		    printf("Reading defaults from %L\n" ini_file) 
		    (data = TBX_UTIL_File_Lineread(ini_file))
		)
	    )
	) 
	(user_units = car((axlDBGetDesignUnits)))
	if(data then 
	    foreach(entry data 
		when((car(entry) == 'units) 
		    (user_units = cadr(entry))
		)
	    ) 
	    (user_settings = copy((tbx_xsecgen_global->defaults))) 
	    foreach(entry data 
		(token = car(entry)) 
		(value = cadr(entry)) 
		cond((member(token check_fields) 
			if(((type(value) == 'string) && (upperCase(value) == "ON")) then 
			    (value = t) else 
			    (value = nil)
			)
		    ) 
		    (member(token mks_fields) 
			when(((type(value) == 'flonum) || (type(value) == 'fixnum)) 
			    (value = (axlMKSConvert value user_units 
				    car((axlDBGetDesignUnits))
				))
			)
		    )
		)
		putprop(user_settings value token)
	    )
	    else 
	    (user_settings = (tbx_xsecgen_global->defaults))
	) user_settings
    )
)
procedure(TBX_XSECGEN_Run() 
    let((sym_name sym_inst sym_list sym_list_tbx sym_list_legacy
	    sym_location total_width total_height result msg_str
	) 
	(sym_name = "tbx_xsecgen") 
	(sym_list_tbx = (axlSelectByName "SYMTYPE" sym_name)) 
	(sym_list_legacy = (axlSelectByName "SYMTYPE" "flw_xsecgen")) 
	(sym_list = nconc(sym_list_tbx sym_list_legacy))
	when(sym_list 
	    when((length(sym_list) > 1) 
		printf("Warning: More than 1 instances of %L found. Will take the first one as reference for symbol location\n" sym_name)
	    ) 
	    (sym_location = (car(sym_list)->xy))
	) 
	(result = TBX_XSECGEN_Get_Total_Extents()) 
	(total_width = car(result)) 
	(total_height = cadr(result)) 
	unless(sym_location 
	    TBX_XSECGEN_Build_Dynamics(total_width total_height) 
	    if((boundp('tbx_postproc_data) && ((eval('tbx_postproc_data)->batchControl)->xsecgenSymLocation)) then 
		(sym_location = ((eval('tbx_postproc_data)->batchControl)->xsecgenSymLocation)) else 
		(sym_location = (axlEnterPoint ?prompts "Pick Cross Section Detail Location" ?gridSnap t))
	    )
	)
	(axlClearSelSet) 
	if(sym_location then 
	    if(TBX_XSECGEN_Fit_to_Canvas(sym_location total_width total_height) then 
		when(sym_list 
		    (axlDeleteObject sym_list) 
		    (axlDBRefreshId nil)
		) 
		(axlDBCreateSymDefSkeleton 
		    list(sym_name "format") 
		    list(list(0 
			    (axlMKSConvert -100 "MILS")
			) 
			list((axlMKSConvert 100 "MILS") 0)
		    )
		) 
		(sym_inst = car((axlDBCreateSymbolSkeleton 
			    list(sym_name "format") sym_location nil 0.0
			    nil
			)
		    ))
		TBX_XSECGEN_Draw_Geometry(sym_location sym_inst) 
		TBX_XSECGEN_Add_Labels(sym_location sym_inst) else 
		(msg_str = "Warning: Symbol graphics do not fit into canvas area.\nReposition symbol or change parameters") 
		(axlUIConfirm msg_str)
	    ) else 
	    printf("Warning: Cannot create symbol instance due to missing xy coordinate\n")
	) t
    )
)
procedure(TBX_XSECGEN_Save_Config(output_file) 
    let((formid checkbox config_data data_str port) 
	(formid = (tbx_xsecgen_global->formid)) 
	(checkbox = makeTable("checkbox_table" nil)) 
	foreach(chk 
	    list("include_layer_name" "include_material_name" "include_thickness" "include_via_stack" "include_via_label"
		"show_inner_pads" "scale_layers"
	    ) 
	    if((axlFormGetField formid chk) then 
		(checkbox[chk] = "on") else 
		(checkbox[chk] = "off")
	    )
	) 
	(config_data = list(list('units 
		    car((axlDBGetDesignUnits))
		) 
		list('includeLayerName 
		    checkbox["include_layer_name"]
		) 
		list('includeMaterialName 
		    checkbox["include_material_name"]
		) 
		list('includeThickness 
		    checkbox["include_thickness"]
		) 
		list('includeViaStack 
		    checkbox["include_via_stack"]
		)
		list('showInnerPads 
		    checkbox["show_inner_pads"]
		) 
		list('includeViaLabel 
		    checkbox["include_via_label"]
		) 
		list('xsectionBaseWidth 
		    (axlFormGetField formid "xsection_base_width")
		) 
		list('extraRowSpacing 
		    (axlFormGetField formid "extra_row_spacing")
		) 
		list('extraColumnSpacing 
		    (axlFormGetField formid "extra_column_spacing")
		)
		list('labelTextBlock 
		    (axlFormGetField formid "label_text_block")
		) 
		list('scaleLayers 
		    checkbox["scale_layers"]
		) 
		list('layerScaleType 
		    (axlFormGetField formid "layer_scale_type")
		) 
		list('minLayerHeight 
		    (axlFormGetField formid "min_layer_height")
		) 
		list('conductorHeight 
		    (axlFormGetField formid "conductor_height")
		)
		list('conductorStyle 
		    (axlFormGetField formid "conductor_style")
		) 
		list('conductorHatchWidth 
		    (axlFormGetField formid "conductor_hatch_width")
		) 
		list('conductorHatchSpacing 
		    (axlFormGetField formid "conductor_hatch_spacing")
		) 
		list('dielectricHeight 
		    (axlFormGetField formid "dielectric_height")
		) 
		list('dielectricStyle 
		    (axlFormGetField formid "dielectric_style")
		)
		list('dielectricHatchWidth 
		    (axlFormGetField formid "dielectric_hatch_width")
		) 
		list('dielectricHatchSpacing 
		    (axlFormGetField formid "dielectric_hatch_spacing")
		)
	    ))
	if(output_file then 
	    (port = outfile(output_file)) 
	    fprintf(port "(\n") 
	    foreach(entry config_data 
		fprintf(port "   %L\n" entry)
	    )
	    fprintf(port ")\n") 
	    close(port) else 
	    (axlDeleteAttachment "tbx_xsecgen") 
	    (data_str = sprintf(nil "%L" config_data))
	    (axlCreateAttachment "tbx_xsecgen" nil 1 
		'string
		data_str
	    )
	) t
    )
)
procedure(TBX_XSECGEN_Sort_Via_Stacks(via_list) 
    let((tmp_list via_name via_start_nr via_end_nr data
	    span span_sorted master_list start_lyr_sorted via_list_new
	) 
	(data = makeTable("tmp_data_table" nil)) 
	foreach(entry via_list 
	    (via_name = car(entry)) 
	    (via_start_nr = cadr(entry)) 
	    (via_end_nr = caddr(entry))
	    (span = (via_end_nr - via_start_nr)) 
	    (data[span] = cons(list(via_start_nr via_name via_end_nr) 
		    data[span]
		))
	) 
	foreach(key data 
	    (tmp_list = cons(key 
		    data[key]
		)) 
	    (master_list = cons(tmp_list master_list))
	) 
	(span_sorted = sortcar(master_list 
		'lessp
	    ))
	(via_list_new = list()) 
	foreach(entry1 span_sorted 
	    (start_lyr_sorted = sortcar(cdr(entry1) 
		    'lessp
		)) 
	    foreach(entry2 start_lyr_sorted 
		(via_list_new = cons(list(cadr(entry2) 
			    car(entry2) 
			    caddr(entry2)
			) via_list_new
		    ))
	    )
	) 
	(via_list_new = reverse(via_list_new)) via_list_new
    )
)
procedure(TBX_XSECGEN_Update_Form(user_settings) 
    let((form_handle) 
	(form_handle = (tbx_xsecgen_global->formid)) 
	(axlFormSetField form_handle "include_layer_name" 
	    get(user_settings 
		'includeLayerName
	    )
	) 
	(axlFormSetField form_handle "include_material_name" 
	    get(user_settings 
		'includeMaterialName
	    )
	) 
	(axlFormSetField form_handle "include_thickness" 
	    get(user_settings 
		'includeThickness
	    )
	)
	(axlFormSetField form_handle "include_via_stack" 
	    get(user_settings 
		'includeViaStack
	    )
	) 
	(axlFormSetField form_handle "show_inner_pads" 
	    get(user_settings 
		'showInnerPads
	    )
	) 
	(axlFormSetField form_handle "include_via_label" 
	    get(user_settings 
		'includeViaLabel
	    )
	) 
	(axlFormSetField form_handle "xsection_base_width" 
	    get(user_settings 
		'xsectionBaseWidth
	    )
	) 
	(axlFormSetField form_handle "extra_row_spacing" 
	    get(user_settings 
		'extraRowSpacing
	    )
	)
	(axlFormSetField form_handle "extra_column_spacing" 
	    get(user_settings 
		'extraColumnSpacing
	    )
	) 
	(axlFormSetField form_handle "label_text_block" 
	    get(user_settings 
		'labelTextBlock
	    )
	) 
	(axlFormSetField form_handle "scale_layers" 
	    get(user_settings 
		'scaleLayers
	    )
	) 
	(axlFormSetField form_handle "layer_scale_type" 
	    get(user_settings 
		'layerScaleType
	    )
	) 
	(axlFormSetField form_handle "min_layer_height" 
	    get(user_settings 
		'minLayerHeight
	    )
	)
	(axlFormSetField form_handle "conductor_height" 
	    get(user_settings 
		'conductorHeight
	    )
	) 
	(axlFormSetField form_handle "conductor_style" 
	    get(user_settings 
		'conductorStyle
	    )
	) 
	(axlFormSetField form_handle "conductor_hatch_width" 
	    get(user_settings 
		'conductorHatchWidth
	    )
	) 
	(axlFormSetField form_handle "conductor_hatch_spacing" 
	    get(user_settings 
		'conductorHatchSpacing
	    )
	) 
	(axlFormSetField form_handle "dielectric_height" 
	    get(user_settings 
		'dielectricHeight
	    )
	)
	(axlFormSetField form_handle "dielectric_style" 
	    get(user_settings 
		'dielectricStyle
	    )
	) 
	(axlFormSetField form_handle "dielectric_hatch_width" 
	    get(user_settings 
		'dielectricHatchWidth
	    )
	) 
	(axlFormSetField form_handle "dielectric_hatch_spacing" 
	    get(user_settings 
		'dielectricHatchSpacing
	    )
	) 
	if(((axlFormGetField form_handle "dielectric_style") == "hatch_diag") then 
	    (axlFormSetFieldEditable form_handle "dielectric_hatch_width" t) 
	    (axlFormSetFieldEditable form_handle "dielectric_hatch_spacing" t) else
	    (axlFormSetFieldEditable form_handle "dielectric_hatch_width" nil) 
	    (axlFormSetFieldEditable form_handle "dielectric_hatch_spacing" nil)
	) 
	if(((axlFormGetField form_handle "conductor_style") == "hatch_both") then 
	    (axlFormSetFieldEditable form_handle "conductor_hatch_width" t) 
	    (axlFormSetFieldEditable form_handle "conductor_hatch_spacing" t) else
	    (axlFormSetFieldEditable form_handle "conductor_hatch_width" nil) 
	    (axlFormSetFieldEditable form_handle "conductor_hatch_spacing" nil)
	)
	if((axlFormGetField form_handle "scale_layers") then 
	    (axlFormSetFieldEditable form_handle "conductor_height" nil) 
	    (axlFormSetFieldEditable form_handle "dielectric_height" nil) 
	    (axlFormSetFieldEditable form_handle "layer_scale_type" t)
	    (axlFormSetFieldEditable form_handle "min_layer_height" t) else 
	    (axlFormSetFieldEditable form_handle "conductor_height" t) 
	    (axlFormSetFieldEditable form_handle "dielectric_height" t) 
	    (axlFormSetFieldEditable form_handle "layer_scale_type" nil)
	    (axlFormSetFieldEditable form_handle "min_layer_height" nil)
	) 
	if((axlFormGetField form_handle "include_via_stack") then 
	    (axlFormSetFieldEditable form_handle "show_inner_pads" t) 
	    (axlFormSetFieldEditable form_handle "include_via_label" t) else
	    (axlFormSetFieldEditable form_handle "show_inner_pads" nil) 
	    (axlFormSetFieldEditable form_handle "include_via_label" nil)
	) t
    )
)
procedure(TBX_ZDRC_Build_Class_Filter(class_members) 
    let((class_filter) 
	(class_filter = list()) 
	foreach(key class_members 
	    (class_filter = cons(key class_filter))
	) 
	if(class_filter then 
	    (class_filter = sort(class_filter nil)) 
	    (class_filter = cons("ALL CLASS" class_filter)) 
	    (class_filter = cons("ALL NETS" class_filter))
	    else 
	    (class_filter = cons("ALL NETS" class_filter))
	) class_filter
    )
)
procedure(TBX_ZDRC_Build_Filter_Popups() 
    let((popup_list layer_pair drc_type pair_key) 
	if((tbx_zdrc_global->externalDRC) then 
	    (layer_pair = makeTable("layer_pair_table" nil)) 
	    (drc_type = makeTable("drc_type_table" nil)) 
	    foreach(drc 
		(tbx_zdrc_global->externalDRC) 
		(pair_key = strcat(car((drc->layerPair)) " <> " 
			cadr((drc->layerPair))
		    )) 
		(layer_pair[pair_key] = t) 
		(drc_type[(drc->type)] = t)
	    )
	    (popup_list = list()) 
	    foreach(key layer_pair 
		(popup_list = cons(key popup_list))
	    ) 
	    (popup_list = sort(popup_list nil)) 
	    (popup_list = cons("ALL" popup_list)) 
	    (axlFormBuildPopup 
		(tbx_zdrc_global->formid) "zdrc_layer_pair" popup_list
	    )
	    (axlFormSetField 
		(tbx_zdrc_global->formid) "zdrc_layer_pair" 
		car(popup_list)
	    ) 
	    (popup_list = list()) 
	    foreach(key drc_type 
		(popup_list = cons(key popup_list))
	    ) 
	    (popup_list = sort(popup_list nil)) 
	    (popup_list = cons("ALL" popup_list))
	    (axlFormBuildPopup 
		(tbx_zdrc_global->formid) "zdrc_type" popup_list
	    ) 
	    (axlFormSetField 
		(tbx_zdrc_global->formid) "zdrc_type" 
		car(popup_list)
	    ) else 
	    (popup_list = list()) 
	    (popup_list = cons("ALL" popup_list))
	    (axlFormBuildPopup 
		(tbx_zdrc_global->formid) "zdrc_layer_pair" popup_list
	    ) 
	    (axlFormSetField 
		(tbx_zdrc_global->formid) "zdrc_layer_pair" 
		car(popup_list)
	    ) 
	    (axlFormBuildPopup 
		(tbx_zdrc_global->formid) "zdrc_type" popup_list
	    ) 
	    (axlFormSetField 
		(tbx_zdrc_global->formid) "zdrc_type" 
		car(popup_list)
	    )
	)
    )
)
procedure(TBX_ZDRC_Clear_DRC_Layers() 
    let((org_visibility class_name) 
	(org_visibility = (axlVisibleGet)) 
	(axlVisibleDesign nil) 
	foreach(layer 
	    ((axlGetParam "paramLayerGroup:BOARD GEOMETRY")->groupMembers) 
	    when((upperCase(car(parseString(layer "_"))) == "ZDRC") 
		(class_name = sprintf(nil "BOARD GEOMETRY/%s" layer)) 
		(axlVisibleLayer class_name t) 
		(axlSetFindFilter ?enabled 
		    list("noall" "shapes") ?onButtons 
		    list("all")
		) 
		(axlClearSelSet)
		(axlAddSelectAll) 
		(axlDeleteObject 
		    (axlGetSelSet)
		) 
		(axlVisibleLayer class_name nil)
	    )
	) 
	(axlVisibleSet org_visibility)
    )
)
procedure(TBX_ZDRC_Create_Debug_Layer() 
    let((debug_layer) 
	foreach(lyr 
	    (axlSubclassRoute) 
	    (debug_layer = sprintf(nil "BOARD GEOMETRY/ZDRC_%s" 
		    upperCase(lyr)
		)) 
	    unless((axlIsLayer debug_layer) 
		printf("Creating layer %L\n" debug_layer) 
		(axlLayerCreateNonConductor debug_layer)
	    )
	)
    )
)
procedure(TBX_ZDRC_Create_External_DRC(drc_poly obj1 obj2 layer1 layer2
	drc_val act_val
    ) 
    let((id_str zdrc_string box_ll box_ur box_width
	    box_height box_center marker_xy marker_type
	) 
	(id_str = lowerCase(strcat((obj1->objType) "|" 
		    (obj2->objType)
		)
	    )) 
	(marker_type = (tbx_zdrc_global->markerType)[id_str]) 
	unless(marker_type 
	    (marker_type = "NA-NA")
	) 
	(box_ll = car((drc_poly->bBox)))
	(box_ur = cadr((drc_poly->bBox))) 
	(box_width = (car(box_ur) - car(box_ll))) 
	(box_height = (cadr(box_ur) - cadr(box_ll))) 
	(box_center = ((car(box_ll) + (box_width / 2.0)):(cadr(box_ll) + (box_height / 2.0)))) 
	if((axlGeoPointInShape box_center drc_poly) then 
	    (marker_xy = box_center) else 
	    (marker_xy = caar((drc_poly->vertices)))
	)
	(zdrc_string = list("ZDRC" 
		sprintf(nil "%s | %s | %s | %s | %s | %f" 
		    ((obj1->net)->name) 
		    ((obj2->net)->name) layer1
		    layer2 marker_type drc_val
		)
	    )) 
	(axlDBCreateExternalDRC zdrc_string marker_xy "DRC ERROR CLASS/ALL" 
	    list(obj2 obj1)
	    nil act_val
	) t
    )
)
procedure(TBX_ZDRC_Delete_All_DRC() 
    let((drc_list) 
	(axlSetFindFilter ?enabled 
	    list("noall" "invisible" "drcs") ?onButtons 
	    list("all")
	) 
	(axlVisibleLayer "DRC ERROR CLASS" t) 
	(axlClearSelSet) 
	(axlAddSelectAll)
	(drc_list = setof(x 
		(axlGetSelSet) 
		(((x->name) == "Externally Determined Violation") && (upperCase((x->source)) == "ZDRC"))
	    )) 
	(axlClearSelSet) 
	when(drc_list 
	    (axlDeleteObject drc_list)
	) 
	(axlFormListDeleteAll 
	    (tbx_zdrc_global->formid) "spacing_drc_list"
	)
    )
)
procedure(TBX_ZDRC_Detect_Z_Layer_Objects(obj1 layer2 offset net_list2) 
    let((polyList2 path2_list sel_set poly_list2 bBox
	    class_name_1 class_name_2 max_val ll_x ll_y
	    ur_x ur_y
	) 
	(bBox = (obj1->bBox)) 
	(ll_x = (caar(bBox) - offset)) 
	(ll_y = (cadar(bBox) - offset)) 
	(ur_x = (caadr(bBox) + offset))
	(ur_y = (cadadr(bBox) + offset)) 
	(bBox = list((ll_x:ll_y) 
		(ur_x:ur_y)
	    )) 
	(axlVisibleDesign nil) 
	(axlVisibleLayer 
	    sprintf(nil "ETCH/%s" layer2) t
	) 
	(axlVisibleLayer 
	    sprintf(nil "PIN/%s" layer2) t
	)
	(axlVisibleLayer 
	    sprintf(nil "VIA CLASS/%s" layer2) t
	) 
	(axlSetFindFilter ?enabled 
	    list("noall" "pins" "vias" "clines" "shapes") ?onButtons 
	    list("all")
	) 
	(path2_list = list()) 
	(sel_set = (axlSingleSelectBox bBox)) 
	when(sel_set 
	    (path2_list = (axlGetSelSet))
	)
	(axlClearSelSet) 
	(poly_list2 = list()) 
	foreach(cls 
	    (tbx_zdrc_global->classMembers) 
	    when(member(((obj1->net)->name) 
		    (tbx_zdrc_global->classMembers)[cls]
		) 
		(class_name_1 = cls)
	    )
	) 
	foreach(path2 path2_list 
	    when((((obj1->net)->name) != ((path2->net)->name)) 
		when(((((path2->net)->name) != "") && member(((path2->net)->name) net_list2)) 
		    if(((path2->objType) == "path") then 
			(polyList2 = (axlPolyFromDB path2 ?layer 
				sprintf(nil "ETCH/%s" layer2) ?endCapType
				'ROUND
			    )) else 
			(polyList2 = (axlPolyFromDB path2 ?layer 
				sprintf(nil "ETCH/%s" layer2) ?padType
				'REGULAR
			    ))
		    ) 
		    when(polyList2 
			foreach(cls 
			    (tbx_zdrc_global->classMembers) 
			    when(member(((path2->net)->name) 
				    (tbx_zdrc_global->classMembers)[cls]
				) 
				(class_name_2 = cls)
			    )
			) 
			if((axlFormGetField 
				(tbx_zdrc_global->formid) "system_defined"
			    ) then 
			    (max_val = TBX_ZDRC_Matrix_Value_Max(class_name_1 class_name_2)) else 
			    (max_val = offset)
			) 
			(poly_list2 = cons(list(polyList2 path2 max_val) poly_list2)) poly_list2
		    )
		)
	    )
	) poly_list2
    )
)
procedure(TBX_ZDRC_Display_DRC_Layer(value) 
    let((Available_Layers layer_str value_str) 
	(Available_Layers = ((axlGetParam "paramLayerGroup:BOARD GEOMETRY")->groupMembers)) 
	foreach(layer Available_Layers 
	    (layer_str = parseString(layer "_")) 
	    (layer_str = car(layer_str)) 
	    when((layer_str == "ZDRC") 
		(axlVisibleLayer 
		    sprintf(nil "BOARD GEOMETRY/%s" layer) nil
		)
	    )
	) 
	(value_str = parseString(value "|")) 
	(value_str = nth(6 value_str))
	(value_str = parseString(value_str "-")) 
	(value_str = cadr(value_str)) 
	(axlVisibleLayer 
	    sprintf(nil "BOARD GEOMETRY/ZDRC_%s" value_str) t
	)
    )
)
procedure(TBX_ZDRC_Extract_Tech() 
    let((tech_file port data) 
	(tech_file = "./class_tech.tcf") 
	when(isFile(tech_file) 
	    deleteFile(tech_file)
	) 
	(axlRunBatchDBProgram "techfile" 
	    sprintf(nil "techfile -$ -w %%s %s" tech_file)
	) 
	(port = (axlDMOpenFile "ALLEGRO_TECHNOLOGY_FILE" tech_file "r"))
	t 
	(axlDMClose port) 
	when(isFile(tech_file) 
	    deleteFile(tech_file)
	) data
    )
)
procedure(TBX_ZDRC_Filter_Objects(filter_string class_members) 
    let((object_list) 
	(object_list = tconc(nil nil)) 
	case(upperCase(filter_string) 
	    ("ALL NETS" 
		foreach(key class_members 
		    lconc(object_list 
			copy(class_members[key])
		    )
		)
	    ) 
	    ("ALL CLASS" 
		foreach(key class_members 
		    tconc(object_list key)
		)
	    ) 
	    (t 
		lconc(object_list 
		    copy(class_members[filter_string])
		)
	    )
	) 
	(object_list = cdar(object_list)) 
	(object_list = sort(object_list nil))
	object_list
    )
)
procedure(TBX_ZDRC_Filter_Spacing_DRC(drc_list drc_layer_pair drc_type drc_net) 
    let((indx drc_string filtered_drc_list pair_key) 
	(filtered_drc_list = list()) 
	(indx = 1) 
	rexMagic(nil) 
	rexCompile("*")
	rexMagic(t) 
	(drc_net = rexReplace(drc_net ".*" 0)) 
	foreach(drc drc_list 
	    (pair_key = strcat(car((drc->layerPair)) " <> " 
		    cadr((drc->layerPair))
		)) 
	    when((((drc_layer_pair == "ALL") || (drc_layer_pair == pair_key)) && ((drc_type == "ALL") || (drc_type == (drc->type))) && rexMatchList(drc_net 
			(drc->nets)
		    )) 
		(drc_string = sprintf(nil "%d | %L | %s <> %s | %s <> %s | %s | req: %s" indx 
			(drc->xy) 
			car((drc->nets))
			cadr((drc->nets)) 
			car((drc->layerPair)) 
			cadr((drc->layerPair)) 
			(drc->type) 
			(drc->required)
		    )) 
		(filtered_drc_list = cons(drc_string filtered_drc_list)) 
		indx++
	    )
	) 
	(filtered_drc_list = reverse(filtered_drc_list))
    )
)
procedure(TBX_ZDRC_Form_Action(form_handle) 
    let((zdrc_layer_pair zdrc_type zdrc_net net_list1 net_list2
	    object_filter1 object_filter2 object_list1 object_list2 calc_mode
	    zdrc_string layer1 layer2 layer_string net_string
	    arr drc_xy
	) 
	case((form_handle->curField) 
	    ("user_defined" 
		(axlFormSetFieldEditable form_handle "user_defined_value" t)
	    ) 
	    ("user_defined_value" t) 
	    ("system_defined" 
		(axlFormSetField form_handle "user_defined_value" 
		    (tbx_zdrc_global->maxValue)
		) 
		(axlFormSetFieldEditable form_handle "user_defined_value" nil)
	    ) 
	    ("inc_cu_all" 
		(axlFormSetField form_handle "calc_info" 
		    (tbx_zdrc_global->calcInfo)["inc_cu_all"]
		)
	    )
	    ("exc_cu_all" 
		(axlFormSetField form_handle "calc_info" 
		    (tbx_zdrc_global->calcInfo)["exc_cu_all"]
		)
	    ) 
	    ("exc_cu_start_end" 
		(axlFormSetField form_handle "calc_info" 
		    (tbx_zdrc_global->calcInfo)["exc_cu_start_end"]
		)
	    ) 
	    ("from_start_layer" 
		(axlFormSetField form_handle "from_end_layer" 
		    ((form_handle->curValueInt) + 1)
		)
	    ) 
	    ("clear_all" 
		TBX_ZDRC_Delete_All_DRC() 
		(tbx_zdrc_global->externalDRC = nil) 
		TBX_ZDRC_Clear_DRC_Layers()
	    ) 
	    ("zdrc_layer_pair" 
		if((axlOKToProceed) then 
		    (axlFormListDeleteAll form_handle "spacing_drc_list") 
		    (zdrc_type = (axlFormGetField form_handle "zdrc_type")) 
		    (zdrc_layer_pair = (form_handle->curValue))
		    (zdrc_net = (axlFormGetField form_handle "zdrc_net")) 
		    (tbx_zdrc_global->filteredDRC = TBX_ZDRC_Filter_Spacing_DRC((tbx_zdrc_global->externalDRC) zdrc_layer_pair zdrc_type zdrc_net)) 
		    (axlFormListDeleteAll form_handle "spacing_drc_list") 
		    (axlFormSetField form_handle "spacing_drc_list" 
			(tbx_zdrc_global->filteredDRC)
		    ) else
		    printf("Warning: Finish current command first!")
		)
	    )
	    ("zdrc_type" 
		if((axlOKToProceed) then 
		    (axlFormListDeleteAll form_handle "spacing_drc_list") 
		    (zdrc_type = (form_handle->curValue)) 
		    (zdrc_layer_pair = (axlFormGetField form_handle "zdrc_layer_pair"))
		    (zdrc_net = (axlFormGetField form_handle "zdrc_net")) 
		    (tbx_zdrc_global->filteredDRC = TBX_ZDRC_Filter_Spacing_DRC((tbx_zdrc_global->externalDRC) zdrc_layer_pair zdrc_type zdrc_net)) 
		    (axlFormListDeleteAll form_handle "spacing_drc_list") 
		    (axlFormSetField form_handle "spacing_drc_list" 
			(tbx_zdrc_global->filteredDRC)
		    ) else
		    printf("Warning: Finish current command first!")
		)
	    ) 
	    ("zdrc_net" 
		if((axlOKToProceed) then 
		    (axlFormListDeleteAll form_handle "spacing_drc_list") 
		    (zdrc_type = (axlFormGetField form_handle "zdrc_type")) 
		    (zdrc_layer_pair = (axlFormGetField form_handle "zdrc_layer_pair"))
		    (zdrc_net = (form_handle->curValue)) 
		    (tbx_zdrc_global->filteredDRC = TBX_ZDRC_Filter_Spacing_DRC((tbx_zdrc_global->externalDRC) zdrc_layer_pair zdrc_type zdrc_net)) 
		    (axlFormListDeleteAll form_handle "spacing_drc_list") 
		    (axlFormSetField form_handle "spacing_drc_list" 
			(tbx_zdrc_global->filteredDRC)
		    ) else
		    printf("Warning: Finish current command first!")
		)
	    ) 
	    ("zdrc_run" 
		if((axlOKToProceed) then 
		    (object_filter1 = (axlFormGetField form_handle "class_popup1")) 
		    (object_filter2 = (axlFormGetField form_handle "class_popup2")) 
		    (object_list1 = (axlFormListGetSelItems form_handle "net_class_list1"))
		    (object_list2 = (axlFormListGetSelItems form_handle "net_class_list2")) 
		    if((object_list1 && object_list2) then 
			when(((axlFormGetField form_handle "system_defined") && 
				((axlVersion 
					'version
				    ) < 16.5)) 
			    when(isFile((tbx_zdrc_global->techFile)) 
				deleteFile((tbx_zdrc_global->techFile))
			    ) 
			    (axlRunBatchDBProgram "techfile" 
				sprintf(nil "techfile -$ -w %%s %s" 
				    (tbx_zdrc_global->techFile)
				)
			    ) 
			    (tbx_zdrc_global->classClassCset = TBX_ZDRC_Get_Class_Class_Cset_Legacy())
			) 
			(net_list1 = TBX_ZDRC_Resolve_Net_Objects(object_filter1 object_list1 
				(tbx_zdrc_global->classMembers)
			    )) 
			(net_list2 = TBX_ZDRC_Resolve_Net_Objects(object_filter2 object_list2 
				(tbx_zdrc_global->classMembers)
			    ))
			(calc_mode = TBX_ZDRC_Get_Calc_Mode(form_handle)) 
			(tbx_zdrc_global->distInfo = TBX_ZDRC_Get_Layer_Distance(calc_mode)) 
			TBX_ZDRC_Run(net_list1 net_list2) 
			(tbx_zdrc_global->externalDRC = TBX_ZDRC_Get_Design_DRC()) 
			TBX_ZDRC_Build_Filter_Popups()
			(axlFormListDeleteAll form_handle "spacing_drc_list") 
			(zdrc_type = (axlFormGetField form_handle "zdrc_type")) 
			(zdrc_layer_pair = (axlFormGetField form_handle "zdrc_layer_pair")) 
			(zdrc_net = (axlFormGetField form_handle "zdrc_net")) 
			(tbx_zdrc_global->filteredDRC = TBX_ZDRC_Filter_Spacing_DRC((tbx_zdrc_global->externalDRC) zdrc_layer_pair zdrc_type zdrc_net))
			(axlFormListDeleteAll form_handle "spacing_drc_list") 
			(axlFormSetField form_handle "spacing_drc_list" 
			    (tbx_zdrc_global->filteredDRC)
			) else 
			printf("Warning: Please select at least one item from each list\n")
		    ) else 
		    printf("Warning: Finish current command first\n")
		)
	    ) 
	    ("spacing_drc_list" 
		if((axlOKToProceed) then 
		    (zdrc_string = (axlFormGetField form_handle "spacing_drc_list")) 
		    when(zdrc_string 
			rexCompile(" | ") 
			(zdrc_string = rexReplace(zdrc_string "|" 0)) 
			(arr = parseString(zdrc_string "|")) 
			(drc_xy = car(linereadstring(cadr(arr))))
			(net_string = caddr(arr)) 
			(layer_string = nth(3 arr)) 
			rexCompile(" <> ") 
			(net_string = rexReplace(net_string "!" 0)) 
			(layer_string = rexReplace(layer_string "!" 0))
			(arr = parseString(layer_string "!")) 
			(layer1 = car(arr)) 
			(layer2 = cadr(arr)) 
			when((axlFormGetField form_handle "drc_zoom") 
			    TBX_ZDRC_Zoom_To_Point(drc_xy 
				(tbx_zdrc_global->drcSize) 
				(axlFormGetField form_handle "drc_zoom_size")
			    )
			) 
			when((axlFormGetField form_handle "limit_layers") 
			    (axlVisibleDesign nil) 
			    (axlVisibleLayer 
				sprintf(nil "ETCH/%s" layer1) t
			    ) 
			    (axlVisibleLayer 
				sprintf(nil "PIN/%s" layer1) t
			    ) 
			    (axlVisibleLayer 
				sprintf(nil "VIA CLASS/%s" layer1) t
			    )
			    (axlVisibleLayer 
				sprintf(nil "ETCH/%s" layer2) t
			    ) 
			    (axlVisibleLayer 
				sprintf(nil "PIN/%s" layer2) t
			    ) 
			    (axlVisibleLayer 
				sprintf(nil "VIA CLASS/%s" layer2) t
			    ) 
			    (axlVisibleLayer "DRC ERROR CLASS/ALL" t) 
			    (axlVisibleLayer "BOARD GEOMETRY/OUTLINE" t)
			    (axlVisibleLayer "BOARD GEOMETRY/CONSTRAINT_AREA" t) 
			    (axlVisibleLayer "ROUTE KEEPIN" t) 
			    (axlVisibleLayer "ROUTE KEEPOUT" t)
			)
			foreach(lyr 
			    (axlSubclassRoute) 
			    (axlVisibleLayer 
				sprintf(nil "BOARD GEOMETRY/ZDRC_%s" lyr) nil
			    )
			) 
			when((axlFormGetField form_handle "show_overlap") 
			    (axlVisibleLayer 
				sprintf(nil "BOARD GEOMETRY/ZDRC_%s" layer2) t
			    ) 
			    (axlDBControl 
				'activeLayer 
				sprintf(nil "BOARD GEOMETRY/ZDRC_%s" layer2)
			    )
			) 
			(axlVisibleUpdate t)
		    ) else
		    (axlUIWPrint form_handle "E - Finish current command first!")
		)
	    ) 
	    ("class_popup1" 
		if((axlOKToProceed) then 
		    (axlFormListDeleteAll form_handle "net_class_list1") 
		    (object_list1 = TBX_ZDRC_Filter_Objects((axlFormGetField form_handle "class_popup1") 
			    (tbx_zdrc_global->classMembers)
			)) 
		    when(object_list1 
			(axlFormSetField form_handle "net_class_list1" object_list1)
		    )
		    else 
		    printf("Warning: Finish current command first\n")
		)
	    )
	    ("class_popup2" 
		if((axlOKToProceed) then 
		    (axlFormListDeleteAll form_handle "net_class_list2") 
		    (object_list2 = TBX_ZDRC_Filter_Objects((axlFormGetField form_handle "class_popup2") 
			    (tbx_zdrc_global->classMembers)
			)) 
		    when(object_list2 
			(axlFormSetField form_handle "net_class_list2" object_list2)
		    )
		    else 
		    printf("Warning: Finish current command first\n")
		)
	    ) 
	    ("net_class_list1" 
		if((axlOKToProceed) then t else 
		    printf("Warning: Finish current command first\n")
		)
	    ) 
	    ("net_class_list2" 
		if((axlOKToProceed) then t else 
		    printf("Warning: Finish current command first\n")
		)
	    ) 
	    ("limit_layers" t) 
	    ("thickness_report" 
		if((axlOKToProceed) then 
		    (calc_mode = TBX_ZDRC_Get_Calc_Mode(form_handle)) 
		    (tbx_zdrc_global->distInfo = TBX_ZDRC_Get_Layer_Distance(calc_mode)) 
		    TBX_ZDRC_Write_Layer_Distance_Report((tbx_zdrc_global->distInfo) calc_mode)
		    else 
		    printf("Warning: Finish current command first\n")
		)
	    )
	    ("drc_report" 
		if((axlOKToProceed) then 
		    TBX_ZDRC_Write_Error_Report() else 
		    printf("Warning: Finish current command first\n")
		)
	    ) 
	    ("close" 
		(axlVisibleSet 
		    (tbx_zdrc_global->orgVis)
		) 
		(axlVisibleUpdate t) 
		(axlFormClose form_handle) 
		(axlCancelEnterFun)
	    ) 
	    ("cancel" t) 
	    ("my_help" 
		(axlShell "tbx help zdrc")
	    ) 
	    (t t)
	) 
	when(((form_handle->doneState) == 3) 
	    (axlVisibleSet 
		(tbx_zdrc_global->orgVis)
	    ) 
	    (axlVisibleUpdate t)
	)
    )
)
procedure(TBX_ZDRC_Get_Calc_Mode(form_handle) 
    let((calc_mode) 
	cond(((axlFormGetField form_handle "inc_cu_all") 
		(calc_mode = "inc_cu_all")
	    ) 
	    ((axlFormGetField form_handle "exc_cu_all") 
		(calc_mode = "exc_cu_all")
	    ) 
	    ((axlFormGetField form_handle "exc_cu_start_end") 
		(calc_mode = "exc_cu_start_end")
	    )
	) calc_mode
    )
)
procedure(TBX_ZDRC_Get_Class_Class_Cset() 
    let((class_class_cset cset_name class1_name class2_name) 
	(class_class_cset = makeTable("class_class_cset" nil)) 
	foreach(entry 
	    (axlCnsClassTableFind 
		'classClass
	    ) 
	    when((((entry->objType) == "classTable") && (entry->spacing)) 
		(cset_name = (entry->spacing)) 
		(class1_name = ((entry->netclass1)->name)) 
		(class2_name = ((entry->netclass2)->name)) 
		(class_class_cset[strcat(class1_name "!" class2_name)] = cset_name)
		(class_class_cset[strcat(class2_name "!" class1_name)] = cset_name)
	    )
	) class_class_cset
    )
)
procedure(TBX_ZDRC_Get_Class_Class_Cset_Legacy() 
    let((arr cns_data tech_data class_class_cset cset_name
	    class1_name class2_name
	) 
	(class_class_cset = makeTable("class_class_cset" nil)) 
	(tech_data = TBX_READTECHXML_Load_File((tbx_zdrc_global->techFile))) 
	when(tech_data 
	    (cns_data = tech_data["CadenceAllegroConstraintManager"]["allegroTechnologyFile"]["constraints"]) 
	    foreach(key cns_data 
		when((rexMatchp("^classClass" key) && 
			cns_data[key]["spacingCSetRef"]) 
		    (cset_name = upperCase(cns_data[key]["spacingCSetRef"])) 
		    (arr = parseString(cns_data[key]["name"] ":")) 
		    (class1_name = upperCase(cadr(arr))) 
		    (class2_name = upperCase(nth(3 arr)))
		    (class_class_cset[strcat(class1_name "!" class2_name)] = cset_name) 
		    (class_class_cset[strcat(class2_name "!" class1_name)] = cset_name)
		)
	    )
	) class_class_cset
    )
)
procedure(TBX_ZDRC_Get_Class_Cset() 
    let((class_cset) 
	(class_cset = makeTable("class_cset_table" nil)) 
	foreach(ncl 
	    ((axlDBGetDesign)->netclass) 
	    when((ncl->spacing) 
		if(((ncl->prop)->SPACING_CONSTRAINT_SET) then 
		    (class_cset[(ncl->name)] = ((ncl->prop)->SPACING_CONSTRAINT_SET)) else 
		    (class_cset[(ncl->name)] = "DEFAULT")
		)
	    )
	) 
	(class_cset["NO_TYPE"] = "DEFAULT") class_cset
    )
)
procedure(TBX_ZDRC_Get_Class_Members() 
    let((class_members netclass) 
	(class_members = makeTable("class_members_table" nil)) 
	foreach(net 
	    ((axlDBGetDesign)->nets) 
	    (netclass = (axlNetClassGet net 
		    'spacing t
		)) 
	    if(netclass then 
		(class_members[(netclass->name)] = cons((net->name) 
			class_members[(netclass->name)]
		    )) else 
		(class_members["NO_TYPE"] = cons((net->name) 
			class_members["NO_TYPE"]
		    ))
	    )
	) 
	foreach(cls class_members 
	    (class_members[cls] = sort(class_members[cls] nil))
	) class_members
    )
)
procedure(TBX_ZDRC_Get_Cset_Max_Value() 
    let((cset_max csets max_val rule) 
	(cset_max = makeTable("cset_max_table" nil)) 
	(csets = (axlCnsList 
		'spacing
	    )) 
	foreach(cset csets 
	    (max_val = 0) 
	    foreach(subclass 
		(axlSubclassRoute) 
		(rule = (axlCNSGetSpacing cset subclass nil)) 
		foreach(object rule 
		    when((cadr(object) && (cadr(object) > max_val)) 
			(max_val = cadr(object))
		    )
		)
	    ) 
	    (cset_max[upperCase(cset)] = max_val)
	) cset_max
    )
)
procedure(TBX_ZDRC_Get_Design_DRC() 
    let((drc0 drc_size drc_string drc_list new_drc_list
	    zdrc arr
	) 
	(axlSetFindFilter ?enabled 
	    list("noall" "DRCS") ?onButtons 
	    list("all")
	) 
	(axlVisibleLayer "DRC ERROR CLASS" t) 
	(axlClearSelSet) 
	(drc_list = (axlGetSelSet 
		(axlAddSelectAll)
	    ))
	(new_drc_list = list()) 
	when(drc_list 
	    (drc0 = car(drc_list)) 
	    (drc_size = abs((car((upperRight 
				(drc0->bBox)
			    )
			) - car((lowerLeft 
				(drc0->bBox)
			    )
			))
		)) 
	    (tbx_zdrc_global->drcSize = drc_size)
	) 
	rexCompile(" | ") 
	foreach(drc drc_list 
	    when(((((drc->type) == "DESIGN") || ((drc->type) == "EXTERNAL REFERENCE")) && ((drc->source) == "ZDRC")) 
		(zdrc = ncons(nil)) 
		(zdrc->xy = (drc->xy)) 
		(zdrc->layerDist = (drc->actual)) 
		(drc_string = (drc->expected))
		(drc_string = rexReplace(drc_string "|" 0)) 
		(arr = parseString(drc_string "|")) 
		when((length(arr) >= 6) 
		    (zdrc->nets = list(car(arr) 
			    cadr(arr)
			)) 
		    (zdrc->layerPair = list(caddr(arr) 
			    nth(3 arr)
			)) 
		    (zdrc->type = nth(4 arr)) 
		    (zdrc->required = nth(5 arr))
		    (new_drc_list = cons(zdrc new_drc_list))
		)
	    )
	) 
	(new_drc_list = reverse(new_drc_list))
	new_drc_list
    )
)
procedure(TBX_ZDRC_Get_Layer_Distance(calc_mode) 
    let((dist cnt layer_cnt layer_names z_thickness
	    first_layer second_layer layer_name layer_type layer_thickness
	    match
	) 
	(dist = makeTable("dist_table" nil)) 
	(cnt = 1) 
	(layer_names = (axlSubclassRoute)) 
	(layer_cnt = length(layer_names))
	foreach(lyr layer_names 
	    (dist[lyr] = makeTable(sprintf(nil "hash_%02d" cnt) nil)) 
	    ++cnt
	) 
	for(n 0 
	    (layer_cnt - 2) 
	    (first_layer = upperCase(nth(n layer_names))) 
	    for(p 
		(n + 1) 
		(layer_cnt - 1) 
		(second_layer = upperCase(nth(p layer_names))) 
		(z_thickness = 0.0)
		foreach(entry 
		    (axlGetXSection) 
		    (layer_name = upperCase(car(entry))) 
		    (layer_type = upperCase(cadr(entry))) 
		    (layer_thickness = (axlMKSConvert 
			    nth(3 entry) 
			    car((axlDBGetDesignUnits))
			))
		    cond((((layer_name == first_layer) && ((layer_type == "CONDUCTOR") || (layer_type == "PLANE"))) 
			    (match = t) 
			    when((calc_mode == "inc_cu_all") 
				(z_thickness = (z_thickness + layer_thickness))
			    )
			) 
			(((layer_name == second_layer) && ((layer_type == "CONDUCTOR") || (layer_type == "PLANE"))) 
			    (match = nil) 
			    when((calc_mode == "inc_cu_all") 
				(z_thickness = (z_thickness + layer_thickness))
			    )
			) 
			(match 
			    cond((((layer_type == "CONDUCTOR") || (layer_type == "PLANE")) 
				    when(((calc_mode == "inc_cu_all") || (calc_mode == "exc_cu_start_end")) 
					(z_thickness = (z_thickness + layer_thickness))
				    )
				) 
				((layer_type == "DIELECTRIC") 
				    (z_thickness = (z_thickness + layer_thickness))
				) 
				(t t)
			    )
			)
		    )
		) 
		(dist[first_layer][second_layer] = z_thickness) 
		(dist[second_layer][first_layer] = z_thickness)
	    )
	) dist
    )
)
procedure(TBX_ZDRC_Get_Layer_Span(side) 
    let((start end start_layer_id end_layer_id all_layers
	    layer_list tmp_list
	) 
	(all_layers = (axlSubclassRoute)) 
	(layer_list = list()) 
	case(side 
	    ("left" 
		(start = "from_start_layer") 
		(end = "from_end_layer")
	    ) 
	    ("right" 
		(start = "to_start_layer") 
		(end = "to_end_layer")
	    )
	) 
	(start_layer_id = atoi((axlFormGetField 
		    (tbx_zdrc_global->formid) start
		)
	    ))
	(end_layer_id = atoi((axlFormGetField 
		    (tbx_zdrc_global->formid) end
		)
	    )) 
	(tmp_list = list(start_layer_id end_layer_id)) 
	(tmp_list = sort(tmp_list 
		'lessp
	    )) 
	for(n 
	    car(tmp_list) 
	    cadr(tmp_list) 
	    (layer_list = cons(nth((n - 1) all_layers) layer_list))
	) 
	(layer_list = reverse(layer_list))
    )
)
procedure(TBX_ZDRC_Init() 
    let((calc_info tech_file marker_type) 
	(calc_info = makeTable("calc_info_table" nil)) 
	(calc_info["inc_cu_all"] = "All dielectric thicknesses within current ZDRC layer pair plus all Cu thicknesses involved") 
	(calc_info["exc_cu_all"] = "All dielectric thicknesses within current ZDRC layer pair. Cu thicknesses will be ignored.") 
	(calc_info["exc_cu_start_end"] = "All dielectric thicknesses within current ZDRC layer pair plus Cu thicknesses from layers **between** the current ZDRC layer pair")
	(tech_file = strcat(getWorkingDir() "/tbx_zdrc_tech.tcf")) 
	(marker_type = makeTable("marker_type_table" nil)) 
	(marker_type["path|path"] = "L-L") 
	(marker_type["path|via"] = "L-V") 
	(marker_type["via|path"] = "L-V")
	(marker_type["path|pin"] = "L-P") 
	(marker_type["pin|path"] = "L-P") 
	(marker_type["path|shape"] = "L-S") 
	(marker_type["shape|path"] = "L-S") 
	(marker_type["via|pin"] = "V-P")
	(marker_type["pin|via"] = "V-P") 
	(marker_type["via|shape"] = "V-S") 
	(marker_type["shape|via"] = "V-S") 
	(marker_type["pin|shape"] = "P-S") 
	(marker_type["shape|pin"] = "P-S")
	(marker_type["shape|shape"] = "S-S") 
	unless(boundp('tbx_zdrc_global) 
	    iliDefstruct('defstruct(tbx_zdrc_global_struct formid orgVis classMembers classCset
			classClassCset distInfo drcSize csetMax techFile
			externalDRC filteredDRC maxValue markerType calcInfo
			licCheck
		    )
	    ) 
	    defvar(tbx_zdrc_global nil)
	) 
	if(!tbx_zdrc_global then 
	    (tbx_zdrc_global = (make_tbx_zdrc_global_struct ?formid nil ?orgVis nil
		    ?classMembers nil ?classCset nil ?classClassCset
		    nil ?distInfo nil ?drcSize nil
		    ?techFile tech_file ?csetMax nil ?externalDRC
		    nil ?filteredDRC nil ?maxValue nil
		    ?markerType marker_type ?calcInfo calc_info ?licCheck
		    nil
		)) else 
	    (tbx_zdrc_global->formid = nil)
	    (tbx_zdrc_global->orgVis = nil) 
	    (tbx_zdrc_global->classMembers = nil) 
	    (tbx_zdrc_global->classCset = nil) 
	    (tbx_zdrc_global->classClassCset = nil) 
	    (tbx_zdrc_global->distInfo = nil)
	    (tbx_zdrc_global->drcSize = nil) 
	    (tbx_zdrc_global->techFile = tech_file) 
	    (tbx_zdrc_global->csetMax = nil) 
	    (tbx_zdrc_global->externalDRC = nil) 
	    (tbx_zdrc_global->filteredDRC = nil)
	    (tbx_zdrc_global->maxValue = nil) 
	    (tbx_zdrc_global->markerType = marker_type) 
	    (tbx_zdrc_global->calcInfo = calc_info) 
	    (tbx_zdrc_global->licCheck = nil)
	)
    )
)
procedure(TBX_ZDRC_Layer_Popup_List() 
    let((cnt layer_list popup_list) 
	(layer_list = ((axlGetParam "paramLayerGroup:ETCH")->groupMembers)) 
	(cnt = 0) 
	(popup_list = list()) 
	foreach(lyr layer_list 
	    ++cnt 
	    (popup_list = cons(list(lyr cnt) popup_list))
	)
	(popup_list = reverse(popup_list)) popup_list
    )
)
procedure((TBX_ZDRC_Main \@optional arg) 
    let((max_val lic_check_result popup_list class_filter object_list
	    info_file port FC_FEATURE VERSION_STR FC_VERSION
	    SUB_VERSION FORM_FILE fid zdrc_layer_pair zdrc_type
	    zdrc_net ok_start_app
	) 
	(FC_FEATURE = "ZDRC") 
	(FC_VERSION = "17.3") 
	(SUB_VERSION = "01") 
	(VERSION_STR = sprintf(nil "ZDRC %s (C)2017" FC_VERSION))
	(ok_start_app = t) 
	cond(((arg && (lowerCase(arg) == "info")) 
		(info_file = "./zdrc_info.txt") 
		(port = outfile(info_file "w")) 
		fprintf(port "ZDRC information:\n") 
		fprintf(port "===============================\n")
		fprintf(port "Command line arguments:\n") 
		fprintf(port "  version  : Prints the current version of the module\n") 
		fprintf(port "\n") 
		close(port) 
		(axlUIViewFileCreate info_file "ZDRC: Quick Info" nil)
		when(isFile(info_file) 
		    deleteFile(info_file)
		) 
		(ok_start_app = nil)
	    ) 
	    ((arg && (lowerCase(arg) == "version")) 
		printf("Current version is: %s.%s\n" FC_VERSION SUB_VERSION) 
		(ok_start_app = nil)
	    )
	) 
	when(ok_start_app 
	    (lic_check_result = TBX_LIC_Validate(FC_FEATURE FC_VERSION t)) 
	    when(lic_check_result 
		(FORM_FILE = TBX_FORM_Get_Name(lic_check_result "zdrc_main")) 
		unless(boundp('tbxZdrcMainHandle) 
		    defvar(tbxZdrcMainHandle nil)
		) 
		(fid = (axlFormCreate 
			'tbxZdrcMainHandle FORM_FILE 
			'(e outer) 
			'TBX_ZDRC_Form_Action
			t
		    )) 
		when(fid 
		    TBX_ZDRC_Init() 
		    (tbx_zdrc_global->orgVis = (axlVisibleGet)) 
		    (tbx_zdrc_global->formid = fid) 
		    (tbx_zdrc_global->licCheck = lic_check_result)
		    (axlFormDisplay fid) 
		    TBX_FORM_Init_Header(fid "Licensed for " lic_check_result VERSION_STR) 
		    (tbx_zdrc_global->classMembers = TBX_ZDRC_Get_Class_Members()) 
		    (tbx_zdrc_global->classCset = TBX_ZDRC_Get_Class_Cset()) 
		    when(((axlVersion 
				'version
			    ) >= 16.5) 
			(tbx_zdrc_global->classClassCset = TBX_ZDRC_Get_Class_Class_Cset())
		    )
		    (class_filter = TBX_ZDRC_Build_Class_Filter((tbx_zdrc_global->classMembers))) 
		    (axlFormBuildPopup fid "class_popup1" class_filter) 
		    (axlFormBuildPopup fid "class_popup2" class_filter) 
		    (axlFormSetField fid "class_popup1" 
			car(class_filter)
		    ) 
		    (axlFormSetField fid "class_popup2" 
			car(class_filter)
		    )
		    (object_list = TBX_ZDRC_Filter_Objects(car(class_filter) 
			    (tbx_zdrc_global->classMembers)
			)) 
		    when(object_list 
			(axlFormSetField fid "net_class_list1" object_list) 
			(axlFormSetField fid "net_class_list2" object_list)
		    ) 
		    TBX_ZDRC_Create_Debug_Layer() 
		    (axlFormListDeleteAll 
			(tbx_zdrc_global->formid) "spacing_drc_list"
		    ) 
		    (tbx_zdrc_global->externalDRC = TBX_ZDRC_Get_Design_DRC())
		    TBX_ZDRC_Build_Filter_Popups() 
		    (axlFormSetField fid "zdrc_net" "*") 
		    (zdrc_layer_pair = (axlFormGetField fid "zdrc_layer_pair")) 
		    (zdrc_type = (axlFormGetField fid "zdrc_type")) 
		    (zdrc_net = (axlFormGetField fid "zdrc_net"))
		    (tbx_zdrc_global->filteredDRC = TBX_ZDRC_Filter_Spacing_DRC((tbx_zdrc_global->externalDRC) zdrc_layer_pair zdrc_type zdrc_net)) 
		    (axlFormSetField 
			(tbx_zdrc_global->formid) "spacing_drc_list" 
			(tbx_zdrc_global->filteredDRC)
		    ) 
		    (tbx_zdrc_global->csetMax = TBX_ZDRC_Get_Cset_Max_Value()) 
		    (max_val = 0) 
		    foreach(key 
			(tbx_zdrc_global->csetMax) 
			when(((tbx_zdrc_global->csetMax)[key] && ((tbx_zdrc_global->csetMax)[key] > max_val)) 
			    (max_val = (tbx_zdrc_global->csetMax)[key])
			)
		    )
		    (tbx_zdrc_global->maxValue = max_val) 
		    (axlFormSetField fid "user_defined" t) 
		    (axlFormSetField fid "user_defined_value" 
			(tbx_zdrc_global->maxValue)
		    ) 
		    (popup_list = TBX_ZDRC_Layer_Popup_List()) 
		    (axlFormBuildPopup fid "from_start_layer" popup_list)
		    (axlFormBuildPopup fid "from_end_layer" popup_list) 
		    (axlFormBuildPopup fid "to_start_layer" popup_list) 
		    (axlFormBuildPopup fid "to_end_layer" popup_list) 
		    (axlFormSetField fid "from_start_layer" 1) 
		    (axlFormSetField fid "from_end_layer" 
			length(popup_list)
		    )
		    (axlFormSetField fid "to_start_layer" 1) 
		    (axlFormSetField fid "to_end_layer" 
			length(popup_list)
		    ) 
		    (axlFormSetField fid "exc_cu_start_end" t) 
		    (axlFormSetField fid "calc_info" 
			(tbx_zdrc_global->calcInfo)["exc_cu_start_end"]
		    ) 
		    (axlFormSetField fid "drc_zoom" t)
		    (axlFormSetField fid "drc_zoom_size" 25) 
		    (axlFormSetField fid "limit_layers" t) 
		    (axlFormSetField fid "show_overlap" t) 
		    TBX_FORM_Delete(lic_check_result FORM_FILE)
		)
	    )
	)
    )
)
procedure(TBX_ZDRC_Matrix_Value_Max(class_name_1 class_name_2) 
    let((key_str valid_spacing cset1 cset2 cset_name) 
	(key_str = strcat(class_name_1 "!" class_name_2)) 
	if((tbx_zdrc_global->classClassCset)[key_str] then 
	    (cset_name = (tbx_zdrc_global->classClassCset)[key_str]) 
	    (valid_spacing = (tbx_zdrc_global->csetMax)[cset_name]) else
	    (cset1 = (tbx_zdrc_global->classCset)[class_name_1]) 
	    (cset2 = (tbx_zdrc_global->classCset)[class_name_2]) 
	    if(((tbx_zdrc_global->csetMax)[cset1] > (tbx_zdrc_global->csetMax)[cset2]) then 
		(valid_spacing = (tbx_zdrc_global->csetMax)[cset1]) else 
		(valid_spacing = (tbx_zdrc_global->csetMax)[cset2])
	    )
	) valid_spacing
    )
)
procedure(TBX_ZDRC_Process_Nets_By_Layer(net_list1 layer_list1 net_list2 layer_list2 geom_window) 
    let((path_list sel_set poly_list1 layer_name1 org_visibility
	    obj2 poly2 exp_poly1 result drc_res
	    layer_distance drc_spacing_value oversize_val
	) 
	(org_visibility = (axlVisibleGet)) 
	foreach(net1 net_list1 
	    foreach(lyr1 layer_list1 
		(layer_name1 = sprintf(nil "ETCH/%s" lyr1)) 
		(axlVisibleDesign nil) 
		(axlVisibleLayer 
		    sprintf(nil "ETCH/%s" lyr1) t
		)
		(axlVisibleLayer 
		    sprintf(nil "PIN/%s" lyr1) t
		) 
		(axlVisibleLayer 
		    sprintf(nil "VIA CLASS/%s" lyr1) t
		) 
		(axlSetFindFilter ?enabled 
		    list("noall" "equivlogic" "nets" "pins" "vias"
			"clines" "shapes"
		    ) ?onButtons 
		    list("all")
		) 
		(path_list = list()) 
		(sel_set = (axlSingleSelectName "NET" net1))
		when(sel_set 
		    (path_list = cons((axlGetSelSet) path_list))
		) 
		(axlClearSelSet) 
		foreach(path path_list 
		    foreach(obj1 path 
			if(((obj1->objType) == "path") then 
			    (poly_list1 = (axlPolyFromDB obj1 ?layer layer_name1 ?endCapType
				    'ROUND
				)) else 
			    (poly_list1 = (axlPolyFromDB obj1 ?layer layer_name1 ?padType
				    'REGULAR
				))
			) 
			foreach(lyr2 layer_list2 
			    when((upperCase(lyr2) != upperCase(lyr1)) 
				(layer_distance = (tbx_zdrc_global->distInfo)[lyr1][lyr2]) 
				when((layer_distance && (layer_distance <= geom_window)) 
				    (result = TBX_ZDRC_Detect_Z_Layer_Objects(obj1 lyr2 geom_window net_list2)) 
				    when(result 
					foreach(entry result 
					    (poly2 = car(entry)) 
					    (obj2 = cadr(entry)) 
					    (drc_spacing_value = caddr(entry))
					    when((drc_spacing_value >= layer_distance) 
						(oversize_val = sqrt(((drc_spacing_value**2) - (layer_distance**2)))) 
						(exp_poly1 = poly_list1) 
						when((oversize_val > 0.0) 
						    (exp_poly1 = (axlPolyExpand poly_list1 oversize_val 
							    'ALL_ARC
							))
						) 
						(drc_res = (axlPolyOperation exp_poly1 poly2 
							'AND
						    ))
						when(car(drc_res) 
						    foreach(pl drc_res 
							(axlDBCreateShape pl t 
							    sprintf(nil "BOARD GEOMETRY/ZDRC_%s" lyr2)
							) 
							TBX_ZDRC_Create_External_DRC(pl obj1 obj2 lyr1 lyr2
							    drc_spacing_value 
							    sprintf(nil "%f" layer_distance)
							)
						    )
						)
					    )
					)
				    )
				)
			    )
			)
		    )
		)
	    )
	) 
	(axlVisibleSet org_visibility)
    )
)
procedure(TBX_ZDRC_Resolve_Net_Objects(object_filter object_list class_members) 
    let((net_list) 
	(net_list = list()) 
	cond(((object_filter && (upperCase(object_filter) == "ALL NETS")) 
		(net_list = object_list)
	    ) 
	    ((object_filter && (upperCase(object_filter) == "ALL CLASS")) 
		(net_list = tconc(nil nil)) 
		foreach(cls object_list 
		    lconc(net_list 
			copy(class_members[cls])
		    )
		) 
		(net_list = cdar(net_list))
	    ) 
	    (object_filter 
		(net_list = object_list)
	    ) 
	    (t t)
	) 
	(net_list = sort(net_list nil)) net_list
    )
)
procedure(TBX_ZDRC_Run(net_list1 net_list2) 
    let((geom_window_size layer_list1 layer_list2) 
	(layer_list1 = TBX_ZDRC_Get_Layer_Span("left")) 
	(layer_list2 = TBX_ZDRC_Get_Layer_Span("right")) 
	TBX_ZDRC_Delete_All_DRC() 
	TBX_ZDRC_Clear_DRC_Layers()
	if((axlFormGetField 
		(tbx_zdrc_global->formid) "system_defined"
	    ) then 
	    (geom_window_size = (tbx_zdrc_global->maxValue)) else 
	    (geom_window_size = (axlFormGetField 
		    (tbx_zdrc_global->formid) "user_defined_value"
		))
	) 
	if((geom_window_size > 0) then 
	    TBX_ZDRC_Process_Nets_By_Layer(net_list1 layer_list1 net_list2 layer_list2 geom_window_size) else 
	    (axlUIConfirm "Invalid DRC value.")
	)
    )
)
procedure(TBX_ZDRC_Write_Error_Report() 
    let((cnt port report_file csv_file) 
	(report_file = "./zdrc_error_report.txt") 
	(port = outfile(report_file "w")) 
	(cnt = 1) 
	fprintf(port "#=========================================================================================================\n")
	fprintf(port "# ZDRC Error report\n") 
	fprintf(port "#\n") 
	fprintf(port "# Design: %s.brd\n" 
	    (axlCurrentDesign)
	) 
	fprintf(port "# Date:   %s\n" 
	    getCurrentTime()
	) 
	fprintf(port "#\n")
	fprintf(port "# Nr   XY                      Type   Layers                LayDistance      Required         Nets        \n") 
	fprintf(port "#=========================================================================================================\n") 
	foreach(drc 
	    (tbx_zdrc_global->externalDRC) 
	    fprintf(port "  %03d  %-22s  %-5s  %-20s  %-15s  %-15s  %-50s\n" cnt 
		sprintf(nil "%L" 
		    (drc->xy)
		) 
		(drc->type)
		buildString((drc->layerPair) " <> ") 
		(drc->layerDist) 
		(drc->required) 
		buildString((drc->nets) " <> ")
	    ) 
	    ++cnt
	) 
	close(port) 
	(axlUIViewFileCreate report_file report_file nil)
	(csv_file = "./zdrc_error_report.csv") 
	(port = outfile(csv_file "w")) 
	(cnt = 1) 
	fprintf(port "Nr;X;Y;Type;Layer1;Layer2;LayerDistance;Required;Net1;Net2\n") 
	foreach(drc 
	    (tbx_zdrc_global->externalDRC) 
	    fprintf(port "%d;%.3f;%.3f;%s;%s;%s;%.3f;%.3f;%s;%s\n" cnt 
		car((drc->xy)) 
		cadr((drc->xy))
		(drc->type) 
		car((drc->layerPair)) 
		cadr((drc->layerPair)) 
		atof((drc->layerDist)) 
		atof((drc->required))
		car((drc->nets)) 
		cadr((drc->nets))
	    ) 
	    ++cnt
	)
	close(port) 
	(axlUIViewFileCreate csv_file csv_file nil) t
    )
)
procedure(TBX_ZDRC_Write_Layer_Distance_Report(dist_info calc_mode) 
    let((layer_names layer_cnt port report_file first_layer
	    second_layer
	) 
	(report_file = "./zdrc_layer_distance_report.txt") 
	(port = outfile(report_file "w")) 
	(layer_names = (axlSubclassRoute)) 
	(layer_cnt = length(layer_names))
	fprintf(port "#=======================================================================================================\n") 
	fprintf(port "# ZDRC Layer distance report\n") 
	fprintf(port "#\n") 
	fprintf(port "# Design: %s.brd\n" 
	    (axlCurrentDesign)
	) 
	fprintf(port "# Date:   %s\n" 
	    getCurrentTime()
	)
	fprintf(port "#\n") 
	fprintf(port "#  Layer1                Layer2                Thickness\n") 
	fprintf(port "#=======================================================================================================\n") 
	for(n 0 
	    (layer_cnt - 2) 
	    (first_layer = upperCase(nth(n layer_names))) 
	    for(p 
		(n + 1) 
		(layer_cnt - 1) 
		(second_layer = upperCase(nth(p layer_names))) 
		fprintf(port "   %-20s  %-20s  %.3f\n" first_layer second_layer 
		    dist_info[first_layer][second_layer]
		)
	    )
	) 
	fprintf(port "\n")
	cond(((calc_mode == "inc_cu_all") 
		fprintf(port "Mode \"Include all Cu layers\":\n") 
		fprintf(port "   All copper layers from layer span are included\n")
	    ) 
	    ((calc_mode == "exc_cu_all") 
		fprintf(port "Mode \"Exclude all Cu\":\n") 
		fprintf(port "   All copper layers from layer span are excluded\n")
	    ) 
	    ((calc_mode == "exc_cu_start_end") 
		fprintf(port "Mode \"Exclude external Cu\":\n") 
		fprintf(port "   Only internal copper layers from layer span are\n") 
		fprintf(port "   included to thickness calculation\n")
	    )
	) 
	close(port) 
	(axlUIViewFileCreate report_file report_file nil)
    )
)
procedure(TBX_ZDRC_Zoom_To_Point(drc_xy drc_size zoom_size) 
    let((bb_window window_width window_height window_ratio x_ll
	    y_ll x_ur y_ur new_width new_height
	) 
	(bb_window = (axlWindowBoxGet)) 
	(window_width = (abs((car((upperRight bb_window)) - 
			car((lowerLeft bb_window)))
		) * 1.0)) 
	(window_height = (abs((cadr((upperRight bb_window)) - 
			cadr((lowerLeft bb_window)))
		) * 1.0)) 
	(window_ratio = (window_height / window_width))
	(zoom_size = (zoom_size * 1.0)) 
	(new_width = ((drc_size / zoom_size) * 100.0)) 
	(new_height = (new_width * window_ratio)) 
	(x_ll = (car(drc_xy) - (new_width / 2.0))) 
	(y_ll = (cadr(drc_xy) - (new_height / 2.0)))
	(x_ur = (car(drc_xy) + (new_width / 2.0))) 
	(y_ur = (cadr(drc_xy) + (new_height / 2.0))) 
	(axlWindowBoxSet 
	    list(list(x_ll y_ll) 
		list(x_ur y_ur)
	    )
	) t
    )
)

